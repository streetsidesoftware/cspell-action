"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testMethods = exports.hasOptionToSearchOption = exports.wordDictionaryFormsCollector = exports.wordSearchForms = exports.impersonateCollector = exports.defaultNumSuggestions = exports.regexPrefix = exports.PREFIX_NO_CASE = exports.WORD_SEPARATOR = exports.suggestionCollector = exports.JOIN_SEPARATOR = exports.CompoundWordsMethod = void 0;
const gensequence_1 = require("gensequence");
const text_1 = require("../util/text");
// cspell:word cafÃ©
var cspell_trie_lib_1 = require("cspell-trie-lib");
Object.defineProperty(exports, "CompoundWordsMethod", { enumerable: true, get: function () { return cspell_trie_lib_1.CompoundWordsMethod; } });
Object.defineProperty(exports, "JOIN_SEPARATOR", { enumerable: true, get: function () { return cspell_trie_lib_1.JOIN_SEPARATOR; } });
Object.defineProperty(exports, "suggestionCollector", { enumerable: true, get: function () { return cspell_trie_lib_1.suggestionCollector; } });
Object.defineProperty(exports, "WORD_SEPARATOR", { enumerable: true, get: function () { return cspell_trie_lib_1.WORD_SEPARATOR; } });
exports.PREFIX_NO_CASE = '>';
exports.regexPrefix = /^[>]/;
exports.defaultNumSuggestions = 10;
function impersonateCollector(collector, word) {
    return {
        collect: collector.collect,
        add: (suggestion) => collector.add(suggestion),
        get suggestions() {
            return collector.suggestions;
        },
        get maxCost() {
            return collector.maxCost;
        },
        get word() {
            return word;
        },
        get maxNumSuggestions() {
            return collector.maxNumSuggestions;
        },
        includesTies: false,
    };
}
exports.impersonateCollector = impersonateCollector;
function wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase) {
    const forms = new Set();
    word = word.normalize('NFC');
    const wordLc = word.toLowerCase();
    const wordLcNa = text_1.removeAccents(wordLc);
    if (ignoreCase) {
        if (isDictionaryCaseSensitive) {
            forms.add(wordLcNa);
        }
        else {
            forms.add(wordLc);
            forms.add(wordLcNa);
        }
    }
    else {
        if (isDictionaryCaseSensitive) {
            forms.add(word);
            forms.add(wordLc);
            // HOUSE -> House, house
            if (text_1.isUpperCase(word)) {
                forms.add(text_1.ucFirst(wordLc));
            }
        }
        else {
            forms.add(wordLc);
        }
    }
    return [...forms];
}
exports.wordSearchForms = wordSearchForms;
function* wordDictionaryForms(word, isDictionaryCaseSensitive) {
    word = word.normalize('NFC');
    const wordLc = word.toLowerCase();
    const wordNa = text_1.removeAccents(word);
    const wordLcNa = text_1.removeAccents(wordLc);
    function wf(w, p = '') {
        return { w, p };
    }
    const prefix = isDictionaryCaseSensitive ? exports.PREFIX_NO_CASE : '';
    yield wf(word);
    yield wf(wordNa, prefix);
    yield wf(wordLc, prefix);
    yield wf(wordLcNa, prefix);
}
function wordDictionaryFormsCollector(isDictionaryCaseSensitive) {
    const knownWords = new Set();
    return (word) => {
        return gensequence_1.genSequence(wordDictionaryForms(word, isDictionaryCaseSensitive))
            .filter((w) => !knownWords.has(w.w))
            .map((w) => w.p + w.w)
            .filter((w) => !knownWords.has(w))
            .map((w) => (knownWords.add(w), w));
    };
}
exports.wordDictionaryFormsCollector = wordDictionaryFormsCollector;
function hasOptionToSearchOption(opt) {
    return !opt ? {} : typeof opt === 'object' ? opt : { useCompounds: opt };
}
exports.hasOptionToSearchOption = hasOptionToSearchOption;
exports.__testMethods = {
    wordSearchForms,
    wordDictionaryForms,
    wordDictionaryFormsCollector,
};
//# sourceMappingURL=SpellingDictionaryMethods.js.map
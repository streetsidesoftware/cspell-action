"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCollectionP = exports.isWordInAnyDictionary = exports.createCollection = exports.SpellingDictionaryCollection = void 0;
const SpellingDictionaryMethods_1 = require("./SpellingDictionaryMethods");
const gensequence_1 = require("gensequence");
const Settings_1 = require("../Settings");
function identityString(w) {
    return w;
}
class SpellingDictionaryCollection {
    constructor(dictionaries, name, wordsToFlag) {
        this.dictionaries = dictionaries;
        this.name = name;
        this.options = {};
        this.mapWord = identityString;
        this.type = 'SpellingDictionaryCollection';
        this.dictionaries = this.dictionaries.sort((a, b) => b.size - a.size);
        this.wordsToFlag = new Set(wordsToFlag.map((w) => w.toLowerCase()));
        this.source = dictionaries.map((d) => d.name).join(', ');
        this.isDictionaryCaseSensitive = this.dictionaries.reduce((a, b) => a || b.isDictionaryCaseSensitive, false);
    }
    has(word, hasOptions) {
        const options = SpellingDictionaryMethods_1.hasOptionToSearchOption(hasOptions);
        return !this.wordsToFlag.has(word.toLowerCase()) && isWordInAnyDictionary(this.dictionaries, word, options);
    }
    suggest(...args) {
        const [word, options, compoundMethod, numChanges] = args;
        const suggestOptions = typeof options === 'object'
            ? options
            : {
                numSuggestions: options,
                compoundMethod,
                numChanges,
            };
        return this._suggest(word, suggestOptions);
    }
    _suggest(word, suggestOptions) {
        const _suggestOptions = { ...suggestOptions };
        const { numSuggestions = Settings_1.getDefaultSettings().numSuggestions || SpellingDictionaryMethods_1.defaultNumSuggestions, numChanges, compoundMethod, ignoreCase = true, } = suggestOptions;
        _suggestOptions.compoundMethod = this.options.useCompounds ? SpellingDictionaryMethods_1.CompoundWordsMethod.JOIN_WORDS : compoundMethod;
        const filter = (word) => {
            return !this.wordsToFlag.has(word.toLowerCase()) && (ignoreCase || word[0] !== SpellingDictionaryMethods_1.PREFIX_NO_CASE);
        };
        const collector = SpellingDictionaryMethods_1.suggestionCollector(word, numSuggestions, filter, numChanges);
        this.genSuggestions(collector, suggestOptions);
        return collector.suggestions.map((r) => ({ ...r, word: r.word.replace(SpellingDictionaryMethods_1.regexPrefix, '') }));
    }
    get size() {
        return this.dictionaries.reduce((a, b) => a + b.size, 0);
    }
    genSuggestions(collector, suggestOptions) {
        const _suggestOptions = { ...suggestOptions };
        const { compoundMethod = SpellingDictionaryMethods_1.CompoundWordsMethod.SEPARATE_WORDS } = suggestOptions;
        _suggestOptions.compoundMethod = this.options.useCompounds ? SpellingDictionaryMethods_1.CompoundWordsMethod.JOIN_WORDS : compoundMethod;
        this.dictionaries.forEach((dict) => dict.genSuggestions(collector, _suggestOptions));
    }
    getErrors() {
        return this.dictionaries.reduce((errors, dict) => { var _a; return errors.concat(((_a = dict.getErrors) === null || _a === void 0 ? void 0 : _a.call(dict)) || []); }, []);
    }
}
exports.SpellingDictionaryCollection = SpellingDictionaryCollection;
function createCollection(dictionaries, name, wordsToFlag = []) {
    return new SpellingDictionaryCollection(dictionaries, name, wordsToFlag);
}
exports.createCollection = createCollection;
function isWordInAnyDictionary(dicts, word, options) {
    return !!gensequence_1.genSequence(dicts).first((dict) => dict.has(word, options));
}
exports.isWordInAnyDictionary = isWordInAnyDictionary;
function createCollectionP(dicts, name, wordsToFlag) {
    return Promise.all(dicts).then((dicts) => new SpellingDictionaryCollection(dicts, name, wordsToFlag));
}
exports.createCollectionP = createCollectionP;
//# sourceMappingURL=SpellingDictionaryCollection.js.map
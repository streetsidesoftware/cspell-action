"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSpellingDictionaryTrie = exports.SpellingDictionaryFromTrie = void 0;
const cspell_trie_lib_1 = require("cspell-trie-lib");
const repMap_1 = require("../util/repMap");
const Settings_1 = require("../Settings");
const Memorizer_1 = require("../util/Memorizer");
const SpellingDictionaryMethods_1 = require("./SpellingDictionaryMethods");
class SpellingDictionaryFromTrie {
    constructor(trie, name, options = {}, source = 'from trie', size) {
        this.trie = trie;
        this.name = name;
        this.options = options;
        this.source = source;
        this._size = 0;
        this.knownWords = new Set();
        this.unknownWords = new Set();
        this.type = 'SpellingDictionaryFromTrie';
        this._has = Memorizer_1.memorizer((word, useCompounds, ignoreCase) => this.hasAnyForm(word, useCompounds, ignoreCase), SpellingDictionaryFromTrie.cachedWordsLimit);
        this.mapWord = repMap_1.createMapper(options.repMap || []);
        this.isDictionaryCaseSensitive = options.caseSensitive || !trie.isLegacy;
        this._size = size || 0;
    }
    get size() {
        if (!this._size) {
            // walk the trie and get the approximate size.
            const i = this.trie.iterate();
            let deeper = true;
            let size = 0;
            for (let r = i.next(); !r.done; r = i.next(deeper)) {
                // count all nodes even though they are not words.
                // because we are not going to all the leaves, this should give a good enough approximation.
                size += 1;
                deeper = r.value.text.length < 5;
            }
            this._size = size;
        }
        return this._size;
    }
    has(word, hasOptions) {
        var _a;
        const searchOptions = SpellingDictionaryMethods_1.hasOptionToSearchOption(hasOptions);
        const useCompounds = (_a = searchOptions.useCompounds) !== null && _a !== void 0 ? _a : this.options.useCompounds;
        const { ignoreCase = true } = searchOptions;
        return this._has(word, useCompounds, ignoreCase);
    }
    hasAnyForm(word, useCompounds, ignoreCase) {
        const mWord = this.mapWord(word);
        const forms = SpellingDictionaryMethods_1.wordSearchForms(mWord, this.isDictionaryCaseSensitive, ignoreCase);
        for (const w of forms) {
            if (this.trie.hasWord(w, !ignoreCase)) {
                return true;
            }
        }
        if (useCompounds) {
            for (const w of forms) {
                if (this.trie.has(w, useCompounds)) {
                    return true;
                }
            }
        }
        return false;
    }
    suggest(...args) {
        const [word, options, compoundMethod, numChanges] = args;
        const suggestOptions = typeof options === 'object'
            ? options
            : {
                numSuggestions: options,
                compoundMethod,
                numChanges,
            };
        return this._suggest(word, suggestOptions);
    }
    _suggest(word, suggestOptions) {
        const { numSuggestions = Settings_1.getDefaultSettings().numSuggestions || SpellingDictionaryMethods_1.defaultNumSuggestions, numChanges, ignoreCase = true, } = suggestOptions;
        function filter(word) {
            return ignoreCase || word[0] !== SpellingDictionaryMethods_1.PREFIX_NO_CASE;
        }
        const collector = cspell_trie_lib_1.suggestionCollector(word, numSuggestions, filter, numChanges);
        this.genSuggestions(collector, suggestOptions);
        return collector.suggestions.map((r) => ({ ...r, word: r.word.replace(SpellingDictionaryMethods_1.regexPrefix, '') }));
    }
    genSuggestions(collector, suggestOptions) {
        const { compoundMethod = cspell_trie_lib_1.CompoundWordsMethod.SEPARATE_WORDS, ignoreCase = true } = suggestOptions;
        const _compoundMethod = this.options.useCompounds ? cspell_trie_lib_1.CompoundWordsMethod.JOIN_WORDS : compoundMethod;
        SpellingDictionaryMethods_1.wordSearchForms(collector.word, this.isDictionaryCaseSensitive, ignoreCase).forEach((w) => this.trie.genSuggestions(SpellingDictionaryMethods_1.impersonateCollector(collector, w), _compoundMethod));
    }
    getErrors() {
        return [];
    }
}
exports.SpellingDictionaryFromTrie = SpellingDictionaryFromTrie;
SpellingDictionaryFromTrie.cachedWordsLimit = 50000;
async function createSpellingDictionaryTrie(data, name, source, options) {
    const trieNode = cspell_trie_lib_1.importTrie(data);
    const trie = new cspell_trie_lib_1.Trie(trieNode);
    return new SpellingDictionaryFromTrie(trie, name, options, source);
}
exports.createSpellingDictionaryTrie = createSpellingDictionaryTrie;
//# sourceMappingURL=SpellingDictionaryFromTrie.js.map
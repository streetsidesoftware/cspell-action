import { genSequence } from 'gensequence';
import { toInternalSettings } from './Settings/CSpellSettingsServer.mjs';
import { finalizeSettings, mergeSettings } from './Settings/index.mjs';
import { calcSettingsForLanguageId } from './Settings/LanguageSettings.mjs';
import { getDictionaryInternal, refreshDictionaryCache } from './SpellingDictionary/index.mjs';
import * as util from './util/util.mjs';
export async function traceWords(words, settings, options) {
    const results = await util.asyncIterableToArray(traceWordsAsync(words, settings, options));
    const s = genSequence(results)
        .concatMap((p) => p)
        .toArray();
    return s;
}
export async function* traceWordsAsync(words, settings, options) {
    const { languageId, locale: language, ignoreCase = true, allowCompoundWords } = options || {};
    async function finalize(config) {
        const withLocale = mergeSettings(config, util.clean({
            language: language || config.language,
            allowCompoundWords: allowCompoundWords ?? config.allowCompoundWords,
        }));
        const withLanguageId = calcSettingsForLanguageId(withLocale, languageId ?? withLocale.languageId ?? 'plaintext');
        const settings = finalizeSettings(withLanguageId);
        const dictionaries = (settings.dictionaries || [])
            .concat((settings.dictionaryDefinitions || []).map((d) => d.name))
            .filter(util.uniqueFn);
        const dictSettings = toInternalSettings({ ...settings, dictionaries });
        const dictBase = await getDictionaryInternal(settings);
        const dicts = await getDictionaryInternal(dictSettings);
        const activeDictionaries = dictBase.dictionaries.map((d) => d.name);
        return {
            activeDictionaries,
            config: settings,
            dicts,
        };
    }
    await refreshDictionaryCache();
    const { config, dicts, activeDictionaries } = await finalize(settings);
    const setOfActiveDicts = new Set(activeDictionaries);
    const opts = util.clean({ ignoreCase, useCompounds: config.allowCompoundWords });
    function normalizeErrors(errors) {
        if (!errors?.length)
            return undefined;
        return errors;
    }
    function processWord(word) {
        return dicts.dictionaries
            .map((dict) => ({ dict, findResult: dict.find(word, opts) }))
            .map(({ dict, findResult }) => ({
            word,
            found: !!findResult?.found,
            foundWord: findResult?.found || undefined,
            forbidden: findResult?.forbidden || false,
            noSuggest: findResult?.noSuggest || false,
            dictName: dict.name,
            dictSource: dict.source,
            dictActive: setOfActiveDicts.has(dict.name),
            configSource: config.name || '',
            errors: normalizeErrors(dict.getErrors?.()),
        }));
    }
    for await (const word of words) {
        yield processWord(word);
    }
}

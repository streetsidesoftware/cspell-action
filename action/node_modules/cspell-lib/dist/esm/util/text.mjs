import { opConcatMap, opMap, pipe } from '@cspell/cspell-pipe/sync';
import { sequenceFromRegExpMatch } from 'gensequence';
import { binarySearch } from './search.mjs';
import { regExAccents, regExAllLower, regExAllUpper, regExFirstUpper, regExIgnoreCharacters, regExSplitWords, regExSplitWords2, regExUpperSOrIng, regExWords, regExWordsAndDigits, } from './textRegex.mjs';
import { toUri } from './Uri.mjs';
import { scanMap } from './util.mjs';
export { stringToRegExp } from './textRegex.mjs';
// CSpell:ignore ings ning gimuy tsmerge
export function splitCamelCaseWordWithOffset(wo) {
    return splitCamelCaseWord(wo.text).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
        text: '',
        offset: wo.offset,
    }));
}
/**
 * Split camelCase words into an array of strings.
 */
export function splitCamelCaseWord(word) {
    const wPrime = word.replace(regExUpperSOrIng, (s) => s[0] + s.slice(1).toLowerCase());
    const separator = '_<^*_*^>_';
    const pass1 = wPrime.replace(regExSplitWords, '$1' + separator + '$2');
    const pass2 = pass1.replace(regExSplitWords2, '$1' + separator + '$2');
    return pass2.split(separator);
}
/**
 * This function lets you iterate over regular expression matches.
 */
export function match(reg, text) {
    return sequenceFromRegExpMatch(reg, text);
}
export function matchStringToTextOffset(reg, text) {
    return matchToTextOffset(reg, { text, offset: 0 });
}
export function matchToTextOffset(reg, text) {
    const textOffset = text;
    const fnOffsetMap = offsetMap(textOffset.offset);
    textOffset.text.matchAll(reg);
    return pipe(match(reg, textOffset.text), opMap((m) => fnOffsetMap({ text: m[0], offset: m.index || 0 })));
}
export function* extractLinesOfText(text) {
    let i = 0;
    for (let j = text.indexOf('\n', i); j >= 0; j = text.indexOf('\n', i)) {
        const end = j + 1;
        yield { text: text.slice(i, end), offset: i };
        i = end;
    }
    yield { text: text.slice(i, text.length), offset: i };
}
/**
 * Extract out whole words from a string of text.
 */
export function extractWordsFromText(text) {
    return extractWordsFromTextOffset(textOffset(text));
}
/**
 * Extract out whole words from a string of text.
 */
export function extractWordsFromTextOffset(text) {
    const reg = new RegExp(regExWords);
    return matchToTextOffset(reg, cleanTextOffset(text));
}
export function cleanText(text) {
    text = text.replace(regExIgnoreCharacters, (match) => ' '.repeat(match.length));
    return text;
}
export function cleanTextOffset(text) {
    return {
        text: cleanText(text.text),
        offset: text.offset,
    };
}
/**
 * Extract out whole words and words containing numbers from a string of text.
 */
export function extractPossibleWordsFromTextOffset(text) {
    const reg = new RegExp(regExWordsAndDigits);
    return matchToTextOffset(reg, text);
}
export function extractWordsFromCode(text) {
    return extractWordsFromCodeTextOffset(textOffset(text));
}
export function extractWordsFromCodeTextOffset(textOffset) {
    return pipe(extractWordsFromTextOffset(textOffset), opConcatMap(splitCamelCaseWordWithOffset));
}
export function isUpperCase(word) {
    return !!word.match(regExAllUpper);
}
export function isLowerCase(word) {
    return !!word.match(regExAllLower);
}
export function isFirstCharacterUpper(word) {
    return isUpperCase(word.slice(0, 1));
}
export function isFirstCharacterLower(word) {
    return isLowerCase(word.slice(0, 1));
}
export function ucFirst(word) {
    return word.slice(0, 1).toUpperCase() + word.slice(1);
}
export function lcFirst(word) {
    return word.slice(0, 1).toLowerCase() + word.slice(1);
}
export function snakeToCamel(word) {
    return word.split('_').map(ucFirst).join('');
}
export function camelToSnake(word) {
    return splitCamelCaseWord(word).join('_').toLowerCase();
}
export function matchCase(example, word) {
    if (example.match(regExFirstUpper)) {
        return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();
    }
    if (example.match(regExAllLower)) {
        return word.toLowerCase();
    }
    if (example.match(regExAllUpper)) {
        return word.toUpperCase();
    }
    if (isFirstCharacterUpper(example)) {
        return ucFirst(word);
    }
    if (isFirstCharacterLower(example)) {
        return lcFirst(word);
    }
    return word;
}
export function textOffset(text, offset = 0) {
    return { text, offset };
}
export function extractText(textOffset, startPos, endPos) {
    const { text, offset: orig } = textOffset;
    const a = Math.max(startPos - orig, 0);
    const b = Math.max(endPos - orig, 0);
    return text.slice(a, b);
}
function offsetMap(offset) {
    return (xo) => ({ ...xo, offset: xo.offset + offset });
}
export function calculateTextDocumentOffsets(uri, doc, wordOffsets) {
    const lines = [
        -1,
        ...pipe(match(/\n/g, doc), opMap((a) => a.index)),
        doc.length,
    ];
    let lastRow = -1;
    let lastOffset = doc.length + 1;
    let lastLineRow = -1;
    let lastLine;
    function findRowCol(offset) {
        const row = binarySearch(lines, offset, offset >= lastOffset ? lastRow : undefined);
        const col = offset - lines[Math.max(0, row - 1)];
        lastOffset = offset;
        lastRow = row;
        return [row, col];
    }
    function extractLine(row) {
        const offset = lines[row - 1] + 1;
        const text = doc.slice(offset, lines[row] + 1);
        return { text, offset };
    }
    function calcLine(row) {
        const last = lastLineRow === row ? lastLine : undefined;
        lastLineRow = row;
        const r = last ?? extractLine(row);
        lastLine = r;
        return r;
    }
    const _uri = toUri(uri).toString();
    return wordOffsets.map((wo) => {
        const [row, col] = findRowCol(wo.offset);
        return { ...wo, row, col, doc, uri: _uri, line: calcLine(row) };
    });
}
export function removeAccents(text) {
    return text.normalize('NFD').replace(regExAccents, '');
}
export const __testing__ = {
    regExWords,
    regExWordsAndDigits,
};

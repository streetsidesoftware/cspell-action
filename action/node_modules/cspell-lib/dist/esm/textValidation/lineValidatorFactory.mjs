import { opConcatMap, opFilter, opMap, pipe, toArray } from '@cspell/cspell-pipe/sync';
import { createCachingDictionary } from 'cspell-dictionary';
import * as RxPat from '../Settings/RegExpPatterns.mjs';
import * as Text from '../util/text.mjs';
import { clean } from '../util/util.mjs';
import { split } from '../util/wordSplitter.mjs';
import { defaultMinWordLength } from './defaultConstants.mjs';
import { isWordValidWithEscapeRetry } from './isWordValid.mjs';
import { mapRangeBackToOriginalPos } from './parsedText.mjs';
export function lineValidatorFactory(sDict, options) {
    const { minWordLength = defaultMinWordLength, flagWords = [], allowCompoundWords = false, ignoreCase = true, } = options;
    const hasWordOptions = {
        ignoreCase,
        useCompounds: allowCompoundWords || undefined, // let the dictionaries decide on useCompounds if allow is false
    };
    const dictCol = createCachingDictionary(sDict, hasWordOptions);
    const setOfFlagWords = new Set(flagWords);
    const setOfKnownSuccessfulWords = new Set();
    const rememberFilter = (fn) => (v) => {
        const keep = fn(v);
        if (!keep) {
            setOfKnownSuccessfulWords.add(v.text);
        }
        return keep;
    };
    const filterAlreadyChecked = (wo) => {
        return !setOfKnownSuccessfulWords.has(wo.text);
    };
    function testForFlaggedWord(wo) {
        const text = wo.text;
        return setOfFlagWords.has(text) || setOfFlagWords.has(text.toLowerCase()) || dictCol.isForbidden(text);
    }
    function isWordIgnored(word) {
        return dictCol.isNoSuggestWord(word);
    }
    function getSuggestions(word) {
        return dictCol.getPreferredSuggestions(word);
    }
    function isWordFlagged(word) {
        const isIgnored = isWordIgnored(word.text);
        const isFlagged = !isIgnored && testForFlaggedWord(word);
        return isFlagged;
    }
    function annotateIsFlagged(word) {
        word.isFlagged = isWordFlagged(word);
        return word;
    }
    function annotateIssue(issue) {
        const sugs = getSuggestions(issue.text);
        if (sugs && sugs.length) {
            issue.suggestionsEx = sugs;
        }
        return issue;
    }
    function checkWord(word) {
        const isIgnored = isWordIgnored(word.text);
        const { isFlagged = !isIgnored && testForFlaggedWord(word) } = word;
        const isFound = isFlagged ? undefined : isIgnored || isWordValidWithEscapeRetry(dictCol, word, word.line);
        return clean({ ...word, isFlagged, isFound });
    }
    const fn = (lineSegment) => {
        function splitterIsValid(word) {
            return (setOfKnownSuccessfulWords.has(word.text) ||
                (!testForFlaggedWord(word) && isWordValidWithEscapeRetry(dictCol, word, lineSegment.line)));
        }
        function checkFullWord(vr) {
            if (vr.isFlagged) {
                return [vr];
            }
            const codeWordResults = toArray(pipe(Text.extractWordsFromCodeTextOffset(vr), opFilter(filterAlreadyChecked), opMap((t) => ({ ...t, line: vr.line })), opMap(annotateIsFlagged), opFilter(rememberFilter((wo) => wo.text.length >= minWordLength || !!wo.isFlagged)), opMap((wo) => (wo.isFlagged ? wo : checkWord(wo))), opFilter(rememberFilter((wo) => wo.isFlagged || !wo.isFound)), opFilter(rememberFilter((wo) => !RxPat.regExRepeatedChar.test(wo.text))), 
            // get back the original text.
            opMap((wo) => ({
                ...wo,
                text: Text.extractText(lineSegment.segment, wo.offset, wo.offset + wo.text.length),
            }))));
            if (!codeWordResults.length || isWordIgnored(vr.text) || checkWord(vr).isFound) {
                rememberFilter((_) => false)(vr);
                return [];
            }
            return codeWordResults;
        }
        function checkPossibleWords(possibleWord) {
            if (isWordFlagged(possibleWord)) {
                const vr = {
                    ...possibleWord,
                    line: lineSegment.line,
                    isFlagged: true,
                };
                return [vr];
            }
            const mismatches = toArray(pipe(Text.extractWordsFromTextOffset(possibleWord), opFilter(filterAlreadyChecked), opMap((wo) => ({ ...wo, line: lineSegment.line })), opMap(annotateIsFlagged), opFilter(rememberFilter((wo) => wo.text.length >= minWordLength || !!wo.isFlagged)), opConcatMap(checkFullWord)));
            if (mismatches.length) {
                // Try the more expensive word splitter
                const splitResult = split(lineSegment.segment, possibleWord.offset, splitterIsValid);
                const nonMatching = splitResult.words.filter((w) => !w.isFound);
                if (nonMatching.length < mismatches.length) {
                    return nonMatching.map((w) => ({ ...w, line: lineSegment.line })).map(annotateIsFlagged);
                }
            }
            return mismatches;
        }
        const checkedPossibleWords = pipe(Text.extractPossibleWordsFromTextOffset(lineSegment.segment), opFilter(filterAlreadyChecked), opConcatMap(checkPossibleWords), opMap(annotateIssue));
        return checkedPossibleWords;
    };
    return { fn, dict: dictCol };
}
export function textValidatorFactory(dict, options) {
    const lineValidator = lineValidatorFactory(dict, options);
    const lineValidatorFn = lineValidator.fn;
    function validate(pText) {
        const { text, range: srcRange, map } = pText;
        const srcOffset = srcRange[0];
        const segment = { text, offset: 0 };
        const lineSegment = { line: segment, segment };
        function mapBackToOriginSimple(vr) {
            const { text, offset, isFlagged, isFound, suggestionsEx } = vr;
            const r = mapRangeBackToOriginalPos([offset, offset + text.length], map);
            const range = [r[0] + srcOffset, r[1] + srcOffset];
            return { text, range, isFlagged, isFound, suggestionsEx };
        }
        return [...lineValidatorFn(lineSegment)].map(mapBackToOriginSimple);
    }
    return {
        validate,
        lineValidator,
    };
}

import type { CSpellUserSettings, MappedText, ParsedText } from '@cspell/cspell-types';
import type { CSpellSettingsInternal, CSpellSettingsInternalFinalized } from '../Models/CSpellSettingsInternalDef.mjs';
import type { ExtendedSuggestion } from '../Models/Suggestion.mjs';
import type { TextDocument, TextDocumentRef } from '../Models/TextDocument.mjs';
import type { ValidationIssue } from '../Models/ValidationIssue.mjs';
import type { SpellingDictionaryCollection } from '../SpellingDictionary/index.mjs';
import type { WordSuggestion } from '../suggestions.mjs';
import type { MatchRange } from '../util/TextRange.mjs';
import type { TextValidator } from './lineValidatorFactory.mjs';
import type { SimpleRange } from './parsedText.mjs';
import type { ValidateTextOptions } from './ValidateTextOptions.mjs';
import type { ValidationOptions } from './ValidationTypes.mjs';
export interface DocumentValidatorOptions extends ValidateTextOptions {
    /**
     * Optional path to a configuration file.
     * If given, it will be used instead of searching for a configuration file.
     */
    configFile?: string;
    /**
     * Prevents searching for local configuration files
     * By default the spell checker looks for configuration files
     * starting at the location of given filename.
     * If `configFile` is defined it will still be loaded instead of searching.
     * `false` will override the value in `settings.noConfigSearch`.
     * @defaultValue undefined
     */
    noConfigSearch?: boolean;
}
export declare class DocumentValidator {
    readonly settings: CSpellUserSettings;
    private _document;
    private _ready;
    readonly errors: Error[];
    private _prepared;
    private _preparations;
    private _preparationTime;
    private _suggestions;
    readonly options: DocumentValidatorOptions;
    /**
     * @param doc - Document to validate
     * @param config - configuration to use (not finalized).
     */
    constructor(doc: TextDocument, options: DocumentValidatorOptions, settings: CSpellUserSettings);
    get ready(): boolean;
    /**
     * Prepare to validate a document.
     * This will load all the necessary configuration and dictionaries.
     *
     * @deprecated
     * @deprecationMessage Use the async `prepare` method.
     */
    prepareSync(): void;
    prepare(): Promise<void>;
    private _prepareAsync;
    private _updatePrep;
    /**
     * The amount of time in ms to prepare for validation.
     */
    get prepTime(): number;
    get validateDirectives(): boolean;
    checkText(range: SimpleRange, _text: string, scope: string[]): ValidationIssue[];
    check(parsedText: ParsedText): ValidationIssue[];
    /**
     * Check a Document for Validation Issues.
     * @param forceCheck - force a check even if the document would normally be excluded.
     * @returns the validation issues.
     */
    checkDocumentAsync(forceCheck?: boolean): Promise<ValidationIssue[]>;
    /**
     * Check a Document for Validation Issues.
     *
     * Note: The validator must be prepared before calling this method.
     * @param forceCheck - force a check even if the document would normally be excluded.
     * @returns the validation issues.
     */
    checkDocument(forceCheck?: boolean): ValidationIssue[];
    checkDocumentDirectives(forceCheck?: boolean): ValidationIssue[];
    get document(): TextDocument;
    updateDocumentText(text: string): void;
    private defaultParser;
    private _checkParsedText;
    private addPossibleError;
    private _parse;
    private getSuggestions;
    private genSuggestions;
    private adjustSuggestions;
    getFinalizedDocSettings(): CSpellSettingsInternal;
    /**
     * Returns true if the final result of the configuration calculation results
     * in the document being enabled. Note: in some cases, checking the document
     * might still make sense, for example, the `@cspell/eslint-plugin` relies on
     * `eslint` configuration to make that determination.
     * @returns true if the document settings have resolved to be `enabled`
     */
    shouldCheckDocument(): boolean;
    /**
     * Internal `cspell-lib` use.
     */
    _getPreparations(): Preparations | undefined;
}
declare function sanitizeSuggestion(sug: WordSuggestion): ExtendedSuggestion;
interface Preparations {
    /** loaded config */
    config: CSpellSettingsInternal;
    dictionary: SpellingDictionaryCollection;
    /** configuration after applying in-doc settings */
    docSettings: CSpellSettingsInternal;
    finalSettings: CSpellSettingsInternalFinalized;
    includeRanges: MatchRange[];
    textValidator: TextValidator;
    segmenter: (texts: MappedText) => Iterable<MappedText>;
    shouldCheck: boolean;
    validateOptions: ValidationOptions;
    localConfig: CSpellUserSettings | undefined;
    localConfigFilepath: string | undefined;
}
interface ShouldCheckDocumentResult {
    errors: Error[];
    shouldCheck: boolean;
}
export declare function shouldCheckDocument(doc: TextDocumentRef, options: DocumentValidatorOptions, settings: CSpellUserSettings): Promise<ShouldCheckDocumentResult>;
export declare const __testing__: {
    sanitizeSuggestion: typeof sanitizeSuggestion;
};
export {};
//# sourceMappingURL=docValidator.d.mts.map
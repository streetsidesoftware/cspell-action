"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuggestionError = exports.calcSuggestionAdjustedToToMatchCase = exports.suggestionsForWord = exports.suggestionsForWords = void 0;
const assert_1 = __importDefault(require("assert"));
const index_js_1 = require("./Settings/index.js");
const LanguageSettings_js_1 = require("./Settings/LanguageSettings.js");
const index_js_2 = require("./SpellingDictionary/index.js");
const AutoResolve_js_1 = require("./util/AutoResolve.js");
const memorizeLastCall_js_1 = require("./util/memorizeLastCall.js");
const util = __importStar(require("./util/util.js"));
const emptySuggestionOptions = Object.freeze({});
const emptyCSpellSettings = Object.freeze({});
async function* suggestionsForWords(words, options, settings) {
    for await (const word of words) {
        yield await suggestionsForWord(word, options, settings);
    }
}
exports.suggestionsForWords = suggestionsForWords;
const memorizeSuggestions = (0, memorizeLastCall_js_1.memorizeLastCall)(cacheSuggestionsForWord);
function cacheSuggestionsForWord(options, settings) {
    const cache = (0, AutoResolve_js_1.createAutoResolveCache)();
    return (word) => cache.get(word, (word) => _suggestionsForWord(word, options, settings));
}
function suggestionsForWord(word, options = emptySuggestionOptions, settings = emptyCSpellSettings) {
    return memorizeSuggestions(options, settings)(word);
}
exports.suggestionsForWord = suggestionsForWord;
async function _suggestionsForWord(word, options, settings) {
    const { languageId, locale: language, includeDefaultConfig = true, dictionaries } = options;
    async function determineDictionaries(config) {
        const withLocale = (0, index_js_1.mergeSettings)(config, util.clean({
            language: language || config.language,
            // dictionaries: dictionaries?.length ? dictionaries : config.dictionaries,
        }));
        const withLanguageId = (0, LanguageSettings_js_1.calcSettingsForLanguageId)(withLocale, languageId ?? withLocale.languageId ?? 'plaintext');
        const settings = (0, index_js_1.finalizeSettings)(withLanguageId);
        settings.dictionaries = dictionaries?.length ? dictionaries : settings.dictionaries || [];
        validateDictionaries(settings, dictionaries);
        const dictionaryCollection = await (0, index_js_2.getDictionaryInternal)(settings);
        settings.dictionaries = settings.dictionaryDefinitions?.map((def) => def.name) || [];
        const allDictionaryCollection = await (0, index_js_2.getDictionaryInternal)(settings);
        return {
            dictionaryCollection,
            allDictionaryCollection,
        };
    }
    await (0, index_js_2.refreshDictionaryCache)();
    const config = includeDefaultConfig
        ? (0, index_js_1.mergeSettings)((0, index_js_1.getDefaultSettings)(settings.loadDefaultConfiguration ?? true), (0, index_js_1.getGlobalSettings)(), settings)
        : settings;
    const { dictionaryCollection, allDictionaryCollection } = await determineDictionaries(config);
    return _suggestionsForWordSync(word, options, settings, dictionaryCollection, allDictionaryCollection);
}
function _suggestionsForWordSync(word, options, settings, dictionaryCollection, allDictionaryCollection) {
    const extendsDictionaryCollection = allDictionaryCollection || dictionaryCollection;
    const { locale: language, strict = true, numChanges = 4, numSuggestions = 8, includeTies = true, includeDefaultConfig = true, } = options;
    const ignoreCase = !strict;
    const config = includeDefaultConfig
        ? (0, index_js_1.mergeSettings)((0, index_js_1.getDefaultSettings)(settings.loadDefaultConfiguration ?? true), (0, index_js_1.getGlobalSettings)(), settings)
        : settings;
    const opts = { ignoreCase, numChanges, numSuggestions, includeTies };
    const suggestionsByDictionary = dictionaryCollection.dictionaries.flatMap((dict) => dict.suggest(word, opts).map((r) => ({ ...r, dictName: dict.name })));
    const locale = adjustLocale(language || config.language || undefined);
    const collator = Intl.Collator(locale);
    const combined = limitResults(combine(suggestionsByDictionary.sort((a, b) => a.cost - b.cost || collator.compare(a.word, b.word))), numSuggestions, includeTies);
    const sugsAdjusted = calcSuggestionAdjustedToToMatchCase(word, combined, locale, ignoreCase, extendsDictionaryCollection);
    const allSugs = sugsAdjusted.map((sug) => {
        const found = extendsDictionaryCollection.find(sug.word);
        return {
            ...sug,
            forbidden: found?.forbidden || false,
            noSuggest: found?.noSuggest || false,
        };
    });
    return {
        word,
        suggestions: limitResults(allSugs, numSuggestions, includeTies),
    };
}
function combine(suggestions) {
    const words = new Map();
    for (const sug of suggestions) {
        const { word, cost, dictName, ...rest } = sug;
        const f = words.get(word) || { word, cost, ...rest, dictionaries: [] };
        f.cost = Math.min(f.cost, cost);
        f.dictionaries.push(dictName);
        f.dictionaries.sort();
        words.set(word, f);
    }
    return [...words.values()];
}
function adjustLocale(locale) {
    if (!locale)
        return undefined;
    const locales = [...(0, LanguageSettings_js_1.normalizeLocaleIntl)(locale)].filter((locale) => (0, LanguageSettings_js_1.isValidLocaleIntlFormat)(locale));
    if (!locales.length)
        return undefined;
    if (locales.length === 1)
        return locales[0];
    return locales;
}
function calcSuggestionAdjustedToToMatchCase(originalWord, sugs, locale, ignoreCase, dict) {
    locale = adjustLocale(locale);
    const knownSugs = new Set(sugs.map((sug) => sug.word));
    const matchStyle = { ...analyzeCase(originalWord), locale, ignoreCase };
    /* Add adjusted words */
    return sugs.map((sug) => {
        const alt = matchCase(sug.word, !!sug.isPreferred, matchStyle);
        if (alt === sug.word || knownSugs.has(alt))
            return sug;
        const found = dict.find(alt);
        if (!found || !found.forbidden || !found.noSuggest) {
            knownSugs.add(alt);
            return { ...sug, wordAdjustedToMatchCase: alt };
        }
        return sug;
    });
}
exports.calcSuggestionAdjustedToToMatchCase = calcSuggestionAdjustedToToMatchCase;
function limitResults(suggestions, numSuggestions, includeTies) {
    let cost = suggestions[0]?.cost;
    let i = 0;
    for (; i < suggestions.length; ++i) {
        if (i >= numSuggestions && (!includeTies || suggestions[i].cost > cost)) {
            break;
        }
        cost = suggestions[i].cost;
    }
    return suggestions.slice(0, i);
}
function validateDictionaries(settings, dictionaries) {
    if (!dictionaries?.length)
        return;
    const knownDicts = new Set(settings.dictionaryDefinitions?.map((def) => def.name) || []);
    for (const dict of dictionaries) {
        if (!knownDicts.has(dict)) {
            throw new SuggestionError(`Unknown dictionary: "${dict}"`, 'E_dictionary_unknown');
        }
    }
}
function matchCase(word, isPreferred, style) {
    const locale = style.locale;
    if (style.isMixedCaps) {
        /**
         * Do not try matching mixed caps.
         */
        return word;
    }
    if (hasCaps(word)) {
        if (style.isAllCaps)
            return word.toLocaleUpperCase(locale);
        if (!style.ignoreCase || style.hasCaps || isPreferred)
            return word;
        if (isTitleCase(word) || isAllCaps(word))
            return word.toLocaleLowerCase(locale);
        return word;
    }
    if (!style.hasCaps)
        return word;
    if (style.isAllCaps)
        return word.toLocaleUpperCase(locale);
    (0, assert_1.default)(style.isTitleCase);
    return word.replace(/^\p{L}/u, (firstLetter) => firstLetter.toLocaleUpperCase(locale));
}
const regExpHasCaps = /\p{Lu}/u;
const regExpIsAllCaps = /^[\P{L}\p{Lu}]+$/u;
const regExpIsTitleCase = /^\p{Lu}[\P{L}\p{Ll}]+$/u;
function analyzeCase(word) {
    const hasCaps = regExpHasCaps.test(word);
    const isAllCaps = hasCaps && regExpIsAllCaps.test(word);
    const isTitleCase = hasCaps && !isAllCaps && regExpIsTitleCase.test(word);
    const isMixedCaps = hasCaps && !isAllCaps && !isTitleCase;
    return { hasCaps, isAllCaps, isMixedCaps, isTitleCase };
}
function hasCaps(word) {
    return regExpHasCaps.test(word);
}
function isTitleCase(word) {
    return regExpIsTitleCase.test(word);
}
function isAllCaps(word) {
    return regExpIsAllCaps.test(word);
}
class SuggestionError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
exports.SuggestionError = SuggestionError;
//# sourceMappingURL=suggestions.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal = exports.getIgnoreRegExpFromDocument = exports.getIgnoreWordsFromDocument = exports.extractInDocDictionary = exports.regExSpellingGuardLine = exports.regExSpellingGuardNext = exports.regExSpellingGuardBlock = exports.validateInDocumentSettings = exports.getInDocumentSettings = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const gensequence_1 = require("gensequence");
const index_js_1 = require("../SpellingDictionary/index.js");
const Text = __importStar(require("../util/text.js"));
const util_js_1 = require("../util/util.js");
const CSpellSettingsServer_js_1 = require("./CSpellSettingsServer.js");
// cspell:ignore gimuy
const regExMatchRegEx = /\/.*\/[gimuy]*/;
const regExCSpellInDocDirective = /\b(?:spell-?checker|c?spell)::?(.*)/gi;
const regExCSpellDirectiveKey = /(?<=\b(?:spell-?checker|c?spell)::?)(?!:)(.*)/i;
const regExInFileSettings = [regExCSpellInDocDirective, /\b(LocalWords:?.*)/g];
const officialDirectives = [
    'enable',
    'disable',
    'disable-line',
    'disable-next',
    'disable-next-line',
    'word',
    'words',
    'ignore',
    'ignoreWord',
    'ignoreWords',
    'ignore-word',
    'ignore-words',
    'includeRegExp',
    'ignoreRegExp',
    'local',
    'locale',
    'language',
    'dictionaries',
    'dictionary',
    'forbid',
    'forbidWord',
    'forbid-word',
    'flag',
    'flagWord',
    'flag-word',
    'enableCompoundWords',
    'enableAllowCompoundWords',
    'disableCompoundWords',
    'disableAllowCompoundWords',
    'enableCaseSensitive',
    'disableCaseSensitive',
];
const noSuggestDirectives = new Set(['local']);
const preferredDirectives = [
    'enable',
    'disable',
    'disable-line',
    'disable-next-line',
    'words',
    'ignore',
    'forbid',
    'locale',
    'dictionary',
    'dictionaries',
    'enableCaseSensitive',
    'disableCaseSensitive',
];
const allDirectives = new Set(preferredDirectives.concat(officialDirectives));
const allDirectiveSuggestions = [
    ...(0, sync_1.pipeSync)(allDirectives, (0, sync_1.opMap)((word) => ({ word }))),
];
const dictInDocSettings = (0, index_js_1.createSpellingDictionary)(allDirectives, 'Directives', 'Directive List', {
    supportNonStrictSearches: false,
});
const EmptyWords = [];
Object.freeze(EmptyWords);
const staticInDocumentDictionaryName = `[in-document-dict]`;
function getInDocumentSettings(text) {
    const collectedSettings = getPossibleInDocSettings(text)
        .concatMap((a) => parseSettingMatch(a))
        .reduce((s, setting) => {
        return (0, CSpellSettingsServer_js_1.mergeInDocSettings)(s, setting);
    }, { id: 'in-doc-settings' });
    const { words, flagWords, ignoreWords, suggestWords, dictionaries = [], dictionaryDefinitions = [], ...rest } = collectedSettings;
    const dict = (words || flagWords || ignoreWords || suggestWords) &&
        (0, util_js_1.clean)({
            name: staticInDocumentDictionaryName,
            words,
            flagWords,
            ignoreWords,
            suggestWords,
        });
    const dictSettings = dict
        ? {
            dictionaries: dictionaries.concat(staticInDocumentDictionaryName),
            dictionaryDefinitions: dictionaryDefinitions.concat(dict),
        }
        : (0, util_js_1.clean)({
            dictionaries: dictionaries.length ? dictionaries : undefined,
            dictionaryDefinitions: dictionaryDefinitions.length ? dictionaryDefinitions : undefined,
        });
    const settings = {
        ...rest,
        ...dictSettings,
    };
    // console.log('InDocSettings: %o', settings);
    return settings;
}
exports.getInDocumentSettings = getInDocumentSettings;
function validateInDocumentSettings(docText, _settings) {
    return (0, sync_1.pipeSync)(getPossibleInDocSettings(docText), (0, sync_1.opMap)(parseSettingMatchValidation), (0, sync_1.opFilter)(util_js_1.isDefined));
}
exports.validateInDocumentSettings = validateInDocumentSettings;
const settingParsers = [
    [/^(?:enable|disable)(?:allow)?CompoundWords\b(?!-)/i, parseCompoundWords],
    [/^(?:enable|disable)CaseSensitive\b(?!-)/i, parseCaseSensitive],
    [/^enable\b(?!-)/i, parseEnable],
    [/^disable(-line|-next(-line)?)?\b(?!-)/i, parseDisable],
    [/^words?\b(?!-)/i, parseWords],
    [/^ignore(?:-?words?)?\b(?!-)/i, parseIgnoreWords],
    [/^(?:flag|forbid)(?:-?words?)?\b(?!-)/i, parseFlagWords],
    [/^ignore_?Reg_?Exp\s+.+$/i, parseIgnoreRegExp],
    [/^include_?Reg_?Exp\s+.+$/i, parseIncludeRegExp],
    [/^locale?\b(?!-)/i, parseLocale],
    [/^language\s\b(?!-)/i, parseLocale],
    [/^dictionar(?:y|ies)\b(?!-)/i, parseDictionaries],
    [/^LocalWords:/, (w) => parseWords(w.replace(/^LocalWords:?/gi, ' '))],
];
exports.regExSpellingGuardBlock = /(\bc?spell(?:-?checker)?::?)\s*disable(?!-line|-next)\b[\s\S]*?((?:\1\s*enable\b)|$)/gi;
exports.regExSpellingGuardNext = /\bc?spell(?:-?checker)?::?\s*disable-next\b.*\s\s?.*/gi;
exports.regExSpellingGuardLine = /^.*\bc?spell(?:-?checker)?::?\s*disable-line\b.*/gim;
const emptySettings = Object.freeze({});
const issueMessages = {
    unknownDirective: 'Unknown CSpell directive',
};
function parseSettingMatchValidation(matchArray) {
    const [fullMatch = ''] = matchArray;
    const directiveMatch = fullMatch.match(regExCSpellDirectiveKey);
    if (!directiveMatch)
        return undefined;
    const match = directiveMatch[1];
    const possibleSetting = match.trim();
    if (!possibleSetting)
        return undefined;
    const start = (matchArray.index || 0) + (directiveMatch.index || 0) + (match.length - match.trimStart().length);
    const text = possibleSetting.replace(/^([-\w]+)?.*/, '$1');
    const end = start + text.length;
    if (!text)
        return undefined;
    const matchingParsers = settingParsers.filter(([regex]) => regex.test(possibleSetting));
    if (matchingParsers.length > 0)
        return undefined;
    // No matches were found, let make some suggestions.
    const dictSugs = dictInDocSettings
        .suggest(text, { ignoreCase: false })
        .map(({ word, isPreferred }) => (isPreferred ? { word, isPreferred } : { word }))
        .filter((a) => !noSuggestDirectives.has(a.word));
    const sugs = (0, sync_1.pipeSync)(dictSugs, (0, sync_1.opAppend)(allDirectiveSuggestions), filterUniqueSuggestions);
    const suggestionsEx = [...sugs].slice(0, 8);
    const suggestions = suggestionsEx.map((s) => s.word);
    const issue = {
        range: [start, end],
        text,
        message: issueMessages.unknownDirective,
        suggestions,
        suggestionsEx,
    };
    return issue;
}
function* filterUniqueSuggestions(sugs) {
    const map = new Map();
    for (const sug of sugs) {
        const existing = map.get(sug.word);
        if (existing) {
            if (sug.isPreferred) {
                existing.isPreferred = true;
            }
        }
        yield sug;
    }
}
function parseSettingMatch(matchArray) {
    const [, match = ''] = matchArray;
    const possibleSetting = match.trim();
    return settingParsers
        .filter(([regex]) => regex.test(possibleSetting))
        .map(([, fn]) => fn)
        .map((fn) => fn(possibleSetting));
}
function parseCompoundWords(match) {
    const allowCompoundWords = /enable/i.test(match);
    return { allowCompoundWords };
}
function parseCaseSensitive(match) {
    const caseSensitive = /enable/i.test(match);
    return { caseSensitive };
}
function parseWords(match) {
    const words = match
        // .replace(/[@#$%^&={}/"]/g, ' ')
        .split(/[,\s;]+/g)
        .slice(1)
        .filter((a) => !!a);
    return { words };
}
function parseLocale(match) {
    const parts = match.trim().split(/[\s,]+/);
    const language = parts.slice(1).join(',');
    return language ? { language } : emptySettings;
}
function parseIgnoreWords(match) {
    const wordsSetting = parseWords(match);
    const ignoreWords = wordsSetting.words;
    return ignoreWords && ignoreWords.length ? { ignoreWords } : emptySettings;
}
function parseFlagWords(match) {
    const wordsSetting = parseWords(match);
    const flagWords = wordsSetting.words;
    return flagWords && flagWords.length ? { flagWords } : emptySettings;
}
function parseRegEx(match) {
    const patterns = [match.replace(/^[^\s]+\s+/, '')].map((a) => {
        const m = a.match(regExMatchRegEx);
        if (m && m[0]) {
            return m[0];
        }
        return a.replace(/((?:[^\s]|\\ )+).*/, '$1');
    });
    return patterns;
}
function parseIgnoreRegExp(match) {
    const ignoreRegExpList = parseRegEx(match);
    return { ignoreRegExpList };
}
function parseIncludeRegExp(match) {
    const includeRegExpList = parseRegEx(match);
    return { includeRegExpList };
}
function parseDictionaries(match) {
    const dictionaries = match.split(/[,\s]+/g).slice(1);
    return { dictionaries };
}
function getPossibleInDocSettings(text) {
    return (0, gensequence_1.genSequence)(regExInFileSettings).concatMap((regexp) => Text.match(regexp, text));
}
function getWordsFromDocument(text) {
    const dict = extractInDocDictionary(getInDocumentSettings(text));
    return dict?.words || EmptyWords;
}
function parseEnable(_match) {
    // Do nothing. Enable / Disable is handled in a different way.
    return {};
}
function parseDisable(_match) {
    // Do nothing. Enable / Disable is handled in a different way.
    return {};
}
function extractInDocDictionary(settings) {
    const inDocDicts = settings.dictionaryDefinitions?.filter((def) => def.name === staticInDocumentDictionaryName);
    const dict = inDocDicts?.[0];
    return dict;
}
exports.extractInDocDictionary = extractInDocDictionary;
function getIgnoreWordsFromDocument(text) {
    const dict = extractInDocDictionary(getInDocumentSettings(text));
    return dict?.ignoreWords || EmptyWords;
}
exports.getIgnoreWordsFromDocument = getIgnoreWordsFromDocument;
function getIgnoreRegExpFromDocument(text) {
    const { ignoreRegExpList = [] } = getInDocumentSettings(text);
    return ignoreRegExpList;
}
exports.getIgnoreRegExpFromDocument = getIgnoreRegExpFromDocument;
/**
 * These internal functions are used exposed for unit testing.
 */
exports.internal = {
    getPossibleInDocSettings,
    getWordsFromDocument,
    parseWords,
    parseCompoundWords,
    parseIgnoreRegExp,
    parseIgnoreWords,
    staticInDocumentDictionaryName,
};
//# sourceMappingURL=InDocSettings.js.map
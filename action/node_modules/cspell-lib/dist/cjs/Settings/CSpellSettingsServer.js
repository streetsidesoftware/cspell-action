"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testing__ = exports.extractDependencies = exports.getSources = exports.checkFilenameMatchesGlob = exports.toInternalSettings = exports.finalizeSettings = exports.calcOverrideSettings = exports.mergeInDocSettings = exports.mergeSettings = void 0;
const assert_1 = __importDefault(require("assert"));
const cspell_glob_1 = require("cspell-glob");
const path = __importStar(require("path"));
const CSpellSettingsInternalDef_js_1 = require("../Models/CSpellSettingsInternalDef.js");
const AutoResolve_js_1 = require("../util/AutoResolve.js");
const util = __importStar(require("../util/util.js"));
const constants_js_1 = require("./constants.js");
const DictionarySettings_js_1 = require("./DictionarySettings.js");
const patterns_js_1 = require("./patterns.js");
function mergeListUnique(left, right) {
    if (!Array.isArray(left))
        return Array.isArray(right) ? right : undefined;
    if (!Array.isArray(right))
        return left;
    if (!right.length)
        return left;
    if (!left.length)
        return right;
    return [...new Set([...left, ...right])];
}
function mergeList(left, right) {
    if (!Array.isArray(left))
        return Array.isArray(right) ? right : undefined;
    if (!Array.isArray(right))
        return left;
    if (!left.length)
        return right;
    if (!right.length)
        return left;
    return left.concat(right);
}
const emptyWords = [];
Object.freeze(emptyWords);
const cachedMerges = new WeakMap();
function _mergeWordsCached(left, right) {
    const map = (0, AutoResolve_js_1.autoResolveWeak)(cachedMerges, left, () => new WeakMap());
    return (0, AutoResolve_js_1.autoResolveWeak)(map, right, () => left.concat(right));
}
function mergeWordsCached(left, right) {
    if (!Array.isArray(left) || !left.length) {
        return Array.isArray(right) ? (right.length ? right : emptyWords) : undefined;
    }
    if (!Array.isArray(right) || !right.length)
        return left;
    return _mergeWordsCached(left, right);
}
function mergeObjects(left, right) {
    if (!left || typeof left !== 'object')
        return !right || typeof right !== 'object' ? undefined : right;
    if (!right || typeof right !== 'object')
        return left;
    return { ...left, ...right };
}
function replaceIfNotEmpty(left = [], right = []) {
    const filtered = right.filter((a) => !!a);
    if (filtered.length) {
        return filtered;
    }
    return left;
}
function mergeSettings(left, ...settings) {
    const rawSettings = settings.filter(util.isDefined).reduce(merge, toInternalSettings(left));
    return util.clean(rawSettings);
}
exports.mergeSettings = mergeSettings;
// eslint-disable-next-line @typescript-eslint/ban-types
function isEmpty(obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
}
const mergeCache = new AutoResolve_js_1.AutoResolveWeakCache();
function merge(left, right) {
    const map = mergeCache.get(left, () => new WeakMap());
    return (0, AutoResolve_js_1.autoResolveWeak)(map, right, () => _merge(left, right));
}
function _merge(left, right) {
    const _left = toInternalSettings(left);
    const _right = toInternalSettings(right);
    if (left === right) {
        return _left;
    }
    if (isEmpty(right)) {
        return _left;
    }
    if (isEmpty(left)) {
        return _right;
    }
    if (isLeftAncestorOfRight(_left, _right)) {
        return _right;
    }
    if (doesLeftHaveRightAncestor(_left, _right)) {
        return _left;
    }
    const includeRegExpList = takeRightOtherwiseLeft(_left.includeRegExpList, _right.includeRegExpList);
    const optionals = includeRegExpList?.length ? { includeRegExpList } : {};
    const version = max(_left.version, _right.version);
    const valuesToClear = {
        name: undefined,
        id: undefined,
        description: undefined,
        globRoot: undefined,
        import: undefined,
        __importRef: undefined,
    };
    const settings = (0, CSpellSettingsInternalDef_js_1.cleanCSpellSettingsInternal)({
        ..._left,
        ..._right,
        ...optionals,
        ...valuesToClear,
        version,
        words: mergeWordsCached(_left.words, _right.words),
        userWords: mergeWordsCached(_left.userWords, _right.userWords),
        flagWords: mergeWordsCached(_left.flagWords, _right.flagWords),
        ignoreWords: mergeWordsCached(_left.ignoreWords, _right.ignoreWords),
        suggestWords: mergeWordsCached(_left.suggestWords, _right.suggestWords),
        enabledLanguageIds: replaceIfNotEmpty(_left.enabledLanguageIds, _right.enabledLanguageIds),
        enableFiletypes: mergeList(_left.enableFiletypes, _right.enableFiletypes),
        ignoreRegExpList: mergeListUnique(_left.ignoreRegExpList, _right.ignoreRegExpList),
        patterns: mergeListUnique(_left.patterns, _right.patterns),
        dictionaryDefinitions: mergeListUnique(_left.dictionaryDefinitions, _right.dictionaryDefinitions),
        dictionaries: mergeListUnique(_left.dictionaries, _right.dictionaries),
        noSuggestDictionaries: mergeListUnique(_left.noSuggestDictionaries, _right.noSuggestDictionaries),
        languageSettings: mergeList(_left.languageSettings, _right.languageSettings),
        enabled: _right.enabled !== undefined ? _right.enabled : _left.enabled,
        files: mergeListUnique(_left.files, _right.files),
        ignorePaths: versionBasedMergeList(_left.ignorePaths, _right.ignorePaths, version),
        overrides: versionBasedMergeList(_left.overrides, _right.overrides, version),
        features: mergeObjects(_left.features, _right.features),
        source: mergeSources(_left, _right),
        plugins: mergeList(_left.plugins, _right.plugins),
        __imports: mergeImportRefs(_left, _right),
    });
    return settings;
}
function versionBasedMergeList(left, right, version) {
    if (version === constants_js_1.configSettingsFileVersion0_1) {
        return takeRightOtherwiseLeft(left, right);
    }
    return mergeListUnique(left, right);
}
/**
 * Check to see if left is a left ancestor of right.
 * If that is the case, merging is not necessary:
 * @param left - setting on the left side of a merge
 * @param right - setting on the right side of a merge
 */
function isLeftAncestorOfRight(left, right) {
    return hasAncestor(right, left, 0);
}
/**
 * Check to see if left has right as an ancestor to the right.
 * If that is the case, merging is not necessary:
 * @param left - setting on the left side of a merge
 * @param right - setting on the right side of a merge
 */
function doesLeftHaveRightAncestor(left, right) {
    return hasAncestor(left, right, 1);
}
function hasAncestor(s, ancestor, side) {
    const sources = s.source?.sources;
    if (!sources)
        return false;
    // calc the first or last index of the source array.
    const i = side ? sources.length - 1 : 0;
    const src = sources[i];
    return src === ancestor || (src && hasAncestor(src, ancestor, side)) || false;
}
function mergeInDocSettings(left, right) {
    const merged = {
        ...mergeSettings(left, right),
        includeRegExpList: mergeListUnique(left.includeRegExpList, right.includeRegExpList),
    };
    return util.clean(merged);
}
exports.mergeInDocSettings = mergeInDocSettings;
function takeRightOtherwiseLeft(left, right) {
    if (right?.length) {
        return right;
    }
    return left || right;
}
function calcOverrideSettings(settings, filename) {
    const _settings = toInternalSettings(settings);
    const overrides = _settings.overrides || [];
    const result = overrides
        .filter((override) => checkFilenameMatchesGlob(filename, override.filename))
        .reduce((settings, override) => mergeSettings(settings, override), _settings);
    return result;
}
exports.calcOverrideSettings = calcOverrideSettings;
/**
 *
 * @param settings - settings to finalize
 * @returns settings where all globs and file paths have been resolved.
 */
function finalizeSettings(settings) {
    return _finalizeSettings(toInternalSettings(settings));
}
exports.finalizeSettings = finalizeSettings;
function _finalizeSettings(settings) {
    // apply patterns to any RegExpLists.
    const finalized = {
        ...settings,
        finalized: true,
        ignoreRegExpList: (0, patterns_js_1.resolvePatterns)(settings.ignoreRegExpList, settings.patterns),
        includeRegExpList: (0, patterns_js_1.resolvePatterns)(settings.includeRegExpList, settings.patterns),
        parserFn: resolveParser(settings),
    };
    finalized.name = 'Finalized ' + (finalized.name || '');
    finalized.source = { name: settings.name || 'src', sources: [settings] };
    return finalized;
}
const cacheInternalSettings = new AutoResolve_js_1.AutoResolveWeakCache();
function toInternalSettings(settings) {
    if (settings === undefined)
        return undefined;
    if ((0, CSpellSettingsInternalDef_js_1.isCSpellSettingsInternal)(settings))
        return settings;
    return cacheInternalSettings.get(settings, _toInternalSettings);
}
exports.toInternalSettings = toInternalSettings;
function _toInternalSettings(settings) {
    const { dictionaryDefinitions: defs, ...rest } = settings;
    const dictionaryDefinitions = (0, DictionarySettings_js_1.mapDictDefsToInternal)(defs, filenameToDirectory(settings.source?.filename) || resolveCwd());
    const setting = dictionaryDefinitions ? { ...rest, dictionaryDefinitions } : rest;
    return (0, CSpellSettingsInternalDef_js_1.cleanCSpellSettingsInternal)(setting);
}
function filenameToDirectory(filename) {
    return filename ? path.dirname(filename) : undefined;
}
/**
 * @param filename - filename
 * @param globs - globs
 * @returns true if it matches
 * @deprecated true
 * @deprecationMessage No longer actively supported. Use package: `cspell-glob`.
 */
function checkFilenameMatchesGlob(filename, globs) {
    const m = new cspell_glob_1.GlobMatcher(globs);
    return m.match(filename);
}
exports.checkFilenameMatchesGlob = checkFilenameMatchesGlob;
function mergeSources(left, right) {
    return {
        name: 'merged',
        sources: [left, right],
    };
}
function max(a, b) {
    if (a === undefined || a === null)
        return b;
    if (b === undefined || b === null)
        return a;
    return a > b ? a : b;
}
/**
 * Return a list of Setting Sources used to create this Setting.
 * @param settings the settings to search
 */
function getSources(settings) {
    const visited = new Set();
    const sources = [];
    function _walkSourcesTree(settings) {
        if (!settings || visited.has(settings))
            return;
        visited.add(settings);
        if (!settings.source?.sources?.length) {
            sources.push(settings);
            return;
        }
        settings.source.sources.forEach(_walkSourcesTree);
    }
    _walkSourcesTree(settings);
    return sources;
}
exports.getSources = getSources;
function mergeImportRefs(left, right = {}) {
    const imports = new Map(left.__imports || []);
    if (left.__importRef) {
        imports.set(left.__importRef.filename, left.__importRef);
    }
    if (right.__importRef) {
        imports.set(right.__importRef.filename, right.__importRef);
    }
    const rightImports = right.__imports?.values() || [];
    for (const ref of rightImports) {
        imports.set(ref.filename, ref);
    }
    return imports.size ? imports : undefined;
}
function extractDependencies(settings) {
    const settingsI = toInternalSettings(settings);
    const configFiles = [...(mergeImportRefs(settingsI) || [])].map(([filename]) => filename);
    const dictionaryFiles = (0, DictionarySettings_js_1.calcDictionaryDefsToLoad)(settingsI)
        .map((dict) => dict.path)
        .filter((file) => !!file);
    return {
        configFiles,
        dictionaryFiles,
    };
}
exports.extractDependencies = extractDependencies;
function resolveCwd() {
    const envGlobRoot = process.env[constants_js_1.ENV_CSPELL_GLOB_ROOT];
    const cwd = envGlobRoot || process.cwd();
    return cwd;
}
function resolveParser(settings) {
    if (!settings.parser)
        return undefined;
    if (typeof settings.parser === 'function')
        return settings.parser;
    const parserName = settings.parser;
    (0, assert_1.default)(typeof parserName === 'string');
    const parsers = extractParsers(settings.plugins);
    const parser = parsers.get(parserName);
    (0, assert_1.default)(parser, `Parser "${parserName}" not found.`);
    return parser;
}
const parserCache = new AutoResolve_js_1.AutoResolveWeakCache();
const emptyParserMap = new Map();
function* parsers(plugins) {
    for (const plugin of plugins) {
        if (!plugin.parsers)
            continue;
        for (const parser of plugin.parsers) {
            yield [parser.name, parser];
        }
    }
}
function mapPlugins(plugins) {
    return new Map(parsers(plugins));
}
function extractParsers(plugins) {
    if (!plugins || !plugins.length)
        return emptyParserMap;
    return parserCache.get(plugins, mapPlugins);
}
exports.__testing__ = {
    mergeObjects,
};
//# sourceMappingURL=CSpellSettingsServer.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testing__ = exports.from = exports.resolvePath = exports.joinPath = exports.extname = exports.dirname = exports.basename = exports.isUri = exports.normalizeDriveLetter = exports.parse = exports.file = exports.fromStdinFilePath = exports.fromFilePath = exports.uriToFilePath = exports.toUri = void 0;
const assert_1 = __importDefault(require("assert"));
const vscode_uri_1 = require("vscode-uri");
const isFile = /^(?:[a-zA-Z]:|[/\\])/;
const isPossibleUri = /\w:\/\//;
const isUrl = /^(file:|stdin:|https?:|s?ftp:)/;
const STDIN_PROTOCOL = 'stdin:';
function toUri(uriOrFile) {
    if (UriImpl.isUri(uriOrFile))
        return uriOrFile;
    if (vscode_uri_1.URI.isUri(uriOrFile))
        return UriImpl.from(uriOrFile);
    if (uriOrFile instanceof URL)
        return UriImpl.parse(uriOrFile.toString());
    if (isUrlLike(uriOrFile))
        return UriImpl.parse(uriOrFile.href);
    if (isUri(uriOrFile))
        return UriImpl.from(uriOrFile);
    if (isUrl.test(uriOrFile))
        return UriImpl.parse(uriOrFile);
    return isFile.test(uriOrFile) && !isPossibleUri.test(uriOrFile)
        ? UriImpl.file(normalizeDriveLetter(uriOrFile))
        : UriImpl.parse(uriOrFile);
}
exports.toUri = toUri;
const hasDriveLetter = /^[A-Z]:/i;
function uriToFilePath(uri) {
    const adj = uri.scheme === 'stdin' ? { scheme: 'file' } : {};
    return normalizeDriveLetter(vscode_uri_1.URI.from(UriImpl.from(uri, adj)).fsPath);
}
exports.uriToFilePath = uriToFilePath;
function fromFilePath(file) {
    return UriImpl.file(file);
}
exports.fromFilePath = fromFilePath;
function fromStdinFilePath(path) {
    return UriImpl.stdin(path);
}
exports.fromStdinFilePath = fromStdinFilePath;
exports.file = fromFilePath;
function parse(uri) {
    return UriImpl.parse(uri);
}
exports.parse = parse;
function normalizeDriveLetter(path) {
    return hasDriveLetter.test(path) ? path[0].toLowerCase() + path.slice(1) : path;
}
exports.normalizeDriveLetter = normalizeDriveLetter;
function isUrlLike(url) {
    return (!!url && typeof url === 'object' && typeof url.href === 'string') || false;
}
function isUri(uri) {
    if (!uri || typeof uri !== 'object')
        return false;
    if (UriImpl.isUri(uri))
        return true;
    if (vscode_uri_1.URI.isUri(uri))
        return true;
    const u = uri;
    return typeof u.path === 'string' && typeof u.scheme === 'string';
}
exports.isUri = isUri;
function basename(uri) {
    return vscode_uri_1.Utils.basename(vscode_uri_1.URI.from(uri));
}
exports.basename = basename;
function dirname(uri) {
    return UriImpl.from(vscode_uri_1.Utils.dirname(vscode_uri_1.URI.from(uri)));
}
exports.dirname = dirname;
function extname(uri) {
    return vscode_uri_1.Utils.extname(vscode_uri_1.URI.from(uri));
}
exports.extname = extname;
function joinPath(uri, ...paths) {
    return UriImpl.from(vscode_uri_1.Utils.joinPath(vscode_uri_1.URI.from(uri), ...paths));
}
exports.joinPath = joinPath;
function resolvePath(uri, ...paths) {
    return UriImpl.from(vscode_uri_1.Utils.resolvePath(vscode_uri_1.URI.from(uri), ...paths));
}
exports.resolvePath = resolvePath;
function from(uri, ...parts) {
    return UriImpl.from(uri, ...parts);
}
exports.from = from;
const keys = ['scheme', 'authority', 'path', 'query', 'fragment'];
class UriImpl {
    constructor(uri) {
        this.scheme = uri.scheme || '';
        uri.authority && (this.authority = uri.authority);
        this.path = uri.path || '';
        uri.query && (this.query = uri.query);
        uri.fragment && (this.fragment = uri.fragment);
    }
    toString() {
        const path = this.path;
        const base = `${this.scheme}://${this.authority || ''}${path}`;
        const query = (this.query && `?${this.query}`) || '';
        const fragment = (this.fragment && `#${this.fragment}`) || '';
        const url = base + query + fragment;
        return encodeURI(url);
    }
    toJson() {
        const { scheme, authority, path, query, fragment } = this;
        return { scheme, authority, path, query, fragment };
    }
    with(change) {
        const { scheme, authority, path, query, fragment } = this;
        const u = { scheme, authority, path, query, fragment };
        for (const key of keys) {
            if (change[key] && typeof change[key] === 'string') {
                u[key] = change[key];
            }
        }
        return new UriImpl(u);
    }
    static isUri(uri) {
        return uri instanceof UriImpl;
    }
    static from(uri, ...parts) {
        let u = new UriImpl(uri);
        for (const part of parts) {
            u = u.with(part);
        }
        return u;
    }
    static parse(uri) {
        if (uri.startsWith(STDIN_PROTOCOL)) {
            return UriImpl.from(parseStdinUri(uri));
        }
        const u = vscode_uri_1.URI.parse(uri);
        return UriImpl.from(u);
    }
    static file(filename) {
        return UriImpl.from(vscode_uri_1.URI.file(normalizeFilePath(filename)));
    }
    static stdin(filePath = '') {
        return UriImpl.from(UriImpl.file(filePath), { scheme: 'stdin' });
    }
}
function normalizeFilePath(path) {
    return normalizeDriveLetter(path.replace(/\\/g, '/'));
}
function parseStdinUri(uri) {
    (0, assert_1.default)(uri.startsWith(STDIN_PROTOCOL));
    const idxSlash = STDIN_PROTOCOL.length;
    let idxSlashEnd = idxSlash;
    for (; uri[idxSlashEnd] === '/'; ++idxSlashEnd) {
        // empty
    }
    const pathStart = idxSlashEnd;
    const iH = uri.indexOf('#', pathStart);
    const idxHash = iH > 0 ? iH : uri.length;
    const iQ = uri.indexOf('?', pathStart);
    const idxQ = iQ > 0 && iQ < idxHash ? iQ : idxHash;
    const pathEnd = idxQ;
    const path = uri.slice(pathStart, pathEnd);
    const query = idxQ < idxHash ? uri.slice(idxQ + 1, idxHash) : '';
    const hash = uri.slice(idxHash + 1);
    const pathPrefix = idxSlashEnd - idxSlash > 2 ? '/' : '';
    return {
        scheme: 'stdin',
        path: pathPrefix + normalizeFilePath(decodeURI(path)),
        query: decodeURI(query),
        fragment: decodeURI(hash),
    };
}
exports.__testing__ = {
    UriImpl,
    normalizeFilePath,
};
//# sourceMappingURL=Uri.js.map
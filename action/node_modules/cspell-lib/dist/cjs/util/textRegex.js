"use strict";
// cspell:ignore ings ning gimuy anrvtbf gimuxy
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringToRegExp = exports.regExNumericLiteral = exports.regExTrailingEndings = exports.regExDanglingQuote = exports.regExEscapeCharacters = exports.regExAccents = exports.regExMatchRegExParts = exports.regExPossibleWordBreaks = exports.regExAllLower = exports.regExAllUpper = exports.regExFirstUpper = exports.regExIgnoreCharacters = exports.regExWordsAndDigits = exports.regExWords = exports.regExSplitWords2 = exports.regExSplitWords = exports.regExUpperSOrIng = void 0;
exports.regExUpperSOrIng = /([\p{Lu}\p{M}]+\\?['’]?(?:s|ing|ies|es|ings|ed|ning))(?!\p{Ll})/gu;
exports.regExSplitWords = /(\p{Ll}\p{M}?)(\p{Lu})/gu;
exports.regExSplitWords2 = /(\p{Lu}\p{M}?)(\p{Lu}\p{M}?\p{Ll})/gu;
exports.regExWords = /\p{L}\p{M}?(?:(?:\\?['’])?\p{L}\p{M}?)*/gu;
// Words can be made of letters, numbers, period, underscore, dash, plus, and single quote
exports.regExWordsAndDigits = /[\p{L}\w'’`.+-](?:(?:\\(?=[']))?[\p{L}\p{M}\w'’`.+-])*/gu;
exports.regExIgnoreCharacters = /[\p{sc=Hiragana}\p{sc=Han}\p{sc=Katakana}\u30A0-\u30FF\p{sc=Hangul}]/gu;
exports.regExFirstUpper = /^\p{Lu}\p{M}?\p{Ll}+$/u;
exports.regExAllUpper = /^(?:\p{Lu}\p{M}?)+$/u;
exports.regExAllLower = /^(?:\p{Ll}\p{M}?)+$/u;
exports.regExPossibleWordBreaks = /[-+_’'`.\s]/g;
exports.regExMatchRegExParts = /^\s*\/([\s\S]*?)\/([gimuxy]*)\s*$/;
exports.regExAccents = /\p{M}/gu;
exports.regExEscapeCharacters = /(?<=\\)[anrvtbf]/gi;
/** Matches against leading `'` or `{single letter}'` */
exports.regExDanglingQuote = /(?<=(?:^|(?!\p{M})\P{L})(?:\p{L}\p{M}?)?)[']/gu;
/** Match tailing endings after CAPS words */
exports.regExTrailingEndings = /(?<=(?:\p{Lu}\p{M}?){2})['’]?(?:s|d|ings?|ies|e[ds]?|ning|th|nth)(?!\p{Ll})/gu;
exports.regExNumericLiteral = /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/;
function stringToRegExp(pattern, defaultFlags = 'gimu', forceFlags = 'g') {
    if (pattern instanceof RegExp) {
        return pattern;
    }
    try {
        const [, pat, flag] = [
            ...(pattern.match(exports.regExMatchRegExParts) || ['', pattern.trim(), defaultFlags]),
            forceFlags,
        ];
        if (pat) {
            const regPattern = flag.includes('x') ? removeVerboseFromRegExp(pat) : pat;
            // Make sure the flags are unique.
            const flags = [...new Set(forceFlags + flag)].join('').replace(/[^gimuy]/g, '');
            const regex = new RegExp(regPattern, flags);
            return regex;
        }
    }
    catch (e) {
        /* empty */
    }
    return undefined;
}
exports.stringToRegExp = stringToRegExp;
const SPACES = {
    ' ': true,
    '\n': true,
    '\r': true,
    '\t': true,
};
/**
 * Remove all whitespace and comments from a regexp string. The format follows Pythons Verbose.
 * Note: this is a best attempt. Special cases for comments: `#` and spaces should be proceeded with a `\`
 *
 * All space must be proceeded by a `\` or in a character class `[]`
 *
 * @param pattern - the pattern to clean
 */
function removeVerboseFromRegExp(pattern) {
    function escape(acc) {
        const char = pattern[acc.idx];
        if (char !== '\\')
            return undefined;
        const next = pattern[++acc.idx];
        acc.idx++;
        if (next === '#') {
            acc.result += '#';
            return acc;
        }
        if (!(next in SPACES)) {
            acc.result += '\\' + next;
            return acc;
        }
        acc.result += next;
        if (next === '\r' && pattern[acc.idx] === '\n') {
            acc.result += '\n';
            acc.idx++;
        }
        return acc;
    }
    function braces(acc) {
        const char = pattern[acc.idx];
        if (char !== '[')
            return undefined;
        acc.result += char;
        acc.idx++;
        let escCount = 0;
        while (acc.idx < pattern.length) {
            const char = pattern[acc.idx];
            acc.result += char;
            acc.idx++;
            if (char === ']' && !(escCount & 1))
                break;
            escCount = char === '\\' ? escCount + 1 : 0;
        }
        return acc;
    }
    function spaces(acc) {
        const char = pattern[acc.idx];
        if (!(char in SPACES))
            return undefined;
        acc.idx++;
        return acc;
    }
    function comments(acc) {
        const char = pattern[acc.idx];
        if (char !== '#')
            return undefined;
        while (acc.idx < pattern.length && pattern[acc.idx] !== '\n') {
            acc.idx++;
        }
        return acc;
    }
    function copy(acc) {
        const char = pattern[acc.idx++];
        acc.result += char;
        return acc;
    }
    const reducers = [escape, braces, spaces, comments, copy];
    const result = { idx: 0, result: '' };
    while (result.idx < pattern.length) {
        for (const r of reducers) {
            if (r(result))
                break;
        }
    }
    return result.result;
}
//# sourceMappingURL=textRegex.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMappedTextSegmenter = exports.mapRangeToLocal = exports.mapRangeBackToOriginalPos = exports.mapIssueBackToOriginalPos = void 0;
const TextMap_js_1 = require("../util/TextMap.js");
function mapIssueBackToOriginalPos(mappedText, issue) {
    if (!mappedText.map || mappedText.map.length === 0)
        return issue;
    const textOff = mapTextOffsetBackToOriginalPos(mappedText, issue);
    return {
        ...issue,
        ...textOff,
    };
}
exports.mapIssueBackToOriginalPos = mapIssueBackToOriginalPos;
function mapTextOffsetBackToOriginalPos(mappedText, textOff) {
    if (!mappedText.map || !mappedText.map.length)
        return textOff;
    const off = textOff.offset - mappedText.range[0];
    const range = mapRangeBackToOriginalPos([off, off + (textOff.length ?? textOff.text.length)], mappedText.map);
    return {
        text: textOff.text,
        offset: mappedText.range[0] + range[0],
        length: range[1] - range[0],
    };
}
function mapRangeBackToOriginalPos(offRange, map) {
    if (!map || !map.length)
        return offRange;
    const [start, end] = offRange;
    let i = 0, j = 0, p = 1;
    while (p < map.length && map[p] < start) {
        i = map[p - 1];
        j = map[p];
        p += 2;
    }
    const iA = start - j + i;
    while (p < map.length && map[p] < end) {
        i = map[p - 1];
        j = map[p];
        p += 2;
    }
    const iB = end - j + i;
    return [iA, iB];
}
exports.mapRangeBackToOriginalPos = mapRangeBackToOriginalPos;
function mapRangeToLocal(rangeOrig, map) {
    if (!map || !map.length)
        return rangeOrig;
    const [start, end] = rangeOrig;
    let i = 0, j = 0, p = 0;
    while (p < map.length && map[p] < start) {
        i = map[p];
        j = map[p + 1];
        p += 2;
    }
    const jA = start - i + j;
    while (p < map.length && map[p] < end) {
        i = map[p];
        j = map[p + 1];
        p += 2;
    }
    const jB = end - i + j;
    return [jA, jB];
}
exports.mapRangeToLocal = mapRangeToLocal;
/**
 * Factory to create a segmentation function that will segment MappedText against a set of includeRanges.
 * The function produced is optimized for forward scanning. It will perform poorly for randomly ordered offsets.
 * @param includeRanges Allowed ranges for words.
 */
function createMappedTextSegmenter(includeRanges) {
    let rangePos = 0;
    function* segmenter(pText) {
        if (!includeRanges.length) {
            return;
        }
        const range = pText.range;
        const textEndPos = range[1];
        let textStartPos = range[0];
        while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
            rangePos -= 1;
        }
        const cur = includeRanges[rangePos];
        if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
            yield pText;
            return;
        }
        while (textStartPos < textEndPos) {
            while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
                rangePos += 1;
            }
            if (!includeRanges[rangePos]) {
                break;
            }
            const { startPos, endPos } = includeRanges[rangePos];
            if (textEndPos < startPos) {
                break;
            }
            const a = Math.max(textStartPos, startPos);
            const b = Math.min(textEndPos, endPos);
            if (a !== b) {
                yield (0, TextMap_js_1.extractTextMapRangeOrigin)(pText, [a, b]);
            }
            textStartPos = b;
        }
    }
    return segmenter;
}
exports.createMappedTextSegmenter = createMappedTextSegmenter;
//# sourceMappingURL=parsedText.js.map
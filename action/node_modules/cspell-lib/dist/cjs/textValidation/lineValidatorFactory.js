"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.textValidatorFactory = exports.lineValidatorFactory = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const cspell_dictionary_1 = require("cspell-dictionary");
const RxPat = __importStar(require("../Settings/RegExpPatterns.js"));
const Text = __importStar(require("../util/text.js"));
const util_js_1 = require("../util/util.js");
const wordSplitter_js_1 = require("../util/wordSplitter.js");
const defaultConstants_js_1 = require("./defaultConstants.js");
const isWordValid_js_1 = require("./isWordValid.js");
const parsedText_js_1 = require("./parsedText.js");
function lineValidatorFactory(sDict, options) {
    const { minWordLength = defaultConstants_js_1.defaultMinWordLength, flagWords = [], allowCompoundWords = false, ignoreCase = true, } = options;
    const hasWordOptions = {
        ignoreCase,
        useCompounds: allowCompoundWords || undefined, // let the dictionaries decide on useCompounds if allow is false
    };
    const dictCol = (0, cspell_dictionary_1.createCachingDictionary)(sDict, hasWordOptions);
    const setOfFlagWords = new Set(flagWords);
    const setOfKnownSuccessfulWords = new Set();
    const rememberFilter = (fn) => (v) => {
        const keep = fn(v);
        if (!keep) {
            setOfKnownSuccessfulWords.add(v.text);
        }
        return keep;
    };
    const filterAlreadyChecked = (wo) => {
        return !setOfKnownSuccessfulWords.has(wo.text);
    };
    function testForFlaggedWord(wo) {
        const text = wo.text;
        return setOfFlagWords.has(text) || setOfFlagWords.has(text.toLowerCase()) || dictCol.isForbidden(text);
    }
    function isWordIgnored(word) {
        return dictCol.isNoSuggestWord(word);
    }
    function getSuggestions(word) {
        return dictCol.getPreferredSuggestions(word);
    }
    function isWordFlagged(word) {
        const isIgnored = isWordIgnored(word.text);
        const isFlagged = !isIgnored && testForFlaggedWord(word);
        return isFlagged;
    }
    function annotateIsFlagged(word) {
        word.isFlagged = isWordFlagged(word);
        return word;
    }
    function annotateIssue(issue) {
        const sugs = getSuggestions(issue.text);
        if (sugs && sugs.length) {
            issue.suggestionsEx = sugs;
        }
        return issue;
    }
    function checkWord(word) {
        const isIgnored = isWordIgnored(word.text);
        const { isFlagged = !isIgnored && testForFlaggedWord(word) } = word;
        const isFound = isFlagged ? undefined : isIgnored || (0, isWordValid_js_1.isWordValidWithEscapeRetry)(dictCol, word, word.line);
        return (0, util_js_1.clean)({ ...word, isFlagged, isFound });
    }
    const fn = (lineSegment) => {
        function splitterIsValid(word) {
            return (setOfKnownSuccessfulWords.has(word.text) ||
                (!testForFlaggedWord(word) && (0, isWordValid_js_1.isWordValidWithEscapeRetry)(dictCol, word, lineSegment.line)));
        }
        function checkFullWord(vr) {
            if (vr.isFlagged) {
                return [vr];
            }
            const codeWordResults = (0, sync_1.toArray)((0, sync_1.pipe)(Text.extractWordsFromCodeTextOffset(vr), (0, sync_1.opFilter)(filterAlreadyChecked), (0, sync_1.opMap)((t) => ({ ...t, line: vr.line })), (0, sync_1.opMap)(annotateIsFlagged), (0, sync_1.opFilter)(rememberFilter((wo) => wo.text.length >= minWordLength || !!wo.isFlagged)), (0, sync_1.opMap)((wo) => (wo.isFlagged ? wo : checkWord(wo))), (0, sync_1.opFilter)(rememberFilter((wo) => wo.isFlagged || !wo.isFound)), (0, sync_1.opFilter)(rememberFilter((wo) => !RxPat.regExRepeatedChar.test(wo.text))), 
            // get back the original text.
            (0, sync_1.opMap)((wo) => ({
                ...wo,
                text: Text.extractText(lineSegment.segment, wo.offset, wo.offset + wo.text.length),
            }))));
            if (!codeWordResults.length || isWordIgnored(vr.text) || checkWord(vr).isFound) {
                rememberFilter((_) => false)(vr);
                return [];
            }
            return codeWordResults;
        }
        function checkPossibleWords(possibleWord) {
            if (isWordFlagged(possibleWord)) {
                const vr = {
                    ...possibleWord,
                    line: lineSegment.line,
                    isFlagged: true,
                };
                return [vr];
            }
            const mismatches = (0, sync_1.toArray)((0, sync_1.pipe)(Text.extractWordsFromTextOffset(possibleWord), (0, sync_1.opFilter)(filterAlreadyChecked), (0, sync_1.opMap)((wo) => ({ ...wo, line: lineSegment.line })), (0, sync_1.opMap)(annotateIsFlagged), (0, sync_1.opFilter)(rememberFilter((wo) => wo.text.length >= minWordLength || !!wo.isFlagged)), (0, sync_1.opConcatMap)(checkFullWord)));
            if (mismatches.length) {
                // Try the more expensive word splitter
                const splitResult = (0, wordSplitter_js_1.split)(lineSegment.segment, possibleWord.offset, splitterIsValid);
                const nonMatching = splitResult.words.filter((w) => !w.isFound);
                if (nonMatching.length < mismatches.length) {
                    return nonMatching.map((w) => ({ ...w, line: lineSegment.line })).map(annotateIsFlagged);
                }
            }
            return mismatches;
        }
        const checkedPossibleWords = (0, sync_1.pipe)(Text.extractPossibleWordsFromTextOffset(lineSegment.segment), (0, sync_1.opFilter)(filterAlreadyChecked), (0, sync_1.opConcatMap)(checkPossibleWords), (0, sync_1.opMap)(annotateIssue));
        return checkedPossibleWords;
    };
    return { fn, dict: dictCol };
}
exports.lineValidatorFactory = lineValidatorFactory;
function textValidatorFactory(dict, options) {
    const lineValidator = lineValidatorFactory(dict, options);
    const lineValidatorFn = lineValidator.fn;
    function validate(pText) {
        const { text, range: srcRange, map } = pText;
        const srcOffset = srcRange[0];
        const segment = { text, offset: 0 };
        const lineSegment = { line: segment, segment };
        function mapBackToOriginSimple(vr) {
            const { text, offset, isFlagged, isFound, suggestionsEx } = vr;
            const r = (0, parsedText_js_1.mapRangeBackToOriginalPos)([offset, offset + text.length], map);
            const range = [r[0] + srcOffset, r[1] + srcOffset];
            return { text, range, isFlagged, isFound, suggestionsEx };
        }
        return [...lineValidatorFn(lineSegment)].map(mapBackToOriginSimple);
    }
    return {
        validate,
        lineValidator,
    };
}
exports.textValidatorFactory = textValidatorFactory;
//# sourceMappingURL=lineValidatorFactory.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testing__ = exports.shouldCheckDocument = exports.DocumentValidator = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const cspell_types_1 = require("@cspell/cspell-types");
const assert_1 = __importDefault(require("assert"));
const cspell_glob_1 = require("cspell-glob");
const path_1 = __importDefault(require("path"));
const TextDocument_js_1 = require("../Models/TextDocument.js");
const index_js_1 = require("../Settings/Controller/configLoader/index.js");
const index_js_2 = require("../Settings/index.js");
const InDocSettings_js_1 = require("../Settings/InDocSettings.js");
const index_js_3 = require("../SpellingDictionary/index.js");
const suggestions_js_1 = require("../suggestions.js");
const errors_js_1 = require("../util/errors.js");
const simpleCache_js_1 = require("../util/simpleCache.js");
const timer_js_1 = require("../util/timer.js");
const Uri_js_1 = require("../util/Uri.js");
const defaultConstants_js_1 = require("./defaultConstants.js");
const determineTextDocumentSettings_js_1 = require("./determineTextDocumentSettings.js");
const lineValidatorFactory_js_1 = require("./lineValidatorFactory.js");
const parsedText_js_1 = require("./parsedText.js");
const settingsToValidateOptions_js_1 = require("./settingsToValidateOptions.js");
const textValidator_js_1 = require("./textValidator.js");
const ERROR_NOT_PREPARED = 'Validator Must be prepared before calling this function.';
const skipValidation = false;
class DocumentValidator {
    /**
     * @param doc - Document to validate
     * @param config - configuration to use (not finalized).
     */
    constructor(doc, options, settings) {
        this.settings = settings;
        this._ready = false;
        this.errors = [];
        this._preparationTime = -1;
        this._suggestions = new simpleCache_js_1.AutoCache((text) => this.genSuggestions(text), 1000);
        this._document = doc;
        this.options = { ...options };
        const numSuggestions = this.options.numSuggestions ?? settings.numSuggestions;
        if (numSuggestions !== undefined) {
            this.options.numSuggestions = numSuggestions;
        }
        // console.error(`DocumentValidator: ${doc.uri}`);
    }
    get ready() {
        return this._ready;
    }
    /**
     * Prepare to validate a document.
     * This will load all the necessary configuration and dictionaries.
     *
     * @deprecated
     * @deprecationMessage Use the async `prepare` method.
     */
    prepareSync() {
        // @todo
        // Determine doc settings.
        // Calc include ranges
        // Load dictionaries
        if (this._ready)
            return;
        const timer = (0, timer_js_1.createTimer)();
        const { options, settings } = this;
        const useSearchForConfig = (!options.noConfigSearch && !settings.noConfigSearch) || options.noConfigSearch === false;
        const optionsConfigFile = options.configFile;
        const localConfigFn = optionsConfigFile
            ? () => (0, index_js_1.loadConfigSync)(optionsConfigFile, settings)
            : useSearchForConfig
                ? () => searchForDocumentConfigSync(this._document, settings, settings)
                : undefined;
        const localConfig = localConfigFn && (0, errors_js_1.wrapCall)(localConfigFn, (e) => this.addPossibleError(e))();
        this.addPossibleError(localConfig?.__importRef?.error);
        const config = (0, index_js_2.mergeSettings)(settings, localConfig);
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(this._document, config);
        const dict = (0, index_js_3.getDictionaryInternalSync)(docSettings);
        const matcher = new cspell_glob_1.GlobMatcher(localConfig?.ignorePaths || [], { root: process.cwd(), dot: true });
        const uri = this._document.uri;
        const shouldCheck = !matcher.match((0, Uri_js_1.uriToFilePath)(uri)) && (docSettings.enabled ?? true);
        const finalSettings = (0, index_js_2.finalizeSettings)(docSettings);
        const validateOptions = (0, settingsToValidateOptions_js_1.settingsToValidateOptions)(finalSettings);
        const includeRanges = (0, textValidator_js_1.calcTextInclusionRanges)(this._document.text, validateOptions);
        const segmenter = (0, parsedText_js_1.createMappedTextSegmenter)(includeRanges);
        const textValidator = (0, lineValidatorFactory_js_1.textValidatorFactory)(dict, validateOptions);
        this._preparations = {
            config,
            dictionary: dict,
            docSettings,
            finalSettings,
            shouldCheck,
            validateOptions,
            includeRanges,
            segmenter,
            textValidator,
            localConfig,
            localConfigFilepath: localConfig?.__importRef?.filename,
        };
        this._ready = true;
        this._preparationTime = timer.elapsed();
        // console.error(`prepareSync ${this._preparationTime.toFixed(2)}ms`);
    }
    async prepare() {
        if (this._ready)
            return;
        if (this._prepared)
            return this._prepared;
        this._prepared = this._prepareAsync();
        return this._prepared;
    }
    async _prepareAsync() {
        (0, assert_1.default)(!this._ready);
        const timer = (0, timer_js_1.createTimer)();
        const { options, settings } = this;
        const useSearchForConfig = (!options.noConfigSearch && !settings.noConfigSearch) || options.noConfigSearch === false;
        const pLocalConfig = options.configFile
            ? (0, index_js_2.loadConfig)(options.configFile, settings)
            : useSearchForConfig
                ? searchForDocumentConfig(this._document, settings, settings)
                : undefined;
        const localConfig = (await (0, errors_js_1.catchPromiseError)(pLocalConfig, (e) => this.addPossibleError(e))) || {};
        this.addPossibleError(localConfig?.__importRef?.error);
        const config = (0, index_js_2.mergeSettings)(settings, localConfig);
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(this._document, config);
        const dict = await (0, index_js_3.getDictionaryInternal)(docSettings);
        const matcher = new cspell_glob_1.GlobMatcher(localConfig?.ignorePaths || [], { root: process.cwd(), dot: true });
        const uri = this._document.uri;
        const shouldCheck = !matcher.match((0, Uri_js_1.uriToFilePath)(uri)) && (docSettings.enabled ?? true);
        const finalSettings = (0, index_js_2.finalizeSettings)(docSettings);
        const validateOptions = (0, settingsToValidateOptions_js_1.settingsToValidateOptions)(finalSettings);
        const includeRanges = (0, textValidator_js_1.calcTextInclusionRanges)(this._document.text, validateOptions);
        const segmenter = (0, parsedText_js_1.createMappedTextSegmenter)(includeRanges);
        const textValidator = (0, lineValidatorFactory_js_1.textValidatorFactory)(dict, validateOptions);
        this._preparations = {
            config,
            dictionary: dict,
            docSettings,
            finalSettings,
            shouldCheck,
            validateOptions,
            includeRanges,
            segmenter,
            textValidator,
            localConfig,
            localConfigFilepath: localConfig?.__importRef?.filename,
        };
        this._ready = true;
        this._preparationTime = timer.elapsed();
    }
    _updatePrep() {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const timer = (0, timer_js_1.createTimer)();
        const prep = this._preparations;
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(this._document, prep.config);
        const dict = (0, index_js_3.getDictionaryInternalSync)(docSettings);
        const shouldCheck = docSettings.enabled ?? true;
        const finalSettings = (0, index_js_2.finalizeSettings)(docSettings);
        const validateOptions = (0, settingsToValidateOptions_js_1.settingsToValidateOptions)(finalSettings);
        const includeRanges = (0, textValidator_js_1.calcTextInclusionRanges)(this._document.text, validateOptions);
        const segmenter = (0, parsedText_js_1.createMappedTextSegmenter)(includeRanges);
        const textValidator = (0, lineValidatorFactory_js_1.textValidatorFactory)(dict, validateOptions);
        this._preparations = {
            ...prep,
            dictionary: dict,
            docSettings,
            shouldCheck,
            validateOptions,
            includeRanges,
            segmenter,
            textValidator,
        };
        this._preparationTime = timer.elapsed();
    }
    /**
     * The amount of time in ms to prepare for validation.
     */
    get prepTime() {
        return this._preparationTime;
    }
    get validateDirectives() {
        return this.options.validateDirectives ?? this._preparations?.config.validateDirectives ?? false;
    }
    checkText(range, _text, scope) {
        const text = this._document.text.slice(range[0], range[1]);
        return this.check({ text, range, scope: scope.join(' ') });
    }
    check(parsedText) {
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const { segmenter, textValidator } = this._preparations;
        // Determine settings for text range
        // Slice text based upon include ranges
        // Check text against dictionaries.
        const document = this._document;
        let line = undefined;
        function mapToIssue(issue) {
            const { range, text, isFlagged, isFound, suggestionsEx } = issue;
            const offset = range[0];
            const length = range[1] - range[0];
            (0, assert_1.default)(!line || line.offset <= offset);
            if (!line || line.offset + line.text.length <= offset) {
                line = document.lineAt(offset);
            }
            return { text, offset, line, length, isFlagged, isFound, suggestionsEx };
        }
        const issues = [...(0, sync_1.pipeSync)(segmenter(parsedText), (0, sync_1.opConcatMap)(textValidator.validate), (0, sync_1.opMap)(mapToIssue))];
        if (!this.options.generateSuggestions) {
            return issues.map((issue) => {
                if (!issue.suggestionsEx)
                    return issue;
                const suggestionsEx = this.adjustSuggestions(issue.text, issue.suggestionsEx);
                const suggestions = suggestionsEx.map((s) => s.word);
                return { ...issue, suggestionsEx, suggestions };
            });
        }
        const withSugs = issues.map((t) => {
            // lazy suggestion calculation.
            const text = t.text;
            const suggestionsEx = this.getSuggestions(text);
            t.suggestionsEx = suggestionsEx;
            t.suggestions = suggestionsEx.map((s) => s.word);
            return t;
        });
        return withSugs;
    }
    /**
     * Check a Document for Validation Issues.
     * @param forceCheck - force a check even if the document would normally be excluded.
     * @returns the validation issues.
     */
    async checkDocumentAsync(forceCheck) {
        await this.prepare();
        return this.checkDocument(forceCheck);
    }
    /**
     * Check a Document for Validation Issues.
     *
     * Note: The validator must be prepared before calling this method.
     * @param forceCheck - force a check even if the document would normally be excluded.
     * @returns the validation issues.
     */
    checkDocument(forceCheck = false) {
        if (skipValidation)
            return [];
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const spellingIssues = forceCheck || this.shouldCheckDocument() ? [...this._checkParsedText(this._parse())] : [];
        const directiveIssues = this.checkDocumentDirectives();
        // console.log('Stats: %o', this._preparations.textValidator.lineValidator.dict.stats());
        const allIssues = spellingIssues.concat(directiveIssues).sort((a, b) => a.offset - b.offset);
        return allIssues;
    }
    checkDocumentDirectives(forceCheck = false) {
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const validateDirectives = forceCheck || this.validateDirectives;
        if (!validateDirectives)
            return [];
        const document = this.document;
        const issueType = cspell_types_1.IssueType.directive;
        function toValidationIssue(dirIssue) {
            const { text, range, suggestions, suggestionsEx, message } = dirIssue;
            const offset = range[0];
            const pos = document.positionAt(offset);
            const line = document.getLine(pos.line);
            const issue = { text, offset, line, suggestions, suggestionsEx, message, issueType };
            return issue;
        }
        return [...(0, InDocSettings_js_1.validateInDocumentSettings)(this.document.text, this._preparations.config)].map(toValidationIssue);
    }
    get document() {
        return this._document;
    }
    updateDocumentText(text) {
        (0, TextDocument_js_1.updateTextDocument)(this._document, [{ text }]);
        this._updatePrep();
    }
    defaultParser() {
        return (0, sync_1.pipeSync)(this.document.getLines(), (0, sync_1.opMap)((line) => {
            const { text, offset } = line;
            const range = [offset, offset + text.length];
            return { text, range };
        }));
    }
    *_checkParsedText(parsedTexts) {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const { maxNumberOfProblems = defaultConstants_js_1.defaultMaxNumberOfProblems, maxDuplicateProblems = defaultConstants_js_1.defaultMaxDuplicateProblems } = this._preparations.validateOptions;
        let numProblems = 0;
        const mapOfProblems = new Map();
        for (const pText of parsedTexts) {
            for (const issue of this.check(pText)) {
                const { text } = issue;
                const n = (mapOfProblems.get(text) || 0) + 1;
                mapOfProblems.set(text, n);
                if (n > maxDuplicateProblems)
                    continue;
                yield issue;
                if (++numProblems >= maxNumberOfProblems)
                    return;
            }
        }
    }
    addPossibleError(error) {
        if (!error)
            return;
        error = this.errors.push((0, errors_js_1.toError)(error));
    }
    _parse() {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const parser = this._preparations.finalSettings.parserFn;
        if (typeof parser !== 'object')
            return this.defaultParser();
        return parser.parse(this.document.text, this.document.uri.path).parsedTexts;
    }
    getSuggestions(text) {
        return this._suggestions.get(text);
    }
    genSuggestions(text) {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const settings = this._preparations.docSettings;
        const dict = this._preparations.dictionary;
        const sugOptions = {
            compoundMethod: 0,
            numSuggestions: this.options.numSuggestions,
            includeTies: false,
            ignoreCase: !(settings.caseSensitive ?? false),
            timeout: settings.suggestionsTimeout,
            numChanges: settings.suggestionNumChanges,
        };
        const rawSuggestions = dict.suggest(text, sugOptions);
        return this.adjustSuggestions(text, rawSuggestions);
    }
    adjustSuggestions(text, rawSuggestions) {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const settings = this._preparations.docSettings;
        const ignoreCase = !(settings.caseSensitive ?? false);
        const locale = this._preparations.config.language;
        const dict = this._preparations.dictionary;
        const sugsWithAlt = (0, suggestions_js_1.calcSuggestionAdjustedToToMatchCase)(text, rawSuggestions.map(mapSug), locale, ignoreCase, dict);
        return sugsWithAlt.map(sanitizeSuggestion);
    }
    getFinalizedDocSettings() {
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        return this._preparations.docSettings;
    }
    /**
     * Returns true if the final result of the configuration calculation results
     * in the document being enabled. Note: in some cases, checking the document
     * might still make sense, for example, the `@cspell/eslint-plugin` relies on
     * `eslint` configuration to make that determination.
     * @returns true if the document settings have resolved to be `enabled`
     */
    shouldCheckDocument() {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        return this._preparations.shouldCheck;
    }
    /**
     * Internal `cspell-lib` use.
     */
    _getPreparations() {
        return this._preparations;
    }
}
exports.DocumentValidator = DocumentValidator;
function sanitizeSuggestion(sug) {
    const { word, isPreferred, wordAdjustedToMatchCase } = sug;
    if (isPreferred && wordAdjustedToMatchCase)
        return { word, wordAdjustedToMatchCase, isPreferred };
    if (isPreferred)
        return { word, isPreferred };
    if (wordAdjustedToMatchCase)
        return { word, wordAdjustedToMatchCase };
    return { word };
}
async function searchForDocumentConfig(document, defaultConfig, pnpSettings) {
    const { uri } = document;
    if (uri.scheme !== 'file')
        return Promise.resolve(defaultConfig);
    return (0, index_js_2.searchForConfig)(path_1.default.dirname((0, Uri_js_1.uriToFilePath)(uri)), pnpSettings).then((s) => s || defaultConfig);
}
function mapSug(sug) {
    return { cost: 999, ...sug };
}
function searchForDocumentConfigSync(document, defaultConfig, pnpSettings) {
    const { uri } = document;
    if (uri.scheme !== 'file')
        defaultConfig;
    return (0, index_js_1.searchForConfigSync)((0, Uri_js_1.uriToFilePath)(uri), pnpSettings) || defaultConfig;
}
async function shouldCheckDocument(doc, options, settings) {
    const errors = [];
    function addPossibleError(error) {
        if (!error)
            return undefined;
        error = errors.push((0, errors_js_1.toError)(error));
        return undefined;
    }
    async function shouldCheck() {
        const useSearchForConfig = (!options.noConfigSearch && !settings.noConfigSearch) || options.noConfigSearch === false;
        const pLocalConfig = options.configFile
            ? (0, index_js_2.loadConfig)(options.configFile, settings)
            : useSearchForConfig
                ? searchForDocumentConfig(doc, settings, settings)
                : undefined;
        const localConfig = (await (0, errors_js_1.catchPromiseError)(pLocalConfig, addPossibleError)) || {};
        addPossibleError(localConfig?.__importRef?.error);
        const config = (0, index_js_2.mergeSettings)(settings, localConfig);
        const matcher = new cspell_glob_1.GlobMatcher(localConfig?.ignorePaths || [], { root: process.cwd(), dot: true });
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(doc, config);
        const uri = doc.uri;
        return !matcher.match((0, Uri_js_1.uriToFilePath)(uri)) && (docSettings.enabled ?? true);
    }
    return { errors, shouldCheck: await shouldCheck() };
}
exports.shouldCheckDocument = shouldCheckDocument;
exports.__testing__ = {
    sanitizeSuggestion,
};
//# sourceMappingURL=docValidator.js.map
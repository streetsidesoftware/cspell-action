"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDocumentToTextDocument = exports.fileToTextDocument = exports.fileToDocument = exports.isBinaryFile = exports.isBinaryDoc = exports.determineFinalDocumentSettings = exports.spellCheckDocument = exports.spellCheckFile = void 0;
const fs_extra_1 = require("fs-extra");
const vscode_uri_1 = require("vscode-uri");
const LanguageIds_1 = require("./LanguageIds");
const TextDocument_1 = require("./Models/TextDocument");
const textValidation_1 = require("./textValidation");
const determineTextDocumentSettings_1 = require("./textValidation/determineTextDocumentSettings");
const errors_1 = require("./util/errors");
const util_1 = require("./util/util");
const defaultEncoding = 'utf8';
/**
 * Spell Check a file
 * @param file - absolute path to file to read and check.
 * @param options - options to control checking
 * @param settings - default settings to use.
 */
function spellCheckFile(file, options, settings) {
    const doc = {
        uri: vscode_uri_1.URI.file(file).toString(),
    };
    return spellCheckDocument(doc, options, settings);
}
exports.spellCheckFile = spellCheckFile;
/**
 * Spell Check a Document.
 * @param document - document to be checked. If `document.text` is `undefined` the file will be loaded
 * @param options - options to control checking
 * @param settings - default settings to use.
 */
async function spellCheckDocument(document, options, settings) {
    if (isBinaryDoc(document)) {
        return {
            document,
            options,
            settingsUsed: settings,
            localConfigFilepath: undefined,
            issues: [],
            checked: false,
            errors: undefined,
        };
    }
    try {
        return spellCheckFullDocument(await resolveDocument(document), options, settings);
    }
    catch (e) {
        const errors = (0, errors_1.isError)(e) ? [e] : [];
        return {
            document,
            options,
            settingsUsed: settings,
            localConfigFilepath: undefined,
            issues: [],
            checked: false,
            errors,
        };
    }
}
exports.spellCheckDocument = spellCheckDocument;
async function spellCheckFullDocument(document, options, settings) {
    const doc = documentToTextDocument(document);
    const docValOptions = options;
    const docValidator = new textValidation_1.DocumentValidator(doc, docValOptions, settings);
    await docValidator.prepare();
    const prep = docValidator._getPreparations();
    if (docValidator.errors.length) {
        return {
            document,
            options,
            settingsUsed: prep?.localConfig || settings,
            localConfigFilepath: prep?.localConfigFilepath,
            issues: [],
            checked: false,
            errors: docValidator.errors,
        };
    }
    const issues = docValidator.checkDocument();
    const result = {
        document,
        options,
        settingsUsed: docValidator.getFinalizedDocSettings(),
        localConfigFilepath: prep?.localConfigFilepath,
        issues,
        checked: docValidator.shouldCheckDocument(),
        errors: undefined,
    };
    return result;
}
async function readDocument(filename, encoding = defaultEncoding) {
    const text = await (0, fs_extra_1.readFile)(filename, encoding);
    const uri = vscode_uri_1.URI.file(filename).toString();
    return {
        uri,
        text,
    };
}
function resolveDocument(document, encoding) {
    if (isDocumentWithText(document))
        return Promise.resolve(document);
    const uri = vscode_uri_1.URI.parse(document.uri);
    if (uri.scheme !== 'file') {
        throw new Error(`Unsupported schema: "${uri.scheme}", open "${uri.toString()}"`);
    }
    return readDocument(uri.fsPath, encoding);
}
function isDocumentWithText(doc) {
    return doc.text !== undefined;
}
/**
 * Combines all relevant setting values into a final configuration to be used for spell checking.
 * It applies any overrides and appropriate language settings by taking into account the document type (languageId)
 * the locale (natural language) and any in document settings.
 *
 * Note: this method will not search for configuration files. Configuration files should already be merged into `settings`.
 * It is NOT necessary to include the cspell defaultSettings or globalSettings. They will be applied within this function.
 * @param document - The document to be spell checked. Note: if the URI doesn't have a path, overrides cannot be applied.
 *   `locale` - if defined will be used unless it is overridden by an in-document setting.
 *   `languageId` - if defined will be used to select appropriate file type dictionaries.
 * @param settings - The near final settings. Should already be the combination of all configuration files.
 */
function determineFinalDocumentSettings(document, settings) {
    const doc = (0, TextDocument_1.createTextDocument)({
        uri: document.uri,
        content: document.text,
        languageId: document.languageId,
        locale: document.locale,
    });
    return {
        document,
        settings: (0, determineTextDocumentSettings_1.determineTextDocumentSettings)(doc, settings),
    };
}
exports.determineFinalDocumentSettings = determineFinalDocumentSettings;
function isBinaryDoc(document) {
    return isBinaryFile(vscode_uri_1.URI.parse(document.uri), document.languageId);
}
exports.isBinaryDoc = isBinaryDoc;
function isBinaryFile(filenameUri, languageId) {
    if (languageId) {
        const ids = normalizeLanguageIds(languageId);
        if (ids.length)
            return (0, LanguageIds_1.isGenerated)(ids);
    }
    const filename = vscode_uri_1.Utils.basename(filenameUri);
    return (0, LanguageIds_1.isGeneratedFile)(filename);
}
exports.isBinaryFile = isBinaryFile;
function normalizeLanguageIds(languageId) {
    return (Array.isArray(languageId) ? languageId.join(',') : languageId).split(',').map((s) => s.trim());
}
function fileToDocument(file, text, languageId, locale) {
    return (0, util_1.clean)({
        uri: vscode_uri_1.URI.file(file).toString(),
        text,
        languageId,
        locale,
    });
}
exports.fileToDocument = fileToDocument;
async function fileToTextDocument(file) {
    return documentToTextDocument(await resolveDocument(fileToDocument(file)));
}
exports.fileToTextDocument = fileToTextDocument;
function documentToTextDocument(document) {
    const { uri, text: content, languageId, locale } = document;
    return (0, TextDocument_1.createTextDocument)({ uri, content, languageId, locale });
}
async function resolveDocumentToTextDocument(doc) {
    return documentToTextDocument(await resolveDocument(doc));
}
exports.resolveDocumentToTextDocument = resolveDocumentToTextDocument;
//# sourceMappingURL=spellCheckFile.js.map
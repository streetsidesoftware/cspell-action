"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDictionaryDefinitionInlineInternalWithSource = exports.isDictionaryFileDefinitionInternalWithSource = exports.isDictionaryDefinitionInternal = exports.isDictionaryDefinitionWithSource = exports.calcDictionaryDefsToLoad = exports.mapDictDefToInternal = exports.mapDictDefsToInternal = exports.filterDictDefsToLoad = void 0;
const cspell_trie_lib_1 = require("cspell-trie-lib");
const path = __importStar(require("path"));
const CSpellSettingsInternalDef_1 = require("../Models/CSpellSettingsInternalDef");
const AutoResolve_1 = require("../util/AutoResolve");
const resolveFile_1 = require("../util/resolveFile");
const util_1 = require("../util/util");
const DictionaryReferenceCollection_1 = require("./DictionaryReferenceCollection");
/**
 * Combines the list of desired dictionaries with the list of dictionary
 * definitions. Order does not matter, but the number of leading `!` does.
 *
 * Excluding dictionaries.
 * - Adding `!` to a dictId will remove the dictionary.
 * - Adding `!!` will add it back.
 *
 * @param dictRefCol - dictionaries desired
 * @param defs - dictionary definitions
 * @returns map from dictIds to definitions
 */
function filterDictDefsToLoad(dictRefCol, defs) {
    const allActiveDefs = defs.filter(({ name }) => dictRefCol.isEnabled(name)).map(fixPath);
    return [...new Map(allActiveDefs.map((d) => [d.name, d])).values()];
}
exports.filterDictDefsToLoad = filterDictDefsToLoad;
function fixPath(def) {
    if (def instanceof _DictionaryDefinitionInternalWithSource) {
        return def;
    }
    const newPath = fixDicPath(def.path, def.file);
    return {
        ...def,
        file: undefined,
        path: newPath,
    };
}
function fixDicPath(defPath, defFile) {
    const parts = [defPath || '', defFile || ''].filter((p) => !!p);
    return parts.length > 1 ? path.join(...parts) : parts[0] || '';
}
function mapDictDefsToInternal(defs, pathToSettingsFile) {
    return defs?.map((def) => mapDictDefToInternal(def, pathToSettingsFile));
}
exports.mapDictDefsToInternal = mapDictDefsToInternal;
const internalDefs = new AutoResolve_1.AutoResolveWeakCache();
function mapDictDefToInternal(def, pathToSettingsFile) {
    return internalDefs.get(def, (def) => _mapDictDefToInternal(def, pathToSettingsFile));
}
exports.mapDictDefToInternal = mapDictDefToInternal;
function _mapDictDefToInternal(def, pathToSettingsFile) {
    if (isDictionaryDefinitionWithSource(def)) {
        return def;
    }
    if ((0, CSpellSettingsInternalDef_1.isDictionaryDefinitionInlineInternal)(def)) {
        return { ...def, __source: pathToSettingsFile };
    }
    return new _DictionaryDefinitionInternalWithSource(def, pathToSettingsFile);
}
function determineName(filename, options) {
    return options.name || path.basename(filename);
}
function calcDictionaryDefsToLoad(settings) {
    const { dictionaries = [], dictionaryDefinitions = [], noSuggestDictionaries = [] } = settings;
    const colNoSug = (0, DictionaryReferenceCollection_1.createDictionaryReferenceCollection)(noSuggestDictionaries);
    const colDicts = (0, DictionaryReferenceCollection_1.createDictionaryReferenceCollection)(dictionaries.concat(colNoSug.enabled()));
    const modDefs = dictionaryDefinitions.map((def) => {
        const enabled = colNoSug.isEnabled(def.name);
        if (enabled === undefined)
            return def;
        return { ...def, noSuggest: enabled };
    });
    return filterDictDefsToLoad(colDicts, modDefs);
}
exports.calcDictionaryDefsToLoad = calcDictionaryDefsToLoad;
function isDictionaryDefinitionWithSource(d) {
    return isDictionaryFileDefinitionInternalWithSource(d) || isDictionaryDefinitionInlineInternalWithSource(d);
}
exports.isDictionaryDefinitionWithSource = isDictionaryDefinitionWithSource;
function isDictionaryDefinitionInternal(def) {
    return def instanceof _DictionaryDefinitionInternalWithSource;
}
exports.isDictionaryDefinitionInternal = isDictionaryDefinitionInternal;
function isDictionaryFileDefinitionInternalWithSource(def) {
    return def instanceof _DictionaryDefinitionInternalWithSource;
}
exports.isDictionaryFileDefinitionInternalWithSource = isDictionaryFileDefinitionInternalWithSource;
function isDictionaryDefinitionInlineInternalWithSource(def) {
    return (0, CSpellSettingsInternalDef_1.isDictionaryDefinitionInlineInternal)(def) && !!def.__source;
}
exports.isDictionaryDefinitionInlineInternalWithSource = isDictionaryDefinitionInlineInternalWithSource;
class _DictionaryDefinitionInternalWithSource {
    constructor(def, __source) {
        this.__source = __source;
        // this bit of assignment is to have the compiler help use if any new fields are added.
        const defAll = def;
        const { path: relPath = '', file = '', addWords, description, dictionaryInformation, type, repMap, noSuggest, scope, useCompounds, } = defAll;
        const defaultPath = path.dirname(__source);
        const filePath = fixDicPath(relPath, file);
        const name = determineName(filePath, def);
        const r = (0, resolveFile_1.resolveFile)(filePath, defaultPath);
        const ddi = {
            name,
            file: undefined,
            path: r.filename,
            addWords,
            description,
            dictionaryInformation,
            type,
            repMap,
            noSuggest,
            scope,
            useCompounds,
        };
        Object.assign(this, (0, util_1.clean)(ddi));
        this.ddi = ddi;
        this.name = ddi.name;
        this.file = ddi.file;
        this.path = ddi.path;
        this._weightMap = this.dictionaryInformation
            ? (0, cspell_trie_lib_1.mapDictionaryInformationToWeightMap)(this.dictionaryInformation)
            : undefined;
    }
    get weightMap() {
        return this._weightMap;
    }
    toJSON() {
        return this.ddi;
    }
}
//# sourceMappingURL=DictionarySettings.js.map
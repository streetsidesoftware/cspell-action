"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDictionaryDefinitionWithSource = exports.normalizePathForDictDef = exports.normalizePathForDictDefs = exports.filterDictDefsToLoad = void 0;
const path = __importStar(require("path"));
const resolveFile_1 = require("../util/resolveFile");
/**
 * Combines the list of desired dictionaries with the list of dictionary
 * definitions. Order does not matter, but the number of leading `!` does.
 *
 * Excluding dictionaries.
 * - Adding `!` to a dictId will remove the dictionary.
 * - Adding `!!` will add it back.
 *
 * @param dictIds - dictionaries desired
 * @param defs - dictionary definitions
 * @returns map from dictIds to definitions
 */
function filterDictDefsToLoad(dictIds, defs) {
    const negPrefixRegEx = /^!+/;
    // Collect the ids based upon the `!` depth.
    const dictIdMap = dictIds
        .map((id) => id.trim())
        .filter((id) => !!id)
        .reduce((dictDepthMap, id) => {
        var _a;
        const pfx = id.match(negPrefixRegEx);
        const depth = ((_a = pfx === null || pfx === void 0 ? void 0 : pfx[0]) === null || _a === void 0 ? void 0 : _a.length) || 0;
        const _dictSet = dictDepthMap.get(depth);
        const dictSet = _dictSet || new Set();
        if (!_dictSet) {
            dictDepthMap.set(depth, dictSet);
        }
        dictSet.add(id.slice(depth));
        return dictDepthMap;
    }, new Map());
    const orderedSets = [...dictIdMap].sort((a, b) => a[0] - b[0]);
    const dictIdSet = orderedSets.reduce((dictIdSet, [depth, ids]) => {
        if (depth & 1) {
            [...ids].forEach((id) => dictIdSet.delete(id));
        }
        else {
            [...ids].forEach((id) => dictIdSet.add(id));
        }
        return dictIdSet;
    }, new Set());
    const activeDefs = defs
        .filter(({ name }) => dictIdSet.has(name))
        .map((def) => ({ ...def, path: getFullPathName(def) }))
        // Remove any empty paths.
        .filter((def) => !!def.path)
        .map((def) => [def.name, def]);
    return [...new Map(activeDefs)];
}
exports.filterDictDefsToLoad = filterDictDefsToLoad;
function getFullPathName(def) {
    const { path: filePath = '', file = '' } = def;
    if (!filePath && !file) {
        return '';
    }
    return path.join(filePath, file);
}
function normalizePathForDictDefs(defs, pathToSettingsFile) {
    return defs === null || defs === void 0 ? void 0 : defs.map((def) => normalizePathForDictDef(def, pathToSettingsFile));
}
exports.normalizePathForDictDefs = normalizePathForDictDefs;
function normalizePathForDictDef(def, pathToSettingsFile) {
    const defaultPath = path.dirname(pathToSettingsFile);
    const { path: relPath = '', file = '', ...rest } = def;
    const filePath = path.join(relPath, file);
    const name = determineName(filePath, def);
    if (isDictionaryDefinitionWithSource(def)) {
        if (def.__source !== pathToSettingsFile) {
            throw new Error('Trying to normalize a dictionary definition with a different source.');
        }
        return def;
    }
    const r = resolveFile_1.resolveFile(filePath, defaultPath);
    return {
        ...rest,
        name,
        path: r.filename,
        __source: pathToSettingsFile,
    };
}
exports.normalizePathForDictDef = normalizePathForDictDef;
function isDictionaryDefinitionWithSource(d) {
    return d.__source !== undefined;
}
exports.isDictionaryDefinitionWithSource = isDictionaryDefinitionWithSource;
function determineName(filename, options) {
    return options.name || path.basename(filename);
}
//# sourceMappingURL=DictionarySettings.js.map
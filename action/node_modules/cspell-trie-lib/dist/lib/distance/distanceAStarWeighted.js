"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.distanceAStarWeighted = void 0;
const PairingHeap_1 = require("../utils/PairingHeap");
/**
 * Calculate the edit distance between two words using an A* algorithm.
 *
 * Using basic weights, this algorithm has the same results as the Damerau-Levenshtein algorithm.
 */
function distanceAStarWeighted(wordA, wordB, map, cost = 100) {
    // Add ^ and $ for begin/end detection.
    const a = '^' + wordA + '$';
    const b = '^' + wordB + '$';
    const aN = a.length;
    const bN = b.length;
    const candidates = new PairingHeap_1.PairingHeap(compare);
    candidates.add({ ai: 0, bi: 0, c: 0, p: 0 });
    /** Substitute / Replace */
    function opSub(n) {
        const { ai, bi, c, p } = n;
        if (ai < aN && bi < bN) {
            const cc = a[ai] === b[bi] ? c : c + cost;
            candidates.add({ ai: ai + 1, bi: bi + 1, c: cc, p });
        }
    }
    /** Insert */
    function opIns(n) {
        const { ai, bi, c, p } = n;
        if (bi < bN) {
            candidates.add({ ai: ai, bi: bi + 1, c: c + cost, p });
        }
    }
    /** Delete */
    function opDel(n) {
        const { ai, bi, c, p } = n;
        if (ai < aN) {
            candidates.add({ ai: ai + 1, bi: bi, c: c + cost, p });
        }
    }
    /** Swap adjacent letters */
    function opSwap(n) {
        const { ai, bi, c, p } = n;
        if (a[ai] === b[bi + 1] && a[ai + 1] === b[bi]) {
            candidates.add({ ai: ai + 2, bi: bi + 2, c: c + cost, p });
        }
    }
    function opMap(n) {
        const { ai, bi, c, p } = n;
        const pos = { a, b, ai, bi, c, p };
        const costCalculations = [map.calcInsDelCosts(pos), map.calcSwapCosts(pos), map.calcReplaceCosts(pos)];
        costCalculations.forEach((iter) => {
            for (const nn of iter) {
                candidates.add(nn);
            }
        });
    }
    let best;
    // const bc2 = 2 * bc;
    while ((best = candidates.dequeue())) {
        if (best.ai === aN && best.bi === bN)
            break;
        opSwap(best);
        opIns(best);
        opDel(best);
        opMap(best);
        opSub(best);
    }
    // istanbul ignore else
    return best ? best.c + best.p : -1;
}
exports.distanceAStarWeighted = distanceAStarWeighted;
function compare(a, b) {
    // Choose lowest cost or farthest Manhattan distance.
    return a.c - b.c || b.ai + b.bi - a.ai - a.bi;
}
//# sourceMappingURL=distanceAStarWeighted.js.map
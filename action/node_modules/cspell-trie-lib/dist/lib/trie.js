"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trie = exports.FORBID = exports.NORMALIZED = exports.OPTIONAL_COMPOUND = exports.COMPOUND = exports.defaultTrieOptions = exports.FORBID_PREFIX = exports.CASE_INSENSITIVE_PREFIX = exports.OPTIONAL_COMPOUND_FIX = exports.COMPOUND_FIX = void 0;
const gensequence_1 = require("gensequence");
const suggest_1 = require("./suggest");
const util_1 = require("./util");
const walker_1 = require("./walker");
const constants_1 = require("./constants");
const find_1 = require("./find");
var constants_2 = require("./constants");
Object.defineProperty(exports, "COMPOUND_FIX", { enumerable: true, get: function () { return constants_2.COMPOUND_FIX; } });
Object.defineProperty(exports, "OPTIONAL_COMPOUND_FIX", { enumerable: true, get: function () { return constants_2.OPTIONAL_COMPOUND_FIX; } });
Object.defineProperty(exports, "CASE_INSENSITIVE_PREFIX", { enumerable: true, get: function () { return constants_2.CASE_INSENSITIVE_PREFIX; } });
Object.defineProperty(exports, "FORBID_PREFIX", { enumerable: true, get: function () { return constants_2.FORBID_PREFIX; } });
var constants_3 = require("./constants");
Object.defineProperty(exports, "defaultTrieOptions", { enumerable: true, get: function () { return constants_3.defaultTrieOptions; } });
/** @deprecated */
exports.COMPOUND = constants_1.COMPOUND_FIX;
/** @deprecated */
exports.OPTIONAL_COMPOUND = constants_1.OPTIONAL_COMPOUND_FIX;
/** @deprecated */
exports.NORMALIZED = constants_1.CASE_INSENSITIVE_PREFIX;
/** @deprecated */
exports.FORBID = constants_1.FORBID_PREFIX;
const defaultLegacyMinCompoundLength = 3;
class Trie {
    constructor(root, count) {
        this.root = root;
        this.count = count;
        this._options = util_1.mergeOptionalWithDefaults(root);
        this.isLegacy = this.calcIsLegacy();
        this.hasForbidden = !!root.c.get(root.forbiddenWordPrefix);
    }
    /**
     * Number of words in the Trie
     */
    size() {
        var _a;
        this.count = (_a = this.count) !== null && _a !== void 0 ? _a : util_1.countWords(this.root);
        return this.count;
    }
    isSizeKnown() {
        return this.count !== undefined;
    }
    get options() {
        return this._options;
    }
    find(text, minCompoundLength = false) {
        const minLength = !minCompoundLength || minCompoundLength === true ? undefined : minCompoundLength;
        return minCompoundLength ? this.findCompound(text, minLength) : this.findExact(text);
    }
    findCompound(text, minCompoundLength = defaultLegacyMinCompoundLength) {
        const r = find_1.findLegacyCompoundNode(this.root, text, minCompoundLength);
        return r.node;
    }
    findExact(text) {
        const r = find_1.findCompoundNode(this.root, text, this.options.compoundCharacter);
        return r.node;
    }
    has(word, minLegacyCompoundLength) {
        const f = find_1.findCompoundWord(this.root, word, this.options.compoundCharacter);
        if (f.found)
            return true;
        if (minLegacyCompoundLength) {
            const len = minLegacyCompoundLength !== true ? minLegacyCompoundLength : defaultLegacyMinCompoundLength;
            return !!find_1.findLegacyCompoundWord(this.root, word, len).found;
        }
        return false;
    }
    /**
     * Determine if a word is in the dictionary.
     * @param word - the exact word to search for - must be normalized - for non-case sensitive
     *      searches, word must be lower case with accents removed.
     * @param caseSensitive - false means searching a dictionary where the words were normalized to lower case and accents removed.
     * @returns true if the word was found and is not forbidden.
     */
    hasWord(word, caseSensitive) {
        var _a;
        const root = !caseSensitive ? ((_a = this.root.c) === null || _a === void 0 ? void 0 : _a.get(this.options.stripCaseAndAccentsPrefix)) || this.root : this.root;
        const f = find_1.findCompoundWord(root, word, this.options.compoundCharacter);
        return !!f.found;
    }
    /**
     * Determine if a word is in the forbidden word list.
     * @param word the word to lookup.
     */
    isForbiddenWord(word) {
        return this.hasForbidden && find_1.isForbiddenWord(this.root, word, this.options.forbiddenWordPrefix);
    }
    /**
     * Provides an ordered sequence of words with the prefix of text.
     */
    completeWord(text) {
        const n = this.find(text);
        const compoundChar = this.options.compoundCharacter;
        const subNodes = util_1.iteratorTrieWords(n || {})
            .filter((w) => w[w.length - 1] !== compoundChar)
            .map((suffix) => text + suffix);
        return gensequence_1.genSequence(n && util_1.isWordTerminationNode(n) ? [text] : []).concat(subNodes);
    }
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * @param text - the text to search for
     * @param maxNumSuggestions - the maximum number of suggestions to return.
     * @param compoundMethod - Use to control splitting words.
     * @param numChanges - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
     *                      the lower the value, the faster results are returned. Values less than 4 are best.
     */
    suggest(text, maxNumSuggestions, compoundMethod, numChanges) {
        return this.suggestWithCost(text, maxNumSuggestions, compoundMethod, numChanges).map((a) => a.word);
    }
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
     */
    suggestWithCost(text, maxNumSuggestions, compoundMethod, numChanges) {
        return suggest_1.suggest(this.getSuggestRoot(true), text, maxNumSuggestions, compoundMethod, numChanges).filter((sug) => !this.isForbiddenWord(sug.word));
    }
    /**
     * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
     * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
     * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
     */
    genSuggestions(collector, compoundMethod) {
        const filter = (sug) => !this.isForbiddenWord(sug.word);
        const suggestions = suggest_1.genSuggestions(this.getSuggestRoot(true), collector.word, compoundMethod);
        function* filteredSuggestions() {
            let maxCost = collector.maxCost;
            let ir;
            while (!(ir = suggestions.next(maxCost)).done) {
                if (ir.value !== undefined && filter(ir.value)) {
                    maxCost = yield ir.value;
                }
            }
            return undefined;
        }
        collector.collect(filteredSuggestions());
    }
    /**
     * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
     */
    words() {
        return util_1.iteratorTrieWords(this.root);
    }
    /**
     * Allows iteration over the entire tree.
     * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
     */
    iterate() {
        return walker_1.walker(this.root);
    }
    insert(word) {
        util_1.insert(word, this.root);
        return this;
    }
    getSuggestRoot(caseSensitive) {
        var _a;
        const root = (!caseSensitive && ((_a = this.root.c) === null || _a === void 0 ? void 0 : _a.get(this._options.stripCaseAndAccentsPrefix))) || this.root;
        if (!root.c)
            return { c: new Map(), ...this._options };
        const blockNodes = new Set([this._options.forbiddenWordPrefix, this._options.stripCaseAndAccentsPrefix]);
        return {
            c: new Map([...root.c].filter(([k]) => !blockNodes.has(k))),
            ...this._options,
        };
    }
    calcIsLegacy() {
        const c = this.root.c;
        return !((c === null || c === void 0 ? void 0 : c.get(this._options.compoundCharacter)) || (c === null || c === void 0 ? void 0 : c.get(this._options.stripCaseAndAccentsPrefix)) || (c === null || c === void 0 ? void 0 : c.get(this._options.forbiddenWordPrefix)));
    }
    static create(words, options) {
        const root = util_1.createTriFromList(words, options);
        util_1.orderTrie(root);
        return new Trie(root, undefined);
    }
}
exports.Trie = Trie;
//# sourceMappingURL=trie.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hintedWalker = exports.walker = exports.CompoundWordsMethod = exports.WORD_SEPARATOR = exports.JOIN_SEPARATOR = void 0;
exports.JOIN_SEPARATOR = '+';
exports.WORD_SEPARATOR = ' ';
var CompoundWordsMethod;
(function (CompoundWordsMethod) {
    /**
     * Do not compound words.
     */
    CompoundWordsMethod[CompoundWordsMethod["NONE"] = 0] = "NONE";
    /**
     * Create word compounds separated by spaces.
     */
    CompoundWordsMethod[CompoundWordsMethod["SEPARATE_WORDS"] = 1] = "SEPARATE_WORDS";
    /**
     * Create word compounds without separation.
     */
    CompoundWordsMethod[CompoundWordsMethod["JOIN_WORDS"] = 2] = "JOIN_WORDS";
})(CompoundWordsMethod = exports.CompoundWordsMethod || (exports.CompoundWordsMethod = {}));
/**
 * Walks the Trie and yields a value at each node.
 * next(goDeeper: boolean):
 */
function* walker(root, compoundingMethod = CompoundWordsMethod.NONE) {
    const roots = {
        [CompoundWordsMethod.NONE]: [],
        [CompoundWordsMethod.JOIN_WORDS]: [[exports.JOIN_SEPARATOR, root]],
        [CompoundWordsMethod.SEPARATE_WORDS]: [[exports.WORD_SEPARATOR, root]],
    };
    function* children(n) {
        if (n.c) {
            yield* n.c;
        }
        if (n.f) {
            yield* roots[compoundingMethod];
        }
    }
    let depth = 0;
    const stack = [];
    stack[depth] = { t: '', c: children(root) };
    let ir;
    while (depth >= 0) {
        let baseText = stack[depth].t;
        while (!(ir = stack[depth].c.next()).done) {
            const [char, node] = ir.value;
            const text = baseText + char;
            const goDeeper = yield { text, node, depth };
            if (goDeeper || goDeeper === undefined) {
                depth++;
                baseText = text;
                stack[depth] = { t: text, c: children(node) };
            }
        }
        depth -= 1;
    }
}
exports.walker = walker;
/**
 * Walks the Trie and yields a value at each node.
 * next(goDeeper: boolean):
 */
function* hintedWalker(root, compoundingMethod = CompoundWordsMethod.NONE, hint) {
    const baseRoot = {
        c: new Map([...root.c].filter((n) => n[0] !== root.compoundCharacter)),
    };
    const roots = {
        [CompoundWordsMethod.NONE]: [],
        [CompoundWordsMethod.JOIN_WORDS]: [[exports.JOIN_SEPARATOR, baseRoot]],
        [CompoundWordsMethod.SEPARATE_WORDS]: [[exports.WORD_SEPARATOR, baseRoot]],
    };
    const compoundCharacter = root.compoundCharacter;
    function* children(n, hintOffset) {
        if (n.c) {
            const h = hint.slice(hintOffset, hintOffset + 3) + hint.slice(Math.max(0, hintOffset - 2), hintOffset);
            const hints = new Set(h);
            const c = n.c;
            // First yield the hints
            yield* [...hints]
                .filter((a) => c.has(a))
                .map((letter) => ({
                letter,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                node: c.get(letter),
                hintOffset: hintOffset + 1,
            }));
            // We don't want to suggest the compound character.
            hints.add(compoundCharacter);
            // Then yield everything else.
            yield* [...c]
                .filter((a) => !hints.has(a[0]))
                .map(([letter, node]) => ({
                letter,
                node,
                hintOffset: hintOffset + 1,
            }));
            if (c.has(compoundCharacter)) {
                const compoundRoot = root.c.get(compoundCharacter);
                if (compoundRoot) {
                    yield* children(compoundRoot, hintOffset);
                }
            }
        }
        if (n.f) {
            yield* [...roots[compoundingMethod]].map(([letter, node]) => ({
                letter,
                node,
                hintOffset,
            }));
        }
    }
    let depth = 0;
    const stack = [];
    let baseText = '';
    stack[depth] = children(baseRoot, depth);
    let ir;
    while (depth >= 0) {
        while (!(ir = stack[depth].next()).done) {
            const { letter: char, node, hintOffset } = ir.value;
            const text = baseText + char;
            const hinting = (yield { text, node, depth });
            if (hinting && hinting.goDeeper) {
                depth++;
                baseText = text;
                stack[depth] = children(node, hintOffset);
            }
        }
        depth -= 1;
        baseText = baseText.slice(0, -1);
    }
}
exports.hintedWalker = hintedWalker;
//# sourceMappingURL=walker.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isForbiddenWord = exports.findLegacyCompoundWord = exports.findLegacyCompoundNode = exports.findNodeExact = exports.findWordExact = exports.findCompoundWord = exports.findCompoundNode = exports.findWord = void 0;
const TrieNode_1 = require("./TrieNode");
const util_1 = require("./util");
const constants_1 = require("./constants");
const _defaultFindOptions = {
    matchCase: false,
    compoundMode: 'compound',
    forbidPrefix: constants_1.FORBID_PREFIX,
    compoundFix: constants_1.COMPOUND_FIX,
    caseInsensitivePrefix: constants_1.CASE_INSENSITIVE_PREFIX,
};
const arrayCompoundModes = ['none', 'compound', 'legacy'];
const knownCompoundModes = new Map(arrayCompoundModes.map((a) => [a, a]));
/**
 *
 * @param root Trie root node. root.c contains the compound root and forbidden root.
 * @param word A pre normalized word use `normalizeWord` or `normalizeWordToLowercase`
 * @param options
 */
function findWord(root, word, options) {
    var _a;
    const _options = util_1.mergeDefaults(options, _defaultFindOptions);
    const compoundMode = knownCompoundModes.get(_options.compoundMode) || _defaultFindOptions.compoundMode;
    // word = _options.matchCase ? normalizeWord(word) : normalizeWordToLowercase(word);
    function __findCompound(r) {
        const f = findCompoundWord(r, word, _options.compoundFix);
        let forbidden = false;
        if (f.found !== false && f.compoundUsed) {
            forbidden = isForbiddenWord(root, word, _options.forbidPrefix);
        }
        const result = { ...f, forbidden };
        return result;
    }
    function __findLegacyCompound(r) {
        const f = findLegacyCompoundWord(r, word);
        const forbidden = false;
        const result = { ...f, forbidden };
        return result;
    }
    function __findExact(r) {
        const isFound = findWordExact(r, word);
        let forbidden = false;
        if (!isFound) {
            forbidden = isForbiddenWord(root, word, _options.forbidPrefix);
        }
        const result = {
            found: (isFound || forbidden) && word,
            compoundUsed: false,
            forbidden,
        };
        return result;
    }
    const r = _options.matchCase ? root : ((_a = root.c) === null || _a === void 0 ? void 0 : _a.get(_options.caseInsensitivePrefix)) || root;
    switch (compoundMode) {
        case 'none':
            return __findExact(r);
        case 'compound':
            return __findCompound(r);
        case 'legacy':
            return __findLegacyCompound(r);
    }
}
exports.findWord = findWord;
function findCompoundNode(root, word, compoundCharacter) {
    var _a, _b, _c, _d, _e;
    // Approach - do a depth first search for the matching word.
    const stack = [{ n: root, usedCompound: true }];
    const compoundRoot = (_a = root === null || root === void 0 ? void 0 : root.c) === null || _a === void 0 ? void 0 : _a.get(compoundCharacter);
    const w = word;
    let compoundUsed = false;
    let i = 0;
    let node;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const s = stack[i];
        const h = w[i++];
        const c = (_c = (_b = s.n) === null || _b === void 0 ? void 0 : _b.c) === null || _c === void 0 ? void 0 : _c.get(h);
        if (c && i < word.length) {
            // Go deeper.
            stack[i] = { n: c, usedCompound: false };
        }
        else if (!c || !c.f) {
            // Remember the first matching node for possible auto completion.
            node = node || c;
            // We did not find the word backup and take the first unused compound branch
            while (--i > 0 && (stack[i].usedCompound || !((_e = (_d = stack[i].n) === null || _d === void 0 ? void 0 : _d.c) === null || _e === void 0 ? void 0 : _e.has(compoundCharacter)))) {
                /* empty */
            }
            if (i > 0) {
                compoundUsed = true;
                const s = stack[i];
                s.n = compoundRoot;
                s.usedCompound = true;
            }
            else {
                break;
            }
        }
        else {
            node = c;
            break;
        }
    }
    const found = (i && i === word.length && word) || false;
    const result = { found, compoundUsed, node };
    return result;
}
exports.findCompoundNode = findCompoundNode;
function findCompoundWord(root, word, compoundCharacter) {
    const { found, compoundUsed, node } = findCompoundNode(root, word, compoundCharacter);
    // Was it a word?
    if (!node || !node.f) {
        return { found: false, compoundUsed };
    }
    return { found, compoundUsed };
}
exports.findCompoundWord = findCompoundWord;
function findWordExact(root, word) {
    const { node } = findNodeExact(root, word);
    return ((node === null || node === void 0 ? void 0 : node.f) || 0) === TrieNode_1.FLAG_WORD;
}
exports.findWordExact = findWordExact;
function findNodeExact(root, word) {
    var _a;
    const w = word;
    let n = root;
    let i = 0;
    while (n && i < word.length) {
        const h = w[i++];
        n = (_a = n.c) === null || _a === void 0 ? void 0 : _a.get(h);
    }
    return { node: n };
}
exports.findNodeExact = findNodeExact;
function findLegacyCompoundNode(root, word, minCompoundLength) {
    var _a, _b, _c;
    // Approach - do a depth first search for the matching word.
    const stack = [{ n: root, usedCompound: true, subLength: 0, isCompound: false }];
    const compoundRoot = root;
    const w = word;
    let compoundUsed = false;
    let i = 0;
    let node;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const s = stack[i];
        const h = w[i++];
        const c = (_b = (_a = s.n) === null || _a === void 0 ? void 0 : _a.c) === null || _b === void 0 ? void 0 : _b.get(h);
        if (c && i < word.length) {
            // Go deeper.
            stack[i] = {
                n: c,
                usedCompound: false,
                subLength: s.subLength + 1,
                isCompound: s.isCompound,
            };
        }
        else if (!c || !c.f || (c.f && s.subLength < minCompoundLength - 1)) {
            // We did not find the word backup and take the first unused compound branch
            while (--i > 0) {
                const s = stack[i];
                if (!s.usedCompound && ((_c = s.n) === null || _c === void 0 ? void 0 : _c.f) && s.subLength >= minCompoundLength) {
                    break;
                }
            }
            if (i > 0) {
                compoundUsed = true;
                const s = stack[i];
                s.n = compoundRoot;
                s.usedCompound = true;
                s.subLength = 0;
                s.isCompound = true;
            }
            else {
                break;
            }
        }
        else {
            node = c;
            break;
        }
    }
    const found = (i && i === word.length && word) || false;
    const result = { found, compoundUsed, node };
    return result;
}
exports.findLegacyCompoundNode = findLegacyCompoundNode;
function findLegacyCompoundWord(root, word, minCompoundLength = 3) {
    const { found, compoundUsed } = findLegacyCompoundNode(root, word, minCompoundLength);
    return { found, compoundUsed };
}
exports.findLegacyCompoundWord = findLegacyCompoundWord;
function isForbiddenWord(root, word, forbiddenPrefix) {
    var _a;
    return findWordExact((_a = root === null || root === void 0 ? void 0 : root.c) === null || _a === void 0 ? void 0 : _a.get(forbiddenPrefix), word);
}
exports.isForbiddenWord = isForbiddenWord;
//# sourceMappingURL=find.js.map
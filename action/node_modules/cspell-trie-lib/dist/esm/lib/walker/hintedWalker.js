import { isDefined } from '../utils/isDefined.js';
import { CompoundWordsMethod, JOIN_SEPARATOR, WORD_SEPARATOR } from './walkerTypes.js';
export function hintedWalker(root, ignoreCase, hint, compoundingMethod, emitWordSeparator) {
    return hintedWalkerNext(root, ignoreCase, hint, compoundingMethod, emitWordSeparator);
}
/**
 * Walks the Trie and yields a value at each node.
 * next(goDeeper: boolean):
 */
function* hintedWalkerNext(root, ignoreCase, hint, compoundingMethod, emitWordSeparator = '') {
    const _compoundingMethod = compoundingMethod ?? CompoundWordsMethod.NONE;
    const compoundCharacter = root.compoundCharacter;
    const noCaseCharacter = root.stripCaseAndAccentsPrefix;
    const rawRoots = [root, ignoreCase ? root.c.get(noCaseCharacter) : undefined].filter(isDefined);
    const specialRootsPrefix = existMap([compoundCharacter, noCaseCharacter, root.forbiddenWordPrefix]);
    function filterRoot(root) {
        const children = root.c?.entries();
        const c = children && [...children].filter(([v]) => !(v in specialRootsPrefix));
        return {
            c: c && new Map(c),
        };
    }
    const roots = rawRoots.map(filterRoot);
    const compoundRoots = rawRoots.map((r) => r.c?.get(compoundCharacter)).filter(isDefined);
    const setOfCompoundRoots = new Set(compoundRoots);
    const rootsForCompoundMethods = roots.concat(compoundRoots);
    const compoundMethodRoots = {
        [CompoundWordsMethod.NONE]: [],
        [CompoundWordsMethod.JOIN_WORDS]: [...rootsForCompoundMethods.map((r) => [JOIN_SEPARATOR, r])],
        [CompoundWordsMethod.SEPARATE_WORDS]: [...rootsForCompoundMethods.map((r) => [WORD_SEPARATOR, r])],
    };
    function* children(n, hintOffset) {
        if (n.c) {
            const h = hint.slice(hintOffset, hintOffset + 3) + hint.slice(Math.max(0, hintOffset - 2), hintOffset);
            const hints = new Set(h);
            const c = n.c;
            // First yield the hints
            yield* [...hints]
                .filter((a) => c.has(a))
                .map((letter) => ({
                letter,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                node: c.get(letter),
                hintOffset: hintOffset + 1,
            }));
            // We don't want to suggest the compound character.
            hints.add(compoundCharacter);
            // Then yield everything else.
            yield* [...c]
                .filter((a) => !hints.has(a[0]))
                .map(([letter, node]) => ({
                letter,
                node,
                hintOffset: hintOffset + 1,
            }));
            if (c.has(compoundCharacter) && !setOfCompoundRoots.has(n)) {
                for (const compoundRoot of compoundRoots) {
                    for (const child of children(compoundRoot, hintOffset)) {
                        const { letter, node, hintOffset } = child;
                        yield { letter: emitWordSeparator + letter, node, hintOffset };
                    }
                }
            }
        }
        if (n.f) {
            yield* [...compoundMethodRoots[_compoundingMethod]].map(([letter, node]) => ({
                letter: letter,
                node,
                hintOffset,
            }));
        }
    }
    for (const root of roots) {
        let depth = 0;
        const stack = [];
        const stackText = [''];
        stack[depth] = children(root, depth);
        let ir;
        while (depth >= 0) {
            while (!(ir = stack[depth].next()).done) {
                const { letter: char, node, hintOffset } = ir.value;
                const text = stackText[depth] + char;
                const hinting = (yield { text, node, depth });
                if (hinting && hinting.goDeeper) {
                    depth++;
                    stackText[depth] = text;
                    stack[depth] = children(node, hintOffset);
                }
            }
            depth -= 1;
        }
    }
}
function existMap(values) {
    const m = Object.create(null);
    for (const v of values) {
        m[v] = true;
    }
    return m;
}
export const __testing__ = {
    hintedWalkerNext,
};

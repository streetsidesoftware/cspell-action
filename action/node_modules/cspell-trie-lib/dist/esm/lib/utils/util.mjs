export function isDefined(a) {
    return a !== undefined;
}
/**
 * Remove any fields with an `undefined` value.
 * @param t - object to clean
 * @returns t
 */
export function cleanCopy(t) {
    const r = { ...t };
    return clean(r);
}
/**
 * Remove any fields with an `undefined` value.
 * **MODIFIES THE OBJECT**
 * @param t - object to clean
 * @returns t
 */
export function clean(t) {
    for (const prop in t) {
        if (t[prop] === undefined) {
            delete t[prop];
        }
    }
    return t;
}
export function unique(a) {
    return [...new Set(a)];
}
export function* flatten(i) {
    for (const v of i) {
        yield* v;
    }
}
export function replaceAll(text, match, withText) {
    const fn = replaceAllFactory(match, withText);
    return fn(text);
}
/**
 *
 * @param text verbatim text to be inserted into a regexp
 * @returns text that can be used in a regexp.
 */
export function regexQuote(text) {
    return text.replace(/([[\]\-+(){},|*.\\])/g, '\\$1');
}
/**
 * Factory to create a function that will replace all occurrences of `match` with `withText`
 * @param match - string to match
 * @param replaceWithText - the text to substitute.
 */
export function replaceAllFactory(match, replaceWithText) {
    const r = RegExp(regexQuote(match), 'g');
    return (text) => text.replace(r, replaceWithText);
}
/**
 * Shallow is Equal test.
 * @param a - array of values
 * @param b - array of values
 * @returns true if the values of `a` are exactly equal to the values of `b`
 */
export function isArrayEqual(a, b) {
    if (a === b)
        return true;
    let isMatch = a.length === b.length;
    const len = a.length;
    for (let i = 0; isMatch && i < len; ++i) {
        isMatch = a[i] === b[i];
    }
    return isMatch;
}

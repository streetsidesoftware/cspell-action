"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapDictionaryInformationToAdjustment = exports.mapDictionaryInformation = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const index_js_1 = require("../models/locale/index.js");
const util_js_1 = require("../utils/util.js");
const mapCosts_js_1 = require("./mapCosts.js");
const mapHunspellInformation_js_1 = require("./mapHunspellInformation.js");
const mapToSuggestionCostDef_js_1 = require("./mapToSuggestionCostDef.js");
function mapDictionaryInformation(dictInfo) {
    const _locale = dictInfo.locale;
    const locale = _locale ? (0, index_js_1.parseLocale)(_locale).filter((loc) => loc.isValid()) : undefined;
    const locales = locale?.map((loc) => loc.locale);
    const costs = (0, mapCosts_js_1.mapEditCosts)(dictInfo.costs);
    const defsEC = dictInfo.suggestionEditCosts || [];
    const defsHI = dictInfo.hunspellInformation
        ? (0, mapHunspellInformation_js_1.hunspellInformationToSuggestionCostDef)(dictInfo.hunspellInformation, locale)
        : [];
    return [
        ...defsEC,
        ...processAlphabet(dictInfo.alphabet, locales, costs),
        ...processAccents(dictInfo.accents, costs),
        ...defsHI,
    ];
}
exports.mapDictionaryInformation = mapDictionaryInformation;
function processAlphabet(alphabet, locale, editCost) {
    const csAlphabet = toCharSets(alphabet, 'a-zA-Z', editCost.baseCost);
    return [
        ...(0, sync_1.pipeSync)(csAlphabet, (0, sync_1.opMap)((cs) => (0, mapToSuggestionCostDef_js_1.parseAlphabet)(cs, locale, editCost)), (0, sync_1.opFlatten)()),
        ...(0, mapToSuggestionCostDef_js_1.calcFirstCharacterReplaceDefs)(csAlphabet, editCost),
    ];
}
function toCharSets(cs, defaultValue, cost, penalty) {
    cs = cs ?? defaultValue;
    if (!cs)
        return [];
    if (typeof cs === 'string') {
        cs = [
            {
                characters: cs,
                cost,
            },
        ];
    }
    if (penalty !== undefined) {
        cs.forEach((cs) => (cs.penalty = penalty));
    }
    return cs;
}
function processAccents(accents, editCost) {
    const cs = toCharSets(accents, '\u0300-\u0341', editCost.accentCosts);
    return cs.map((cs) => (0, mapToSuggestionCostDef_js_1.parseAccents)(cs, editCost)).filter(util_js_1.isDefined);
}
function mapDictionaryInformationToAdjustment(dictInfo) {
    if (!dictInfo.adjustments)
        return [];
    return dictInfo.adjustments.map(mapAdjustment);
}
exports.mapDictionaryInformationToAdjustment = mapDictionaryInformationToAdjustment;
function mapAdjustment(adj) {
    const { id, regexp, penalty } = adj;
    return {
        id: id,
        regexp: new RegExp(regexp),
        penalty,
    };
}
//# sourceMappingURL=mapDictionaryInfo.js.map
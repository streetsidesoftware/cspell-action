"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parser = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const typescript_js_1 = require("../../grammars/typescript.js");
const appendMappedText_js_1 = require("../../mappers/appendMappedText.js");
const typescript_js_2 = require("../../mappers/typescript.js");
const grammar_js_1 = require("../../parser/grammar.js");
const parser_js_1 = require("../../parser/parser.js");
const scope_js_1 = require("../../parser/scope.js");
const tsGrammar = (0, grammar_js_1.compileGrammar)(typescript_js_1.grammar);
const pool = new scope_js_1.ScopePool();
const useScope = new WeakMap();
function* transform(texts) {
    for (const parsed of texts) {
        if (doesScopeMatch(parsed.scope, 'constant.character.escape.ts')) {
            const mapped = (0, typescript_js_2.mapRawString)(parsed.text);
            const scope = parsed.scope ? pool.parseScope(parsed.scope) : undefined;
            yield {
                text: mapped.text,
                scope: scope?.parent,
                map: mapped.map,
                range: parsed.range,
            };
            continue;
        }
        yield parsed;
    }
}
function* mergeStringResults(results) {
    let last;
    for (const next of results) {
        if (!doesScopeMatch(next.scope, 'string.')) {
            if (last) {
                yield last;
                last = undefined;
            }
            yield next;
            continue;
        }
        if (!last) {
            last = next;
            continue;
        }
        if (next.scope !== last.scope || last.range[1] !== next.range[0]) {
            yield last;
            last = next;
            continue;
        }
        last = mergeParsedText(last, next);
    }
    if (last)
        yield last;
}
function mergeParsedText(a, b) {
    const abT = (0, appendMappedText_js_1.appendMappedText)(a, b);
    const ab = {
        text: abT.text,
        scope: a.scope,
        range: [a.range[0], b.range[1]],
        map: abT.map,
        delegate: a.delegate,
    };
    return ab;
}
function filterScope(scope) {
    const cached = useScope.get(scope);
    if (cached !== undefined)
        return cached;
    const value = scope.value;
    const use = !value.startsWith('punctuation') && !value.startsWith('keyword.');
    useScope.set(scope, use);
    return use;
}
function mapTokenizedLine(tl) {
    return tl.tokens
        .filter((t) => filterScope(t.scope))
        .map((t) => ({
        text: t.text,
        range: [tl.offset + t.range[0], tl.offset + t.range[1]],
        scope: t.scope,
    }));
}
function mapTokenizedLines(itl) {
    return (0, sync_1.pipe)(itl, (0, sync_1.opMap)(mapTokenizedLine), (0, sync_1.opFlatten)(), transform, mergeStringResults);
}
exports.parser = (0, parser_js_1.createParser)(tsGrammar, 'typescript', mapTokenizedLines);
function doesScopeMatch(s, match) {
    if (!s)
        return false;
    return typeof s === 'string' ? s.startsWith(match) : s.value.startsWith(match);
}
//# sourceMappingURL=TypeScriptParser.js.map
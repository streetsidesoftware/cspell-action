"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appendMappedText = void 0;
const assert_1 = __importDefault(require("assert"));
function appendMappedText(a, b) {
    if (!a.map && !b.map) {
        return { text: a.text + b.text };
    }
    const aLen = a.text.length;
    const bLen = b.text.length;
    const aMap = [0, 0].concat(a.map || [0, 0, aLen, aLen]);
    const bMap = [0, 0].concat(b.map || [0, 0, bLen, bLen]);
    (0, assert_1.default)(aMap[aMap.length - 1] === aLen);
    (0, assert_1.default)(bMap[bMap.length - 1] === bLen);
    (0, assert_1.default)((aMap.length & 1) === 0);
    (0, assert_1.default)((bMap.length & 1) === 0);
    return {
        text: a.text + b.text,
        map: joinMaps(aMap, bMap),
    };
}
exports.appendMappedText = appendMappedText;
function joinMaps(aMap, bMap) {
    const n = aMap.length - 1;
    const offsets = [aMap[n - 1], aMap[n]];
    const ab = aMap.concat(bMap.map((v, i) => v + offsets[i & 1]));
    // Normalize the map by removing duplicate entries
    const r = [0, 0];
    let last0 = 0, last1 = 0;
    for (let i = 0; i < ab.length; i += 2) {
        const v0 = ab[i];
        const v1 = ab[i + 1];
        if (v0 === last0 && v1 === last1) {
            continue;
        }
        r.push(v0, v1);
        last0 = v0;
        last1 = v1;
    }
    return r;
}
//# sourceMappingURL=appendMappedText.js.map
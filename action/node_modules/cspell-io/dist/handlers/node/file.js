"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerHandlers = void 0;
const cspell_service_bus_1 = require("@cspell/cspell-service-bus");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const zlib_1 = require("zlib");
const errors_1 = require("../../errors");
const dataUrl_1 = require("../../node/dataUrl");
const fetch_1 = require("../../node/file/fetch");
const stat_1 = require("../../node/file/stat");
const requests_1 = require("../../requests");
const url_1 = require("url");
const isGzFileRegExp = /\.gz($|[?#])/;
function isGzFile(url) {
    return isGzFileRegExp.test(url.pathname);
}
/*
 * NOTE: fileURLToPath is used because of yarn bug https://github.com/yarnpkg/berry/issues/899
 */
/**
 * Handle Binary File Reads
 */
const handleRequestFsReadBinaryFile = requests_1.RequestFsReadBinaryFile.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.readFile((0, url_1.fileURLToPath)(params.url)).then((content) => ({ url: params.url, content }))), undefined, 'Node: Read Binary File.');
/**
 * Handle Binary File Sync Reads
 */
const handleRequestFsReadBinaryFileSync = requests_1.RequestFsReadBinaryFileSync.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)({ url: params.url, content: (0, fs_1.readFileSync)((0, url_1.fileURLToPath)(params.url)) }), undefined, 'Node: Sync Read Binary File.');
/**
 * Handle UTF-8 Text File Reads
 */
const handleRequestFsReadFile = requests_1.RequestFsReadFile.createRequestHandler((req, _, dispatcher) => {
    const { url, encoding } = req.params;
    const res = dispatcher.dispatch(requests_1.RequestFsReadBinaryFile.create({ url }));
    if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
        (0, assert_1.default)((0, cspell_service_bus_1.isServiceResponseFailure)(res));
        return (0, cspell_service_bus_1.createResponseFail)(req, res.error);
    }
    return (0, cspell_service_bus_1.createResponse)(res.value.then((res) => ({
        url,
        content: bufferToText(res.content, encoding),
        baseFilename: res.baseFilename,
    })));
}, undefined, 'Node: Read Text File.');
/**
 * Handle UTF-8 Text File Reads
 */
const handleRequestFsReadFileSync = requests_1.RequestFsReadFileSync.createRequestHandler((req, _, dispatcher) => {
    const { url, encoding } = req.params;
    const res = dispatcher.dispatch(requests_1.RequestFsReadBinaryFileSync.create({ url }));
    if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
        (0, assert_1.default)((0, cspell_service_bus_1.isServiceResponseFailure)(res));
        return (0, cspell_service_bus_1.createResponseFail)(req, res.error);
    }
    return (0, cspell_service_bus_1.createResponse)({
        ...res.value,
        content: bufferToText(res.value.content, encoding),
    });
}, undefined, 'Node: Sync Read Text File.');
/**
 * Handle deflating gzip data
 */
const handleRequestZlibInflate = requests_1.RequestZlibInflate.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)((0, zlib_1.gunzipSync)(params.data).toString('utf-8')), undefined, 'Node: gz deflate.');
const supportedFetchProtocols = { 'http:': true, 'https:': true };
/**
 * Handle fetching a file from http
 */
const handleRequestFsReadBinaryFileHttp = requests_1.RequestFsReadBinaryFile.createRequestHandler((req, next) => {
    const { url } = req.params;
    if (!(url.protocol in supportedFetchProtocols))
        return next(req);
    return (0, cspell_service_bus_1.createResponse)((0, fetch_1.fetchURL)(url).then((content) => ({ url, content })));
}, undefined, 'Node: Read Http(s) file.');
/**
 * Handle decoding a data url
 */
const handleRequestFsReadBinaryFileSyncData = requests_1.RequestFsReadBinaryFileSync.createRequestHandler((req, next) => {
    const { url } = req.params;
    if (url.protocol !== 'data:')
        return next(req);
    const data = (0, dataUrl_1.decodeDataUrl)(url);
    return (0, cspell_service_bus_1.createResponse)({ url, content: data.data, baseFilename: data.attributes.get('filename') });
}, undefined, 'Node: Read data: urls.');
/**
 * Handle decoding a data url
 */
const handleRequestFsReadBinaryFileData = requests_1.RequestFsReadBinaryFile.createRequestHandler((req, next, dispatcher) => {
    const { url } = req.params;
    if (url.protocol !== 'data:')
        return next(req);
    const res = dispatcher.dispatch(requests_1.RequestFsReadBinaryFileSync.create(req.params));
    if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res))
        return res;
    return (0, cspell_service_bus_1.createResponse)(Promise.resolve(res.value));
}, undefined, 'Node: Read data: urls.');
function bufferToText(buf, encoding) {
    return buf[0] === 0x1f && buf[1] === 0x8b ? bufferToText((0, zlib_1.gunzipSync)(buf), encoding) : buf.toString(encoding);
}
/**
 * Handle fs:stat
 */
const handleRequestFsStat = requests_1.RequestFsStat.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.stat((0, url_1.fileURLToPath)(params.url))), undefined, 'Node: fs.stat.');
/**
 * Handle fs:statSync
 */
const handleRequestFsStatSync = requests_1.RequestFsStatSync.createRequestHandler((req) => {
    const { params } = req;
    try {
        return (0, cspell_service_bus_1.createResponse)((0, fs_1.statSync)((0, url_1.fileURLToPath)(params.url)));
    }
    catch (e) {
        return (0, cspell_service_bus_1.createResponseFail)(req, (0, errors_1.toError)(e));
    }
}, undefined, 'Node: fs.stat.');
/**
 * Handle deflating gzip data
 */
const handleRequestFsStatHttp = requests_1.RequestFsStat.createRequestHandler((req, next) => {
    const { url } = req.params;
    if (!(url.protocol in supportedFetchProtocols))
        return next(req);
    return (0, cspell_service_bus_1.createResponse)((0, stat_1.getStatHttp)(url));
}, undefined, 'Node: http get stat');
/**
 * Handle fs:writeFile
 */
const handleRequestFsWriteFile = requests_1.RequestFsWriteFile.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.writeFile(params.url, params.content)), undefined, 'Node: fs.writeFile');
/**
 * Handle fs:writeFile compressed
 */
const handleRequestFsWriteFileGz = requests_1.RequestFsWriteFile.createRequestHandler((req, next) => {
    const { url, content } = req.params;
    if (!isGzFile(url))
        return next(req);
    return (0, cspell_service_bus_1.createResponse)(fs_1.promises.writeFile(url, (0, zlib_1.gzipSync)(content)));
}, undefined, 'Node: http get stat');
function registerHandlers(serviceBus) {
    /**
     * Handlers are in order of low to high level
     * Order is VERY important.
     */
    const handlers = [
        handleRequestFsWriteFile,
        handleRequestFsWriteFileGz,
        handleRequestFsReadBinaryFile,
        handleRequestFsReadBinaryFileSync,
        handleRequestFsReadBinaryFileHttp,
        handleRequestFsReadBinaryFileData,
        handleRequestFsReadBinaryFileSyncData,
        handleRequestFsReadFile,
        handleRequestFsReadFileSync,
        handleRequestZlibInflate,
        handleRequestFsStatSync,
        handleRequestFsStat,
        handleRequestFsStatHttp,
    ];
    handlers.forEach((handler) => serviceBus.addHandler(handler));
}
exports.registerHandlers = registerHandlers;
//# sourceMappingURL=file.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerHandlers = void 0;
const cspell_service_bus_1 = require("@cspell/cspell-service-bus");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const zlib_1 = require("zlib");
const errors_1 = require("../../errors");
const fetch_1 = require("../../node/file/fetch");
const stat_1 = require("../../node/file/stat");
const requests_1 = require("../../requests");
const isGzFileRegExp = /\.gz($|[?#])/;
function isGzFile(url) {
    return isGzFileRegExp.test(url.pathname);
}
/**
 * Handle Binary File Reads
 */
const handleRequestFsReadBinaryFile = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsReadBinaryFile, ({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.readFile(params.url)), undefined, 'Node: Read Binary File.');
/**
 * Handle Binary File Sync Reads
 */
const handleRequestFsReadBinaryFileSync = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsReadBinaryFileSync, ({ params }) => (0, cspell_service_bus_1.createResponse)((0, fs_1.readFileSync)(params.url)), undefined, 'Node: Sync Read Binary File.');
/**
 * Handle UTF-8 Text File Reads
 */
const handleRequestFsReadFile = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsReadFile, (req, _, dispatcher) => {
    const { url, encoding } = req.params;
    const res = dispatcher.dispatch(requests_1.RequestFsReadBinaryFile.create({ url }));
    if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
        (0, assert_1.default)((0, cspell_service_bus_1.isServiceResponseFailure)(res));
        return (0, cspell_service_bus_1.createResponseFail)(req, res.error);
    }
    return (0, cspell_service_bus_1.createResponse)(res.value.then((buf) => bufferToText(buf, encoding)));
}, undefined, 'Node: Read Text File.');
/**
 * Handle UTF-8 Text File Reads
 */
const handleRequestFsReadFileSync = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsReadFileSync, (req, _, dispatcher) => {
    const { url, encoding } = req.params;
    const res = dispatcher.dispatch(requests_1.RequestFsReadBinaryFileSync.create({ url }));
    if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
        (0, assert_1.default)((0, cspell_service_bus_1.isServiceResponseFailure)(res));
        return (0, cspell_service_bus_1.createResponseFail)(req, res.error);
    }
    return (0, cspell_service_bus_1.createResponse)(bufferToText(res.value, encoding));
}, undefined, 'Node: Sync Read Text File.');
/**
 * Handle deflating gzip data
 */
const handleRequestZlibInflate = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestZlibInflate, ({ params }) => (0, cspell_service_bus_1.createResponse)((0, zlib_1.gunzipSync)(params.data).toString('utf-8')), undefined, 'Node: gz deflate.');
const supportedFetchProtocols = { 'http:': true, 'https:': true };
/**
 * Handle reading gzip'ed text files.
 */
const handleRequestFsReadBinaryFileHttp = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsReadBinaryFile, (req, next) => {
    const { url } = req.params;
    if (!(url.protocol in supportedFetchProtocols))
        return next(req);
    return (0, cspell_service_bus_1.createResponse)((0, fetch_1.fetchURL)(url));
}, undefined, 'Node: Read Http(s) file.');
function bufferToText(buf, encoding) {
    return buf[0] === 0x1f && buf[1] === 0x8b ? bufferToText((0, zlib_1.gunzipSync)(buf), encoding) : buf.toString(encoding);
}
/**
 * Handle fs:stat
 */
const handleRequestFsStat = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsStat, ({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.stat(params.url)), undefined, 'Node: fs.stat.');
/**
 * Handle fs:statSync
 */
const handleRequestFsStatSync = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsStatSync, (req) => {
    const { params } = req;
    try {
        return (0, cspell_service_bus_1.createResponse)((0, fs_1.statSync)(params.url));
    }
    catch (e) {
        return (0, cspell_service_bus_1.createResponseFail)(req, (0, errors_1.toError)(e));
    }
}, undefined, 'Node: fs.stat.');
/**
 * Handle deflating gzip data
 */
const handleRequestFsStatHttp = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsStat, (req, next) => {
    const { url } = req.params;
    if (!(url.protocol in supportedFetchProtocols))
        return next(req);
    return (0, cspell_service_bus_1.createResponse)((0, stat_1.getStatHttp)(url));
}, undefined, 'Node: http get stat');
/**
 * Handle fs:writeFile
 */
const handleRequestFsWriteFile = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsWriteFile, ({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.writeFile(params.url, params.content)), undefined, 'Node: fs.writeFile');
/**
 * Handle fs:writeFile compressed
 */
const handleRequestFsWriteFileGz = (0, cspell_service_bus_1.createRequestHandler)(requests_1.RequestFsWriteFile, (req, next) => {
    const { url, content } = req.params;
    if (!isGzFile(url))
        return next(req);
    return (0, cspell_service_bus_1.createResponse)(fs_1.promises.writeFile(url, (0, zlib_1.gzipSync)(content)));
}, undefined, 'Node: http get stat');
function registerHandlers(serviceBus) {
    /**
     * Handlers are in order of low to high level
     * Order is VERY important.
     */
    const handlers = [
        handleRequestFsWriteFile,
        handleRequestFsWriteFileGz,
        handleRequestFsReadBinaryFile,
        handleRequestFsReadBinaryFileSync,
        handleRequestFsReadBinaryFileHttp,
        handleRequestFsReadFile,
        handleRequestFsReadFileSync,
        handleRequestZlibInflate,
        handleRequestFsStatSync,
        handleRequestFsStat,
        handleRequestFsStatHttp,
    ];
    handlers.forEach((handler) => serviceBus.addHandler(handler));
}
exports.registerHandlers = registerHandlers;
//# sourceMappingURL=file.js.map
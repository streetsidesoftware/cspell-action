"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.basename = exports.urlDirname = exports.urlBasename = exports.toURL = exports.isFileURL = exports.isSupportedURL = exports.isUrlLike = exports.isZipped = void 0;
const url_1 = require("url");
const isZippedRegExp = /\.gz($|[?#])/i;
const isURLRegExp = /^(\w{2,64}:\/\/|data:)/i;
const supportedProtocols = { 'file:': true, 'http:': true, 'https:': true };
function isZipped(filename) {
    const path = typeof filename === 'string' ? filename : filename.pathname;
    return isZippedRegExp.test(path);
}
exports.isZipped = isZipped;
function isUrlLike(filename) {
    return filename instanceof URL || isURLRegExp.test(filename);
}
exports.isUrlLike = isUrlLike;
function isSupportedURL(url) {
    return !!supportedProtocols[url.protocol];
}
exports.isSupportedURL = isSupportedURL;
function isFileURL(url) {
    return url.protocol === 'file:';
}
exports.isFileURL = isFileURL;
function toURL(filename) {
    return filename instanceof URL || typeof filename !== 'string'
        ? filename
        : isUrlLike(filename)
            ? new URL(filename)
            : (0, url_1.pathToFileURL)(filename);
}
exports.toURL = toURL;
const regMatchFilename = /filename=([^;,]*)/;
function urlBasename(url) {
    function guessDataUrlName(header) {
        const filenameMatch = header.match(regMatchFilename);
        if (filenameMatch)
            return filenameMatch[1];
        const mime = header.split(';', 1)[0];
        return mime.replace(/\W/g, '.');
    }
    if (typeof url === 'string' && url.startsWith('data:')) {
        return guessDataUrlName(url.split(',', 1)[0].split(':', 2)[1]);
    }
    url = toURL(url);
    if (url.protocol === 'data:') {
        return guessDataUrlName(url.pathname.split(',', 1)[0]);
    }
    return basename(url.pathname);
}
exports.urlBasename = urlBasename;
function urlDirname(url) {
    if (typeof url === 'string' && url.startsWith('data:')) {
        return toURL('data:');
    }
    url = toURL(url);
    if (url.protocol === 'data:') {
        return toURL('data:');
    }
    return new URL(url.pathname.endsWith('/') ? '..' : '.', url);
}
exports.urlDirname = urlDirname;
function basename(path) {
    path = path.endsWith('/') ? path.slice(0, path.length - 1) : path;
    const idx = path.lastIndexOf('/');
    return idx >= 0 ? path.slice(idx + 1) || '' : path;
}
exports.basename = basename;
//# sourceMappingURL=util.js.map
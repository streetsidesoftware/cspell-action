"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.guessMimeType = exports.encodeDataUrlFromFile = exports.decodeDataUrl = exports.toDataUrl = exports.encodeDataUrl = void 0;
const fs_1 = require("fs");
const fsPath = __importStar(require("path"));
const util_js_1 = require("./file/util.js");
/**
 * Generates a string of the following format:
 *
 * `data:[mediaType][;charset=<encoding>[;base64],<data>`
 *
 * - `encoding` - defaults to `utf8` for text data
 * @param data
 * @param mediaType - The mediaType is a [MIME](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) type string
 * @param attributes - Additional attributes
 */
function encodeDataUrl(data, mediaType, attributes) {
    if (typeof data === 'string')
        return encodeString(data, mediaType, attributes);
    const attribs = encodeAttributes(attributes || []);
    return `data:${mediaType}${attribs};base64,${data.toString('base64url')}`;
}
exports.encodeDataUrl = encodeDataUrl;
function toDataUrl(data, mediaType, attributes) {
    return new URL(encodeDataUrl(data, mediaType, attributes));
}
exports.toDataUrl = toDataUrl;
function encodeString(data, mediaType, attributes) {
    mediaType = mediaType || 'text/plain';
    attributes = attributes || [];
    const asUrlComp = encodeURIComponent(data);
    const asBase64 = Buffer.from(data).toString('base64url');
    const useBase64 = asBase64.length < asUrlComp.length - 7;
    const encoded = useBase64 ? asBase64 : asUrlComp;
    // Ensure charset is first.
    const attribMap = new Map([['charset', 'utf8']].concat([...attributes]));
    attribMap.set('charset', 'utf8'); // Make sure it is always `utf8`.
    const attribs = encodeAttributes(attribMap);
    return `data:${mediaType}${attribs}${useBase64 ? ';base64' : ''},${encoded}`;
}
function encodeAttributes(attributes) {
    return [...attributes].map(([key, value]) => `;${key}=${encodeURIComponent(value)}`).join('');
}
const dataUrlRegExHead = /^data:(?<mediaType>[^;,]*)(?<attributes>(?:;[^=]+=[^;,]*)*)(?<base64>;base64)?$/;
function decodeDataUrl(url) {
    url = url.toString();
    const [head, encodedData] = url.split(',', 2);
    if (!head || encodedData === undefined)
        throw Error('Not a data url');
    const match = head.match(dataUrlRegExHead);
    if (!match || !match.groups)
        throw Error('Not a data url');
    const mediaType = match.groups['mediaType'] || '';
    const rawAttributes = (match.groups['attributes'] || '')
        .split(';')
        .filter((a) => !!a)
        .map((entry) => entry.split('=', 2))
        .map(([key, value]) => [key, decodeURIComponent(value)]);
    const attributes = new Map(rawAttributes);
    const encoding = attributes.get('charset');
    const isBase64 = !!match.groups['base64'];
    const data = isBase64 ? Buffer.from(encodedData, 'base64url') : Buffer.from(decodeURIComponent(encodedData));
    return { mediaType, data, encoding, attributes };
}
exports.decodeDataUrl = decodeDataUrl;
async function encodeDataUrlFromFile(path, mediaType, attributes) {
    const url = (0, util_js_1.toURL)(path);
    const filename = fsPath.basename(url.pathname);
    const guess = guessMimeType(filename);
    mediaType = mediaType || guess?.mimeType || 'text/plain';
    const _attributes = new Map(attributes || []);
    filename && _attributes.set('filename', filename);
    const content = guess?.encoding ? await fs_1.promises.readFile(url, guess?.encoding) : await fs_1.promises.readFile(url);
    return encodeDataUrl(content, mediaType, _attributes);
}
exports.encodeDataUrlFromFile = encodeDataUrlFromFile;
function guessMimeType(filename) {
    if (filename.endsWith('.trie'))
        return { mimeType: 'application/vnd.cspell.dictionary+trie', encoding: 'utf-8' };
    if (filename.endsWith('.trie.gz'))
        return { mimeType: 'application/vnd.cspell.dictionary+trie.gz' };
    if (filename.endsWith('.txt'))
        return { mimeType: 'text/plain', encoding: 'utf-8' };
    if (filename.endsWith('.gz'))
        return { mimeType: 'application/gzip' };
    if (filename.endsWith('.json'))
        return { mimeType: 'application/json', encoding: 'utf-8' };
    if (filename.endsWith('.yaml') || filename.endsWith('.yml'))
        return { mimeType: 'application/x-yaml', encoding: 'utf-8' };
    return undefined;
}
exports.guessMimeType = guessMimeType;
//# sourceMappingURL=dataUrl.js.map
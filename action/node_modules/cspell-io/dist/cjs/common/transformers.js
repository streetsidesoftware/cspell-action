"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encoderTransformer = exports.createDecoderTransformer = void 0;
const encode_decode_js_1 = require("./encode-decode.js");
function createDecoderTransformer(encoding) {
    function standardDecoder(buf) {
        return (0, encode_decode_js_1.decode)(buf, encoding);
    }
    let decoder = undefined;
    if (encoding && !encoding.startsWith('utf'))
        return decoderNonUtf;
    return decoderUtf;
    async function* decoderNonUtf(iterable) {
        for await (const buf of iterable) {
            yield typeof buf === 'string' ? buf : (0, encode_decode_js_1.decode)(buf, encoding);
        }
    }
    async function* decoderUtf(iterable) {
        for await (const sb of iterable) {
            if (typeof sb === 'string') {
                yield sb;
                continue;
            }
            if (sb.length < 2) {
                yield standardDecoder(sb);
                continue;
            }
            if (decoder) {
                yield decoder(sb);
                continue;
            }
            decoder = standardDecoder;
            const _encoding = (0, encode_decode_js_1.calcEncodingFromBom)(sb);
            if (_encoding === 'utf16le') {
                decoder = encode_decode_js_1.decodeUtf16LE;
                yield decoder(sb.subarray(2));
                continue;
            }
            if (_encoding === 'utf16be') {
                decoder = encode_decode_js_1.decodeUtf16BE;
                yield decoder(sb.subarray(2));
                continue;
            }
            yield decoder(sb);
        }
    }
}
exports.createDecoderTransformer = createDecoderTransformer;
function encoderTransformer(iterable, encoding) {
    return isAsyncIterable(iterable) ? encoderAsyncIterable(iterable, encoding) : encoderIterable(iterable, encoding);
}
exports.encoderTransformer = encoderTransformer;
function* encoderIterable(iterable, encoding) {
    let useBom = true;
    for (const chunk of iterable) {
        yield (0, encode_decode_js_1.encodeString)(chunk, encoding, useBom);
        useBom = false;
    }
}
async function* encoderAsyncIterable(iterable, encoding) {
    let useBom = true;
    for await (const chunk of iterable) {
        yield (0, encode_decode_js_1.encodeString)(chunk, encoding, useBom);
        useBom = false;
    }
}
function isAsyncIterable(v) {
    return v && typeof v === 'object' && !!v[Symbol.asyncIterator];
}
//# sourceMappingURL=transformers.js.map
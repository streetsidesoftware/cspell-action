"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testMethods__ = exports.createWeightMapFromDictionaryInformation = exports.suggestArgsToSuggestOptions = exports.canonicalSearchOptions = exports.hasOptionToSearchOption = exports.wordSuggestForms = exports.wordSuggestFormsArray = exports.wordSearchForms = exports.defaultNumSuggestions = exports.suggestionCollector = exports.impersonateCollector = void 0;
const cspell_trie_lib_1 = require("cspell-trie-lib");
const clean_1 = require("../util/clean");
const text_1 = require("../util/text");
var cspell_trie_lib_2 = require("cspell-trie-lib");
Object.defineProperty(exports, "impersonateCollector", { enumerable: true, get: function () { return cspell_trie_lib_2.impersonateCollector; } });
Object.defineProperty(exports, "suggestionCollector", { enumerable: true, get: function () { return cspell_trie_lib_2.suggestionCollector; } });
exports.defaultNumSuggestions = 10;
function wordSearchFormsArray(word, isDictionaryCaseSensitive, ignoreCase) {
    return [...wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase)];
}
function wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase) {
    const forms = new Set();
    word = word.normalize('NFC');
    const wordLc = word.toLowerCase();
    if (ignoreCase) {
        if (isDictionaryCaseSensitive) {
            forms.add(wordLc);
        }
        else {
            forms.add(wordLc);
            // Legacy remove any unbound accents
            forms.add((0, text_1.removeUnboundAccents)(wordLc));
        }
    }
    else {
        if (isDictionaryCaseSensitive) {
            forms.add(word);
            forms.add(wordLc);
            // HOUSE -> House, house
            if ((0, text_1.isUpperCase)(word)) {
                forms.add((0, text_1.ucFirst)(wordLc));
            }
        }
        else {
            forms.add(wordLc);
            // Legacy remove any unbound accents
            forms.add((0, text_1.removeUnboundAccents)(wordLc));
        }
    }
    return forms;
}
exports.wordSearchForms = wordSearchForms;
function wordSuggestFormsArray(word) {
    return [...wordSuggestForms(word)];
}
exports.wordSuggestFormsArray = wordSuggestFormsArray;
function wordSuggestForms(word) {
    word = word.normalize('NFC');
    const forms = new Set([word]);
    const wordLc = word.toLowerCase();
    forms.add(wordLc);
    return forms;
}
exports.wordSuggestForms = wordSuggestForms;
const DEFAULT_HAS_OPTIONS = Object.freeze({});
function hasOptionToSearchOption(opt) {
    return canonicalSearchOptions(!opt ? DEFAULT_HAS_OPTIONS : opt);
}
exports.hasOptionToSearchOption = hasOptionToSearchOption;
const canonicalSearchOptionsMap = new Map();
const knownCanonicalOptions = new WeakMap();
/**
 * Find the canonical form for SearchOptions. Useful Maps and WeakMaps.
 * @param opt - options to normalize
 * @returns SearchOptions - the canonical form
 */
function canonicalSearchOptions(opt) {
    const known = knownCanonicalOptions.get(opt);
    if (known)
        return known;
    const { ignoreCase, useCompounds } = opt;
    const foundLevel1Map = canonicalSearchOptionsMap.get(ignoreCase);
    const useLevel1Map = foundLevel1Map || new Map();
    if (!foundLevel1Map) {
        canonicalSearchOptionsMap.set(ignoreCase, useLevel1Map);
    }
    const foundCanOpts = useLevel1Map.get(useCompounds);
    const canOpts = foundCanOpts || Object.freeze({ ignoreCase, useCompounds });
    if (!foundCanOpts) {
        useLevel1Map.set(useCompounds, canOpts);
    }
    knownCanonicalOptions.set(opt, canOpts);
    return canOpts;
}
exports.canonicalSearchOptions = canonicalSearchOptions;
function suggestArgsToSuggestOptions(args) {
    const [_word, options, compoundMethod, numChanges, ignoreCase] = args;
    const suggestOptions = typeof options === 'object'
        ? options
        : (0, clean_1.clean)({
            numSuggestions: options,
            compoundMethod,
            numChanges,
            ignoreCase,
            includeTies: undefined,
            timeout: undefined,
        });
    return suggestOptions;
}
exports.suggestArgsToSuggestOptions = suggestArgsToSuggestOptions;
function createWeightMapFromDictionaryInformation(di) {
    return di ? (0, cspell_trie_lib_1.mapDictionaryInformationToWeightMap)(di) : undefined;
}
exports.createWeightMapFromDictionaryInformation = createWeightMapFromDictionaryInformation;
exports.__testMethods__ = {
    wordSearchForms,
    wordSearchFormsArray,
};
//# sourceMappingURL=SpellingDictionaryMethods.js.map
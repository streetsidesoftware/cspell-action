"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testing__ = exports.createSpellingDictionaryFromTrieFile = exports.SpellingDictionaryFromTrie = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const cspell_trie_lib_1 = require("cspell-trie-lib");
const AutoCache_1 = require("../util/AutoCache");
const clean_1 = require("../util/clean");
const repMap_1 = require("../util/repMap");
const Defaults = __importStar(require("./defaults"));
const SpellingDictionaryMethods_1 = require("./SpellingDictionaryMethods");
const findWordOptionsCaseSensitive = Object.freeze({ caseSensitive: true });
const findWordOptionsNotCaseSensitive = Object.freeze({ caseSensitive: false });
class SpellingDictionaryFromTrie {
    constructor(trie, name, options, source = 'from trie', size) {
        this.trie = trie;
        this.name = name;
        this.options = options;
        this.source = source;
        this._size = 0;
        this.knownWords = new Set();
        this.unknownWords = new Set();
        this.type = 'SpellingDictionaryFromTrie';
        this._find = findCache((word, useCompounds, ignoreCase) => this.findAnyForm(word, useCompounds, ignoreCase));
        this._isForbidden = (0, AutoCache_1.autoCache)((word) => {
            return this.trie.isForbiddenWord(word);
        });
        this.mapWord = (0, repMap_1.createMapper)(options.repMap, options.dictionaryInformation?.ignore);
        this.isDictionaryCaseSensitive = options.caseSensitive ?? !trie.isLegacy;
        this.containsNoSuggestWords = options.noSuggest || false;
        this._size = size || 0;
        this.weightMap = options.weightMap || (0, SpellingDictionaryMethods_1.createWeightMapFromDictionaryInformation)(options.dictionaryInformation);
    }
    get size() {
        if (!this._size) {
            // walk the trie and get the approximate size.
            const i = this.trie.iterate();
            let deeper = true;
            let size = 0;
            for (let r = i.next(); !r.done; r = i.next(deeper)) {
                // count all nodes even though they are not words.
                // because we are not going to all the leaves, this should give a good enough approximation.
                size += 1;
                deeper = r.value.text.length < 5;
            }
            this._size = size;
        }
        return this._size;
    }
    has(word, hasOptions) {
        const { useCompounds, ignoreCase } = this.resolveOptions(hasOptions);
        const r = this._find(word, useCompounds, ignoreCase);
        return !!r && !r.forbidden && !!r.found;
    }
    find(word, hasOptions) {
        const { useCompounds, ignoreCase } = this.resolveOptions(hasOptions);
        const r = this._find(word, useCompounds, ignoreCase);
        const { forbidden = this.isForbidden(word) } = r || {};
        if (!r && !forbidden)
            return undefined;
        const { found = forbidden ? word : false } = r || {};
        const noSuggest = found !== false && this.containsNoSuggestWords;
        return { found, forbidden, noSuggest };
    }
    resolveOptions(hasOptions) {
        const { useCompounds = this.options.useCompounds, ignoreCase = Defaults.ignoreCase } = (0, SpellingDictionaryMethods_1.hasOptionToSearchOption)(hasOptions);
        return { useCompounds, ignoreCase };
    }
    findAnyForm(word, useCompounds, ignoreCase) {
        const outerForms = outerWordForms(word, this.mapWord);
        for (const form of outerForms) {
            const r = this._findAnyForm(form, useCompounds, ignoreCase);
            if (r)
                return r;
        }
        return undefined;
    }
    _findAnyForm(mWord, useCompounds, ignoreCase) {
        const opts = ignoreCase ? findWordOptionsNotCaseSensitive : findWordOptionsCaseSensitive;
        const findResult = this.trie.findWord(mWord, opts);
        if (findResult.found !== false) {
            return findResult;
        }
        const forms = (0, SpellingDictionaryMethods_1.wordSearchForms)(mWord, this.isDictionaryCaseSensitive, ignoreCase);
        for (const w of forms) {
            const findResult = this.trie.findWord(w, opts);
            if (findResult.found !== false) {
                return findResult;
            }
        }
        if (useCompounds) {
            const optsUseCompounds = { ...opts, useLegacyWordCompounds: useCompounds };
            for (const w of forms) {
                const findResult = this.trie.findWord(w, optsUseCompounds);
                if (findResult.found !== false) {
                    return findResult;
                }
            }
        }
        return undefined;
    }
    isNoSuggestWord(word, options) {
        return this.containsNoSuggestWords ? this.has(word, options) : false;
    }
    isForbidden(word, _ignoreCaseAndAccents) {
        return this._isForbidden(word);
    }
    suggest(...args) {
        const [word] = args;
        const suggestOptions = (0, SpellingDictionaryMethods_1.suggestArgsToSuggestOptions)(args);
        return this._suggest(word, suggestOptions);
    }
    _suggest(word, suggestOptions) {
        const { numSuggestions = SpellingDictionaryMethods_1.defaultNumSuggestions, numChanges, includeTies, ignoreCase, timeout } = suggestOptions;
        function filter(_word) {
            return true;
        }
        const collector = (0, cspell_trie_lib_1.suggestionCollector)(word, (0, clean_1.clean)({
            numSuggestions,
            filter,
            changeLimit: numChanges,
            includeTies,
            ignoreCase,
            timeout,
            weightMap: this.weightMap,
        }));
        this.genSuggestions(collector, suggestOptions);
        return collector.suggestions.map((r) => ({ ...r, word: r.word }));
    }
    genSuggestions(collector, suggestOptions) {
        if (this.options.noSuggest)
            return;
        const _compoundMethod = suggestOptions.compoundMethod ??
            (this.options.useCompounds ? cspell_trie_lib_1.CompoundWordsMethod.JOIN_WORDS : cspell_trie_lib_1.CompoundWordsMethod.NONE);
        (0, SpellingDictionaryMethods_1.wordSuggestFormsArray)(collector.word).forEach((w) => this.trie.genSuggestions((0, SpellingDictionaryMethods_1.impersonateCollector)(collector, w), _compoundMethod));
    }
    getErrors() {
        return [];
    }
}
exports.SpellingDictionaryFromTrie = SpellingDictionaryFromTrie;
SpellingDictionaryFromTrie.cachedWordsLimit = 50000;
/**
 * Create a dictionary from a trie file.
 * @param data - contents of a trie file.
 * @param name - name of dictionary
 * @param source - filename or uri
 * @param options - options.
 * @returns SpellingDictionary
 */
function createSpellingDictionaryFromTrieFile(data, name, source, options) {
    data = typeof data === 'string' ? data.split('\n') : data;
    const trieNode = (0, cspell_trie_lib_1.importTrie)(data);
    const trie = new cspell_trie_lib_1.Trie(trieNode);
    return new SpellingDictionaryFromTrie(trie, name, options, source);
}
exports.createSpellingDictionaryFromTrieFile = createSpellingDictionaryFromTrieFile;
function findCache(fn, size = 2000) {
    const cache = (0, AutoCache_1.createCache01)(size);
    function find(word, useCompounds, ignoreCase) {
        const r = cache.get(word);
        if (r !== undefined) {
            if (r.useCompounds === useCompounds && r.ignoreCase === ignoreCase) {
                return r.findResult;
            }
        }
        const findResult = fn(word, useCompounds, ignoreCase);
        cache.set(word, { useCompounds, ignoreCase, findResult });
        return findResult;
    }
    return find;
}
function outerWordForms(word, mapWord) {
    const forms = (0, sync_1.pipe)([word], (0, sync_1.opConcatMap)((word) => [word, word.normalize('NFC'), word.normalize('NFD')]), (0, sync_1.opConcatMap)((word) => [word, mapWord(word)]));
    return new Set(forms);
}
exports.__testing__ = { outerWordForms };
//# sourceMappingURL=SpellingDictionaryFromTrie.js.map
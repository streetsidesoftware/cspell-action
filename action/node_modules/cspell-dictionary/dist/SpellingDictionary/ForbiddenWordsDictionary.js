"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createForbiddenWordsDictionary = void 0;
const cspell_trie_lib_1 = require("cspell-trie-lib");
const createSpellingDictionary_1 = require("./createSpellingDictionary");
const SpellingDictionaryFromTrie_1 = require("./SpellingDictionaryFromTrie");
class ForbiddenWordsDictionaryTrie extends SpellingDictionaryFromTrie_1.SpellingDictionaryFromTrie {
    constructor(trie, name, source) {
        super(trie, name, createSpellingDictionary_1.defaultOptions, source);
        this.name = name;
        this.source = source;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.isDictionaryCaseSensitive = true;
    }
    /**
     * A Forbidden word list does not "have" valid words.
     * Therefore it always returns false.
     * @param _word - the word
     * @param _options - options
     * @returns always false
     */
    has(_word, _options) {
        return false;
    }
    find(word, hasOptions) {
        const f = super.find(word, hasOptions);
        if (!f || !f.forbidden)
            return undefined;
        return f;
    }
    suggest() {
        return [];
    }
    genSuggestions() {
        return;
    }
}
class ForbiddenWordsDictionary {
    constructor(name, source, words) {
        this.name = name;
        this.source = source;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.type = 'forbidden';
        this.isDictionaryCaseSensitive = true;
        this.dict = new Set(words);
        this.dictIgnore = new Set(words.filter((w) => w.startsWith('!')).map((w) => w.slice(1)));
    }
    /**
     * A Forbidden word list does not "have" valid words.
     * Therefore it always returns false.
     * @param _word - the word
     * @param _options - options
     * @returns always false
     */
    has(_word, _options) {
        return false;
    }
    /** A more detailed search for a word, might take longer than `has` */
    find(word, _options) {
        const forbidden = this.isForbidden(word);
        return forbidden ? { found: word, forbidden, noSuggest: false } : undefined;
    }
    isForbidden(word) {
        return (this.dict.has(word) || this.dict.has(word.toLowerCase())) && !this.dictIgnore.has(word);
    }
    isNoSuggestWord(_word, _options) {
        return false;
    }
    suggest() {
        return [];
    }
    genSuggestions() {
        return;
    }
    mapWord(word) {
        return word;
    }
    get size() {
        return this.dict.size;
    }
    getErrors() {
        return [];
    }
}
/**
 * Create a dictionary where all words are to be forbidden.
 * @param wordList - list of words
 * @param name
 * @param source
 * @param options
 * @returns
 */
function createForbiddenWordsDictionary(wordList, name, source) {
    const testSpecialCharacters = /[~*+]/;
    const regExpCleanIgnore = /^(!!)+/;
    const words = [...(0, cspell_trie_lib_1.parseDictionaryLines)(wordList, { stripCaseAndAccents: false })];
    const hasSpecial = words.findIndex((word) => testSpecialCharacters.test(word)) >= 0;
    if (hasSpecial) {
        const trie = (0, cspell_trie_lib_1.buildTrieFast)(words.map((w) => '!' + w).map((w) => w.replace(regExpCleanIgnore, '')));
        return new ForbiddenWordsDictionaryTrie(trie, name, source);
    }
    return new ForbiddenWordsDictionary(name, source, words);
}
exports.createForbiddenWordsDictionary = createForbiddenWordsDictionary;
//# sourceMappingURL=ForbiddenWordsDictionary.js.map
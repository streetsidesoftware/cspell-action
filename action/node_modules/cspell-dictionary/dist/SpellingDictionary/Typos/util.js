"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractIgnoreValues = exports.extractAllSuggestions = exports.createTyposDef = exports.appendToDef = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
/**
 * Append an entry to a TyposDef.
 * @param def - modified in place
 * @param entry- entry to add.
 * @returns def
 */
function appendToDef(def, entry) {
    if (!entry)
        return def;
    if (typeof entry === 'string') {
        def[entry] = null;
        return def;
    }
    if (Array.isArray(entry)) {
        const [key, ...sugs] = entry.map((s) => s.trim());
        if (!key)
            return def;
        const s = sugs.map((s) => s.trim()).filter((s) => !!s);
        def[key] = !s.length ? null : s.length === 1 ? s[0] : s;
        return def;
    }
    Object.assign(def, entry);
    return def;
}
exports.appendToDef = appendToDef;
function createTyposDef(entries) {
    const def = Object.create(null);
    if (!entries)
        return def;
    for (const [key, value] of entries) {
        def[key] = value;
    }
    return def;
}
exports.createTyposDef = createTyposDef;
function extractAllSuggestions(typosDef) {
    const allSugs = (0, sync_1.pipe)(Object.values(typosDef), (0, sync_1.opFilter)(isDefined), (0, sync_1.opConcatMap)((v) => (Array.isArray(v) ? v : [v])));
    return new Set(allSugs);
}
exports.extractAllSuggestions = extractAllSuggestions;
function extractIgnoreValues(typosDef, ignorePrefix) {
    const sugs = extractAllSuggestions(typosDef);
    const pfxLen = ignorePrefix.length;
    const ignoreKeys = Object.keys(typosDef)
        .filter((k) => k.startsWith(ignorePrefix))
        .map((k) => k.slice(pfxLen));
    return (0, sync_1.reduce)(ignoreKeys, (sugs, word) => sugs.add(word), sugs);
}
exports.extractIgnoreValues = extractIgnoreValues;
function isDefined(v) {
    return v !== undefined && v !== null;
}
//# sourceMappingURL=util.js.map
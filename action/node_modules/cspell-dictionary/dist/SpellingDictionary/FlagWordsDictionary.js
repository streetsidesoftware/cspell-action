"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFlagWordsDictionary = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const cspell_trie_lib_1 = require("cspell-trie-lib");
const createSpellingDictionary_1 = require("./createSpellingDictionary");
const Defaults = __importStar(require("./defaults"));
const SpellingDictionaryFromTrie_1 = require("./SpellingDictionaryFromTrie");
const SpellingDictionaryMethods_1 = require("./SpellingDictionaryMethods");
const TyposDictionary_1 = require("./TyposDictionary");
class FlagWordsDictionaryTrie extends SpellingDictionaryFromTrie_1.SpellingDictionaryFromTrie {
    constructor(trie, name, source) {
        super(trie, name, createSpellingDictionary_1.defaultOptions, source);
        this.name = name;
        this.source = source;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.isDictionaryCaseSensitive = true;
    }
    /**
     * A Forbidden word list does not "have" valid words.
     * Therefore it always returns false.
     * @param _word - the word
     * @param _options - options
     * @returns always false
     */
    has(_word, _options) {
        return false;
    }
    find(word, hasOptions) {
        const f = super.find(word, hasOptions);
        if (!f || !f.forbidden)
            return undefined;
        return f;
    }
    suggest() {
        return [];
    }
    genSuggestions() {
        return;
    }
}
class FlagWordsDictionary {
    constructor(name, source, dictTypos, dictTrie) {
        this.name = name;
        this.source = source;
        this.dictTypos = dictTypos;
        this.dictTrie = dictTrie;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.type = 'flag-words';
        this.isDictionaryCaseSensitive = true;
    }
    /**
     * A Forbidden word list does not "have" valid words.
     * Therefore it always returns false.
     * @param word - the word
     * @param options - options
     * @returns always false
     */
    has(word, options) {
        return this.dictTypos.has(word, options) || this.dictTrie?.has(word, options) || false;
    }
    /** A more detailed search for a word, might take longer than `has` */
    find(word, options) {
        const findTypos = this.dictTypos.find(word, options);
        if (findTypos)
            return findTypos;
        const ignoreCase = options?.ignoreCase ?? Defaults.ignoreCase;
        if (this.dictTypos.isSuggestedWord(word, ignoreCase))
            return undefined;
        return this.dictTrie?.find(word, options);
    }
    isForbidden(word, ignoreCaseAndAccents = Defaults.isForbiddenIgnoreCaseAndAccents) {
        const findResult = this.find(word, { ignoreCase: ignoreCaseAndAccents });
        return findResult?.forbidden || false;
    }
    isNoSuggestWord(word, options) {
        return this.dictTrie?.isNoSuggestWord(word, options) || this.dictTypos.isNoSuggestWord(word, options);
    }
    suggest(...args) {
        const [word] = args;
        const suggestOptions = (0, SpellingDictionaryMethods_1.suggestArgsToSuggestOptions)(args);
        return this.dictTypos.suggest(word, suggestOptions);
    }
    genSuggestions() {
        return;
    }
    mapWord(word) {
        return word;
    }
    get size() {
        return this.dictTypos.size + (this.dictTrie?.size || 0);
    }
    getErrors() {
        return [];
    }
}
/**
 * Create a dictionary where all words are to be forbidden.
 * @param wordList - list of words
 * @param name
 * @param source
 * @param options
 * @returns SpellingDictionary
 */
function createFlagWordsDictionary(wordList, name, source) {
    const testSpecialCharacters = /[~*+]/;
    const { t: specialWords, f: typoWords } = bisect((0, cspell_trie_lib_1.parseDictionaryLines)(wordList, { stripCaseAndAccents: false }), (line) => testSpecialCharacters.test(line));
    const trieDict = specialWords.size ? buildTrieDict(specialWords, name, source) : undefined;
    const typosDict = (0, TyposDictionary_1.createTyposDictionary)(typoWords, name, source);
    if (!trieDict)
        return typosDict;
    return new FlagWordsDictionary(name, source, typosDict, trieDict);
}
exports.createFlagWordsDictionary = createFlagWordsDictionary;
const regExpCleanIgnore = /^(!!)+/;
function buildTrieDict(words, name, source) {
    const trie = (0, cspell_trie_lib_1.buildTrieFast)((0, sync_1.pipe)(words, (0, sync_1.opMap)((w) => '!' + w), (0, sync_1.opMap)((w) => w.replace(regExpCleanIgnore, ''))));
    return new FlagWordsDictionaryTrie(trie, name, source);
}
function bisect(values, predicate) {
    const t = new Set();
    const f = new Set();
    for (const v of values) {
        if (predicate(v)) {
            t.add(v);
        }
        else {
            f.add(v);
        }
    }
    return { t, f };
}
//# sourceMappingURL=FlagWordsDictionary.js.map
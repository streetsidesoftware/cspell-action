"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCachingDictionary = void 0;
const AutoCache_1 = require("../util/AutoCache");
const SpellingDictionaryMethods_1 = require("./SpellingDictionaryMethods");
let dictionaryCounter = 0;
class CachedDict {
    constructor(dict, options) {
        this.dict = dict;
        this.options = options;
        this.id = ++dictionaryCounter;
        this.has = (0, AutoCache_1.autoCache)((word) => this.dict.has(word, this.options));
        this.isNoSuggestWord = (0, AutoCache_1.autoCache)((word) => this.dict.isNoSuggestWord(word, this.options));
        this.isForbidden = (0, AutoCache_1.autoCache)((word) => this.dict.isForbidden(word));
        this.name = dict.name;
        // console.log(`CachedDict for ${this.name}`);
    }
    stats() {
        return {
            name: this.name,
            id: this.id,
            has: (0, AutoCache_1.extractStats)(this.has),
            isNoSuggestWord: (0, AutoCache_1.extractStats)(this.isNoSuggestWord),
            isForbidden: (0, AutoCache_1.extractStats)(this.isForbidden),
        };
    }
}
const knownDicts = new Map();
/**
 * create a caching dictionary
 * @param dict - Dictionary to cache the search results.
 * @param options - Search options to use.
 * @returns CachingDictionary
 */
function createCachingDictionary(dict, options) {
    options = (0, SpellingDictionaryMethods_1.canonicalSearchOptions)(options);
    let knownOptions = knownDicts.get(options);
    if (!knownOptions) {
        knownOptions = new WeakMap();
        knownDicts.set(options, knownOptions);
    }
    const known = knownOptions.get(dict);
    if (known)
        return known;
    const cached = new CachedDict(dict, options);
    knownOptions.set(dict, cached);
    return cached;
}
exports.createCachingDictionary = createCachingDictionary;
//# sourceMappingURL=CachingDictionary.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTyposDictionary = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const Typos_1 = require("./Typos");
const util_1 = require("./Typos/util");
const symIgnore = Symbol('ignored');
class TyposDictionary {
    constructor(name, source, typosDef, ignoreList) {
        this.name = name;
        this.source = source;
        this.typosDef = typosDef;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.type = 'typos';
        this.isDictionaryCaseSensitive = true;
        this.size = Object.keys(typosDef).length;
        this.ignoreWords = new Set((0, sync_1.pipe)((0, util_1.extractIgnoreValues)(typosDef, '!'), (0, sync_1.opAppend)(ignoreList || [])));
    }
    /**
     * A Forbidden word list does not "have" valid words.
     * Therefore it always returns false.
     * @param _word - the word
     * @param _options - options
     * @returns always false
     */
    has(_word, _options) {
        return false;
    }
    /** A more detailed search for a word, might take longer than `has` */
    find(word, _options) {
        const found = this._findForms(word);
        return typeof found === 'string' ? { found, forbidden: true, noSuggest: false } : undefined;
    }
    _findForms(word) {
        const f = this._find(word);
        if (f !== false)
            return f;
        const lcWord = word.toLowerCase();
        if (lcWord === word)
            return false;
        return this._find(lcWord);
    }
    _find(word) {
        if (this.ignoreWords.has(word))
            return symIgnore;
        if (word in this.typosDef)
            return word;
        return false;
    }
    isForbidden(word) {
        const found = this._findForms(word);
        return typeof found === 'string';
    }
    isNoSuggestWord(_word, _options) {
        return false;
    }
    suggest(word) {
        return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
    }
    _suggest(word) {
        if (this.ignoreWords.has(word))
            return [];
        if (!(word in this.typosDef))
            return undefined;
        const sug = this.typosDef[word];
        if (!sug)
            return [];
        if (typeof sug === 'string') {
            return [
                {
                    word: sug,
                    cost: 1,
                    isPreferred: true,
                },
            ];
        }
        return sug.map((word, index) => ({ word, cost: index + 1 }));
    }
    genSuggestions(collector) {
        const sugs = this.suggest(collector.word);
        sugs.forEach((result) => collector.add(result));
    }
    mapWord(word) {
        return word;
    }
    getErrors() {
        return [];
    }
}
/**
 * Create a dictionary where all words are to be forbidden.
 * @param entries - list of Typos Entries
 * @param name
 * @param source
 * @param options
 * @returns
 */
function createTyposDictionary(entries, name, source) {
    const def = (0, Typos_1.processEntriesToTyposDef)(entries);
    return new TyposDictionary(name, source, def);
}
exports.createTyposDictionary = createTyposDictionary;
//# sourceMappingURL=TyposDictionary.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTyposFile = exports.parseTyposLine = exports.processEntriesToTyposDef = exports.sanitizeIntoTypoDef = exports.createTyposDefFromEntries = void 0;
const assert_1 = __importDefault(require("assert"));
const util_js_1 = require("./util.js");
function assertString(v) {
    (0, assert_1.default)(typeof v === 'string', 'A string was expected.');
    return true;
}
const suggestionsSeparator = /[,]/;
const typoSuggestionsSeparator = /:|->/;
const typoEntrySeparator = /[\n;]/;
const inlineComment = /#.*/gm;
function createTyposDefFromEntries(entries) {
    const def = Object.create(null);
    for (const entry of entries) {
        (0, util_js_1.appendToDef)(def, entry);
    }
    return def;
}
exports.createTyposDefFromEntries = createTyposDefFromEntries;
function normalize(s) {
    return s.normalize();
}
function trimAndFilter(lines) {
    return lines
        .map((s) => s.trim())
        .filter((s) => !!s)
        .map(normalize);
}
function cleanSugs(rawSugs) {
    const sugs = trimAndFilter(rawSugs);
    return sugs.length === 1 ? sugs[0] : sugs.length ? sugs : false;
}
function splitSuggestionsValue(value) {
    return cleanSugs(value.split(suggestionsSeparator));
}
function sanitizeIntoTypoDef(dirtyDef) {
    if (!dirtyDef || typeof dirtyDef !== 'object')
        return undefined;
    const def = (0, util_js_1.createTyposDef)();
    for (const [rawKey, value] of Object.entries(dirtyDef)) {
        const key = normalize(rawKey.trim());
        if (!key)
            continue;
        if (typeof value === 'string') {
            def[key] = splitSuggestionsValue(value);
            continue;
        }
        if (Array.isArray(value)) {
            const sugs = cleanSugs(value.filter(assertString));
            def[key] = sugs;
            continue;
        }
        (0, assert_1.default)(value === false, 'Unexpected suggestion type.');
        def[key] = false;
    }
    return def;
}
exports.sanitizeIntoTypoDef = sanitizeIntoTypoDef;
/**
 * Parse Typos Entries
 *
 * Format:
 * - `word:suggestion`
 * - `word->suggestion`
 * - `word: first, second, third suggestions`
 *
 * Note:
 * ```plaintext
 * yellow:blue, green
 * ```
 * Is the same as multiple entries with the same key and different suggestions.
 * ```plaintext
 * yellow:blue
 * yellow:green
 * ```
 *
 * Used to process entries found in a `cspell.json` file.
 * @param entries - entries to process
 * @returns a TyposDef
 */
function processEntriesToTyposDef(entries) {
    const def = isIterable(entries) ? reduceToTyposDef(entries) : entries;
    const result = sanitizeIntoTypoDef(def);
    (0, assert_1.default)(result);
    return result;
}
exports.processEntriesToTyposDef = processEntriesToTyposDef;
function reduceToTyposDef(entries) {
    const def = (0, util_js_1.createTyposDef)();
    for (const entry of entries) {
        (0, util_js_1.appendToDef)(def, parseTyposLine(entry));
    }
    return def;
}
/**
 * Tries to parse an entry.
 * @param line - any valid TypoEntry.
 * @returns a valid TypoEntry
 */
function parseTyposLine(line) {
    if (!line)
        return undefined;
    if (typeof line === 'string') {
        const def = (0, util_js_1.createTyposDef)();
        for (const subEntry of splitIntoLines(line)) {
            const [left, right] = splitEntry(subEntry);
            const typo = left.trim();
            if (!right)
                return typo;
            const sugs = splitSuggestionsValue(right);
            def[typo] = sugs;
        }
        return def;
    }
    if (Array.isArray(line)) {
        const [key, ...sugs] = line.filter(assertString).map((s) => s.trim());
        if (!key)
            return undefined;
        return [key, ...sugs];
    }
    return sanitizeIntoTypoDef(line);
}
exports.parseTyposLine = parseTyposLine;
function splitIntoLines(content) {
    return trimAndFilter(normalize(content).split(typoEntrySeparator));
}
function splitEntry(line) {
    return line.split(typoSuggestionsSeparator, 2);
}
function parseTyposFile(content) {
    const lines = splitIntoLines(content.replace(inlineComment, ''));
    return reduceToTyposDef(lines);
}
exports.parseTyposFile = parseTyposFile;
function isIterable(v) {
    return Symbol.iterator in v;
}
//# sourceMappingURL=typosParser.js.map
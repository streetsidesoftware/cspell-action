"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testing__ = exports.isSpellingDictionaryCollection = exports.createCollection = void 0;
const cspell_trie_lib_1 = require("cspell-trie-lib");
const gensequence_1 = require("gensequence");
const util_js_1 = require("../util/util.js");
const Defaults = __importStar(require("./defaults.js"));
const SpellingDictionary_js_1 = require("./SpellingDictionary.js");
const SpellingDictionaryMethods_js_1 = require("./SpellingDictionaryMethods.js");
function identityString(w) {
    return w;
}
class SpellingDictionaryCollectionImpl {
    constructor(dictionaries, name, source) {
        this.dictionaries = dictionaries;
        this.name = name;
        this.options = { weightMap: undefined };
        this.mapWord = identityString;
        this.type = 'SpellingDictionaryCollection';
        this._isNoSuggestWord = (word, options) => {
            if (!this.containsNoSuggestWords)
                return false;
            return !!isNoSuggestWordInAnyDictionary(this.dictionaries, word, options || {});
        };
        this.dictionaries = this.dictionaries.sort((a, b) => b.size - a.size);
        this.source = source || dictionaries.map((d) => d.name).join(', ');
        this.isDictionaryCaseSensitive = this.dictionaries.reduce((a, b) => a || b.isDictionaryCaseSensitive, false);
        this.containsNoSuggestWords = this.dictionaries.reduce((a, b) => a || b.containsNoSuggestWords, false);
    }
    has(word, hasOptions) {
        const options = (0, SpellingDictionaryMethods_js_1.hasOptionToSearchOption)(hasOptions);
        return !!isWordInAnyDictionary(this.dictionaries, word, options) && !this.isForbidden(word);
    }
    find(word, hasOptions) {
        const options = (0, SpellingDictionaryMethods_js_1.hasOptionToSearchOption)(hasOptions);
        return findInAnyDictionary(this.dictionaries, word, options);
    }
    isNoSuggestWord(word, options) {
        return this._isNoSuggestWord(word, options);
    }
    isForbidden(word, ignoreCaseAndAccents) {
        const ignoreCase = ignoreCaseAndAccents ?? Defaults.isForbiddenIgnoreCaseAndAccents;
        return !!this._isForbiddenInDict(word, ignoreCase) && !this.isNoSuggestWord(word, { ignoreCase });
    }
    suggest(...args) {
        const [word] = args;
        const suggestOptions = (0, SpellingDictionaryMethods_js_1.suggestArgsToSuggestOptions)(args);
        return this._suggest(word, suggestOptions);
    }
    _suggest(word, suggestOptions) {
        const { numSuggestions = SpellingDictionaryMethods_js_1.defaultNumSuggestions, numChanges, ignoreCase, includeTies, timeout } = suggestOptions;
        const prefixNoCase = cspell_trie_lib_1.CASE_INSENSITIVE_PREFIX;
        const filter = (word, _cost) => {
            return ((ignoreCase || word[0] !== prefixNoCase) &&
                !this.isForbidden(word) &&
                !this.isNoSuggestWord(word, suggestOptions));
        };
        const collectorOptions = {
            numSuggestions,
            filter,
            changeLimit: numChanges,
            includeTies,
            ignoreCase,
            timeout,
        };
        const collector = (0, SpellingDictionaryMethods_js_1.suggestionCollector)(word, collectorOptions);
        this.genSuggestions(collector, suggestOptions);
        return collector.suggestions;
    }
    get size() {
        return this.dictionaries.reduce((a, b) => a + b.size, 0);
    }
    getPreferredSuggestions(word) {
        const sugs = this.dictionaries.flatMap((dict) => dict.getPreferredSuggestions?.(word)).filter(util_js_1.isDefined);
        if (sugs.length <= 1)
            return sugs;
        const unique = new Set();
        return sugs.filter((sug) => {
            if (unique.has(sug.word))
                return false;
            unique.add(sug.word);
            return true;
        });
    }
    genSuggestions(collector, suggestOptions) {
        const _suggestOptions = { ...suggestOptions };
        const { compoundMethod = SpellingDictionary_js_1.CompoundWordsMethod.SEPARATE_WORDS } = suggestOptions;
        _suggestOptions.compoundMethod = this.options.useCompounds ? SpellingDictionary_js_1.CompoundWordsMethod.JOIN_WORDS : compoundMethod;
        this.dictionaries.forEach((dict) => dict.genSuggestions(collector, _suggestOptions));
    }
    getErrors() {
        return this.dictionaries.reduce((errors, dict) => errors.concat(dict.getErrors?.() || []), []);
    }
    _isForbiddenInDict(word, ignoreCase) {
        return isWordForbiddenInAnyDictionary(this.dictionaries, word, ignoreCase);
    }
}
function createCollection(dictionaries, name, source) {
    return new SpellingDictionaryCollectionImpl(dictionaries, name, source);
}
exports.createCollection = createCollection;
function isWordInAnyDictionary(dicts, word, options) {
    return (0, gensequence_1.genSequence)(dicts).first((dict) => dict.has(word, options));
}
function findInAnyDictionary(dicts, word, options) {
    const found = dicts.map((dict) => dict.find(word, options)).filter(util_js_1.isDefined);
    if (!found.length)
        return undefined;
    return found.reduce((a, b) => ({
        found: a.forbidden ? a.found : b.forbidden ? b.found : a.found || b.found,
        forbidden: a.forbidden || b.forbidden,
        noSuggest: a.noSuggest || b.noSuggest,
    }));
}
function isNoSuggestWordInAnyDictionary(dicts, word, options) {
    return (0, gensequence_1.genSequence)(dicts).first((dict) => dict.isNoSuggestWord(word, options));
}
function isWordForbiddenInAnyDictionary(dicts, word, ignoreCase) {
    return (0, gensequence_1.genSequence)(dicts).first((dict) => dict.isForbidden(word, ignoreCase));
}
function isSpellingDictionaryCollection(dict) {
    return dict instanceof SpellingDictionaryCollectionImpl;
}
exports.isSpellingDictionaryCollection = isSpellingDictionaryCollection;
exports.__testing__ = {
    isWordInAnyDictionary,
    isWordForbiddenInAnyDictionary,
};
//# sourceMappingURL=SpellingDictionaryCollection.js.map
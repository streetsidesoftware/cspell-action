"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTyposDictionary = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const AutoResolve_js_1 = require("../util/AutoResolve.js");
const textMappers_js_1 = require("../util/textMappers.js");
const defaults = __importStar(require("./defaults.js"));
const index_js_1 = require("./Typos/index.js");
const util_js_1 = require("./Typos/util.js");
class TyposDictionaryImpl {
    constructor(name, source, typosDef, ignoreList) {
        this.name = name;
        this.source = source;
        this.typosDef = typosDef;
        this.options = {};
        this.type = 'typos';
        this.isDictionaryCaseSensitive = true;
        this.size = Object.keys(typosDef).length;
        this.explicitIgnoreWords = (0, util_js_1.extractIgnoreValues)(typosDef, '!');
        this.suggestions = (0, util_js_1.extractAllSuggestions)(typosDef);
        this.ignoreWords = new Set((0, sync_1.pipe)(this.explicitIgnoreWords, (0, sync_1.opAppend)(ignoreList || [])));
        this.suggestionsLower = new Set((0, sync_1.pipe)(this.suggestions, textMappers_js_1.mapperRemoveCaseAndAccents));
        this.containsNoSuggestWords = this.ignoreWords.size > 0;
    }
    /**
     * A Forbidden word list does not "have" valid words.
     * Therefore it always returns false.
     * @param _word - the word
     * @param _options - options
     * @returns always false
     */
    has(_word, _options) {
        return false;
    }
    /** A more detailed search for a word, might take longer than `has` */
    find(word, options) {
        const result = this._findForms(word, options?.ignoreCase ?? defaults.ignoreCase);
        if (result === false)
            return undefined;
        const { found, ignore } = result;
        return { found, forbidden: !ignore, noSuggest: ignore };
    }
    _findForms(word, ignoreCaseAndAccents) {
        const lcWord = word.toLowerCase();
        if (this.ignoreWords.has(word)) {
            return { found: word, ignore: true };
        }
        if (this.suggestions.has(word)) {
            return false;
        }
        if (ignoreCaseAndAccents) {
            if (this.suggestionsLower.has(lcWord)) {
                return false;
            }
            if (this.ignoreWords.has(lcWord)) {
                return { found: lcWord, ignore: true };
            }
        }
        if (word in this.typosDef)
            return { found: word, ignore: false };
        if (lcWord in this.typosDef)
            return { found: lcWord, ignore: false };
        return false;
    }
    isForbidden(word, ignoreCaseAndAccents = defaults.isForbiddenIgnoreCaseAndAccents) {
        const found = this._findForms(word, ignoreCaseAndAccents);
        return found !== false && !found.ignore;
    }
    isNoSuggestWord(word, options) {
        const result = this.find(word, options);
        return result?.noSuggest ?? false;
    }
    /**
     * Determine if the word can appear in a list of suggestions.
     * @param word - word
     * @param ignoreCaseAndAccents - ignore case.
     * @returns true if a word is suggested, otherwise false.
     */
    isSuggestedWord(word, ignoreCaseAndAccents = defaults.isForbiddenIgnoreCaseAndAccents) {
        if (this.suggestions.has(word))
            return true;
        const lcWord = word.toLowerCase();
        return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
    }
    suggest(word) {
        return this.getPreferredSuggestions(word);
    }
    _suggest(word) {
        if (this.ignoreWords.has(word))
            return [];
        if (!(word in this.typosDef))
            return undefined;
        const sug = this.typosDef[word];
        const isPreferred = true;
        if (!sug)
            return [];
        if (typeof sug === 'string') {
            return [
                {
                    word: sug,
                    cost: 1,
                    isPreferred,
                },
            ];
        }
        return sug.map((word, index) => ({ word, cost: index + 1, isPreferred }));
    }
    genSuggestions(collector) {
        const sugs = this.suggest(collector.word);
        sugs.forEach((result) => collector.add(result));
    }
    getPreferredSuggestions(word) {
        return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
    }
    mapWord(word) {
        return word;
    }
    getErrors() {
        return [];
    }
}
const createCache = (0, AutoResolve_js_1.createAutoResolveWeakCache)();
/**
 * Create a dictionary where all words are to be forbidden.
 * @param entries - list of Typos Entries
 * @param name - name of dictionary
 * @param source - source
 * @returns
 */
function createTyposDictionary(entries, name, source) {
    return createCache.get(entries, () => {
        const def = (0, index_js_1.processEntriesToTyposDef)(entries);
        return new TyposDictionaryImpl(name, source, def);
    });
}
exports.createTyposDictionary = createTyposDictionary;
//# sourceMappingURL=TyposDictionary.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIgnoreWordsDictionary = void 0;
const sync_1 = require("@cspell/cspell-pipe/sync");
const cspell_trie_lib_1 = require("cspell-trie-lib");
const AutoResolve_js_1 = require("../util/AutoResolve.js");
const createSpellingDictionary_js_1 = require("./createSpellingDictionary.js");
const Defaults = __importStar(require("./defaults.js"));
const NormalizeForm = 'NFC';
class IgnoreWordsDictionary {
    constructor(name, source, words) {
        this.name = name;
        this.source = source;
        this.containsNoSuggestWords = true;
        this.options = {};
        this.type = 'ignore';
        this.isDictionaryCaseSensitive = true;
        this.dict = new Set(words);
        this.dictNonStrict = new Set((0, sync_1.pipe)(this.dict, (0, sync_1.opFilter)((w) => w.startsWith('~')), (0, sync_1.opMap)((w) => w.slice(1))));
    }
    /**
     * A Forbidden word list does not "have" valid words.
     * Therefore it always returns false.
     * @param _word - the word
     * @param _options - options
     * @returns always false
     */
    has(word, options) {
        const nWord = word.normalize(NormalizeForm);
        if (this.dict.has(nWord))
            return true;
        const lcWord = nWord.toLowerCase();
        if (this.dict.has(lcWord))
            return true;
        const ignoreCase = options?.ignoreCase ?? Defaults.ignoreCase;
        return ignoreCase && (this.dictNonStrict.has(nWord) || this.dictNonStrict.has(lcWord));
    }
    /** A more detailed search for a word, might take longer than `has` */
    find(word, options) {
        const nWord = word.normalize(NormalizeForm);
        if (this.dict.has(nWord))
            return { found: nWord, forbidden: false, noSuggest: true };
        const lcWord = nWord.toLowerCase();
        if (this.dict.has(lcWord))
            return { found: lcWord, forbidden: false, noSuggest: true };
        const ignoreCase = options?.ignoreCase ?? Defaults.ignoreCase;
        if (!ignoreCase)
            return undefined;
        if (this.dictNonStrict.has(nWord))
            return { found: nWord, forbidden: false, noSuggest: true };
        return (this.dictNonStrict.has(lcWord) && { found: lcWord, forbidden: false, noSuggest: true }) || undefined;
    }
    isForbidden(_word, _ignoreCase) {
        return false;
    }
    isNoSuggestWord(word, options) {
        return this.has(word, options);
    }
    suggest() {
        return [];
    }
    genSuggestions() {
        return;
    }
    mapWord(word) {
        return word;
    }
    get size() {
        return this.dict.size;
    }
    getErrors() {
        return [];
    }
}
const createCache = (0, AutoResolve_js_1.createAutoResolveWeakCache)();
/**
 * Create a dictionary where all words are to be ignored.
 * Ignored words override forbidden words.
 * @param wordList - list of words
 * @param name - name of dictionary
 * @param source - dictionary source
 * @returns
 */
function createIgnoreWordsDictionary(wordList, name, source) {
    return createCache.get(wordList, () => {
        const testSpecialCharacters = /[*+]/;
        const words = [...(0, cspell_trie_lib_1.parseDictionaryLines)(wordList, { stripCaseAndAccents: true })].map((w) => w.normalize(NormalizeForm));
        const hasSpecial = words.findIndex((word) => testSpecialCharacters.test(word)) >= 0;
        if (hasSpecial) {
            return (0, createSpellingDictionary_js_1.createSpellingDictionary)(words, name, source, {
                caseSensitive: true,
                noSuggest: true,
                weightMap: undefined,
                supportNonStrictSearches: true,
            });
        }
        return new IgnoreWordsDictionary(name, source, words);
    });
}
exports.createIgnoreWordsDictionary = createIgnoreWordsDictionary;
//# sourceMappingURL=IgnoreWordsDictionary.js.map
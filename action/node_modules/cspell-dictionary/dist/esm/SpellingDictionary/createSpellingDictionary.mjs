import { buildTrieFast, parseDictionaryLines } from 'cspell-trie-lib';
import { deepEqual } from 'fast-equals';
import { AutoWeakCache, SimpleCache } from '../util/simpleCache.mjs';
import { defaultOptions } from './SpellingDictionary.mjs';
import { SpellingDictionaryFromTrie } from './SpellingDictionaryFromTrie.mjs';
import { createWeightMapFromDictionaryInformation } from './SpellingDictionaryMethods.mjs';
const cachedDictionaries = new AutoWeakCache(_createSpellingDictionary, 64);
const maxSetSize = 3;
const cachedParamsByWordList = new SimpleCache(64);
/**
 * Create a SpellingDictionary
 * @param wordList - list of words
 * @param name - name of dictionary
 * @param source - filename or uri
 * @param options - dictionary options
 * @returns a Spelling Dictionary
 */
export function createSpellingDictionary(wordList, name, source, options) {
    const params = [wordList, name, source, options];
    if (!Array.isArray(wordList)) {
        return _createSpellingDictionary(params);
    }
    const cached = cachedParamsByWordList.get(name) || new Set();
    for (const cachedParams of cached) {
        if (deepEqual(params, cachedParams)) {
            return cachedDictionaries.get(cachedParams);
        }
    }
    if (cached.size > maxSetSize)
        cached.clear();
    cached.add(params);
    cachedParamsByWordList.set(name, cached);
    return cachedDictionaries.get(params);
}
function _createSpellingDictionary(params) {
    const [wordList, name, source, options] = params;
    // console.log(`createSpellingDictionary ${name} ${source}`);
    const parseOptions = { stripCaseAndAccents: options?.supportNonStrictSearches ?? true };
    const words = parseDictionaryLines(wordList, parseOptions);
    const trie = buildTrieFast(words);
    const opts = { ...(options || defaultOptions) };
    if (opts.weightMap === undefined && opts.dictionaryInformation) {
        opts.weightMap = createWeightMapFromDictionaryInformation(opts.dictionaryInformation);
    }
    return new SpellingDictionaryFromTrie(trie, name, opts, source);
}
export function createFailedToLoadDictionary(name, source, error, options) {
    options = options || {};
    return {
        name,
        source,
        type: 'error',
        containsNoSuggestWords: false,
        has: () => false,
        find: () => undefined,
        isNoSuggestWord: () => false,
        isForbidden: () => false,
        suggest: () => [],
        mapWord: (a) => a,
        genSuggestions: () => {
            return;
        },
        size: 0,
        options,
        isDictionaryCaseSensitive: false,
        getErrors: () => [error],
    };
}

import { autoCache, extractStats } from '../util/AutoCache.mjs';
import { canonicalSearchOptions } from './SpellingDictionaryMethods.mjs';
let dictionaryCounter = 0;
const DefaultAutoCacheSize = 1000;
class CachedDict {
    constructor(dict, options) {
        this.dict = dict;
        this.options = options;
        this.id = ++dictionaryCounter;
        this.has = autoCache((word) => this.dict.has(word, this.options), DefaultAutoCacheSize);
        this.isNoSuggestWord = autoCache((word) => this.dict.isNoSuggestWord(word, this.options), DefaultAutoCacheSize);
        this.isForbidden = autoCache((word) => this.dict.isForbidden(word), DefaultAutoCacheSize);
        this.getPreferredSuggestions = autoCache((word) => this.dict.getPreferredSuggestions?.(word), DefaultAutoCacheSize);
        this.name = dict.name;
        // console.log(`CachedDict for ${this.name}`);
    }
    stats() {
        return {
            name: this.name,
            id: this.id,
            has: extractStats(this.has),
            isNoSuggestWord: extractStats(this.isNoSuggestWord),
            isForbidden: extractStats(this.isForbidden),
            getPreferredSuggestions: extractStats(this.getPreferredSuggestions),
        };
    }
}
const knownDicts = new Map();
/**
 * create a caching dictionary
 * @param dict - Dictionary to cache the search results.
 * @param options - Search options to use.
 * @returns CachingDictionary
 */
export function createCachingDictionary(dict, options) {
    options = canonicalSearchOptions(options);
    let knownOptions = knownDicts.get(options);
    if (!knownOptions) {
        knownOptions = new WeakMap();
        knownDicts.set(options, knownOptions);
    }
    const known = knownOptions.get(dict);
    if (known)
        return known;
    const cached = new CachedDict(dict, options);
    knownOptions.set(dict, cached);
    return cached;
}

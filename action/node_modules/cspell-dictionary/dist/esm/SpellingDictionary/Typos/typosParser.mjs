import assert from 'assert';
import { appendToDef, createTyposDef } from './util.mjs';
function assertString(v) {
    assert(typeof v === 'string', 'A string was expected.');
    return true;
}
const suggestionsSeparator = /[,]/;
const typoSuggestionsSeparator = /:|->/;
const typoEntrySeparator = /[\n;]/;
const inlineComment = /#.*/gm;
export function createTyposDefFromEntries(entries) {
    const def = Object.create(null);
    for (const entry of entries) {
        appendToDef(def, entry);
    }
    return def;
}
function normalize(s) {
    return s.normalize();
}
function trimAndFilter(lines) {
    return lines
        .map((s) => s.trim())
        .filter((s) => !!s)
        .map(normalize);
}
function cleanSugs(rawSugs) {
    const sugs = trimAndFilter(rawSugs);
    return sugs.length === 1 ? sugs[0] : sugs.length ? sugs : false;
}
function splitSuggestionsValue(value) {
    return cleanSugs(value.split(suggestionsSeparator));
}
export function sanitizeIntoTypoDef(dirtyDef) {
    if (!dirtyDef || typeof dirtyDef !== 'object')
        return undefined;
    const def = createTyposDef();
    for (const [rawKey, value] of Object.entries(dirtyDef)) {
        const key = normalize(rawKey.trim());
        if (!key)
            continue;
        if (typeof value === 'string') {
            def[key] = splitSuggestionsValue(value);
            continue;
        }
        if (Array.isArray(value)) {
            const sugs = cleanSugs(value.filter(assertString));
            def[key] = sugs;
            continue;
        }
        assert(value === false, 'Unexpected suggestion type.');
        def[key] = false;
    }
    return def;
}
/**
 * Parse Typos Entries
 *
 * Format:
 * - `word:suggestion`
 * - `word->suggestion`
 * - `word: first, second, third suggestions`
 *
 * Note:
 * ```plaintext
 * yellow:blue, green
 * ```
 * Is the same as multiple entries with the same key and different suggestions.
 * ```plaintext
 * yellow:blue
 * yellow:green
 * ```
 *
 * Used to process entries found in a `cspell.json` file.
 * @param entries - entries to process
 * @returns a TyposDef
 */
export function processEntriesToTyposDef(entries) {
    const def = isIterable(entries) ? reduceToTyposDef(entries) : entries;
    const result = sanitizeIntoTypoDef(def);
    assert(result);
    return result;
}
function reduceToTyposDef(entries) {
    const def = createTyposDef();
    for (const entry of entries) {
        appendToDef(def, parseTyposLine(entry));
    }
    return def;
}
/**
 * Tries to parse an entry.
 * @param line - any valid TypoEntry.
 * @returns a valid TypoEntry
 */
export function parseTyposLine(line) {
    if (!line)
        return undefined;
    if (typeof line === 'string') {
        const def = createTyposDef();
        for (const subEntry of splitIntoLines(line)) {
            const [left, right] = splitEntry(subEntry);
            const typo = left.trim();
            if (!right)
                return typo;
            const sugs = splitSuggestionsValue(right);
            def[typo] = sugs;
        }
        return def;
    }
    if (Array.isArray(line)) {
        const [key, ...sugs] = line.filter(assertString).map((s) => s.trim());
        if (!key)
            return undefined;
        return [key, ...sugs];
    }
    return sanitizeIntoTypoDef(line);
}
function splitIntoLines(content) {
    return trimAndFilter(normalize(content).split(typoEntrySeparator));
}
function splitEntry(line) {
    return line.split(typoSuggestionsSeparator, 2);
}
export function parseTyposFile(content) {
    const lines = splitIntoLines(content.replace(inlineComment, ''));
    return reduceToTyposDef(lines);
}
function isIterable(v) {
    return Symbol.iterator in v;
}

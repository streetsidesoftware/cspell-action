"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterableToStream = void 0;
const stream = require("stream");
function iterableToStream(src, options = { encoding: 'utf8' }) {
    var _a, _b;
    const useNode = ((_a = options._useNode) !== null && _a !== void 0 ? _a : true) && !!stream.Readable.from;
    const objectMode = (_b = options.objectMode) !== null && _b !== void 0 ? _b : useNode;
    const filterFn = objectMode ? filterNullOrUndefined : filterEmptyStringOrBuffer;
    const iter = options.removeEmpty ? filterFn(src) : src;
    if (useNode) {
        return stream.Readable.from(iter, options);
    }
    return new ReadableObservableStream(iter, options);
}
exports.iterableToStream = iterableToStream;
class ReadableObservableStream extends stream.Readable {
    constructor(_source, options) {
        super(options);
        this._source = _source;
    }
    _read() {
        if (!this.iter) {
            this.iter = this._source[Symbol.iterator]();
        }
        let r = this.iter.next();
        while (!r.done && this.push(r.value)) {
            r = this.iter.next();
        }
        if (r.done) {
            // since it is possible for r.value to have something meaningful, we must check.
            if (r.value) {
                this.push(r.value);
            }
            this.push(null);
        }
    }
}
function* filterEmptyStringOrBuffer(src) {
    for (const v of src) {
        if (v === undefined || v === null || (typeof v === 'string' && v === '') || (Buffer.isBuffer(v) && v.byteLength === 0)) {
            continue;
        }
        yield v;
    }
}
function* filterNullOrUndefined(src) {
    for (const v of src) {
        if (v === undefined || v === null) {
            continue;
        }
        yield v;
    }
}
exports.default = iterableToStream;
//# sourceMappingURL=iterableToStream.js.map
'use strict';

function* iteratorToIterable(iterator) {
    let n;
    while (!(n = iterator.next()).done) {
        yield n.value;
    }
}
async function* asyncIteratorToAsyncIterable(iterator) {
    let n;
    while (!(n = await iterator.next()).done) {
        yield n.value;
    }
}

function toPipeFn(syncFn, asyncFn) {
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}
function isAsyncIterable(i) {
    return typeof i[Symbol.asyncIterator] === 'function';
}

function toArray(i) {
    return isAsyncIterable(i) ? toArrayAsync(i) : toArraySync(i);
}
function toArraySync(iter) {
    return [...iter];
}
async function toArrayAsync(iter) {
    const collection = [];
    for await (const i of iter) {
        collection.push(i);
    }
    return collection;
}

/**
 * Append values onto the end of an iterable.
 * @param iterablesToAppend - the iterables in the order to be appended.
 * @returns
 */
function opAppendAsync(...iterablesToAppend) {
    async function* fn(iter) {
        yield* iter;
        for (const i of iterablesToAppend) {
            yield* i;
        }
    }
    return fn;
}
/**
 * Append values onto the end of an iterable.
 * @param iterablesToAppend - the iterables in the order to be appended.
 * @returns
 */
function opAppendSync(...iterablesToAppend) {
    function* fn(iter) {
        yield* iter;
        for (const i of iterablesToAppend) {
            yield* i;
        }
    }
    return fn;
}
function opAppend(...iterablesToAppend) {
    function _(i) {
        return isAsyncIterable(i) ? opAppendAsync(...iterablesToAppend)(i) : opAppendSync(...iterablesToAppend)(i);
    }
    return _;
}

async function* _asyncAwait(iter) {
    for await (const v of iter) {
        yield v;
    }
}
function opAwaitAsync() {
    return _asyncAwait;
}

function opCombineAsync(...fns) {
    function combine(iter) {
        for (const fn of fns) {
            iter = fn(iter);
        }
        return iter;
    }
    return combine;
}
function opCombineSync(...fns) {
    function combine(iter) {
        for (const fn of fns) {
            iter = fn(iter);
        }
        return iter;
    }
    return combine;
}

function opConcatMapAsync(mapFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            yield* mapFn(v);
        }
    }
    return fn;
}
function opConcatMapSync(mapFn) {
    function* fn(iter) {
        for (const v of iter) {
            yield* mapFn(v);
        }
    }
    return fn;
}
const opConcatMap = (fn) => toPipeFn(opConcatMapSync(fn), opConcatMapAsync(fn));

// prettier-ignore
function opFilterAsync(filterFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            const pass = await filterFn(v);
            if (pass)
                yield v;
        }
    }
    return fn;
}
function opFilterSync(filterFn) {
    function* fn(iter) {
        for (const v of iter) {
            if (filterFn(v))
                yield v;
        }
    }
    return fn;
}
function opFilter(fn) {
    const asyncFn = opFilterAsync(fn);
    const syncFn = opFilterSync(fn);
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}

// prettier-ignore
function opFirstAsync(firstFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            const pass = await firstFn(v);
            if (pass) {
                yield v;
                break;
            }
        }
    }
    return fn;
}
function opFirstSync(firstFn) {
    function* fn(iter) {
        for (const v of iter) {
            if (firstFn(v)) {
                yield v;
                break;
            }
        }
    }
    return fn;
}
function opFirst(fn) {
    const asyncFn = opFirstAsync(fn);
    const syncFn = opFirstSync(fn);
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}

function opFlattenAsync() {
    async function* fn(iter) {
        for await (const v of iter) {
            yield* v;
        }
    }
    return fn;
}
function opFlattenSync() {
    function* fn(iter) {
        for (const v of iter) {
            yield* v;
        }
    }
    return fn;
}
const opFlatten = () => toPipeFn(opFlattenSync(), opFlattenAsync());

function opJoinStringsAsync(joinCharacter = ',') {
    async function* fn(iter) {
        for await (const v of iter) {
            const a = await toArray(v);
            yield a.join(joinCharacter);
        }
    }
    return fn;
}
function opJoinStringsSync(joinCharacter = ',') {
    function* fn(iter) {
        for (const v of iter) {
            const a = toArray(v);
            yield a.join(joinCharacter);
        }
    }
    return fn;
}
const opJoinStrings = (joinCharacter) => toPipeFn(opJoinStringsSync(joinCharacter), opJoinStringsAsync(joinCharacter));

const symNotFound = Symbol('LastNotFound');
// prettier-ignore
function opLastAsync(lastFn) {
    async function* fn(iter) {
        let last = symNotFound;
        for await (const v of iter) {
            const pass = await lastFn(v);
            if (pass) {
                last = v;
            }
        }
        if (last !== symNotFound)
            yield last;
    }
    return fn;
}
function opLastSync(lastFn) {
    function* fn(iter) {
        let last = symNotFound;
        for (const v of iter) {
            if (lastFn(v)) {
                last = v;
            }
        }
        if (last !== symNotFound)
            yield last;
    }
    return fn;
}
function opLast(fn) {
    const asyncFn = opLastAsync(fn);
    const syncFn = opLastSync(fn);
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}

function opMapAsync(mapFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            yield mapFn(v);
        }
    }
    return fn;
}
function opMapSync(mapFn) {
    function* fn(iter) {
        for (const v of iter) {
            yield mapFn(v);
        }
    }
    return fn;
}
const opMap = (fn) => toPipeFn(opMapSync(fn), opMapAsync(fn));

function opReduceAsync(reduceFn, initialValue) {
    async function* reduce(head, tail) {
        for await (const v of tail) {
            head = reduceFn(head, v);
        }
        yield head;
    }
    async function* fn(iter) {
        const ht = initialValue === undefined ? await headTailAsync(iter) : { head: await initialValue, tail: iter };
        if (!ht)
            return;
        yield* reduce(ht.head, ht.tail);
    }
    return fn;
}
function opReduceSync(reduceFn, initialValue) {
    function* reduce(head, tail) {
        for (const v of tail) {
            head = reduceFn(head, v);
        }
        yield head;
    }
    function* fn(iter) {
        const ht = initialValue === undefined ? headTail(iter) : { head: initialValue, tail: iter };
        if (!ht)
            return;
        yield* reduce(ht.head, ht.tail);
    }
    return fn;
}
function headTail(iter) {
    const iterator = iter[Symbol.iterator]();
    const first = iterator.next();
    if (first.done)
        return undefined;
    return { head: first.value, tail: iteratorToIterable(iterator) };
}
async function headTailAsync(iter) {
    const iterator = isIterable(iter) ? iter[Symbol.iterator]() : iter[Symbol.asyncIterator]();
    const first = await iterator.next();
    if (first.done)
        return undefined;
    return { head: first.value, tail: asyncIteratorToAsyncIterable(iterator) };
}
function isIterable(i) {
    return typeof i[Symbol.iterator] === 'function';
}

function opSkipAsync(count) {
    async function* fn(iter) {
        for await (const v of iter) {
            if (count > 0) {
                --count;
                continue;
            }
            yield v;
        }
    }
    return fn;
}
function opSkipSync(count) {
    function* fn(iter) {
        for (const v of iter) {
            if (count > 0) {
                --count;
                continue;
            }
            yield v;
        }
    }
    return fn;
}
const opSkip = (count) => toPipeFn(opSkipSync(count), opSkipAsync(count));

function opTakeAsync(count) {
    async function* fn(iter) {
        if (count <= 0)
            return;
        for await (const v of iter) {
            yield v;
            if (--count <= 0)
                return;
        }
    }
    return fn;
}
function opTakeSync(count) {
    function* fn(iter) {
        if (count <= 0)
            return;
        for (const v of iter) {
            yield v;
            if (--count <= 0)
                return;
        }
    }
    return fn;
}
/**
 * Consume only the first `count` number from the iterable.
 * @param count - number to take
 */
const opTake = (count) => toPipeFn(opTakeSync(count), opTakeAsync(count));

/**
 * Tap allows you to listen on values, without modifying them.
 *
 * @param fn - function to call for each value.
 */
function opTapAsync(tapFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            tapFn(v);
            yield v;
        }
    }
    return fn;
}
/**
 * Tap allows you to listen on values, without modifying them.
 *
 * @param fn - function to call for each value.
 */
function opTapSync(tapFn) {
    function* fn(iter) {
        for (const v of iter) {
            tapFn(v);
            yield v;
        }
    }
    return fn;
}
/**
 * Tap allows you to listen on values, without modifying them.
 *
 * @param fn - function to call for each value.
 */
const opTap = (fn) => toPipeFn(opTapSync(fn), opTapAsync(fn));

function opUniqueAsync(k) {
    function fnK(k) {
        async function* fn(iter) {
            const s = new Set();
            for await (const v of iter) {
                const kk = k(v);
                if (s.has(kk))
                    continue;
                s.add(kk);
                yield v;
            }
        }
        return fn;
    }
    async function* fn(iter) {
        const s = new Set();
        for await (const v of iter) {
            if (s.has(v))
                continue;
            s.add(v);
            yield v;
        }
    }
    return k ? fnK(k) : fn;
}
function opUniqueSync(k) {
    function fnK(key) {
        function* fn(iter) {
            const s = new Set();
            for (const v of iter) {
                const kk = key(v);
                if (s.has(kk))
                    continue;
                s.add(kk);
                yield v;
            }
        }
        return fn;
    }
    function* fn(iter) {
        const s = new Set();
        for (const v of iter) {
            if (s.has(v))
                continue;
            s.add(v);
            yield v;
        }
    }
    return k ? fnK(k) : fn;
}
const opUnique = (getKey) => toPipeFn(opUniqueSync(getKey), opUniqueAsync(getKey));

exports.opAppend = opAppend;
exports.opAppendAsync = opAppendAsync;
exports.opAppendSync = opAppendSync;
exports.opAwaitAsync = opAwaitAsync;
exports.opCombineAsync = opCombineAsync;
exports.opCombineSync = opCombineSync;
exports.opConcatMap = opConcatMap;
exports.opConcatMapAsync = opConcatMapAsync;
exports.opConcatMapSync = opConcatMapSync;
exports.opFilter = opFilter;
exports.opFilterAsync = opFilterAsync;
exports.opFilterSync = opFilterSync;
exports.opFirst = opFirst;
exports.opFirstAsync = opFirstAsync;
exports.opFirstSync = opFirstSync;
exports.opFlatten = opFlatten;
exports.opFlattenAsync = opFlattenAsync;
exports.opFlattenSync = opFlattenSync;
exports.opJoinStrings = opJoinStrings;
exports.opJoinStringsAsync = opJoinStringsAsync;
exports.opJoinStringsSync = opJoinStringsSync;
exports.opLast = opLast;
exports.opLastAsync = opLastAsync;
exports.opLastSync = opLastSync;
exports.opMap = opMap;
exports.opMapAsync = opMapAsync;
exports.opMapSync = opMapSync;
exports.opReduceAsync = opReduceAsync;
exports.opReduceSync = opReduceSync;
exports.opSkip = opSkip;
exports.opSkipAsync = opSkipAsync;
exports.opSkipSync = opSkipSync;
exports.opTake = opTake;
exports.opTakeAsync = opTakeAsync;
exports.opTakeSync = opTakeSync;
exports.opTap = opTap;
exports.opTapAsync = opTapAsync;
exports.opTapSync = opTapSync;
exports.opUnique = opUnique;
exports.opUniqueAsync = opUniqueAsync;
exports.opUniqueSync = opUniqueSync;

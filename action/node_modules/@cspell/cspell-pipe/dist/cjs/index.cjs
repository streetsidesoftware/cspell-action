'use strict';

/**
 * Allows an iterable to be shared by multiple consumers.
 * Each consumer takes from the iterable.
 * @param iterable - the iterable to share
 */
function toDistributableIterableSync(iterable) {
    let lastValue;
    let iter;
    function getNext() {
        if (lastValue && lastValue.done) {
            return { ...lastValue };
        }
        iter = iter || iterable[Symbol.iterator]();
        lastValue = iter.next();
        return lastValue;
    }
    function* iterableFn() {
        let next;
        while (!(next = getNext()).done) {
            yield next.value;
        }
    }
    return {
        [Symbol.iterator]: iterableFn,
    };
}
/**
 * Allows an iterable to be shared by multiple consumers.
 * Each consumer takes from the iterable.
 * @param iterable - the iterable to share
 */
const toDistributableIterable = toDistributableIterableSync;

function* interleave(a, b) {
    const ai = a[Symbol.iterator]();
    const bi = b[Symbol.iterator]();
    for (let aNext = ai.next(); !aNext.done; aNext = ai.next()) {
        yield aNext.value;
        const bNext = bi.next();
        if (bNext.done)
            break;
        yield bNext.value;
    }
    for (let aNext = ai.next(); !aNext.done; aNext = ai.next()) {
        yield aNext.value;
    }
    for (let bNext = bi.next(); !bNext.done; bNext = bi.next()) {
        yield bNext.value;
    }
}

function* iteratorToIterable(iterator) {
    let n;
    while (!(n = iterator.next()).done) {
        yield n.value;
    }
}
async function* asyncIteratorToAsyncIterable(iterator) {
    let n;
    while (!(n = await iterator.next()).done) {
        yield n.value;
    }
}

function toPipeFn(syncFn, asyncFn) {
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}
function isAsyncIterable(i) {
    return typeof i[Symbol.asyncIterator] === 'function';
}

function toArray(i) {
    return isAsyncIterable(i) ? toArrayAsync(i) : toArraySync(i);
}
function toArraySync(iter) {
    return [...iter];
}
async function toArrayAsync(iter) {
    const collection = [];
    for await (const i of iter) {
        collection.push(i);
    }
    return collection;
}

/**
 * Merge multiple iterables into an AsyncIterable
 * @param iter - initial iterable.
 * @param rest - iterables to merge.
 */
async function* mergeAsyncIterables(iter, ...rest) {
    for await (const i of [iter, ...rest]) {
        yield* i;
    }
}
/**
 * Convert one or more iterables to an AsyncIterable
 */
const toAsyncIterable = mergeAsyncIterables;

var _helpers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    asyncIteratorToAsyncIterable: asyncIteratorToAsyncIterable,
    interleave: interleave,
    isAsyncIterable: isAsyncIterable,
    iteratorToIterable: iteratorToIterable,
    toArray: toArray,
    toAsyncIterable: toAsyncIterable,
    toDistributableIterable: toDistributableIterable
});

/**
 * Append values onto the end of an iterable.
 * @param iterablesToAppend - the iterables in the order to be appended.
 * @returns
 */
function opAppendAsync(...iterablesToAppend) {
    async function* fn(iter) {
        yield* iter;
        for (const i of iterablesToAppend) {
            yield* i;
        }
    }
    return fn;
}
/**
 * Append values onto the end of an iterable.
 * @param iterablesToAppend - the iterables in the order to be appended.
 * @returns
 */
function opAppendSync(...iterablesToAppend) {
    function* fn(iter) {
        yield* iter;
        for (const i of iterablesToAppend) {
            yield* i;
        }
    }
    return fn;
}
function opAppend(...iterablesToAppend) {
    function _(i) {
        return isAsyncIterable(i) ? opAppendAsync(...iterablesToAppend)(i) : opAppendSync(...iterablesToAppend)(i);
    }
    return _;
}

async function* _asyncAwait(iter) {
    for await (const v of iter) {
        yield v;
    }
}
function opAwaitAsync() {
    return _asyncAwait;
}

function opCombineAsync(...fns) {
    function combine(iter) {
        for (const fn of fns) {
            iter = fn(iter);
        }
        return iter;
    }
    return combine;
}
function opCombineSync(...fns) {
    function combine(iter) {
        for (const fn of fns) {
            iter = fn(iter);
        }
        return iter;
    }
    return combine;
}

function opConcatMapAsync(mapFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            yield* mapFn(v);
        }
    }
    return fn;
}
function opConcatMapSync(mapFn) {
    function* fn(iter) {
        for (const v of iter) {
            yield* mapFn(v);
        }
    }
    return fn;
}
const opConcatMap = (fn) => toPipeFn(opConcatMapSync(fn), opConcatMapAsync(fn));

// prettier-ignore
function opFilterAsync(filterFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            const pass = await filterFn(v);
            if (pass)
                yield v;
        }
    }
    return fn;
}
function opFilterSync(filterFn) {
    function* fn(iter) {
        for (const v of iter) {
            if (filterFn(v))
                yield v;
        }
    }
    return fn;
}
function opFilter(fn) {
    const asyncFn = opFilterAsync(fn);
    const syncFn = opFilterSync(fn);
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}

// prettier-ignore
function opFirstAsync(firstFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            const pass = await firstFn(v);
            if (pass) {
                yield v;
                break;
            }
        }
    }
    return fn;
}
function opFirstSync(firstFn) {
    function* fn(iter) {
        for (const v of iter) {
            if (firstFn(v)) {
                yield v;
                break;
            }
        }
    }
    return fn;
}
function opFirst(fn) {
    const asyncFn = opFirstAsync(fn);
    const syncFn = opFirstSync(fn);
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}

function opFlattenAsync() {
    async function* fn(iter) {
        for await (const v of iter) {
            yield* v;
        }
    }
    return fn;
}
function opFlattenSync() {
    function* fn(iter) {
        for (const v of iter) {
            yield* v;
        }
    }
    return fn;
}
const opFlatten = () => toPipeFn(opFlattenSync(), opFlattenAsync());

function opJoinStringsAsync(joinCharacter = ',') {
    async function* fn(iter) {
        for await (const v of iter) {
            const a = await toArray(v);
            yield a.join(joinCharacter);
        }
    }
    return fn;
}
function opJoinStringsSync(joinCharacter = ',') {
    function* fn(iter) {
        for (const v of iter) {
            const a = toArray(v);
            yield a.join(joinCharacter);
        }
    }
    return fn;
}
const opJoinStrings = (joinCharacter) => toPipeFn(opJoinStringsSync(joinCharacter), opJoinStringsAsync(joinCharacter));

const symNotFound = Symbol('LastNotFound');
// prettier-ignore
function opLastAsync(lastFn) {
    async function* fn(iter) {
        let last = symNotFound;
        for await (const v of iter) {
            const pass = await lastFn(v);
            if (pass) {
                last = v;
            }
        }
        if (last !== symNotFound)
            yield last;
    }
    return fn;
}
function opLastSync(lastFn) {
    function* fn(iter) {
        let last = symNotFound;
        for (const v of iter) {
            if (lastFn(v)) {
                last = v;
            }
        }
        if (last !== symNotFound)
            yield last;
    }
    return fn;
}
function opLast(fn) {
    const asyncFn = opLastAsync(fn);
    const syncFn = opLastSync(fn);
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}

function opMapAsync(mapFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            yield mapFn(v);
        }
    }
    return fn;
}
function opMapSync(mapFn) {
    function* fn(iter) {
        for (const v of iter) {
            yield mapFn(v);
        }
    }
    return fn;
}
const opMap = (fn) => toPipeFn(opMapSync(fn), opMapAsync(fn));

function opReduceAsync(reduceFn, initialValue) {
    async function* reduce(head, tail) {
        for await (const v of tail) {
            head = reduceFn(head, v);
        }
        yield head;
    }
    async function* fn(iter) {
        const ht = initialValue === undefined ? await headTailAsync(iter) : { head: await initialValue, tail: iter };
        if (!ht)
            return;
        yield* reduce(ht.head, ht.tail);
    }
    return fn;
}
function opReduceSync(reduceFn, initialValue) {
    function* reduce(head, tail) {
        for (const v of tail) {
            head = reduceFn(head, v);
        }
        yield head;
    }
    function* fn(iter) {
        const ht = initialValue === undefined ? headTail(iter) : { head: initialValue, tail: iter };
        if (!ht)
            return;
        yield* reduce(ht.head, ht.tail);
    }
    return fn;
}
function headTail(iter) {
    const iterator = iter[Symbol.iterator]();
    const first = iterator.next();
    if (first.done)
        return undefined;
    return { head: first.value, tail: iteratorToIterable(iterator) };
}
async function headTailAsync(iter) {
    const iterator = isIterable(iter) ? iter[Symbol.iterator]() : iter[Symbol.asyncIterator]();
    const first = await iterator.next();
    if (first.done)
        return undefined;
    return { head: first.value, tail: asyncIteratorToAsyncIterable(iterator) };
}
function isIterable(i) {
    return typeof i[Symbol.iterator] === 'function';
}

function opSkipAsync(count) {
    async function* fn(iter) {
        for await (const v of iter) {
            if (count > 0) {
                --count;
                continue;
            }
            yield v;
        }
    }
    return fn;
}
function opSkipSync(count) {
    function* fn(iter) {
        for (const v of iter) {
            if (count > 0) {
                --count;
                continue;
            }
            yield v;
        }
    }
    return fn;
}
const opSkip = (count) => toPipeFn(opSkipSync(count), opSkipAsync(count));

function opTakeAsync(count) {
    async function* fn(iter) {
        if (count <= 0)
            return;
        for await (const v of iter) {
            yield v;
            if (--count <= 0)
                return;
        }
    }
    return fn;
}
function opTakeSync(count) {
    function* fn(iter) {
        if (count <= 0)
            return;
        for (const v of iter) {
            yield v;
            if (--count <= 0)
                return;
        }
    }
    return fn;
}
/**
 * Consume only the first `count` number from the iterable.
 * @param count - number to take
 */
const opTake = (count) => toPipeFn(opTakeSync(count), opTakeAsync(count));

/**
 * Tap allows you to listen on values, without modifying them.
 *
 * @param fn - function to call for each value.
 */
function opTapAsync(tapFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            tapFn(v);
            yield v;
        }
    }
    return fn;
}
/**
 * Tap allows you to listen on values, without modifying them.
 *
 * @param fn - function to call for each value.
 */
function opTapSync(tapFn) {
    function* fn(iter) {
        for (const v of iter) {
            tapFn(v);
            yield v;
        }
    }
    return fn;
}
/**
 * Tap allows you to listen on values, without modifying them.
 *
 * @param fn - function to call for each value.
 */
const opTap = (fn) => toPipeFn(opTapSync(fn), opTapAsync(fn));

function opUniqueAsync(k) {
    function fnK(k) {
        async function* fn(iter) {
            const s = new Set();
            for await (const v of iter) {
                const kk = k(v);
                if (s.has(kk))
                    continue;
                s.add(kk);
                yield v;
            }
        }
        return fn;
    }
    async function* fn(iter) {
        const s = new Set();
        for await (const v of iter) {
            if (s.has(v))
                continue;
            s.add(v);
            yield v;
        }
    }
    return k ? fnK(k) : fn;
}
function opUniqueSync(k) {
    function fnK(key) {
        function* fn(iter) {
            const s = new Set();
            for (const v of iter) {
                const kk = key(v);
                if (s.has(kk))
                    continue;
                s.add(kk);
                yield v;
            }
        }
        return fn;
    }
    function* fn(iter) {
        const s = new Set();
        for (const v of iter) {
            if (s.has(v))
                continue;
            s.add(v);
            yield v;
        }
    }
    return k ? fnK(k) : fn;
}
const opUnique = (getKey) => toPipeFn(opUniqueSync(getKey), opUniqueAsync(getKey));

var _operators = /*#__PURE__*/Object.freeze({
    __proto__: null,
    opAppend: opAppend,
    opAppendAsync: opAppendAsync,
    opAppendSync: opAppendSync,
    opAwaitAsync: opAwaitAsync,
    opCombineAsync: opCombineAsync,
    opCombineSync: opCombineSync,
    opConcatMap: opConcatMap,
    opConcatMapAsync: opConcatMapAsync,
    opConcatMapSync: opConcatMapSync,
    opFilter: opFilter,
    opFilterAsync: opFilterAsync,
    opFilterSync: opFilterSync,
    opFirst: opFirst,
    opFirstAsync: opFirstAsync,
    opFirstSync: opFirstSync,
    opFlatten: opFlatten,
    opFlattenAsync: opFlattenAsync,
    opFlattenSync: opFlattenSync,
    opJoinStrings: opJoinStrings,
    opJoinStringsAsync: opJoinStringsAsync,
    opJoinStringsSync: opJoinStringsSync,
    opLast: opLast,
    opLastAsync: opLastAsync,
    opLastSync: opLastSync,
    opMap: opMap,
    opMapAsync: opMapAsync,
    opMapSync: opMapSync,
    opReduceAsync: opReduceAsync,
    opReduceSync: opReduceSync,
    opSkip: opSkip,
    opSkipAsync: opSkipAsync,
    opSkipSync: opSkipSync,
    opTake: opTake,
    opTakeAsync: opTakeAsync,
    opTakeSync: opTakeSync,
    opTap: opTap,
    opTapAsync: opTapAsync,
    opTapSync: opTapSync,
    opUnique: opUnique,
    opUniqueAsync: opUniqueAsync,
    opUniqueSync: opUniqueSync
});

function pipeAsync(i, ...fns) {
    const iter = toAsyncIterable(i);
    return opCombineAsync(...fns)(iter);
}
function pipeSync(i, ...fns) {
    return opCombineSync(...fns)(i);
}

function reduceSync(iter, reduceFn, initialValue) {
    const i = initialValue === undefined
        ? pipeSync(iter, opReduceSync(reduceFn))
        : pipeSync(iter, opReduceSync(reduceFn, initialValue));
    return [...i][0];
}
async function reduceAsync(iter, reduceFn, initialValue) {
    const i = initialValue === undefined
        ? pipeAsync(iter, opReduceAsync(reduceFn))
        : pipeAsync(iter, opReduceAsync(reduceFn, initialValue));
    const arr = await toArrayAsync(i);
    return arr[0];
}
function reduce(iter, reduceFn, initialValue) {
    return isAsyncIterable(iter) ? reduceAsync(iter, reduceFn, initialValue) : reduceSync(iter, reduceFn, initialValue);
}

// eslint-disable-next-line unicorn/prefer-export-from
const operators = _operators;
// eslint-disable-next-line unicorn/prefer-export-from
const helpers = _helpers;

exports.helpers = helpers;
exports.interleave = interleave;
exports.isAsyncIterable = isAsyncIterable;
exports.opAppend = opAppend;
exports.opAwaitAsync = opAwaitAsync;
exports.opConcatMap = opConcatMap;
exports.opFilter = opFilter;
exports.opFirst = opFirst;
exports.opFlatten = opFlatten;
exports.opJoinStrings = opJoinStrings;
exports.opLast = opLast;
exports.opMap = opMap;
exports.opSkip = opSkip;
exports.opTake = opTake;
exports.opTap = opTap;
exports.opUnique = opUnique;
exports.operators = operators;
exports.pipeAsync = pipeAsync;
exports.pipeSync = pipeSync;
exports.reduce = reduce;
exports.reduceAsync = reduceAsync;
exports.reduceSync = reduceSync;
exports.toArray = toArray;
exports.toAsyncIterable = toAsyncIterable;
exports.toDistributableIterable = toDistributableIterable;

'use strict';

function isAsyncIterable(i) {
    return typeof i[Symbol.asyncIterator] === 'function';
}

function toArray(i) {
    return isAsyncIterable(i) ? toArrayAsync(i) : toArraySync(i);
}
function toArraySync(iter) {
    return [...iter];
}
async function toArrayAsync(iter) {
    const collection = [];
    for await (const i of iter) {
        collection.push(i);
    }
    return collection;
}

function* iteratorToIterable(iterator) {
    let n;
    while (!(n = iterator.next()).done) {
        yield n.value;
    }
}

/**
 * Append values onto the end of an iterable.
 * @param iterablesToAppend - the iterables in the order to be appended.
 * @returns
 */
function opAppendSync(...iterablesToAppend) {
    function* fn(iter) {
        yield* iter;
        for (const i of iterablesToAppend) {
            yield* i;
        }
    }
    return fn;
}

function opCombineSync(...fns) {
    function combine(iter) {
        for (const fn of fns) {
            iter = fn(iter);
        }
        return iter;
    }
    return combine;
}

function opConcatMapSync(mapFn) {
    function* fn(iter) {
        for (const v of iter) {
            yield* mapFn(v);
        }
    }
    return fn;
}

function opFilterSync(filterFn) {
    function* fn(iter) {
        for (const v of iter) {
            if (filterFn(v))
                yield v;
        }
    }
    return fn;
}

function opFirstSync(firstFn) {
    function* fn(iter) {
        for (const v of iter) {
            if (firstFn(v)) {
                yield v;
                break;
            }
        }
    }
    return fn;
}

function opFlattenSync() {
    function* fn(iter) {
        for (const v of iter) {
            yield* v;
        }
    }
    return fn;
}

function opJoinStringsSync(joinCharacter = ',') {
    function* fn(iter) {
        for (const v of iter) {
            const a = toArray(v);
            yield a.join(joinCharacter);
        }
    }
    return fn;
}

const symNotFound = Symbol('LastNotFound');
function opLastSync(lastFn) {
    function* fn(iter) {
        let last = symNotFound;
        for (const v of iter) {
            if (lastFn(v)) {
                last = v;
            }
        }
        if (last !== symNotFound)
            yield last;
    }
    return fn;
}

function opMapSync(mapFn) {
    function* fn(iter) {
        for (const v of iter) {
            yield mapFn(v);
        }
    }
    return fn;
}

function opReduceSync(reduceFn, initialValue) {
    function* reduce(head, tail) {
        for (const v of tail) {
            head = reduceFn(head, v);
        }
        yield head;
    }
    function* fn(iter) {
        const ht = initialValue === undefined ? headTail(iter) : { head: initialValue, tail: iter };
        if (!ht)
            return;
        yield* reduce(ht.head, ht.tail);
    }
    return fn;
}
function headTail(iter) {
    const iterator = iter[Symbol.iterator]();
    const first = iterator.next();
    if (first.done)
        return undefined;
    return { head: first.value, tail: iteratorToIterable(iterator) };
}

function opSkipSync(count) {
    function* fn(iter) {
        for (const v of iter) {
            if (count > 0) {
                --count;
                continue;
            }
            yield v;
        }
    }
    return fn;
}

function opTakeSync(count) {
    function* fn(iter) {
        if (count <= 0)
            return;
        for (const v of iter) {
            yield v;
            if (--count <= 0)
                return;
        }
    }
    return fn;
}

/**
 * Tap allows you to listen on values, without modifying them.
 *
 * @param fn - function to call for each value.
 */
function opTapSync(tapFn) {
    function* fn(iter) {
        for (const v of iter) {
            tapFn(v);
            yield v;
        }
    }
    return fn;
}

function opUniqueSync(k) {
    function fnK(key) {
        function* fn(iter) {
            const s = new Set();
            for (const v of iter) {
                const kk = key(v);
                if (s.has(kk))
                    continue;
                s.add(kk);
                yield v;
            }
        }
        return fn;
    }
    function* fn(iter) {
        const s = new Set();
        for (const v of iter) {
            if (s.has(v))
                continue;
            s.add(v);
            yield v;
        }
    }
    return k ? fnK(k) : fn;
}

function pipeSync(i, ...fns) {
    return opCombineSync(...fns)(i);
}

function reduceSync(iter, reduceFn, initialValue) {
    const i = initialValue === undefined
        ? pipeSync(iter, opReduceSync(reduceFn))
        : pipeSync(iter, opReduceSync(reduceFn, initialValue));
    return [...i][0];
}

exports.opAppend = opAppendSync;
exports.opCombine = opCombineSync;
exports.opConcatMap = opConcatMapSync;
exports.opFilter = opFilterSync;
exports.opFirst = opFirstSync;
exports.opFlatten = opFlattenSync;
exports.opJoinStrings = opJoinStringsSync;
exports.opLast = opLastSync;
exports.opMap = opMapSync;
exports.opReduce = opReduceSync;
exports.opSkip = opSkipSync;
exports.opTake = opTakeSync;
exports.opTap = opTapSync;
exports.opUnique = opUniqueSync;
exports.pipe = pipeSync;
exports.pipeSync = pipeSync;
exports.reduce = reduceSync;
exports.toArray = toArraySync;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.opReduceSync = exports.opReduceAsync = void 0;
const helpers_1 = require("../helpers");
function opReduceAsync(reduceFn, initialValue) {
    async function* reduce(head, tail) {
        for await (const v of tail) {
            head = reduceFn(head, v);
        }
        yield head;
    }
    async function* fn(iter) {
        const ht = initialValue !== undefined ? { head: await initialValue, tail: iter } : await headTailAsync(iter);
        if (!ht)
            return;
        yield* reduce(ht.head, ht.tail);
    }
    return fn;
}
exports.opReduceAsync = opReduceAsync;
function opReduceSync(reduceFn, initialValue) {
    function* reduce(head, tail) {
        for (const v of tail) {
            head = reduceFn(head, v);
        }
        yield head;
    }
    function* fn(iter) {
        const ht = initialValue !== undefined ? { head: initialValue, tail: iter } : headTail(iter);
        if (!ht)
            return;
        yield* reduce(ht.head, ht.tail);
    }
    return fn;
}
exports.opReduceSync = opReduceSync;
function headTail(iter) {
    const iterator = iter[Symbol.iterator]();
    const first = iterator.next();
    if (first.done)
        return undefined;
    return { head: first.value, tail: (0, helpers_1.iteratorToIterable)(iterator) };
}
async function headTailAsync(iter) {
    const iterator = isIterable(iter) ? iter[Symbol.iterator]() : iter[Symbol.asyncIterator]();
    const first = await iterator.next();
    if (first.done)
        return undefined;
    return { head: first.value, tail: (0, helpers_1.asyncIteratorToAsyncIterable)(iterator) };
}
function isIterable(i) {
    return typeof i[Symbol.iterator] === 'function';
}
//# sourceMappingURL=reduce.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeFileOrGlobsToRoot = exports.normalizeGlobsToRoot = exports.extractGlobsFromMatcher = exports.buildGlobMatcher = exports.extractGlobExcludesFromConfig = exports.calcExcludeGlobInfo = exports.extractPatterns = exports.calcGlobs = exports.globP = void 0;
const cspell_glob_1 = require("cspell-glob");
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_1 = require("fs");
const path = __importStar(require("path"));
const path_1 = require("path");
const util_js_1 = require("./util.js");
const defaultExcludeGlobs = ['node_modules/**'];
/**
 *
 * @param pattern - glob patterns and NOT file paths. It can be a file path turned into a glob.
 * @param options - search options.
 */
async function globP(pattern, options) {
    const cwd = options?.root || options?.cwd || process.cwd();
    const ignore = typeof options?.ignore === 'string' ? [options.ignore] : options?.ignore;
    const onlyFiles = options?.nodir;
    const dot = options?.dot;
    const patterns = typeof pattern === 'string' ? [pattern] : pattern;
    const useOptions = (0, util_js_1.clean)({
        cwd,
        onlyFiles,
        dot,
        ignore,
        absolute: true,
        followSymbolicLinks: false,
    });
    const compare = new Intl.Collator('en').compare;
    const absolutePaths = (await (0, fast_glob_1.default)(patterns, useOptions)).sort(compare);
    const relativePaths = absolutePaths.map((absFilename) => path.relative(cwd, absFilename));
    return relativePaths;
}
exports.globP = globP;
function calcGlobs(commandLineExclude) {
    const globs = new Set((commandLineExclude || []).flatMap((glob) => glob.split(/(?<!\\)\s+/g)).map((g) => g.replace(/\\ /g, ' ')));
    const commandLineExcludes = {
        globs: [...globs],
        source: 'arguments',
    };
    const defaultExcludes = {
        globs: defaultExcludeGlobs,
        source: 'default',
    };
    return commandLineExcludes.globs.length ? commandLineExcludes : defaultExcludes;
}
exports.calcGlobs = calcGlobs;
function extractPatterns(globs) {
    const r = globs.reduce((info, g) => {
        const source = g.source;
        const patterns = g.matcher.patternsNormalizedToRoot;
        return info.concat(patterns.map((glob) => ({ glob, source })));
    }, []);
    return r;
}
exports.extractPatterns = extractPatterns;
function calcExcludeGlobInfo(root, commandLineExclude) {
    commandLineExclude = typeof commandLineExclude === 'string' ? [commandLineExclude] : commandLineExclude;
    const choice = calcGlobs(commandLineExclude);
    const matcher = new cspell_glob_1.GlobMatcher(choice.globs, { root, dot: true });
    return [
        {
            matcher,
            source: choice.source,
        },
    ];
}
exports.calcExcludeGlobInfo = calcExcludeGlobInfo;
function extractGlobExcludesFromConfig(root, source, config) {
    if (!config.ignorePaths || !config.ignorePaths.length) {
        return [];
    }
    const matcher = new cspell_glob_1.GlobMatcher(config.ignorePaths, { root, dot: true });
    return [{ source, matcher }];
}
exports.extractGlobExcludesFromConfig = extractGlobExcludesFromConfig;
/**
 * Build GlobMatcher from command line or config file globs.
 * @param globs Glob patterns or file paths
 * @param root - directory to use as the root
 */
function buildGlobMatcher(globs, root, isExclude) {
    const withRoots = globs.map((g) => {
        const source = typeof g === 'string' ? 'command line' : undefined;
        return { source, ...(0, cspell_glob_1.fileOrGlobToGlob)(g, root) };
    });
    return new cspell_glob_1.GlobMatcher(withRoots, { root, mode: isExclude ? 'exclude' : 'include' });
}
exports.buildGlobMatcher = buildGlobMatcher;
function extractGlobsFromMatcher(globMatcher) {
    return globMatcher.patternsNormalizedToRoot.map((g) => g.glob);
}
exports.extractGlobsFromMatcher = extractGlobsFromMatcher;
function normalizeGlobsToRoot(globs, root, isExclude) {
    const urls = globs.filter((g) => typeof g === 'string' && isPossibleUrlRegExp.test(g));
    const onlyGlobs = globs.filter((g) => typeof g !== 'string' || !isPossibleUrlRegExp.test(g));
    return [urls, extractGlobsFromMatcher(buildGlobMatcher(onlyGlobs, root, isExclude))].flatMap((a) => a);
}
exports.normalizeGlobsToRoot = normalizeGlobsToRoot;
const isPossibleGlobRegExp = /[*{}()?[]/;
const isPossibleUrlRegExp = /^[-a-z_0-9]{3,}:\/\//;
/**
 * If a 'glob' is a path to a directory, then append `**` so that
 * directory searches work.
 * @param glob - a glob, file, or directory
 * @param root - root to use.
 * @returns `**` is appended directories.
 */
async function adjustPossibleDirectory(glob, root) {
    const g = typeof glob === 'string'
        ? {
            glob,
            root,
        }
        : {
            glob: glob.glob,
            root: glob.root ?? root,
        };
    // Do not ask the file system to look up obvious glob patterns.
    if (isPossibleGlobRegExp.test(g.glob)) {
        return glob;
    }
    if (isPossibleUrlRegExp.test(g.glob)) {
        return glob;
    }
    const dirPath = path.resolve(g.root, g.glob);
    try {
        const stat = await fs_1.promises.stat(dirPath);
        if (stat.isDirectory()) {
            const useGlob = path_1.posix.join(posixPath(g.glob), '**');
            return typeof glob === 'string' ? useGlob : { ...glob, glob: useGlob };
        }
    }
    catch (e) {
        // it was not possible to access the dirPath, no problem, just let the file glob search look for it.
        return glob;
    }
    return glob;
}
function posixPath(p) {
    return path.sep === '\\' ? p.replace(/\\/g, '/') : p;
}
async function normalizeFileOrGlobsToRoot(globs, root) {
    const adjustedGlobs = await Promise.all(globs.map((g) => adjustPossibleDirectory(g, root)));
    return normalizeGlobsToRoot(adjustedGlobs, root, false);
}
exports.normalizeFileOrGlobsToRoot = normalizeFileOrGlobsToRoot;
//# sourceMappingURL=glob.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.emitSuggestionResult = void 0;
const chalk_1 = __importDefault(require("chalk"));
const util_1 = require("../util/util");
const regExpRTL = /([\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC ×™]+)/g;
function reverseRtlText(s) {
    return s.replace(regExpRTL, (s) => s.split('').reverse().join(''));
}
function emitSuggestionResult(result, options) {
    const { word, suggestions } = result;
    const { verbose, output = console } = options;
    const elapsed = verbose && verbose > 1 && result.elapsedTimeMs ? ` ${result.elapsedTimeMs.toFixed(2)} ms` : '';
    const rWord = reverseRtlText(word);
    const wordEx = rWord !== word ? ` (${chalk_1.default.yellow(rWord)})` : '';
    output.log((word ? chalk_1.default.yellow(word) + wordEx : chalk_1.default.yellow('<empty>')) + ':' + elapsed);
    if (!suggestions.length) {
        console.log(chalk_1.default.yellow(' <no suggestions>'));
        return;
    }
    function handleRtl(word) {
        const r = reverseRtlText(word);
        return r === word ? word : `${word} (${r})`;
    }
    if (verbose) {
        const mappedSugs = suggestions.map((s) => ({
            ...s,
            w: handleRtl(s.compoundWord || s.wordAdjustedToMatchCase || s.word),
        }));
        const sugWidths = mappedSugs.map((s) => (0, util_1.width)(s.w));
        const maxWidth = sugWidths.reduce((max, len) => Math.max(max, len), 0);
        for (const sug of mappedSugs) {
            const { cost, dictionaries, w } = sug;
            const padding = ' '.repeat((0, util_1.padWidth)(w, maxWidth));
            const forbid = sug.forbidden && sug.isPreferred
                ? chalk_1.default.red('*')
                : sug.forbidden
                    ? chalk_1.default.red('X')
                    : sug.isPreferred
                        ? chalk_1.default.yellow('*')
                        : ' ';
            const ignore = sug.noSuggest ? chalk_1.default.yellow('N') : ' ';
            const strCost = (0, util_1.padLeft)(cost.toString(10), 4);
            const dicts = dictionaries.map((n) => chalk_1.default.gray(n)).join(', ');
            output.log(` - ${formatWord(w, sug)}${padding} ${forbid}${ignore} - ${chalk_1.default.yellow(strCost)} ${dicts}`);
        }
    }
    else {
        const mappedSugs = suggestions.map((s) => ({ ...s, word: handleRtl(s.wordAdjustedToMatchCase || s.word) }));
        for (const r of mappedSugs) {
            output.log(` - ${formatWordSingle(r)}`);
        }
    }
}
exports.emitSuggestionResult = emitSuggestionResult;
function formatWord(word, r) {
    return r.forbidden || r.noSuggest
        ? chalk_1.default.gray(chalk_1.default.strikethrough(word))
        : word === r.wordAdjustedToMatchCase
            ? diff(word, r.word)
            : word;
}
function diff(wordA, wordB) {
    const a = [...wordA];
    const b = [...wordB];
    const parts = [];
    for (let idx = 0; idx < a.length; ++idx) {
        const aa = a[idx];
        const bb = b[idx];
        parts.push(aa === bb ? aa : chalk_1.default.yellow(aa));
    }
    return parts.join('');
}
function formatWordSingle(s) {
    let word = formatWord(s.word, s);
    word = s.forbidden ? word + chalk_1.default.red(' X') : word;
    word = s.noSuggest ? word + chalk_1.default.yellow(' Not suggested.') : word;
    word = s.isPreferred ? chalk_1.default.yellow(word + ' *') : word;
    return word;
}
//# sourceMappingURL=suggestionsEmitter.js.map
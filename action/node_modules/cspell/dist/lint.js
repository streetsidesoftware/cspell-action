"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runLint = void 0;
const commentJson = __importStar(require("comment-json"));
const cspell = __importStar(require("cspell-lib"));
const path = __importStar(require("path"));
const util_1 = require("util");
const vscode_uri_1 = require("vscode-uri");
const emitters_1 = require("./emitters");
const fileHelper_1 = require("./fileHelper");
const glob_1 = require("./util/glob");
const timer_1 = require("./util/timer");
const util = __importStar(require("./util/util"));
function runLint(cfg) {
    const configErrors = new Set();
    const log = (...params) => {
        const msg = util_1.format(...params);
        cfg.emitters.info(msg, 'Info');
    };
    const error = (...params) => {
        const msg = util_1.format(...params);
        const err = { message: '', name: 'error', toString: () => '' };
        cfg.emitters.error(msg, err);
    };
    const warn = (...params) => {
        const msg = util_1.format(...params);
        cfg.emitters.info(msg, 'Warning');
    };
    const logger = {
        log,
        warn,
        error,
    };
    cspell.setLogger(logger);
    return run();
    async function processFile(fileInfo, configInfo) {
        var _a, _b, _c, _d;
        const doc = fileHelper_1.fileInfoToDocument(fileInfo, cfg.options.languageId, cfg.locale);
        const { filename, text } = fileInfo;
        cfg.debug(`Filename: ${fileInfo.filename}, LanguageIds: ${(_a = doc.languageId) !== null && _a !== void 0 ? _a : 'default'}`);
        const result = {
            fileInfo,
            issues: [],
            processed: false,
            errors: 0,
            configErrors: 0,
            elapsedTimeMs: 0,
        };
        const startTime = Date.now();
        let spellResult = {};
        cfg.info(`Checking: ${filename}, File type: ${(_b = doc.languageId) !== null && _b !== void 0 ? _b : 'auto'}, Language: ${(_c = doc.locale) !== null && _c !== void 0 ? _c : 'default'}`, emitters_1.MessageTypes.Info);
        try {
            const validateOptions = { generateSuggestions: cfg.options.showSuggestions, numSuggestions: 5 };
            const r = await cspell.spellCheckDocument(doc, validateOptions, configInfo.config);
            spellResult = r;
            result.processed = r.checked;
            result.issues = cspell.Text.calculateTextDocumentOffsets(filename, text, r.issues).map(mapIssue);
        }
        catch (e) {
            cfg.emitters.error(`Failed to process "${filename}"`, e);
            result.errors += 1;
        }
        result.elapsedTimeMs = Date.now() - startTime;
        const config = (_d = spellResult.settingsUsed) !== null && _d !== void 0 ? _d : {};
        result.configErrors += await reportConfigurationErrors(config);
        const debugCfg = { config: { ...config, source: null }, source: spellResult.localConfigFilepath };
        cfg.debug(commentJson.stringify(debugCfg, undefined, 2));
        const elapsed = result.elapsedTimeMs / 1000.0;
        const dictionaries = config.dictionaries || [];
        cfg.info(`Checked: ${filename}, File type: ${config.languageId}, Language: ${config.language} ... Issues: ${result.issues.length} ${elapsed}S`, emitters_1.MessageTypes.Info);
        cfg.info(`Config file Used: ${spellResult.localConfigFilepath || configInfo.source}`, emitters_1.MessageTypes.Info);
        cfg.info(`Dictionaries Used: ${dictionaries.join(', ')}`, emitters_1.MessageTypes.Info);
        return result;
    }
    function mapIssue(tdo) {
        const context = cfg.showContext
            ? extractContext(tdo, cfg.showContext)
            : { text: tdo.line.text.trimEnd(), offset: tdo.line.offset };
        return { ...tdo, context };
    }
    /**
     * The file loader is written this way to cause files to be loaded in parallel while the previous one is being processed.
     * @param fileNames names of files to load one at a time.
     */
    function* fileLoader(fileNames) {
        for (const filename of fileNames) {
            const file = fileHelper_1.readFileInfo(filename);
            yield file;
        }
    }
    async function processFiles(files, configInfo, fileCount) {
        const status = runResult();
        let n = 0;
        for (const fileP of files) {
            ++n;
            const fileNum = n;
            const file = await fileP;
            const emitProgress = (elapsedTimeMs, processed, numErrors) => cfg.progress({
                type: 'ProgressFileComplete',
                fileNum,
                fileCount,
                filename: file.filename,
                elapsedTimeMs,
                processed,
                numErrors,
            });
            if (!file.text) {
                emitProgress();
                continue;
            }
            const p = processFile(file, configInfo);
            const { elapsedTimeMs } = await timer_1.measurePromise(p);
            const result = await p;
            emitProgress(elapsedTimeMs, result.processed, result.issues.length);
            // Show the spelling errors after emitting the progress.
            result.issues.filter(cfg.uniqueFilter).forEach((issue) => cfg.logIssue(issue));
            const r = await p;
            status.files += 1;
            if (r.issues.length || r.errors) {
                status.filesWithIssues.add(file.filename);
                status.issues += r.issues.length;
                status.errors += r.errors;
            }
            status.errors += r.configErrors;
        }
        return status;
    }
    async function reportConfigurationErrors(config) {
        const errors = cspell.extractImportErrors(config);
        let count = 0;
        errors.forEach((ref) => {
            const key = ref.error.toString();
            if (configErrors.has(key))
                return;
            configErrors.add(key);
            count += 1;
            cfg.emitters.error('Configuration', ref.error);
        });
        const dictCollection = await cspell.getDictionary(config);
        dictCollection.dictionaries.forEach((dict) => {
            var _a;
            const dictErrors = ((_a = dict.getErrors) === null || _a === void 0 ? void 0 : _a.call(dict)) || [];
            const msg = `Dictionary Error with (${dict.name})`;
            dictErrors.forEach((error) => {
                const key = msg + error.toString();
                if (configErrors.has(key))
                    return;
                configErrors.add(key);
                count += 1;
                cfg.emitters.error(msg, error);
            });
        });
        return count;
    }
    function countConfigErrors(configInfo) {
        return reportConfigurationErrors(configInfo.config);
    }
    async function run() {
        if (cfg.options.root) {
            process.env[cspell.ENV_CSPELL_GLOB_ROOT] = cfg.root;
        }
        const configInfo = await fileHelper_1.readConfig(cfg.configFile, cfg.root);
        const cliGlobs = cfg.files;
        const allGlobs = cliGlobs.length ? cliGlobs : configInfo.config.files || [];
        const combinedGlobs = glob_1.normalizeGlobsToRoot(allGlobs, cfg.root, false);
        const cliExcludeGlobs = glob_1.extractPatterns(cfg.excludes).map((p) => p.glob);
        const normalizedExcludes = glob_1.normalizeGlobsToRoot(cliExcludeGlobs, cfg.root, true);
        const includeGlobs = combinedGlobs.filter((g) => !g.startsWith('!'));
        const excludeGlobs = combinedGlobs.filter((g) => g.startsWith('!')).concat(normalizedExcludes);
        const fileGlobs = includeGlobs;
        if (!fileGlobs.length) {
            // Nothing to do.
            return runResult();
        }
        header(fileGlobs, excludeGlobs);
        cfg.info(`Config Files Found:\n    ${configInfo.source}\n`, emitters_1.MessageTypes.Info);
        const configErrors = await countConfigErrors(configInfo);
        if (configErrors)
            return runResult({ errors: configErrors });
        // Get Exclusions from the config files.
        const { root } = cfg;
        const globsToExclude = (configInfo.config.ignorePaths || []).concat(excludeGlobs);
        const globMatcher = glob_1.buildGlobMatcher(globsToExclude, root, true);
        const ignoreGlobs = glob_1.extractGlobsFromMatcher(globMatcher);
        const globOptions = { root, cwd: root, ignore: ignoreGlobs.concat(normalizedExcludes) };
        const files = filterFiles(await fileHelper_1.findFiles(fileGlobs, globOptions), globMatcher);
        return processFiles(fileLoader(files), configInfo, files.length);
    }
    function header(files, cliExcludes) {
        const formattedFiles = files.length > 100 ? files.slice(0, 100).concat(['...']) : files;
        cfg.info(`
cspell;
Date: ${new Date().toUTCString()}
Options:
    verbose:   ${yesNo(!!cfg.options.verbose)}
    config:    ${cfg.configFile || 'default'}
    exclude:   ${cliExcludes.join('\n               ')}
    files:     ${formattedFiles}
    wordsOnly: ${yesNo(!!cfg.options.wordsOnly)}
    unique:    ${yesNo(!!cfg.options.unique)}
`, emitters_1.MessageTypes.Info);
    }
    function isExcluded(filename, globMatcher) {
        if (cspell.isBinaryFile(vscode_uri_1.URI.file(filename))) {
            return true;
        }
        const { root } = cfg;
        const absFilename = path.resolve(root, filename);
        const r = globMatcher.matchEx(absFilename);
        if (r.matched) {
            const { glob, source } = extractGlobSource(r.pattern);
            cfg.info(`Excluded File: ${path.relative(root, absFilename)}; Excluded by ${glob} from ${source}`, emitters_1.MessageTypes.Info);
        }
        return r.matched;
    }
    function extractGlobSource(g) {
        const { glob, rawGlob, source } = g;
        return {
            glob: rawGlob || glob,
            source,
        };
    }
    function filterFiles(files, globMatcher) {
        const patterns = globMatcher.patterns;
        const excludeInfo = patterns.map(extractGlobSource).map(({ glob, source }) => `Glob: ${glob} from ${source}`);
        cfg.info(`Exclusion Globs: \n    ${excludeInfo.join('\n    ')}\n`, emitters_1.MessageTypes.Info);
        const result = files.filter(util.uniqueFn()).filter((filename) => !isExcluded(filename, globMatcher));
        return result;
    }
}
exports.runLint = runLint;
function extractContext(tdo, contextRange) {
    const { line, offset } = tdo;
    const textOffsetInLine = offset - line.offset;
    let left = Math.max(textOffsetInLine - contextRange, 0);
    let right = Math.min(line.text.length, textOffsetInLine + contextRange + tdo.text.length);
    const lineText = line.text;
    const isLetter = /^[a-z]$/i;
    const isSpace = /^\s$/;
    for (let n = contextRange / 2; n > 0 && left > 0; n--, left--) {
        if (!isLetter.test(lineText[left - 1])) {
            break;
        }
    }
    for (let n = contextRange / 2; n > 0 && right < lineText.length; n--, right++) {
        if (!isLetter.test(lineText[right])) {
            break;
        }
    }
    // remove leading space
    for (; left < textOffsetInLine && isSpace.test(lineText[left]); left++) {
        /* do nothing */
    }
    const context = {
        text: line.text.slice(left, right).trimEnd(),
        offset: left + line.offset,
    };
    return context;
}
function runResult(init = {}) {
    const { files = 0, filesWithIssues = new Set(), issues = 0, errors = 0 } = init;
    return { files, filesWithIssues, issues, errors };
}
function yesNo(value) {
    return value ? 'Yes' : 'No';
}
//# sourceMappingURL=lint.js.map
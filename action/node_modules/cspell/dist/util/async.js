"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAsyncIterable = exports.asyncIterableToArray = exports.toAsyncIterable = exports.mergeAsyncIterables = exports.pipeSync = exports.pipeAsync = exports.filter = exports.asyncAwait = exports.map = void 0;
function asyncMap(mapFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            yield mapFn(v);
        }
    }
    return fn;
}
function syncMap(mapFn) {
    function* fn(iter) {
        for (const v of iter) {
            yield mapFn(v);
        }
    }
    return fn;
}
const map = (fn) => toPipeFn(syncMap(fn), asyncMap(fn));
exports.map = map;
function asyncFilter(filterFn) {
    async function* fn(iter) {
        for await (const v of iter) {
            if (filterFn(v))
                yield v;
        }
    }
    return fn;
}
function syncFilter(filterFn) {
    function* fn(iter) {
        for (const v of iter) {
            if (filterFn(v))
                yield v;
        }
    }
    return fn;
}
async function* _asyncAwait(iter) {
    for await (const v of iter) {
        yield v;
    }
}
function asyncAwait() {
    return _asyncAwait;
}
exports.asyncAwait = asyncAwait;
const filter = (fn) => toPipeFn(syncFilter(fn), asyncFilter(fn));
exports.filter = filter;
function toPipeFn(syncFn, asyncFn) {
    function _(i) {
        return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
    }
    return _;
}
function pipeAsync(i, ...fns) {
    let iter = (0, exports.toAsyncIterable)(i);
    for (const fn of fns) {
        iter = fn(iter);
    }
    return iter;
}
exports.pipeAsync = pipeAsync;
function pipeSync(i, ...fns) {
    let iter = i;
    for (const fn of fns) {
        iter = fn(iter);
    }
    return iter;
}
exports.pipeSync = pipeSync;
/**
 * Merge multiple iterables into an AsyncIterable
 * @param iter - initial iterable.
 * @param rest - iterables to merge.
 */
async function* mergeAsyncIterables(iter, ...rest) {
    for await (const i of [iter, ...rest]) {
        yield* i;
    }
}
exports.mergeAsyncIterables = mergeAsyncIterables;
/**
 * Convert one or more iterables to an AsyncIterable
 */
exports.toAsyncIterable = mergeAsyncIterables;
async function asyncIterableToArray(iter) {
    const r = [];
    for await (const t of iter) {
        r.push(t);
    }
    return r;
}
exports.asyncIterableToArray = asyncIterableToArray;
function isAsyncIterable(i) {
    return typeof i[Symbol.asyncIterator] === 'function';
}
exports.isAsyncIterable = isAsyncIterable;
//  type Last<T extends [...any]> = T extends [infer U, ...infer R] ? (R extends [any, ...any] ? Last<R> : U) : never;
//# sourceMappingURL=async.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiskCache = void 0;
const file_entry_cache_1 = require("file-entry-cache");
const fileHelper_1 = require("../../fileHelper");
const getConfigHash_1 = require("./getConfigHash");
/**
 * Caches cspell results on disk
 */
class DiskCache {
    constructor(cacheFileLocation, useCheckSum) {
        this.fileEntryCache = (0, file_entry_cache_1.create)(cacheFileLocation, undefined, useCheckSum);
    }
    async getCachedLintResults(filename, configInfo) {
        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filename);
        const meta = fileDescriptor.meta;
        // Cached lint results are valid if and only if:
        // 1. The file is present in the filesystem
        // 2. The file has not changed since the time it was previously linted
        // 3. The CSpell configuration has not changed since the time the file was previously linted
        // If any of these are not true, we will not reuse the lint results.
        if (fileDescriptor.notFound ||
            fileDescriptor.changed ||
            !meta ||
            meta.configHash !== (0, getConfigHash_1.getConfigHash)(configInfo)) {
            return undefined;
        }
        // Skip reading empty files and files without lint error
        const hasErrors = meta.result.errors > 0 || meta.result.configErrors > 0 || meta.result.issues.length > 0;
        const cached = !!meta.size;
        const shouldReadFile = cached && hasErrors;
        return {
            ...meta.result,
            elapsedTimeMs: undefined,
            fileInfo: shouldReadFile ? await (0, fileHelper_1.readFileInfo)(filename) : { filename },
            cached,
        };
    }
    setCachedLintResults({ fileInfo, elapsedTimeMs: _, ...result }, configInfo) {
        const fileDescriptor = this.fileEntryCache.getFileDescriptor(fileInfo.filename);
        const meta = fileDescriptor.meta;
        if (fileDescriptor.notFound || !meta) {
            return;
        }
        meta.result = result;
        meta.configHash = (0, getConfigHash_1.getConfigHash)(configInfo);
    }
    reconcile() {
        this.fileEntryCache.reconcile();
    }
}
exports.DiskCache = DiskCache;
//# sourceMappingURL=DiskCache.js.map
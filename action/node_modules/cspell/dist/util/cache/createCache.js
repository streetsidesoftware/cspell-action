"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__testing__ = exports.calcCacheSettings = exports.createCache = exports.DEFAULT_CACHE_LOCATION = void 0;
const assert_1 = __importDefault(require("assert"));
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const errors_1 = require("../errors");
const DiskCache_1 = require("./DiskCache");
const DummyCache_1 = require("./DummyCache");
// cspell:word cspellcache
exports.DEFAULT_CACHE_LOCATION = '.cspellcache';
const versionSuffix = '';
/**
 * Creates CSpellLintResultCache (disk cache if caching is enabled in config or dummy otherwise)
 */
function createCache(options) {
    const { useCache, cacheLocation, cacheStrategy, reset } = options;
    const location = path_1.default.resolve(cacheLocation);
    const useChecksum = cacheStrategy === 'content';
    const version = normalizeVersion(options.version);
    const useUniversal = options.cacheFormat === 'universal';
    const cache = useCache ? new DiskCache_1.DiskCache(location, useChecksum, version, useUniversal) : new DummyCache_1.DummyCache();
    reset && cache.reset();
    return cache;
}
exports.createCache = createCache;
async function calcCacheSettings(config, cacheOptions, root) {
    const cs = config.cache ?? {};
    const useCache = cacheOptions.cache ?? cs.useCache ?? false;
    const cacheLocation = await resolveCacheLocation(path_1.default.resolve(root, cacheOptions.cacheLocation ?? cs.cacheLocation ?? exports.DEFAULT_CACHE_LOCATION));
    const cacheStrategy = cacheOptions.cacheStrategy ?? cs.cacheStrategy ?? 'metadata';
    const optionals = {};
    if (cacheOptions.cacheReset) {
        optionals.reset = true;
    }
    return {
        ...optionals,
        useCache,
        cacheLocation,
        cacheStrategy,
        version: cacheOptions.version,
        cacheFormat: cacheOptions.cacheFormat || 'legacy',
    };
}
exports.calcCacheSettings = calcCacheSettings;
async function resolveCacheLocation(cacheLocation) {
    try {
        const s = await (0, fs_extra_1.stat)(cacheLocation);
        if (s.isFile())
            return cacheLocation;
        return path_1.default.join(cacheLocation, exports.DEFAULT_CACHE_LOCATION);
    }
    catch (err) {
        if ((0, errors_1.isError)(err) && err.code === 'ENOENT') {
            return cacheLocation;
        }
        throw err;
    }
}
/**
 * Normalizes the version and return only `major.minor + versionSuffix`
 * @param version The cspell semantic version.
 */
function normalizeVersion(version) {
    const parts = version.split('.').slice(0, 2);
    (0, assert_1.default)(parts.length === 2);
    return parts.join('.') + versionSuffix;
}
exports.__testing__ = {
    normalizeVersion,
    versionSuffix,
};
//# sourceMappingURL=createCache.js.map
import { opMap, opTap, pipeAsync, toAsyncIterable } from '@cspell/cspell-pipe';
import { checkTextDocument, getDefaultSettings, getGlobalSettings, mergeSettings, SuggestionError, suggestionsForWords, traceWordsAsync, } from 'cspell-lib';
import { getReporter } from './cli-reporter.mjs';
import { getFeatureFlags, parseFeatureFlags } from './featureFlags/index.mjs';
import { LintRequest, runLint } from './lint/index.mjs';
import { fixLegacy } from './options.mjs';
import { simpleRepl } from './repl/index.mjs';
import { fileInfoToDocument, readConfig, readFileInfo } from './util/fileHelper.mjs';
import { finalizeReporter } from './util/reporters.mjs';
import { readStdin } from './util/stdin.mjs';
import { getTimeMeasurer } from './util/timer.mjs';
import * as util from './util/util.mjs';
export { IncludeExcludeFlag } from 'cspell-lib';
export function lint(fileGlobs, options, reporter) {
    options = fixLegacy(options);
    const cfg = new LintRequest(fileGlobs, options, finalizeReporter(reporter) ?? getReporter({ ...options, fileGlobs }));
    return runLint(cfg);
}
export async function* trace(words, options) {
    options = fixLegacy(options);
    const iWords = options.stdin ? toAsyncIterable(words, readStdin()) : words;
    const { languageId, locale, allowCompoundWords, ignoreCase } = options;
    const configFile = await readConfig(options.config, undefined);
    const loadDefault = options.defaultConfiguration ?? configFile.config.loadDefaultConfiguration ?? true;
    const config = mergeSettings(getDefaultSettings(loadDefault), getGlobalSettings(), configFile.config);
    yield* traceWordsAsync(iWords, config, util.clean({ languageId, locale, ignoreCase, allowCompoundWords }));
}
export async function checkText(filename, options) {
    options = fixLegacy(options);
    const fileInfo = await readFileInfo(filename);
    const { locale, languageId, validateDirectives } = options;
    const doc = fileInfoToDocument(fileInfo, languageId, locale);
    const checkOptions = {
        configFile: options.config,
        validateDirectives,
    };
    const settingsFromCommandLine = util.clean({
        languageId,
        language: locale,
        loadDefaultConfiguration: options.defaultConfiguration,
    });
    return checkTextDocument(doc, util.clean({ ...checkOptions }), settingsFromCommandLine);
}
export async function* suggestions(words, options) {
    options = fixLegacy(options);
    const configFile = await readConfig(options.config, undefined);
    let timer;
    function tapStart() {
        timer = getTimeMeasurer();
    }
    function mapStart(v) {
        tapStart();
        return v;
    }
    function mapEnd(v) {
        const elapsedTimeMs = timer?.();
        return elapsedTimeMs ? { ...v, elapsedTimeMs } : v;
    }
    const iWords = options.repl
        ? pipeAsync(toAsyncIterable(words, simpleRepl()), opTap(tapStart))
        : options.useStdin
            ? pipeAsync(toAsyncIterable(words, readStdin()), opTap(tapStart))
            : words.map(mapStart);
    try {
        const results = pipeAsync(suggestionsForWords(iWords, util.clean({ ...options }), configFile.config), opMap(mapEnd));
        yield* results;
    }
    catch (e) {
        if (!(e instanceof SuggestionError))
            throw e;
        console.error(e.message);
        process.exitCode = 1;
    }
}
export function createInit() {
    return Promise.reject();
}
function registerApplicationFeatureFlags() {
    const ff = getFeatureFlags();
    const flags = [{ name: 'timer', description: 'Display elapsed time for command.' }];
    flags.forEach((flag) => ff.register(flag));
    return ff;
}
export function parseApplicationFeatureFlags(flags) {
    const ff = registerApplicationFeatureFlags();
    return parseFeatureFlags(flags, ff);
}

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@actions/core/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCommandProperties = exports.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports.toCommandProperties = toCommandProperties;
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/@actions/core/lib/command.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.issue = exports.issueCommand = void 0;
    var os = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand2(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports.issueCommand = issueCommand2;
    function issue(name, message = "") {
      issueCommand2(name, {}, message);
    }
    exports.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version3, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version3;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-node/md5.js"() {
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-node/sha1.js"() {
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/@actions/core/lib/file-command.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
    var fs6 = __importStar(require("fs"));
    var os = __importStar(require("os"));
    var uuid_1 = (init_esm_node(), __toCommonJS(esm_node_exports));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs6.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs6.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: "utf8"
      });
    }
    exports.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${uuid_1.v4()}`;
      const convertedValue = utils_1.toCommandValue(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
    }
    exports.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/@actions/http-client/lib/proxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkBypass = exports.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        return new URL(proxyVar);
      } else {
        return void 0;
      }
    }
    exports.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert7 = require("assert");
    var util = require("util");
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self = this;
      self.options = options || {};
      self.proxyOptions = self.options.proxy || {};
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
      self.requests = [];
      self.sockets = [];
      self.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self = this;
      var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));
      if (self.sockets.length >= this.maxSockets) {
        self.requests.push(options);
        return;
      }
      self.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this;
      var placeholder = {};
      self.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug("making CONNECT request");
      var connectReq = self.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error2 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug("got illegal response body from proxy");
          socket.destroy();
          var error2 = new Error("got illegal response body from proxy");
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self.removeSocket(placeholder);
          return;
        }
        debug("tunneling connection has established");
        self.sockets[self.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self = this;
      TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self.sockets[self.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.debug = debug;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports, module2) {
    module2.exports = require_tunnel();
  }
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/@actions/http-client/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve10) {
          resolve10(value);
        });
      }
      return new (P || (P = Promise))(function(resolve10, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve10(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers = exports.Headers || (exports.Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve10) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve10(output.toString());
            });
          }));
        });
      }
    };
    exports.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info3 = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info3, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info3, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info3 = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info3, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info3, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve10, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve10(res);
              }
            }
            this.requestRawWithCallback(info3, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info3, data, onResult) {
        if (typeof data === "string") {
          if (!info3.options.headers) {
            info3.options.headers = {};
          }
          info3.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info3.httpModule.request(info3.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info3.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info3 = {};
        info3.parsedUrl = requestUrl;
        const usingSsl = info3.parsedUrl.protocol === "https:";
        info3.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info3.options = {};
        info3.options.host = info3.parsedUrl.hostname;
        info3.options.port = info3.parsedUrl.port ? parseInt(info3.parsedUrl.port) : defaultPort;
        info3.options.path = (info3.parsedUrl.pathname || "") + (info3.parsedUrl.search || "");
        info3.options.method = method;
        info3.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info3.options.headers["user-agent"] = this.userAgent;
        }
        info3.options.agent = this._getAgent(info3.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info3.options);
          }
        }
        return info3;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve10) => setTimeout(() => resolve10(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve10, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve10(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve10(response);
            }
          }));
        });
      }
    };
    exports.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  }
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@actions/http-client/lib/auth.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve10) {
          resolve10(value);
        });
      }
      return new (P || (P = Promise))(function(resolve10, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve10(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/@actions/core/lib/oidc-utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve10) {
          resolve10(value);
        });
      }
      return new (P || (P = Promise))(function(resolve10, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve10(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error2) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error2.statusCode}
 
        Error Message: ${error2.result.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            core_1.debug(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            core_1.setSecret(id_token);
            return id_token;
          } catch (error2) {
            throw new Error(`Error message: ${error2.message}`);
          }
        });
      }
    };
    exports.OidcClient = OidcClient;
  }
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/@actions/core/lib/summary.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve10) {
          resolve10(value);
        });
      }
      return new (P || (P = Promise))(function(resolve10, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve10(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os");
    var fs_1 = require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports.markdownSummary = _summary;
    exports.summary = _summary;
  }
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/@actions/core/lib/path-utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
    var path16 = __importStar(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path16.sep);
    }
    exports.toPlatformPath = toPlatformPath;
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/@actions/core/lib/core.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve10) {
          resolve10(value);
        });
      }
      return new (P || (P = Promise))(function(resolve10, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve10(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os = __importStar(require("os"));
    var path16 = __importStar(require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = utils_1.toCommandValue(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("ENV", file_command_1.prepareKeyValueMessage(name, val));
      }
      command_1.issueCommand("set-env", { name }, convertedVal);
    }
    exports.exportVariable = exportVariable;
    function setSecret(secret) {
      command_1.issueCommand("add-mask", {}, secret);
    }
    exports.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        file_command_1.issueFileCommand("PATH", inputPath);
      } else {
        command_1.issueCommand("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path16.delimiter}${process.env["PATH"]}`;
    }
    exports.addPath = addPath;
    function getInput3(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports.getInput = getInput3;
    function getMultilineInput(name, options) {
      const inputs = getInput3(name, options).split("\n").filter((x) => x !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput3(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports.getBooleanInput = getBooleanInput;
    function setOutput2(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("OUTPUT", file_command_1.prepareKeyValueMessage(name, value));
      }
      process.stdout.write(os.EOL);
      command_1.issueCommand("set-output", { name }, utils_1.toCommandValue(value));
    }
    exports.setOutput = setOutput2;
    function setCommandEcho(enabled) {
      command_1.issue("echo", enabled ? "on" : "off");
    }
    exports.setCommandEcho = setCommandEcho;
    function setFailed3(message) {
      process.exitCode = ExitCode.Failure;
      error2(message);
    }
    exports.setFailed = setFailed3;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports.isDebug = isDebug;
    function debug(message) {
      command_1.issueCommand("debug", {}, message);
    }
    exports.debug = debug;
    function error2(message, properties = {}) {
      command_1.issueCommand("error", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports.error = error2;
    function warning2(message, properties = {}) {
      command_1.issueCommand("warning", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports.warning = warning2;
    function notice(message, properties = {}) {
      command_1.issueCommand("notice", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports.notice = notice;
    function info3(message) {
      process.stdout.write(message + os.EOL);
    }
    exports.info = info3;
    function startGroup(name) {
      command_1.issue("group", name);
    }
    exports.startGroup = startGroup;
    function endGroup() {
      command_1.issue("endgroup");
    }
    exports.endGroup = endGroup;
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("STATE", file_command_1.prepareKeyValueMessage(name, value));
      }
      command_1.issueCommand("save-state", { name }, utils_1.toCommandValue(value));
    }
    exports.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
  }
});

// node_modules/@actions/github/lib/context.js
var require_context = __commonJS({
  "node_modules/@actions/github/lib/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Context = void 0;
    var fs_1 = require("fs");
    var os_1 = require("os");
    var Context2 = class {
      /**
       * Hydrate the context from the environment
       */
      constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
          if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
            this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
          } else {
            const path16 = process.env.GITHUB_EVENT_PATH;
            process.stdout.write(`GITHUB_EVENT_PATH ${path16} does not exist${os_1.EOL}`);
          }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
      }
      get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
      }
      get repo() {
        if (process.env.GITHUB_REPOSITORY) {
          const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
          return { owner, repo };
        }
        if (this.payload.repository) {
          return {
            owner: this.payload.repository.owner.login,
            repo: this.payload.repository.name
          };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
      }
    };
    exports.Context = Context2;
  }
});

// node_modules/@actions/github/lib/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/@actions/github/lib/internal/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
    var httpClient = __importStar(require_lib());
    function getAuthString(token, options) {
      if (!token && !options.auth) {
        throw new Error("Parameter token or opts.auth is required");
      } else if (token && options.auth) {
        throw new Error("Parameters token and opts.auth may not both be specified");
      }
      return typeof options.auth === "string" ? options.auth : `token ${token}`;
    }
    exports.getAuthString = getAuthString;
    function getProxyAgent(destinationUrl) {
      const hc = new httpClient.HttpClient();
      return hc.getAgent(destinationUrl);
    }
    exports.getProxyAgent = getProxyAgent;
    function getApiBaseUrl() {
      return process.env["GITHUB_API_URL"] || "https://api.github.com";
    }
    exports.getApiBaseUrl = getApiBaseUrl;
  }
});

// node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS({
  "node_modules/universal-user-agent/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUserAgent() {
      if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
      }
      if (typeof process === "object" && "version" in process) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
      }
      return "<environment undetectable>";
    }
    exports.getUserAgent = getUserAgent;
  }
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook) {
      var orig = hook;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error2) {
            return orig(error2, options);
          });
        };
      }
      state.registry[name].push({
        hook,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(
        null,
        name ? [state, name] : [state]
      );
      hook.api = { remove: removeHookRef };
      hook.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook = register.bind(null, state);
      bindApi(hook, state);
      return hook;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn(
          '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
        );
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object = __commonJS({
  "node_modules/is-plain-object/dist/is-plain-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObject(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function isPlainObject(o) {
      var ctor, prot;
      if (isObject(o) === false)
        return false;
      ctor = o.constructor;
      if (ctor === void 0)
        return true;
      prot = ctor.prototype;
      if (isObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    exports.isPlainObject = isPlainObject;
  }
});

// node_modules/@actions/github/node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node2 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/endpoint/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isPlainObject = require_is_plain_object();
    var universalUserAgent = require_dist_node();
    function lowercaseKeys(object) {
      if (!object) {
        return {};
      }
      return Object.keys(object).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = object[key];
        return newObj;
      }, {});
    }
    function mergeDeep(defaults, options) {
      const result = Object.assign({}, defaults);
      Object.keys(options).forEach((key) => {
        if (isPlainObject.isPlainObject(options[key])) {
          if (!(key in defaults))
            Object.assign(result, {
              [key]: options[key]
            });
          else
            result[key] = mergeDeep(defaults[key], options[key]);
        } else {
          Object.assign(result, {
            [key]: options[key]
          });
        }
      });
      return result;
    }
    function removeUndefinedProperties(obj) {
      for (const key in obj) {
        if (obj[key] === void 0) {
          delete obj[key];
        }
      }
      return obj;
    }
    function merge(defaults, route, options) {
      if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? {
          method,
          url
        } : {
          url: method
        }, options);
      } else {
        options = Object.assign({}, route);
      }
      options.headers = lowercaseKeys(options.headers);
      removeUndefinedProperties(options);
      removeUndefinedProperties(options.headers);
      const mergedOptions = mergeDeep(defaults || {}, options);
      if (defaults && defaults.mediaType.previews.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
      }
      mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
      return mergedOptions;
    }
    function addQueryParameters(url, parameters) {
      const separator = /\?/.test(url) ? "&" : "?";
      const names = Object.keys(parameters);
      if (names.length === 0) {
        return url;
      }
      return url + separator + names.map((name) => {
        if (name === "q") {
          return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
        }
        return `${name}=${encodeURIComponent(parameters[name])}`;
      }).join("&");
    }
    var urlVariableRegex = /\{[^}]+\}/g;
    function removeNonChars(variableName) {
      return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
    }
    function extractUrlVariableNames(url) {
      const matches = url.match(urlVariableRegex);
      if (!matches) {
        return [];
      }
      return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
    }
    function omit(object, keysToOmit) {
      return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
        obj[key] = object[key];
        return obj;
      }, {});
    }
    function encodeReserved(str) {
      return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
          part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
      }).join("");
    }
    function encodeUnreserved(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeValue(operator, value, key) {
      value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
      if (key) {
        return encodeUnreserved(key) + "=" + value;
      } else {
        return value;
      }
    }
    function isDefined2(value) {
      return value !== void 0 && value !== null;
    }
    function isKeyOperator(operator) {
      return operator === ";" || operator === "&" || operator === "?";
    }
    function getValues(context, operator, key, modifier) {
      var value = context[key], result = [];
      if (isDefined2(value) && value !== "") {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          value = value.toString();
          if (modifier && modifier !== "*") {
            value = value.substring(0, parseInt(modifier, 10));
          }
          result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
        } else {
          if (modifier === "*") {
            if (Array.isArray(value)) {
              value.filter(isDefined2).forEach(function(value2) {
                result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
              });
            } else {
              Object.keys(value).forEach(function(k) {
                if (isDefined2(value[k])) {
                  result.push(encodeValue(operator, value[k], k));
                }
              });
            }
          } else {
            const tmp = [];
            if (Array.isArray(value)) {
              value.filter(isDefined2).forEach(function(value2) {
                tmp.push(encodeValue(operator, value2));
              });
            } else {
              Object.keys(value).forEach(function(k) {
                if (isDefined2(value[k])) {
                  tmp.push(encodeUnreserved(k));
                  tmp.push(encodeValue(operator, value[k].toString()));
                }
              });
            }
            if (isKeyOperator(operator)) {
              result.push(encodeUnreserved(key) + "=" + tmp.join(","));
            } else if (tmp.length !== 0) {
              result.push(tmp.join(","));
            }
          }
        }
      } else {
        if (operator === ";") {
          if (isDefined2(value)) {
            result.push(encodeUnreserved(key));
          }
        } else if (value === "" && (operator === "&" || operator === "?")) {
          result.push(encodeUnreserved(key) + "=");
        } else if (value === "") {
          result.push("");
        }
      }
      return result;
    }
    function parseUrl(template2) {
      return {
        expand: expand.bind(null, template2)
      };
    }
    function expand(template2, context) {
      var operators2 = ["+", "#", ".", "/", ";", "?", "&"];
      return template2.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
        if (expression) {
          let operator = "";
          const values = [];
          if (operators2.indexOf(expression.charAt(0)) !== -1) {
            operator = expression.charAt(0);
            expression = expression.substr(1);
          }
          expression.split(/,/g).forEach(function(variable) {
            var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
            values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
          });
          if (operator && operator !== "+") {
            var separator = ",";
            if (operator === "?") {
              separator = "&";
            } else if (operator !== "#") {
              separator = operator;
            }
            return (values.length !== 0 ? operator : "") + values.join(separator);
          } else {
            return values.join(",");
          }
        } else {
          return encodeReserved(literal);
        }
      });
    }
    function parse3(options) {
      let method = options.method.toUpperCase();
      let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
      let headers = Object.assign({}, options.headers);
      let body;
      let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]);
      const urlVariableNames = extractUrlVariableNames(url);
      url = parseUrl(url).expand(parameters);
      if (!/^http/.test(url)) {
        url = options.baseUrl + url;
      }
      const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
      const remainingParameters = omit(parameters, omittedParameters);
      const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
      if (!isBinaryRequest) {
        if (options.mediaType.format) {
          headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
        }
        if (options.mediaType.previews.length) {
          const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
          headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
            const format5 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
            return `application/vnd.github.${preview}-preview${format5}`;
          }).join(",");
        }
      }
      if (["GET", "HEAD"].includes(method)) {
        url = addQueryParameters(url, remainingParameters);
      } else {
        if ("data" in remainingParameters) {
          body = remainingParameters.data;
        } else {
          if (Object.keys(remainingParameters).length) {
            body = remainingParameters;
          } else {
            headers["content-length"] = 0;
          }
        }
      }
      if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
      }
      if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
        body = "";
      }
      return Object.assign({
        method,
        url,
        headers
      }, typeof body !== "undefined" ? {
        body
      } : null, options.request ? {
        request: options.request
      } : null);
    }
    function endpointWithDefaults(defaults, route, options) {
      return parse3(merge(defaults, route, options));
    }
    function withDefaults(oldDefaults, newDefaults) {
      const DEFAULTS2 = merge(oldDefaults, newDefaults);
      const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
      return Object.assign(endpoint2, {
        DEFAULTS: DEFAULTS2,
        defaults: withDefaults.bind(null, DEFAULTS2),
        merge: merge.bind(null, DEFAULTS2),
        parse: parse3
      });
    }
    var VERSION = "6.0.12";
    var userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`;
    var DEFAULTS = {
      method: "GET",
      baseUrl: "https://api.github.com",
      headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent
      },
      mediaType: {
        format: "",
        previews: []
      }
    };
    var endpoint = withDefaults(null, DEFAULTS);
    exports.endpoint = endpoint;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error2 = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error2 = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error2 = true;
          break;
        }
      }
      return {
        label,
        error: error2
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path16 = url.path;
      if (path16.length === 0) {
        return;
      }
      if (url.scheme === "file" && path16.length === 1 && isNormalizedWindowsDriveLetter(path16[0])) {
        return;
      }
      path16.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils3();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL6(url) {
      if (!this || this[impl] || !(this instanceof URL6)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL6.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL6.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL6.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL6.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL6.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL6.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL6,
      expose: {
        Window: { URL: URL6 },
        Worker: { URL: URL6 }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream3 = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable2 = Stream3.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable2();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough2 = Stream3.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream3)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream3) {
        body.on("error", function(err) {
          const error2 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error2;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream3)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve10, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve10(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream3 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough2();
        p2 = new PassThrough2();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream3) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL6 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL6(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream3.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream3.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream3.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve10, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error2 = new AbortError("The user aborted a request.");
          reject(error2);
          if (request.body && request.body instanceof Stream3.Readable) {
            destroyStream(request.body, error2);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error2);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s) {
            s.addListener("close", function(hadError) {
              const hasDataListener = s.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve10(fetch2(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve10(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve10(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve10(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response(body, response_options);
                resolve10(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve10(response);
            return;
          }
          response = new Response(body, response_options);
          resolve10(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s) {
        socket = s;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports = fetch2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.FetchError = FetchError;
  }
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node3 = __commonJS({
  "node_modules/deprecation/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Deprecation = class extends Error {
      constructor(message) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "Deprecation";
      }
    };
    exports.Deprecation = Deprecation;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/@actions/github/node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node4 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/request-error/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var deprecation = require_dist_node3();
    var once = _interopDefault(require_once());
    var logOnceCode = once((deprecation2) => console.warn(deprecation2));
    var logOnceHeaders = once((deprecation2) => console.warn(deprecation2));
    var RequestError = class extends Error {
      constructor(message, statusCode, options) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        let headers;
        if ("headers" in options && typeof options.headers !== "undefined") {
          headers = options.headers;
        }
        if ("response" in options) {
          this.response = options.response;
          headers = options.response.headers;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
          requestCopy.headers = Object.assign({}, options.request.headers, {
            authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
          });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
        Object.defineProperty(this, "code", {
          get() {
            logOnceCode(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
            return statusCode;
          }
        });
        Object.defineProperty(this, "headers", {
          get() {
            logOnceHeaders(new deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
            return headers || {};
          }
        });
      }
    };
    exports.RequestError = RequestError;
  }
});

// node_modules/@actions/github/node_modules/@octokit/request/dist-node/index.js
var require_dist_node5 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/request/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var endpoint = require_dist_node2();
    var universalUserAgent = require_dist_node();
    var isPlainObject = require_is_plain_object();
    var nodeFetch2 = _interopDefault(require_lib3());
    var requestError = require_dist_node4();
    var VERSION = "5.6.3";
    function getBufferResponse(response) {
      return response.arrayBuffer();
    }
    function fetchWrapper(requestOptions) {
      const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
      if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
        requestOptions.body = JSON.stringify(requestOptions.body);
      }
      let headers = {};
      let status;
      let url;
      const fetch2 = requestOptions.request && requestOptions.request.fetch || nodeFetch2;
      return fetch2(requestOptions.url, Object.assign(
        {
          method: requestOptions.method,
          body: requestOptions.body,
          headers: requestOptions.headers,
          redirect: requestOptions.redirect
        },
        // `requestOptions.request.agent` type is incompatible
        // see https://github.com/octokit/types.ts/pull/264
        requestOptions.request
      )).then(async (response) => {
        url = response.url;
        status = response.status;
        for (const keyAndValue of response.headers) {
          headers[keyAndValue[0]] = keyAndValue[1];
        }
        if ("deprecation" in headers) {
          const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
          const deprecationLink = matches && matches.pop();
          log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
        }
        if (status === 204 || status === 205) {
          return;
        }
        if (requestOptions.method === "HEAD") {
          if (status < 400) {
            return;
          }
          throw new requestError.RequestError(response.statusText, status, {
            response: {
              url,
              status,
              headers,
              data: void 0
            },
            request: requestOptions
          });
        }
        if (status === 304) {
          throw new requestError.RequestError("Not modified", status, {
            response: {
              url,
              status,
              headers,
              data: await getResponseData(response)
            },
            request: requestOptions
          });
        }
        if (status >= 400) {
          const data = await getResponseData(response);
          const error2 = new requestError.RequestError(toErrorMessage(data), status, {
            response: {
              url,
              status,
              headers,
              data
            },
            request: requestOptions
          });
          throw error2;
        }
        return getResponseData(response);
      }).then((data) => {
        return {
          status,
          url,
          headers,
          data
        };
      }).catch((error2) => {
        if (error2 instanceof requestError.RequestError)
          throw error2;
        throw new requestError.RequestError(error2.message, 500, {
          request: requestOptions
        });
      });
    }
    async function getResponseData(response) {
      const contentType = response.headers.get("content-type");
      if (/application\/json/.test(contentType)) {
        return response.json();
      }
      if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
      }
      return getBufferResponse(response);
    }
    function toErrorMessage(data) {
      if (typeof data === "string")
        return data;
      if ("message" in data) {
        if (Array.isArray(data.errors)) {
          return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
        }
        return data.message;
      }
      return `Unknown error: ${JSON.stringify(data)}`;
    }
    function withDefaults(oldEndpoint, newDefaults) {
      const endpoint2 = oldEndpoint.defaults(newDefaults);
      const newApi = function(route, parameters) {
        const endpointOptions = endpoint2.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
          return fetchWrapper(endpoint2.parse(endpointOptions));
        }
        const request2 = (route2, parameters2) => {
          return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
        };
        Object.assign(request2, {
          endpoint: endpoint2,
          defaults: withDefaults.bind(null, endpoint2)
        });
        return endpointOptions.request.hook(request2, endpointOptions);
      };
      return Object.assign(newApi, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      });
    }
    var request = withDefaults(endpoint.endpoint, {
      headers: {
        "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
      }
    });
    exports.request = request;
  }
});

// node_modules/@actions/github/node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node6 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/graphql/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var request = require_dist_node5();
    var universalUserAgent = require_dist_node();
    var VERSION = "4.8.0";
    function _buildMessageForResponseErrors(data) {
      return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
    }
    var GraphqlResponseError = class extends Error {
      constructor(request2, headers, response) {
        super(_buildMessageForResponseErrors(response));
        this.request = request2;
        this.headers = headers;
        this.response = response;
        this.name = "GraphqlResponseError";
        this.errors = response.errors;
        this.data = response.data;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    var NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
    var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
    var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
    function graphql(request2, query, options) {
      if (options) {
        if (typeof query === "string" && "query" in options) {
          return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
        }
        for (const key in options) {
          if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
            continue;
          return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
        }
      }
      const parsedOptions = typeof query === "string" ? Object.assign({
        query
      }, options) : query;
      const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
        if (NON_VARIABLE_OPTIONS.includes(key)) {
          result[key] = parsedOptions[key];
          return result;
        }
        if (!result.variables) {
          result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
      }, {});
      const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
      if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
      }
      return request2(requestOptions).then((response) => {
        if (response.data.errors) {
          const headers = {};
          for (const key of Object.keys(response.headers)) {
            headers[key] = response.headers[key];
          }
          throw new GraphqlResponseError(requestOptions, headers, response.data);
        }
        return response.data.data;
      });
    }
    function withDefaults(request$1, newDefaults) {
      const newRequest = request$1.defaults(newDefaults);
      const newApi = (query, options) => {
        return graphql(newRequest, query, options);
      };
      return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: request.request.endpoint
      });
    }
    var graphql$1 = withDefaults(request.request, {
      headers: {
        "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
      },
      method: "POST",
      url: "/graphql"
    });
    function withCustomRequest(customRequest) {
      return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql"
      });
    }
    exports.GraphqlResponseError = GraphqlResponseError;
    exports.graphql = graphql$1;
    exports.withCustomRequest = withCustomRequest;
  }
});

// node_modules/@actions/github/node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node7 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/auth-token/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
    var REGEX_IS_INSTALLATION = /^ghs_/;
    var REGEX_IS_USER_TO_SERVER = /^ghu_/;
    async function auth(token) {
      const isApp = token.split(/\./).length === 3;
      const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
      const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
      const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
      return {
        type: "token",
        token,
        tokenType
      };
    }
    function withAuthorizationPrefix(token) {
      if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
      }
      return `token ${token}`;
    }
    async function hook(token, request, route, parameters) {
      const endpoint = request.endpoint.merge(route, parameters);
      endpoint.headers.authorization = withAuthorizationPrefix(token);
      return request(endpoint);
    }
    var createTokenAuth = function createTokenAuth2(token) {
      if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
      }
      if (typeof token !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
      }
      token = token.replace(/^(token|bearer) +/i, "");
      return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token)
      });
    };
    exports.createTokenAuth = createTokenAuth;
  }
});

// node_modules/@actions/github/node_modules/@octokit/core/dist-node/index.js
var require_dist_node8 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/core/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var universalUserAgent = require_dist_node();
    var beforeAfterHook = require_before_after_hook();
    var request = require_dist_node5();
    var graphql = require_dist_node6();
    var authToken = require_dist_node7();
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    var VERSION = "3.6.0";
    var _excluded = ["authStrategy"];
    var Octokit = class {
      constructor(options = {}) {
        const hook = new beforeAfterHook.Collection();
        const requestDefaults = {
          baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
          headers: {},
          request: Object.assign({}, options.request, {
            // @ts-ignore internal usage only, no need to type
            hook: hook.bind(null, "request")
          }),
          mediaType: {
            previews: [],
            format: ""
          }
        };
        requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");
        if (options.baseUrl) {
          requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
          requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
          requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = request.request.defaults(requestDefaults);
        this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
        this.log = Object.assign({
          debug: () => {
          },
          info: () => {
          },
          warn: console.warn.bind(console),
          error: console.error.bind(console)
        }, options.log);
        this.hook = hook;
        if (!options.authStrategy) {
          if (!options.auth) {
            this.auth = async () => ({
              type: "unauthenticated"
            });
          } else {
            const auth = authToken.createTokenAuth(options.auth);
            hook.wrap("request", auth.hook);
            this.auth = auth;
          }
        } else {
          const {
            authStrategy
          } = options, otherOptions = _objectWithoutProperties(options, _excluded);
          const auth = authStrategy(Object.assign({
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          }, options.auth));
          hook.wrap("request", auth.hook);
          this.auth = auth;
        }
        const classConstructor = this.constructor;
        classConstructor.plugins.forEach((plugin) => {
          Object.assign(this, plugin(this, options));
        });
      }
      static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
          constructor(...args) {
            const options = args[0] || {};
            if (typeof defaults === "function") {
              super(defaults(options));
              return;
            }
            super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null));
          }
        };
        return OctokitWithDefaults;
      }
      /**
       * Attach a plugin (or many) to your Octokit instance.
       *
       * @example
       * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
       */
      static plugin(...newPlugins) {
        var _a;
        const currentPlugins = this.plugins;
        const NewOctokit = (_a = class extends this {
        }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
        return NewOctokit;
      }
    };
    Octokit.VERSION = VERSION;
    Octokit.plugins = [];
    exports.Octokit = Octokit;
  }
});

// node_modules/@actions/github/node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node9 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Endpoints = {
      actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
        addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
        cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
        createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
        createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
        createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
        deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
        deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
        deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
        deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
        disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
        downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
        downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
        downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
        downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
        enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
        getActionsCacheUsageForEnterprise: ["GET /enterprises/{enterprise}/actions/cache/usage"],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
        getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
        getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
        getGithubActionsDefaultWorkflowPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/workflow"],
        getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
        getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
        getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
        getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
        getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, {
          renamed: ["actions", "getGithubActionsPermissionsRepository"]
        }],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
        getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
        getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
        listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
        listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
        listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
        listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
        listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
        listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
        removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
        setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
        setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
        setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
        setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        setGithubActionsDefaultWorkflowPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/workflow"],
        setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
        setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
        setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
        setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
        setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
        setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"]
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
      },
      apps: {
        addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}", {}, {
          renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"]
        }],
        addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
        getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
        listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
        removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}", {}, {
          renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"]
        }],
        removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"]
      },
      billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
        getGithubAdvancedSecurityBillingGhe: ["GET /enterprises/{enterprise}/settings/billing/advanced-security"],
        getGithubAdvancedSecurityBillingOrg: ["GET /orgs/{org}/settings/billing/advanced-security"],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
        getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
        getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
      },
      checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
        rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
        setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
      },
      codeScanning: {
        deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
        getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
          renamedParameters: {
            alert_id: "alert_number"
          }
        }],
        getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", {}, {
          renamed: ["codeScanning", "listAlertInstances"]
        }],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
      },
      codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct"],
        getConductCode: ["GET /codes_of_conduct/{key}"]
      },
      codespaces: {
        addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
        createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
        createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
        exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
        getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
        listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: ["GET /orgs/{org}/codespaces", {}, {
          renamedParameters: {
            org_id: "org"
          }
        }],
        listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
        setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
      },
      dependabot: {
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"]
      },
      dependencyGraph: {
        createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
        diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"]
      },
      emojis: {
        get: ["GET /emojis"]
      },
      enterpriseAdmin: {
        addCustomLabelsToSelfHostedRunnerForEnterprise: ["POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
        disableSelectedOrganizationGithubActionsEnterprise: ["DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
        enableSelectedOrganizationGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
        getAllowedActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/selected-actions"],
        getGithubActionsPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions"],
        getServerStatistics: ["GET /enterprise-installation/{enterprise_or_org}/server-statistics"],
        listLabelsForSelfHostedRunnerForEnterprise: ["GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
        listSelectedOrganizationsEnabledGithubActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/organizations"],
        removeAllCustomLabelsFromSelfHostedRunnerForEnterprise: ["DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
        removeCustomLabelFromSelfHostedRunnerForEnterprise: ["DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}"],
        setAllowedActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/selected-actions"],
        setCustomLabelsForSelfHostedRunnerForEnterprise: ["PUT /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
        setGithubActionsPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions"],
        setSelectedOrganizationsEnabledGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations"]
      },
      gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
      },
      git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
      },
      gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"]
      },
      interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, {
          renamed: ["interactions", "getRestrictionsForAuthenticatedUser"]
        }],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
        removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, {
          renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"]
        }],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, {
          renamed: ["interactions", "setRestrictionsForAuthenticatedUser"]
        }]
      },
      issues: {
        addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
      },
      licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"]
      },
      markdown: {
        render: ["POST /markdown"],
        renderRaw: ["POST /markdown/raw", {
          headers: {
            "content-type": "text/plain; charset=utf-8"
          }
        }]
      },
      meta: {
        get: ["GET /meta"],
        getOctocat: ["GET /octocat"],
        getZen: ["GET /zen"],
        root: ["GET /"]
      },
      migrations: {
        cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
        deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
        deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
        downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
        getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
        getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
        getImportStatus: ["GET /repos/{owner}/{repo}/import"],
        getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {}, {
          renamed: ["migrations", "listReposForAuthenticatedUser"]
        }],
        mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
        setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: ["PUT /repos/{owner}/{repo}/import"],
        unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
        unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
        updateImport: ["PATCH /repos/{owner}/{repo}/import"]
      },
      orgs: {
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        get: ["GET /orgs/{org}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listCustomRoles: ["GET /organizations/{organization_id}/custom_roles"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
        removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
      },
      packages: {
        deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
        deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
        deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
        deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getAllPackageVersionsForAPackageOwnedByAnOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions", {}, {
          renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"]
        }],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions", {}, {
          renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"]
        }],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
        getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
        getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
        getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
        getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
        getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
        getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
        restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
        restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
      },
      projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"]
      },
      pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
        updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
      },
      rateLimit: {
        get: ["GET /rate_limit"]
      },
      reactions: {
        createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
        createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
        createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
        createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
        createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
        createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
        deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
        deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
        deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
        deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
        listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
        listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
        listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
        listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
        listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
      },
      repos: {
        acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}", {}, {
          renamed: ["repos", "acceptInvitationForAuthenticatedUser"]
        }],
        acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
        addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
          mapToData: "apps"
        }],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
          mapToData: "contexts"
        }],
        addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
          mapToData: "teams"
        }],
        addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
          mapToData: "users"
        }],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}", {}, {
          renamed: ["repos", "declineInvitationForAuthenticatedUser"]
        }],
        declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
        disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
        disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
        downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, {
          renamed: ["repos", "downloadZipballArchive"]
        }],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
        enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
        enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
        generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
        getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
        getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
        listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
        removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
          mapToData: "apps"
        }],
        removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
        removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
          mapToData: "contexts"
        }],
        removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
          mapToData: "teams"
        }],
        removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
          mapToData: "users"
        }],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
          mapToData: "apps"
        }],
        setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
          mapToData: "contexts"
        }],
        setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
          mapToData: "teams"
        }],
        setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
          mapToData: "users"
        }],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
        updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks", {}, {
          renamed: ["repos", "updateStatusCheckProtection"]
        }],
        updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
        uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
          baseUrl: "https://uploads.github.com"
        }]
      },
      search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"]
      },
      secretScanning: {
        getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
        listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
      },
      users: {
        addEmailForAuthenticated: ["POST /user/emails", {}, {
          renamed: ["users", "addEmailForAuthenticatedUser"]
        }],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: ["POST /user/gpg_keys", {}, {
          renamed: ["users", "createGpgKeyForAuthenticatedUser"]
        }],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: ["POST /user/keys", {}, {
          renamed: ["users", "createPublicSshKeyForAuthenticatedUser"]
        }],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        deleteEmailForAuthenticated: ["DELETE /user/emails", {}, {
          renamed: ["users", "deleteEmailForAuthenticatedUser"]
        }],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}", {}, {
          renamed: ["users", "deleteGpgKeyForAuthenticatedUser"]
        }],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}", {}, {
          renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"]
        }],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}", {}, {
          renamed: ["users", "getGpgKeyForAuthenticatedUser"]
        }],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}", {}, {
          renamed: ["users", "getPublicSshKeyForAuthenticatedUser"]
        }],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        list: ["GET /users"],
        listBlockedByAuthenticated: ["GET /user/blocks", {}, {
          renamed: ["users", "listBlockedByAuthenticatedUser"]
        }],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: ["GET /user/emails", {}, {
          renamed: ["users", "listEmailsForAuthenticatedUser"]
        }],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: ["GET /user/following", {}, {
          renamed: ["users", "listFollowedByAuthenticatedUser"]
        }],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: ["GET /user/gpg_keys", {}, {
          renamed: ["users", "listGpgKeysForAuthenticatedUser"]
        }],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: ["GET /user/public_emails", {}, {
          renamed: ["users", "listPublicEmailsForAuthenticatedUser"]
        }],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: ["GET /user/keys", {}, {
          renamed: ["users", "listPublicSshKeysForAuthenticatedUser"]
        }],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility", {}, {
          renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"]
        }],
        setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"]
      }
    };
    var VERSION = "5.16.2";
    function endpointsToMethods(octokit, endpointsMap) {
      const newMethods = {};
      for (const [scope, endpoints] of Object.entries(endpointsMap)) {
        for (const [methodName, endpoint] of Object.entries(endpoints)) {
          const [route, defaults, decorations] = endpoint;
          const [method, url] = route.split(/ /);
          const endpointDefaults = Object.assign({
            method,
            url
          }, defaults);
          if (!newMethods[scope]) {
            newMethods[scope] = {};
          }
          const scopeMethods = newMethods[scope];
          if (decorations) {
            scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
            continue;
          }
          scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
        }
      }
      return newMethods;
    }
    function decorate(octokit, scope, methodName, defaults, decorations) {
      const requestWithDefaults = octokit.request.defaults(defaults);
      function withDecorations(...args) {
        let options = requestWithDefaults.endpoint.merge(...args);
        if (decorations.mapToData) {
          options = Object.assign({}, options, {
            data: options[decorations.mapToData],
            [decorations.mapToData]: void 0
          });
          return requestWithDefaults(options);
        }
        if (decorations.renamed) {
          const [newScope, newMethodName] = decorations.renamed;
          octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
        }
        if (decorations.deprecated) {
          octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
          const options2 = requestWithDefaults.endpoint.merge(...args);
          for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
            if (name in options2) {
              octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
              if (!(alias in options2)) {
                options2[alias] = options2[name];
              }
              delete options2[name];
            }
          }
          return requestWithDefaults(options2);
        }
        return requestWithDefaults(...args);
      }
      return Object.assign(withDecorations, requestWithDefaults);
    }
    function restEndpointMethods2(octokit) {
      const api = endpointsToMethods(octokit, Endpoints);
      return {
        rest: api
      };
    }
    restEndpointMethods2.VERSION = VERSION;
    function legacyRestEndpointMethods(octokit) {
      const api = endpointsToMethods(octokit, Endpoints);
      return _objectSpread2(_objectSpread2({}, api), {}, {
        rest: api
      });
    }
    legacyRestEndpointMethods.VERSION = VERSION;
    exports.legacyRestEndpointMethods = legacyRestEndpointMethods;
    exports.restEndpointMethods = restEndpointMethods2;
  }
});

// node_modules/@actions/github/node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node10 = __commonJS({
  "node_modules/@actions/github/node_modules/@octokit/plugin-paginate-rest/dist-node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VERSION = "2.21.3";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function normalizePaginatedListResponse(response) {
      if (!response.data) {
        return _objectSpread2(_objectSpread2({}, response), {}, {
          data: []
        });
      }
      const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
      if (!responseNeedsNormalization)
        return response;
      const incompleteResults = response.data.incomplete_results;
      const repositorySelection = response.data.repository_selection;
      const totalCount = response.data.total_count;
      delete response.data.incomplete_results;
      delete response.data.repository_selection;
      delete response.data.total_count;
      const namespaceKey = Object.keys(response.data)[0];
      const data = response.data[namespaceKey];
      response.data = data;
      if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
      }
      if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
      }
      response.data.total_count = totalCount;
      return response;
    }
    function iterator(octokit, route, parameters) {
      const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
      const requestMethod = typeof route === "function" ? route : octokit.request;
      const method = options.method;
      const headers = options.headers;
      let url = options.url;
      return {
        [Symbol.asyncIterator]: () => ({
          async next() {
            if (!url)
              return {
                done: true
              };
            try {
              const response = await requestMethod({
                method,
                url,
                headers
              });
              const normalizedResponse = normalizePaginatedListResponse(response);
              url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
              return {
                value: normalizedResponse
              };
            } catch (error2) {
              if (error2.status !== 409)
                throw error2;
              url = "";
              return {
                value: {
                  status: 200,
                  headers: {},
                  data: []
                }
              };
            }
          }
        })
      };
    }
    function paginate(octokit, route, parameters, mapFn) {
      if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = void 0;
      }
      return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
    }
    function gather(octokit, results, iterator2, mapFn) {
      return iterator2.next().then((result) => {
        if (result.done) {
          return results;
        }
        let earlyExit = false;
        function done() {
          earlyExit = true;
        }
        results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
        if (earlyExit) {
          return results;
        }
        return gather(octokit, results, iterator2, mapFn);
      });
    }
    var composePaginateRest = Object.assign(paginate, {
      iterator
    });
    var paginatingEndpoints = ["GET /app/hook/deliveries", "GET /app/installations", "GET /applications/grants", "GET /authorizations", "GET /enterprises/{enterprise}/actions/permissions/organizations", "GET /enterprises/{enterprise}/actions/runner-groups", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners", "GET /enterprises/{enterprise}/actions/runners", "GET /enterprises/{enterprise}/audit-log", "GET /enterprises/{enterprise}/secret-scanning/alerts", "GET /enterprises/{enterprise}/settings/billing/advanced-security", "GET /events", "GET /gists", "GET /gists/public", "GET /gists/starred", "GET /gists/{gist_id}/comments", "GET /gists/{gist_id}/commits", "GET /gists/{gist_id}/forks", "GET /installation/repositories", "GET /issues", "GET /licenses", "GET /marketplace_listing/plans", "GET /marketplace_listing/plans/{plan_id}/accounts", "GET /marketplace_listing/stubbed/plans", "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts", "GET /networks/{owner}/{repo}/events", "GET /notifications", "GET /organizations", "GET /orgs/{org}/actions/cache/usage-by-repository", "GET /orgs/{org}/actions/permissions/repositories", "GET /orgs/{org}/actions/runner-groups", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners", "GET /orgs/{org}/actions/runners", "GET /orgs/{org}/actions/secrets", "GET /orgs/{org}/actions/secrets/{secret_name}/repositories", "GET /orgs/{org}/audit-log", "GET /orgs/{org}/blocks", "GET /orgs/{org}/code-scanning/alerts", "GET /orgs/{org}/codespaces", "GET /orgs/{org}/credential-authorizations", "GET /orgs/{org}/dependabot/secrets", "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories", "GET /orgs/{org}/events", "GET /orgs/{org}/external-groups", "GET /orgs/{org}/failed_invitations", "GET /orgs/{org}/hooks", "GET /orgs/{org}/hooks/{hook_id}/deliveries", "GET /orgs/{org}/installations", "GET /orgs/{org}/invitations", "GET /orgs/{org}/invitations/{invitation_id}/teams", "GET /orgs/{org}/issues", "GET /orgs/{org}/members", "GET /orgs/{org}/migrations", "GET /orgs/{org}/migrations/{migration_id}/repositories", "GET /orgs/{org}/outside_collaborators", "GET /orgs/{org}/packages", "GET /orgs/{org}/packages/{package_type}/{package_name}/versions", "GET /orgs/{org}/projects", "GET /orgs/{org}/public_members", "GET /orgs/{org}/repos", "GET /orgs/{org}/secret-scanning/alerts", "GET /orgs/{org}/settings/billing/advanced-security", "GET /orgs/{org}/team-sync/groups", "GET /orgs/{org}/teams", "GET /orgs/{org}/teams/{team_slug}/discussions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/invitations", "GET /orgs/{org}/teams/{team_slug}/members", "GET /orgs/{org}/teams/{team_slug}/projects", "GET /orgs/{org}/teams/{team_slug}/repos", "GET /orgs/{org}/teams/{team_slug}/teams", "GET /projects/columns/{column_id}/cards", "GET /projects/{project_id}/collaborators", "GET /projects/{project_id}/columns", "GET /repos/{owner}/{repo}/actions/artifacts", "GET /repos/{owner}/{repo}/actions/caches", "GET /repos/{owner}/{repo}/actions/runners", "GET /repos/{owner}/{repo}/actions/runs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs", "GET /repos/{owner}/{repo}/actions/secrets", "GET /repos/{owner}/{repo}/actions/workflows", "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs", "GET /repos/{owner}/{repo}/assignees", "GET /repos/{owner}/{repo}/branches", "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", "GET /repos/{owner}/{repo}/code-scanning/alerts", "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", "GET /repos/{owner}/{repo}/code-scanning/analyses", "GET /repos/{owner}/{repo}/codespaces", "GET /repos/{owner}/{repo}/codespaces/devcontainers", "GET /repos/{owner}/{repo}/codespaces/secrets", "GET /repos/{owner}/{repo}/collaborators", "GET /repos/{owner}/{repo}/comments", "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/commits", "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments", "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", "GET /repos/{owner}/{repo}/commits/{ref}/check-runs", "GET /repos/{owner}/{repo}/commits/{ref}/check-suites", "GET /repos/{owner}/{repo}/commits/{ref}/status", "GET /repos/{owner}/{repo}/commits/{ref}/statuses", "GET /repos/{owner}/{repo}/contributors", "GET /repos/{owner}/{repo}/dependabot/secrets", "GET /repos/{owner}/{repo}/deployments", "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses", "GET /repos/{owner}/{repo}/environments", "GET /repos/{owner}/{repo}/events", "GET /repos/{owner}/{repo}/forks", "GET /repos/{owner}/{repo}/git/matching-refs/{ref}", "GET /repos/{owner}/{repo}/hooks", "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries", "GET /repos/{owner}/{repo}/invitations", "GET /repos/{owner}/{repo}/issues", "GET /repos/{owner}/{repo}/issues/comments", "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/issues/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/comments", "GET /repos/{owner}/{repo}/issues/{issue_number}/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/labels", "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", "GET /repos/{owner}/{repo}/keys", "GET /repos/{owner}/{repo}/labels", "GET /repos/{owner}/{repo}/milestones", "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels", "GET /repos/{owner}/{repo}/notifications", "GET /repos/{owner}/{repo}/pages/builds", "GET /repos/{owner}/{repo}/projects", "GET /repos/{owner}/{repo}/pulls", "GET /repos/{owner}/{repo}/pulls/comments", "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments", "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits", "GET /repos/{owner}/{repo}/pulls/{pull_number}/files", "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments", "GET /repos/{owner}/{repo}/releases", "GET /repos/{owner}/{repo}/releases/{release_id}/assets", "GET /repos/{owner}/{repo}/releases/{release_id}/reactions", "GET /repos/{owner}/{repo}/secret-scanning/alerts", "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations", "GET /repos/{owner}/{repo}/stargazers", "GET /repos/{owner}/{repo}/subscribers", "GET /repos/{owner}/{repo}/tags", "GET /repos/{owner}/{repo}/teams", "GET /repos/{owner}/{repo}/topics", "GET /repositories", "GET /repositories/{repository_id}/environments/{environment_name}/secrets", "GET /search/code", "GET /search/commits", "GET /search/issues", "GET /search/labels", "GET /search/repositories", "GET /search/topics", "GET /search/users", "GET /teams/{team_id}/discussions", "GET /teams/{team_id}/discussions/{discussion_number}/comments", "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /teams/{team_id}/discussions/{discussion_number}/reactions", "GET /teams/{team_id}/invitations", "GET /teams/{team_id}/members", "GET /teams/{team_id}/projects", "GET /teams/{team_id}/repos", "GET /teams/{team_id}/teams", "GET /user/blocks", "GET /user/codespaces", "GET /user/codespaces/secrets", "GET /user/emails", "GET /user/followers", "GET /user/following", "GET /user/gpg_keys", "GET /user/installations", "GET /user/installations/{installation_id}/repositories", "GET /user/issues", "GET /user/keys", "GET /user/marketplace_purchases", "GET /user/marketplace_purchases/stubbed", "GET /user/memberships/orgs", "GET /user/migrations", "GET /user/migrations/{migration_id}/repositories", "GET /user/orgs", "GET /user/packages", "GET /user/packages/{package_type}/{package_name}/versions", "GET /user/public_emails", "GET /user/repos", "GET /user/repository_invitations", "GET /user/starred", "GET /user/subscriptions", "GET /user/teams", "GET /users", "GET /users/{username}/events", "GET /users/{username}/events/orgs/{org}", "GET /users/{username}/events/public", "GET /users/{username}/followers", "GET /users/{username}/following", "GET /users/{username}/gists", "GET /users/{username}/gpg_keys", "GET /users/{username}/keys", "GET /users/{username}/orgs", "GET /users/{username}/packages", "GET /users/{username}/projects", "GET /users/{username}/received_events", "GET /users/{username}/received_events/public", "GET /users/{username}/repos", "GET /users/{username}/starred", "GET /users/{username}/subscriptions"];
    function isPaginatingEndpoint(arg) {
      if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
      } else {
        return false;
      }
    }
    function paginateRest(octokit) {
      return {
        paginate: Object.assign(paginate.bind(null, octokit), {
          iterator: iterator.bind(null, octokit)
        })
      };
    }
    paginateRest.VERSION = VERSION;
    exports.composePaginateRest = composePaginateRest;
    exports.isPaginatingEndpoint = isPaginatingEndpoint;
    exports.paginateRest = paginateRest;
    exports.paginatingEndpoints = paginatingEndpoints;
  }
});

// node_modules/@actions/github/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/@actions/github/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
    var Context2 = __importStar(require_context());
    var Utils = __importStar(require_utils2());
    var core_1 = require_dist_node8();
    var plugin_rest_endpoint_methods_1 = require_dist_node9();
    var plugin_paginate_rest_1 = require_dist_node10();
    exports.context = new Context2.Context();
    var baseUrl = Utils.getApiBaseUrl();
    exports.defaults = {
      baseUrl,
      request: {
        agent: Utils.getProxyAgent(baseUrl)
      }
    };
    exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
    function getOctokitOptions(token, options) {
      const opts = Object.assign({}, options || {});
      const auth = Utils.getAuthString(token, opts);
      if (auth) {
        opts.auth = auth;
      }
      return opts;
    }
    exports.getOctokitOptions = getOctokitOptions;
  }
});

// node_modules/@actions/github/lib/github.js
var require_github = __commonJS({
  "node_modules/@actions/github/lib/github.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOctokit = exports.context = void 0;
    var Context2 = __importStar(require_context());
    var utils_1 = require_utils4();
    exports.context = new Context2.Context();
    function getOctokit2(token, options, ...additionalPlugins) {
      const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
      return new GitHubWithPlugins(utils_1.getOctokitOptions(token, options));
    }
    exports.getOctokit = getOctokit2;
  }
});

// node_modules/braces/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    module2.exports = (ast, options = {}) => {
      let stringify2 = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare2);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains2(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains2(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare2(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains2(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify2 = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify2(start, end, options) === false;
      let format5 = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format5(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format5 = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format5(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils5();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify2 = require_stringify();
    var utils = require_utils5();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify2(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify2(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module2) {
    "use strict";
    var stringify2 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse3 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify2(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse3;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var stringify2 = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse3 = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse3(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify2(braces.parse(input, options), options);
      }
      return stringify2(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path16.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path16 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path16.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils6();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob2 = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2)
          glob2 = utils.removeBackslashes(glob2);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils6();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse3(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix3 = POSIX_REGEX_SOURCE[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse3;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var scan = require_scan();
    var parse3 = require_parse2();
    var utils = require_utils6();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob2, options, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix3 = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob: glob2, posix: posix3 });
        const result = { glob: glob2, state, regex, posix: posix3, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob: glob2, posix: posix3 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format5 = opts.format || (posix3 ? utils.toPosixSlashes : null);
      let match = input === glob2;
      let output = match && format5 ? format5(input) : input;
      if (match === false) {
        output = format5 ? format5(input) : input;
        match = output === glob2;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix3);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob2, options, posix3 = utils.isWindows(options)) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
      return regex.test(path16.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils6();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob2, input, options) => {
      let posix3 = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob2), { ...options, capture: true });
      let match = regex.exec(posix3 ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node11 = __commonJS({
  "node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      legacyRestEndpointMethods: () => legacyRestEndpointMethods,
      restEndpointMethods: () => restEndpointMethods2
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var Endpoints = {
      actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
          "POST /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        addSelectedRepoToRequiredWorkflow: [
          "PUT /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}"
        ],
        approveWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
        ],
        cancelWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
        ],
        createEnvironmentVariable: [
          "POST /repositories/{repository_id}/environments/{environment_name}/variables"
        ],
        createOrUpdateEnvironmentSecret: [
          "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        createOrgVariable: ["POST /orgs/{org}/actions/variables"],
        createRegistrationTokenForOrg: [
          "POST /orgs/{org}/actions/runners/registration-token"
        ],
        createRegistrationTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/registration-token"
        ],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/remove-token"
        ],
        createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
        createRequiredWorkflow: ["POST /orgs/{org}/actions/required_workflows"],
        createWorkflowDispatch: [
          "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        ],
        deleteActionsCacheById: [
          "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
        ],
        deleteActionsCacheByKey: [
          "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
        ],
        deleteArtifact: [
          "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        ],
        deleteEnvironmentSecret: [
          "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        deleteEnvironmentVariable: [
          "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        deleteRepoVariable: [
          "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        deleteRequiredWorkflow: [
          "DELETE /orgs/{org}/actions/required_workflows/{required_workflow_id}"
        ],
        deleteSelfHostedRunnerFromOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}"
        ],
        deleteSelfHostedRunnerFromRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: [
          "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
          "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        disableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
        ],
        downloadArtifact: [
          "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
        ],
        downloadJobLogsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
        ],
        downloadWorkflowRunAttemptLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
        ],
        downloadWorkflowRunLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        enableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
        ],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: [
          "GET /orgs/{org}/actions/cache/usage-by-repository"
        ],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/selected-actions"
        ],
        getAllowedActionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getEnvironmentPublicKey: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
        ],
        getEnvironmentSecret: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        getEnvironmentVariable: [
          "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions/workflow"
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        getGithubActionsPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions"
        ],
        getGithubActionsPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions"
        ],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
        getPendingDeploymentsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        getRepoPermissions: [
          "GET /repos/{owner}/{repo}/actions/permissions",
          {},
          { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
        ],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoRequiredWorkflow: [
          "GET /repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}"
        ],
        getRepoRequiredWorkflowUsage: [
          "GET /repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/timing"
        ],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
        getRequiredWorkflow: [
          "GET /orgs/{org}/actions/required_workflows/{required_workflow_id}"
        ],
        getReviewsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
        ],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/access"
        ],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
        ],
        getWorkflowRunUsage: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
        ],
        getWorkflowUsage: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
        ],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
        ],
        listEnvironmentVariables: [
          "GET /repositories/{repository_id}/environments/{environment_name}/variables"
        ],
        listJobsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
        ],
        listJobsForWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
        ],
        listLabelsForSelfHostedRunnerForOrg: [
          "GET /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        listLabelsForSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listOrgVariables: ["GET /orgs/{org}/actions/variables"],
        listRepoOrganizationSecrets: [
          "GET /repos/{owner}/{repo}/actions/organization-secrets"
        ],
        listRepoOrganizationVariables: [
          "GET /repos/{owner}/{repo}/actions/organization-variables"
        ],
        listRepoRequiredWorkflows: [
          "GET /repos/{org}/{repo}/actions/required_workflows"
        ],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRequiredWorkflowRuns: [
          "GET /repos/{owner}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/runs"
        ],
        listRequiredWorkflows: ["GET /orgs/{org}/actions/required_workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/downloads"
        ],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        listSelectedReposForOrgVariable: [
          "GET /orgs/{org}/actions/variables/{name}/repositories"
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/repositories"
        ],
        listSelectedRepositoriesRequiredWorkflow: [
          "GET /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories"
        ],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
        ],
        listWorkflowRuns: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
        ],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
        ],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgVariable: [
          "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromRequiredWorkflow: [
          "DELETE /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}"
        ],
        reviewCustomGatesForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
        ],
        reviewPendingDeploymentsForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        setAllowedActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/selected-actions"
        ],
        setAllowedActionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
          "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
          "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/workflow"
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        setGithubActionsPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions"
        ],
        setGithubActionsPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories"
        ],
        setSelectedReposToRequiredWorkflow: [
          "PUT /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories"
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories"
        ],
        setWorkflowAccessToRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/access"
        ],
        updateEnvironmentVariable: [
          "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
        updateRepoVariable: [
          "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        updateRequiredWorkflow: [
          "PATCH /orgs/{org}/actions/required_workflows/{required_workflow_id}"
        ]
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: [
          "DELETE /notifications/threads/{thread_id}/subscription"
        ],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: [
          "GET /notifications/threads/{thread_id}/subscription"
        ],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: [
          "GET /users/{username}/events/orgs/{org}"
        ],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: [
          "GET /users/{username}/received_events/public"
        ],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/notifications"
        ],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: [
          "PUT /notifications/threads/{thread_id}/subscription"
        ],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
      },
      apps: {
        addRepoToInstallation: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
        ],
        addRepoToInstallationForAuthenticatedUser: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: [
          "POST /app/installations/{installation_id}/access_tokens"
        ],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: [
          "GET /marketplace_listing/accounts/{account_id}"
        ],
        getSubscriptionPlanForAccountStubbed: [
          "GET /marketplace_listing/stubbed/accounts/{account_id}"
        ],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: [
          "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
        ],
        listInstallationReposForAuthenticatedUser: [
          "GET /user/installations/{installation_id}/repositories"
        ],
        listInstallationRequestsForAuthenticatedApp: [
          "GET /app/installation-requests"
        ],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: [
          "GET /user/marketplace_purchases/stubbed"
        ],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: [
          "POST /app/hook/deliveries/{delivery_id}/attempts"
        ],
        removeRepoFromInstallation: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: [
          "DELETE /app/installations/{installation_id}/suspended"
        ],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"]
      },
      billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: [
          "GET /users/{username}/settings/billing/actions"
        ],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: [
          "GET /users/{username}/settings/billing/packages"
        ],
        getSharedStorageBillingOrg: [
          "GET /orgs/{org}/settings/billing/shared-storage"
        ],
        getSharedStorageBillingUser: [
          "GET /users/{username}/settings/billing/shared-storage"
        ]
      },
      checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: [
          "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
        ],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: [
          "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
        ],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: [
          "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
        ],
        rerequestSuite: [
          "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
        ],
        setSuitesPreferences: [
          "PATCH /repos/{owner}/{repo}/check-suites/preferences"
        ],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
      },
      codeScanning: {
        deleteAnalysis: [
          "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
        ],
        getAlert: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
          {},
          { renamedParameters: { alert_id: "alert_number" } }
        ],
        getAnalysis: [
          "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
        ],
        getCodeqlDatabase: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        ],
        getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
          {},
          { renamed: ["codeScanning", "listAlertInstances"] }
        ],
        listCodeqlDatabases: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
        ],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        ],
        updateDefaultSetup: [
          "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
        ],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
      },
      codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct"],
        getConductCode: ["GET /codes_of_conduct/{key}"]
      },
      codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        codespaceMachinesForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/machines"
        ],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}"
        ],
        createWithPrForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
        ],
        createWithRepoForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/codespaces"
        ],
        deleteCodespacesBillingUsers: [
          "DELETE /orgs/{org}/codespaces/billing/selected_users"
        ],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: [
          "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        deleteSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}"
        ],
        exportForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/exports"
        ],
        getCodespacesForUserInOrg: [
          "GET /orgs/{org}/members/{username}/codespaces"
        ],
        getExportDetailsForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/exports/{export_id}"
        ],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
        getPublicKeyForAuthenticatedUser: [
          "GET /user/codespaces/secrets/public-key"
        ],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        getSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}"
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/devcontainers"
        ],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: [
          "GET /orgs/{org}/codespaces",
          {},
          { renamedParameters: { org_id: "org" } }
        ],
        listInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces"
        ],
        listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}/repositories"
        ],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        preFlightWithRepoForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/new"
        ],
        publishForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/publish"
        ],
        removeRepositoryForSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        repoMachinesForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/machines"
        ],
        setCodespacesBilling: ["PUT /orgs/{org}/codespaces/billing"],
        setCodespacesBillingUsers: [
          "POST /orgs/{org}/codespaces/billing/selected_users"
        ],
        setRepositoriesForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: [
          "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
        ],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
      },
      dependabot: {
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/dependabot/alerts"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        ]
      },
      dependencyGraph: {
        createRepositorySnapshot: [
          "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
        ],
        diffRange: [
          "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
        ],
        exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
      },
      emojis: { get: ["GET /emojis"] },
      gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
      },
      git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
      },
      gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"]
      },
      interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: [
          "GET /user/interaction-limits",
          {},
          { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
        ],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: [
          "DELETE /repos/{owner}/{repo}/interaction-limits"
        ],
        removeRestrictionsForYourPublicRepos: [
          "DELETE /user/interaction-limits",
          {},
          { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
        ],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: [
          "PUT /user/interaction-limits",
          {},
          { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
        ]
      },
      issues: {
        addAssignees: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        checkUserCanBeAssignedToIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
        ],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
        ],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: [
          "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
        ],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
        ],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: [
          "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
        ],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        removeAssignees: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        removeLabel: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
        ],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: [
          "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
        ]
      },
      licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"]
      },
      markdown: {
        render: ["POST /markdown"],
        renderRaw: [
          "POST /markdown/raw",
          { headers: { "content-type": "text/plain; charset=utf-8" } }
        ]
      },
      meta: {
        get: ["GET /meta"],
        getAllVersions: ["GET /versions"],
        getOctocat: ["GET /octocat"],
        getZen: ["GET /zen"],
        root: ["GET /"]
      },
      migrations: {
        cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
        deleteArchiveForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/archive"
        ],
        deleteArchiveForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/archive"
        ],
        downloadArchiveForOrg: [
          "GET /orgs/{org}/migrations/{migration_id}/archive"
        ],
        getArchiveForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/archive"
        ],
        getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
        getImportStatus: ["GET /repos/{owner}/{repo}/import"],
        getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/repositories"
        ],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: [
          "GET /user/migrations/{migration_id}/repositories",
          {},
          { renamed: ["migrations", "listReposForAuthenticatedUser"] }
        ],
        mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
        setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: ["PUT /repos/{owner}/{repo}/import"],
        unlockRepoForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        unlockRepoForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        updateImport: ["PATCH /repos/{owner}/{repo}/import"]
      },
      orgs: {
        addSecurityManagerTeam: [
          "PUT /orgs/{org}/security-managers/teams/{team_slug}"
        ],
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: [
          "PUT /orgs/{org}/outside_collaborators/{username}"
        ],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        delete: ["DELETE /orgs/{org}"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        enableOrDisableSecurityProductOnAllOrgRepos: [
          "POST /orgs/{org}/{security_product}/{enablement}"
        ],
        get: ["GET /orgs/{org}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: [
          "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPatGrantRepositories: [
          "GET /organizations/{org}/personal-access-tokens/{pat_id}/repositories"
        ],
        listPatGrantRequestRepositories: [
          "GET /organizations/{org}/personal-access-token-requests/{pat_request_id}/repositories"
        ],
        listPatGrantRequests: [
          "GET /organizations/{org}/personal-access-token-requests"
        ],
        listPatGrants: ["GET /organizations/{org}/personal-access-tokens"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
          "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: [
          "DELETE /orgs/{org}/outside_collaborators/{username}"
        ],
        removePublicMembershipForAuthenticatedUser: [
          "DELETE /orgs/{org}/public_members/{username}"
        ],
        removeSecurityManagerTeam: [
          "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
        ],
        reviewPatGrantRequest: [
          "POST /organizations/{org}/personal-access-token-requests/{pat_request_id}"
        ],
        reviewPatGrantRequestsInBulk: [
          "POST /organizations/{org}/personal-access-token-requests"
        ],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: [
          "PUT /orgs/{org}/public_members/{username}"
        ],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: [
          "PATCH /user/memberships/orgs/{org}"
        ],
        updatePatAccess: [
          "POST /organizations/{org}/personal-access-tokens/{pat_id}"
        ],
        updatePatAccesses: ["POST /organizations/{org}/personal-access-tokens"],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
      },
      packages: {
        deletePackageForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}"
        ],
        deletePackageForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        deletePackageForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}"
        ],
        deletePackageVersionForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
          {},
          { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions",
          {},
          {
            renamed: [
              "packages",
              "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
            ]
          }
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions"
        ],
        getPackageForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}"
        ],
        getPackageForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        getPackageForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}"
        ],
        getPackageVersionForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        listDockerMigrationConflictingPackagesForAuthenticatedUser: [
          "GET /user/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForOrganization: [
          "GET /orgs/{org}/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForUser: [
          "GET /users/{username}/docker/conflicts"
        ],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageVersionForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ]
      },
      projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: [
          "GET /projects/{project_id}/collaborators/{username}/permission"
        ],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: [
          "DELETE /projects/{project_id}/collaborators/{username}"
        ],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"]
      },
      pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
        ],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        deletePendingReview: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        deleteReviewComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ],
        dismissReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
        ],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
        ],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        listReviewComments: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        requestReviewers: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        submitReview: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
        ],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
        ],
        updateReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        updateReviewComment: [
          "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ]
      },
      rateLimit: { get: ["GET /rate_limit"] },
      reactions: {
        createForCommitComment: [
          "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        createForIssue: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
        ],
        createForIssueComment: [
          "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        createForPullRequestReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        createForRelease: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        createForTeamDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        createForTeamDiscussionInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ],
        deleteForCommitComment: [
          "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForIssue: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
        ],
        deleteForIssueComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForPullRequestComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForRelease: [
          "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussion: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussionComment: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
        ],
        listForCommitComment: [
          "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: [
          "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        listForPullRequestReviewComment: [
          "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        listForRelease: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        listForTeamDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        listForTeamDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ]
      },
      repos: {
        acceptInvitation: [
          "PATCH /user/repository_invitations/{invitation_id}",
          {},
          { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
        ],
        acceptInvitationForAuthenticatedUser: [
          "PATCH /user/repository_invitations/{invitation_id}"
        ],
        addAppAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        addTeamAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        addUserAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: [
          "GET /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: [
          "GET /repos/{owner}/{repo}/compare/{basehead}"
        ],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: [
          "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        createCommitSignatureProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentBranchPolicy: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        createDeploymentProtectionRule: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        createDeploymentStatus: [
          "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateEnvironment: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createOrgRuleset: ["POST /orgs/{org}/rulesets"],
        createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployment"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: [
          "POST /repos/{template_owner}/{template_repo}/generate"
        ],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: [
          "DELETE /user/repository_invitations/{invitation_id}",
          {},
          { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
        ],
        declineInvitationForAuthenticatedUser: [
          "DELETE /user/repository_invitations/{invitation_id}"
        ],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        deleteAdminBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        deleteAnEnvironment: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: [
          "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
        ],
        deleteDeploymentBranchPolicy: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: [
          "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: [
          "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        deleteTagProtection: [
          "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
        ],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: [
          "DELETE /repos/{owner}/{repo}/automated-security-fixes"
        ],
        disableDeploymentProtectionRule: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
        disableVulnerabilityAlerts: [
          "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        downloadArchive: [
          "GET /repos/{owner}/{repo}/zipball/{ref}",
          {},
          { renamed: ["repos", "downloadZipballArchive"] }
        ],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: [
          "PUT /repos/{owner}/{repo}/automated-security-fixes"
        ],
        enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
        enableVulnerabilityAlerts: [
          "PUT /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        generateReleaseNotes: [
          "POST /repos/{owner}/{repo}/releases/generate-notes"
        ],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        getAdminBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        getAllDeploymentProtectionRules: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        ],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        ],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: [
          "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
        ],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getCustomDeploymentProtectionRule: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentBranchPolicy: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        getDeploymentStatus: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
        ],
        getEnvironment: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
        getOrgRulesets: ["GET /orgs/{org}/rulesets"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
        getStatusChecksProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        getTeamsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        ],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        ],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        getWebhookDelivery: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
        ],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: [
          "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
        ],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listCustomDeploymentRuleIntegrations: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
        ],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentBranchPolicies: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        listDeploymentStatuses: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
        ],
        listReleaseAssets: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
        ],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
        ],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
          "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeAppAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        removeCollaborator: [
          "DELETE /repos/{owner}/{repo}/collaborators/{username}"
        ],
        removeStatusCheckContexts: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        removeStatusCheckProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        removeTeamAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        removeUserAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        setAppAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        setStatusCheckContexts: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        setTeamAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        setUserAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateDeploymentBranchPolicy: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: [
          "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
        updatePullRequestReviewProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: [
          "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        updateStatusCheckPotection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          {},
          { renamed: ["repos", "updateStatusCheckProtection"] }
        ],
        updateStatusCheckProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: [
          "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        uploadReleaseAsset: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
          { baseUrl: "https://uploads.github.com" }
        ]
      },
      search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"]
      },
      secretScanning: {
        getAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/secret-scanning/alerts"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ]
      },
      securityAdvisories: {
        createPrivateVulnerabilityReport: [
          "POST /repos/{owner}/{repo}/security-advisories/reports"
        ],
        createRepositoryAdvisory: [
          "POST /repos/{owner}/{repo}/security-advisories"
        ],
        getRepositoryAdvisory: [
          "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ],
        listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
        updateRepositoryAdvisory: [
          "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ]
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        addOrUpdateProjectPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        addOrUpdateRepoPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        checkPermissionsForProjectInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        checkPermissionsForRepoInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        deleteDiscussionInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        getDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        getMembershipForUserInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/invitations"
        ],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        removeProjectInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        removeRepoInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        updateDiscussionCommentInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        updateDiscussionInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
      },
      users: {
        addEmailForAuthenticated: [
          "POST /user/emails",
          {},
          { renamed: ["users", "addEmailForAuthenticatedUser"] }
        ],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: [
          "POST /user/gpg_keys",
          {},
          { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
        ],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: [
          "POST /user/keys",
          {},
          { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
        ],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
        deleteEmailForAuthenticated: [
          "DELETE /user/emails",
          {},
          { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
        ],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: [
          "DELETE /user/gpg_keys/{gpg_key_id}",
          {},
          { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
        ],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: [
          "DELETE /user/keys/{key_id}",
          {},
          { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
        ],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
        deleteSshSigningKeyForAuthenticatedUser: [
          "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: [
          "GET /user/gpg_keys/{gpg_key_id}",
          {},
          { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
        ],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: [
          "GET /user/keys/{key_id}",
          {},
          { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
        ],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        getSshSigningKeyForAuthenticatedUser: [
          "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        list: ["GET /users"],
        listBlockedByAuthenticated: [
          "GET /user/blocks",
          {},
          { renamed: ["users", "listBlockedByAuthenticatedUser"] }
        ],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: [
          "GET /user/emails",
          {},
          { renamed: ["users", "listEmailsForAuthenticatedUser"] }
        ],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: [
          "GET /user/following",
          {},
          { renamed: ["users", "listFollowedByAuthenticatedUser"] }
        ],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: [
          "GET /user/gpg_keys",
          {},
          { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
        ],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: [
          "GET /user/public_emails",
          {},
          { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
        ],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: [
          "GET /user/keys",
          {},
          { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
        ],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
        listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
        listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
        listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
          "PATCH /user/email/visibility",
          {},
          { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
          "PATCH /user/email/visibility"
        ],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"]
      }
    };
    var endpoints_default = Endpoints;
    var VERSION = "7.1.3";
    function endpointsToMethods(octokit, endpointsMap) {
      const newMethods = {};
      for (const [scope, endpoints] of Object.entries(endpointsMap)) {
        for (const [methodName, endpoint] of Object.entries(endpoints)) {
          const [route, defaults, decorations] = endpoint;
          const [method, url] = route.split(/ /);
          const endpointDefaults = Object.assign(
            { method, url },
            defaults
          );
          if (!newMethods[scope]) {
            newMethods[scope] = {};
          }
          const scopeMethods = newMethods[scope];
          if (decorations) {
            scopeMethods[methodName] = decorate(
              octokit,
              scope,
              methodName,
              endpointDefaults,
              decorations
            );
            continue;
          }
          scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
        }
      }
      return newMethods;
    }
    function decorate(octokit, scope, methodName, defaults, decorations) {
      const requestWithDefaults = octokit.request.defaults(defaults);
      function withDecorations(...args) {
        let options = requestWithDefaults.endpoint.merge(...args);
        if (decorations.mapToData) {
          options = Object.assign({}, options, {
            data: options[decorations.mapToData],
            [decorations.mapToData]: void 0
          });
          return requestWithDefaults(options);
        }
        if (decorations.renamed) {
          const [newScope, newMethodName] = decorations.renamed;
          octokit.log.warn(
            `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
          );
        }
        if (decorations.deprecated) {
          octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
          const options2 = requestWithDefaults.endpoint.merge(...args);
          for (const [name, alias] of Object.entries(
            decorations.renamedParameters
          )) {
            if (name in options2) {
              octokit.log.warn(
                `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
              );
              if (!(alias in options2)) {
                options2[alias] = options2[name];
              }
              delete options2[name];
            }
          }
          return requestWithDefaults(options2);
        }
        return requestWithDefaults(...args);
      }
      return Object.assign(withDecorations, requestWithDefaults);
    }
    function restEndpointMethods2(octokit) {
      const api = endpointsToMethods(octokit, endpoints_default);
      return {
        rest: api
      };
    }
    restEndpointMethods2.VERSION = VERSION;
    function legacyRestEndpointMethods(octokit) {
      const api = endpointsToMethods(octokit, endpoints_default);
      return {
        ...api,
        rest: api
      };
    }
    legacyRestEndpointMethods.VERSION = VERSION;
  }
});

// node_modules/vscode-uri/lib/umd/index.js
var require_umd = __commonJS({
  "node_modules/vscode-uri/lib/umd/index.js"(exports, module2) {
    !function(t, e) {
      if ("object" == typeof exports && "object" == typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var r = e();
        for (var n in r)
          ("object" == typeof exports ? exports : t)[n] = r[n];
      }
    }(exports, () => (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", o = 0, i = -1, a = 0, s = 0; s <= t3.length; ++s) {
            if (s < t3.length)
              r3 = t3.charCodeAt(s);
            else {
              if (47 === r3)
                break;
              r3 = 47;
            }
            if (47 === r3) {
              if (i === s - 1 || 1 === a)
                ;
              else if (i !== s - 1 && 2 === a) {
                if (n3.length < 2 || 2 !== o || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var h = n3.lastIndexOf("/");
                    if (h !== n3.length - 1) {
                      -1 === h ? (n3 = "", o = 0) : o = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), i = s, a = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", o = 0, i = s, a = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o = 2);
              } else
                n3.length > 0 ? n3 += "/" + t3.slice(i + 1, s) : n3 = t3.slice(i + 1, s), o = s - i - 1;
              i = s, a = 0;
            } else
              46 === r3 && -1 !== a ? ++a : a = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
            var a;
            i >= 0 ? a = arguments[i] : (void 0 === t3 && (t3 = process.cwd()), a = t3), e2(a), 0 !== a.length && (n3 = a + "/" + n3, o = 47 === a.charCodeAt(0));
          }
          return n3 = r2(n3, !o), o ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          var n3 = 47 === t3.charCodeAt(0), o = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length)
            return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var o = arguments[r3];
            e2(o), o.length > 0 && (void 0 === t3 ? t3 = o : t3 += "/" + o);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3)
            return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
            return "";
          for (var o = 1; o < t3.length && 47 === t3.charCodeAt(o); ++o)
            ;
          for (var i = t3.length, a = i - o, s = 1; s < r3.length && 47 === r3.charCodeAt(s); ++s)
            ;
          for (var h = r3.length - s, c = a < h ? a : h, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (h > c) {
                if (47 === r3.charCodeAt(s + u))
                  return r3.slice(s + u + 1);
                if (0 === u)
                  return r3.slice(s + u);
              } else
                a > c && (47 === t3.charCodeAt(o + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(o + u);
            if (l !== r3.charCodeAt(s + u))
              break;
            47 === l && (f = u);
          }
          var p = "";
          for (u = o + f + 1; u <= i; ++u)
            u !== i && 47 !== t3.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
          return p.length > 0 ? p + r3.slice(s + f) : (s += f, 47 === r3.charCodeAt(s) && ++s, r3.slice(s));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
            if (47 === (r3 = t3.charCodeAt(a))) {
              if (!i) {
                o = a;
                break;
              }
            } else
              i = false;
          return -1 === o ? n3 ? "/" : "." : n3 && 1 === o ? "//" : t3.slice(0, o);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3)
            throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, o = 0, i = -1, a = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3)
              return "";
            var s = r3.length - 1, h = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!a) {
                  o = n3 + 1;
                  break;
                }
              } else
                -1 === h && (a = false, h = n3 + 1), s >= 0 && (c === r3.charCodeAt(s) ? -1 == --s && (i = n3) : (s = -1, i = h));
            }
            return o === i ? i = h : -1 === i && (i = t3.length), t3.slice(o, i);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3)
            if (47 === t3.charCodeAt(n3)) {
              if (!a) {
                o = n3 + 1;
                break;
              }
            } else
              -1 === i && (a = false, i = n3 + 1);
          return -1 === i ? "" : t3.slice(o, i);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, o = -1, i = true, a = 0, s = t3.length - 1; s >= 0; --s) {
            var h = t3.charCodeAt(s);
            if (47 !== h)
              -1 === o && (i = false, o = s + 1), 46 === h ? -1 === r3 ? r3 = s : 1 !== a && (a = 1) : -1 !== r3 && (a = -1);
            else if (!i) {
              n3 = s + 1;
              break;
            }
          }
          return -1 === r3 || -1 === o || 0 === a || 1 === a && r3 === o - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, o);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3)
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length)
            return r3;
          var n3, o = t3.charCodeAt(0), i = 47 === o;
          i ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var a = -1, s = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
            if (47 !== (o = t3.charCodeAt(f)))
              -1 === h && (c = false, h = f + 1), 46 === o ? -1 === a ? a = f : 1 !== u && (u = 1) : -1 !== a && (u = -1);
            else if (!c) {
              s = f + 1;
              break;
            }
          return -1 === a || -1 === h || 0 === u || 1 === u && a === h - 1 && a === s + 1 ? -1 !== h && (r3.base = r3.name = 0 === s && i ? t3.slice(1, h) : t3.slice(s, h)) : (0 === s && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(s, a), r3.base = t3.slice(s, h)), r3.ext = t3.slice(a, h)), s > 0 ? r3.dir = t3.slice(0, s - 1) : i && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      }, 674: (t2, e2) => {
        if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process)
          e2.isWindows = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          var r2 = navigator.userAgent;
          e2.isWindows = r2.indexOf("Windows") >= 0;
        }
      }, 796: function(t2, e2, r2) {
        var n2, o, i = this && this.__extends || (n2 = function(t3, e3) {
          return n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
            t4.__proto__ = e4;
          } || function(t4, e4) {
            for (var r3 in e4)
              Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
          }, n2(t3, e3);
        }, function(t3, e3) {
          if ("function" != typeof e3 && null !== e3)
            throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
          function r3() {
            this.constructor = t3;
          }
          n2(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
        });
        Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
        var a = r2(674), s = /^\w[\w\d+.-]*$/, h = /^\//, c = /^\/\//;
        function f(t3, e3) {
          if (!t3.scheme && e3)
            throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
          if (t3.scheme && !s.test(t3.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!h.test(t3.path))
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (c.test(t3.path))
              throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, d = function() {
          function t3(t4, e3, r3, n3, o2, i2) {
            void 0 === i2 && (i2 = false), "object" == typeof t4 ? (this.scheme = t4.scheme || u, this.authority = t4.authority || u, this.path = t4.path || u, this.query = t4.query || u, this.fragment = t4.fragment || u) : (this.scheme = function(t5, e4) {
              return t5 || e4 ? t5 : "file";
            }(t4, i2), this.authority = e3 || u, this.path = function(t5, e4) {
              switch (t5) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== l && (e4 = l + e4) : e4 = l;
              }
              return e4;
            }(this.scheme, r3 || u), this.query = n3 || u, this.fragment = o2 || u, f(this, i2));
          }
          return t3.isUri = function(e3) {
            return e3 instanceof t3 || !!e3 && "string" == typeof e3.authority && "string" == typeof e3.fragment && "string" == typeof e3.path && "string" == typeof e3.query && "string" == typeof e3.scheme && "string" == typeof e3.fsPath && "function" == typeof e3.with && "function" == typeof e3.toString;
          }, Object.defineProperty(t3.prototype, "fsPath", { get: function() {
            return C(this, false);
          }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {
            if (!t4)
              return this;
            var e3 = t4.scheme, r3 = t4.authority, n3 = t4.path, o2 = t4.query, i2 = t4.fragment;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = u), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = u), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = u), void 0 === o2 ? o2 = this.query : null === o2 && (o2 = u), void 0 === i2 ? i2 = this.fragment : null === i2 && (i2 = u), e3 === this.scheme && r3 === this.authority && n3 === this.path && o2 === this.query && i2 === this.fragment ? this : new v(e3, r3, n3, o2, i2);
          }, t3.parse = function(t4, e3) {
            void 0 === e3 && (e3 = false);
            var r3 = p.exec(t4);
            return r3 ? new v(r3[2] || u, x(r3[4] || u), x(r3[5] || u), x(r3[7] || u), x(r3[9] || u), e3) : new v(u, u, u, u, u);
          }, t3.file = function(t4) {
            var e3 = u;
            if (a.isWindows && (t4 = t4.replace(/\\/g, l)), t4[0] === l && t4[1] === l) {
              var r3 = t4.indexOf(l, 2);
              -1 === r3 ? (e3 = t4.substring(2), t4 = l) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || l);
            }
            return new v("file", e3, t4, u, u);
          }, t3.from = function(t4) {
            var e3 = new v(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
            return f(e3, true), e3;
          }, t3.prototype.toString = function(t4) {
            return void 0 === t4 && (t4 = false), A(this, t4);
          }, t3.prototype.toJSON = function() {
            return this;
          }, t3.revive = function(e3) {
            if (e3) {
              if (e3 instanceof t3)
                return e3;
              var r3 = new v(e3);
              return r3._formatted = e3.external, r3._fsPath = e3._sep === g ? e3.fsPath : null, r3;
            }
            return e3;
          }, t3;
        }();
        e2.URI = d;
        var g = a.isWindows ? 1 : void 0, v = function(t3) {
          function e3() {
            var e4 = null !== t3 && t3.apply(this, arguments) || this;
            return e4._formatted = null, e4._fsPath = null, e4;
          }
          return i(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
            return this._fsPath || (this._fsPath = C(this, false)), this._fsPath;
          }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
            return void 0 === t4 && (t4 = false), t4 ? A(this, true) : (this._formatted || (this._formatted = A(this, false)), this._formatted);
          }, e3.prototype.toJSON = function() {
            var t4 = { $mid: 1 };
            return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = g), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
          }, e3;
        }(d), y = ((o = {})[58] = "%3A", o[47] = "%2F", o[63] = "%3F", o[35] = "%23", o[91] = "%5B", o[93] = "%5D", o[64] = "%40", o[33] = "%21", o[36] = "%24", o[38] = "%26", o[39] = "%27", o[40] = "%28", o[41] = "%29", o[42] = "%2A", o[43] = "%2B", o[44] = "%2C", o[59] = "%3B", o[61] = "%3D", o[32] = "%20", o);
        function m(t3, e3, r3) {
          for (var n3 = void 0, o2 = -1, i2 = 0; i2 < t3.length; i2++) {
            var a2 = t3.charCodeAt(i2);
            if (a2 >= 97 && a2 <= 122 || a2 >= 65 && a2 <= 90 || a2 >= 48 && a2 <= 57 || 45 === a2 || 46 === a2 || 95 === a2 || 126 === a2 || e3 && 47 === a2 || r3 && 91 === a2 || r3 && 93 === a2 || r3 && 58 === a2)
              -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), void 0 !== n3 && (n3 += t3.charAt(i2));
            else {
              void 0 === n3 && (n3 = t3.substr(0, i2));
              var s2 = y[a2];
              void 0 !== s2 ? (-1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), n3 += s2) : -1 === o2 && (o2 = i2);
            }
          }
          return -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2))), void 0 !== n3 ? n3 : t3;
        }
        function b(t3) {
          for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3.charCodeAt(r3);
            35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += y[n3]) : void 0 !== e3 && (e3 += t3[r3]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function C(t3, e3) {
          var r3;
          return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? "//".concat(t3.authority).concat(t3.path) : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, a.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function A(t3, e3) {
          var r3 = e3 ? b : m, n3 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, s2 = t3.query, h2 = t3.fragment;
          if (o2 && (n3 += o2, n3 += ":"), (i2 || "file" === o2) && (n3 += l, n3 += l), i2) {
            var c2 = i2.indexOf("@");
            if (-1 !== c2) {
              var f2 = i2.substr(0, c2);
              i2 = i2.substr(c2 + 1), -1 === (c2 = f2.lastIndexOf(":")) ? n3 += r3(f2, false, false) : (n3 += r3(f2.substr(0, c2), false, false), n3 += ":", n3 += r3(f2.substr(c2 + 1), false, true)), n3 += "@";
            }
            -1 === (c2 = (i2 = i2.toLowerCase()).lastIndexOf(":")) ? n3 += r3(i2, false, true) : (n3 += r3(i2.substr(0, c2), false, true), n3 += i2.substr(c2));
          }
          if (a2) {
            if (a2.length >= 3 && 47 === a2.charCodeAt(0) && 58 === a2.charCodeAt(2))
              (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
            else if (a2.length >= 2 && 58 === a2.charCodeAt(1)) {
              var u2;
              (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
            }
            n3 += r3(a2, true, false);
          }
          return s2 && (n3 += "?", n3 += r3(s2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : m(h2, false, false)), n3;
        }
        function w(t3) {
          try {
            return decodeURIComponent(t3);
          } catch (e3) {
            return t3.length > 3 ? t3.substr(0, 3) + w(t3.substr(3)) : t3;
          }
        }
        e2.uriToFsPath = C;
        var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function x(t3) {
          return t3.match(_) ? t3.replace(_, function(t4) {
            return w(t4);
          }) : t3;
        }
      }, 679: function(t2, e2, r2) {
        var n2 = this && this.__spreadArray || function(t3, e3, r3) {
          if (r3 || 2 === arguments.length)
            for (var n3, o2 = 0, i2 = e3.length; o2 < i2; o2++)
              !n3 && o2 in e3 || (n3 || (n3 = Array.prototype.slice.call(e3, 0, o2)), n3[o2] = e3[o2]);
          return t3.concat(n3 || Array.prototype.slice.call(e3));
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
        var o, i = r2(470), a = i.posix || i, s = "/";
        (o = e2.Utils || (e2.Utils = {})).joinPath = function(t3) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          return t3.with({ path: a.join.apply(a, n2([t3.path], e3, false)) });
        }, o.resolvePath = function(t3) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          var o2 = t3.path, i2 = false;
          o2[0] !== s && (o2 = s + o2, i2 = true);
          var h = a.resolve.apply(a, n2([o2], e3, false));
          return i2 && h[0] === s && !t3.authority && (h = h.substring(1)), t3.with({ path: h });
        }, o.dirname = function(t3) {
          if (0 === t3.path.length || t3.path === s)
            return t3;
          var e3 = a.dirname(t3.path);
          return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t3.with({ path: e3 });
        }, o.basename = function(t3) {
          return a.basename(t3.path);
        }, o.extname = function(t3) {
          return a.extname(t3.path);
        };
      } }, e = {};
      function r(n2) {
        var o = e[n2];
        if (void 0 !== o)
          return o.exports;
        var i = e[n2] = { exports: {} };
        return t[n2].call(i.exports, i, i.exports, r), i.exports;
      }
      var n = {};
      return (() => {
        var t2 = n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
        var e2 = r(796);
        Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
          return e2.URI;
        } });
        var o = r(679);
        Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
          return o.Utils;
        } });
      })(), n;
    })());
  }
});

// node_modules/cspell-glob/dist/cjs/globHelper.js
var require_globHelper = __commonJS({
  "node_modules/cspell-glob/dist/cjs/globHelper.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.normalizeGlobToRoot = exports.normalizeGlobPattern = exports.normalizeGlobPatterns = exports.isGlobPatternNormalized = exports.isGlobPatternWithRoot = exports.isGlobPatternWithOptionalRoot = exports.doesRootContainPath = exports.fileOrGlobToGlob = void 0;
    var Path3 = __importStar(require("path"));
    var { posix: posix3 } = Path3;
    var relRegExp2 = /^\.[\\/]/;
    var isGlobalPatternRegExp2 = /^!*[*]{2}/;
    function fileOrGlobToGlob2(fileOrGlob, root, path16 = Path3) {
      const pathToGlob = path16.sep === "\\" ? (p) => p.replace(/\\/g, "/") : (p) => p;
      const isGlobalPattern = false;
      if (isGlobPatternWithOptionalRoot2(fileOrGlob)) {
        const useRoot = fileOrGlob.root ?? root;
        const isGlobalPattern2 = isGlobPatternWithRoot2(fileOrGlob) ? fileOrGlob.isGlobalPattern : isGlobalGlob2(fileOrGlob.glob);
        return { ...fileOrGlob, root: useRoot, isGlobalPattern: isGlobalPattern2 };
      }
      if (doesRootContainPath2(root, fileOrGlob, path16) || relRegExp2.test(fileOrGlob)) {
        const rel = path16.relative(root, path16.resolve(root, fileOrGlob));
        return { glob: pathToGlob(rel), root, isGlobalPattern };
      }
      return { glob: pathToGlob(fileOrGlob), root, isGlobalPattern };
    }
    exports.fileOrGlobToGlob = fileOrGlobToGlob2;
    function doesRootContainPath2(root, child, path16) {
      if (child.startsWith(root))
        return true;
      const rel = path16.relative(root, child);
      return !rel || rel !== child && !rel.startsWith("..") && !path16.isAbsolute(rel);
    }
    exports.doesRootContainPath = doesRootContainPath2;
    function isGlobPatternWithOptionalRoot2(g) {
      return typeof g !== "string" && typeof g.glob === "string";
    }
    exports.isGlobPatternWithOptionalRoot = isGlobPatternWithOptionalRoot2;
    function isGlobPatternWithRoot2(g) {
      return typeof g.root === "string" && "isGlobalPattern" in g;
    }
    exports.isGlobPatternWithRoot = isGlobPatternWithRoot2;
    function isGlobPatternNormalized2(g) {
      if (!isGlobPatternWithOptionalRoot2(g))
        return false;
      if (!isGlobPatternWithRoot2(g))
        return false;
      const gr = g;
      return "rawGlob" in gr && "rawRoot" in gr && typeof gr.rawGlob === "string";
    }
    exports.isGlobPatternNormalized = isGlobPatternNormalized2;
    function normalizePattern2(pattern, nested) {
      pattern = pattern.replace(/^(!!)+/, "");
      const isNeg = pattern.startsWith("!");
      const prefix = isNeg ? "!" : "";
      pattern = isNeg ? pattern.slice(1) : pattern;
      const patterns = nested ? normalizePatternNested2(pattern) : normalizePatternGeneral2(pattern);
      return patterns.map((p) => prefix + p);
    }
    function normalizePatternNested2(pattern) {
      if (!pattern.includes("/")) {
        if (pattern === "**")
          return ["**"];
        return ["**/" + pattern, "**/" + pattern + "/**"];
      }
      const hasLeadingSlash = pattern.startsWith("/");
      pattern = hasLeadingSlash ? pattern.slice(1) : pattern;
      if (pattern.endsWith("/")) {
        return hasLeadingSlash || pattern.slice(0, -1).includes("/") ? [pattern + "**/*"] : ["**/" + pattern + "**/*"];
      }
      if (pattern.endsWith("**")) {
        return [pattern];
      }
      return [pattern, pattern + "/**"];
    }
    function normalizePatternGeneral2(pattern) {
      pattern = pattern.startsWith("/") ? pattern.slice(1) : pattern;
      pattern = pattern.endsWith("/") ? pattern + "**/*" : pattern;
      return [pattern];
    }
    function normalizeGlobPatterns2(patterns, options) {
      function* normalize() {
        for (const glob2 of patterns) {
          if (isGlobPatternNormalized2(glob2)) {
            yield glob2;
            continue;
          }
          yield* normalizeGlobPattern2(glob2, options);
        }
      }
      return [...normalize()];
    }
    exports.normalizeGlobPatterns = normalizeGlobPatterns2;
    function normalizeGlobPattern2(g, options) {
      const { root, nodePath: path16 = Path3, nested, cwd = Path3.resolve() } = options;
      g = !isGlobPatternWithOptionalRoot2(g) ? { glob: g } : g;
      const gr = { ...g, root: g.root ?? root };
      const rawRoot = gr.root;
      const rawGlob = g.glob;
      gr.glob = gr.glob.trim();
      if (gr.glob.startsWith("${cwd}")) {
        gr.glob = gr.glob.replace("${cwd}", "");
        gr.root = "${cwd}";
      }
      if (gr.root.startsWith("${cwd}")) {
        gr.root = path16.resolve(gr.root.replace("${cwd}", cwd));
      }
      const isGlobalPattern = isGlobalGlob2(gr.glob);
      gr.root = path16.resolve(root, path16.normalize(gr.root));
      const globs = normalizePattern2(gr.glob, nested);
      return globs.map((glob2) => ({ ...gr, glob: glob2, rawGlob, rawRoot, isGlobalPattern }));
    }
    exports.normalizeGlobPattern = normalizeGlobPattern2;
    function normalizeGlobToRoot2(glob2, root, path16) {
      function relToGlob(relativePath2) {
        return path16.sep === "\\" ? relativePath2.replace(/\\/g, "/") : relativePath2;
      }
      if (glob2.root === root) {
        return glob2;
      }
      const relFromRootToGlob = path16.relative(root, glob2.root);
      if (!relFromRootToGlob) {
        return glob2;
      }
      if (glob2.isGlobalPattern) {
        return { ...glob2, root };
      }
      const relFromGlobToRoot = path16.relative(glob2.root, root);
      const globIsUnderRoot = relFromRootToGlob[0] !== "." && !path16.isAbsolute(relFromRootToGlob);
      const rootIsUnderGlob = relFromGlobToRoot[0] !== "." && !path16.isAbsolute(relFromGlobToRoot);
      if (!globIsUnderRoot && !rootIsUnderGlob) {
        return glob2;
      }
      const isNeg = glob2.glob.startsWith("!");
      const g = isNeg ? glob2.glob.slice(1) : glob2.glob;
      const prefix = isNeg ? "!" : "";
      if (globIsUnderRoot) {
        const relGlob2 = relToGlob(relFromRootToGlob);
        return {
          ...glob2,
          glob: prefix + posix3.join(relGlob2, g),
          root
        };
      }
      const relGlob = relToGlob(relFromGlobToRoot) + "/";
      const rebasedGlob = rebaseGlob2(g, relGlob);
      return rebasedGlob ? { ...glob2, glob: prefix + rebasedGlob, root } : glob2;
    }
    exports.normalizeGlobToRoot = normalizeGlobToRoot2;
    function rebaseGlob2(glob2, rebaseTo) {
      if (!rebaseTo || rebaseTo === "/")
        return glob2;
      if (glob2.startsWith("**"))
        return glob2;
      rebaseTo = rebaseTo.endsWith("/") ? rebaseTo : rebaseTo + "/";
      if (glob2.startsWith(rebaseTo)) {
        return glob2.slice(rebaseTo.length);
      }
      const relParts = rebaseTo.split("/");
      const globParts = glob2.split("/");
      for (let i = 0; i < relParts.length && i < globParts.length; ++i) {
        const relSeg = relParts[i];
        const globSeg = globParts[i];
        if (!relSeg || globSeg === "**") {
          return globParts.slice(i).join("/");
        }
        if (relSeg !== globSeg && globSeg !== "*") {
          break;
        }
      }
      return void 0;
    }
    function trimGlob(glob2) {
      glob2 = glob2.replace(/(?<!\\)#.*/g, "");
      glob2 = trimGlobLeft(glob2);
      glob2 = trimGlobRight(glob2);
      return glob2;
    }
    var spaces = {
      " ": true,
      "	": true,
      "\n": true,
      "\r": true
    };
    function trimGlobRight(glob2) {
      const lenMin1 = glob2.length - 1;
      let i = lenMin1;
      while (i >= 0 && glob2[i] in spaces) {
        --i;
      }
      if (glob2[i] === "\\" && i < lenMin1) {
        ++i;
      }
      ++i;
      return i ? glob2.slice(0, i) : "";
    }
    function trimGlobLeft(glob2) {
      let i = 0;
      while (i < glob2.length && glob2[i] in spaces) {
        ++i;
      }
      return glob2.slice(i);
    }
    function isGlobalGlob2(glob2) {
      return isGlobalPatternRegExp2.test(glob2);
    }
    exports.__testing__ = {
      rebaseGlob: rebaseGlob2,
      trimGlob,
      isGlobalGlob: isGlobalGlob2
    };
  }
});

// node_modules/cspell-glob/dist/cjs/GlobMatcher.js
var require_GlobMatcher = __commonJS({
  "node_modules/cspell-glob/dist/cjs/GlobMatcher.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GlobMatcher = void 0;
    var micromatch_1 = __importDefault(require_micromatch());
    var Path3 = __importStar(require("path"));
    var globHelper_js_1 = require_globHelper();
    var GlobMatcher2 = class {
      constructor(patterns, rootOrOptions, _nodePath) {
        _nodePath = _nodePath ?? Path3;
        const options = typeof rootOrOptions === "string" ? { root: rootOrOptions } : rootOrOptions ?? {};
        const { mode = "exclude" } = options;
        const isExcludeMode = mode !== "include";
        _nodePath = options.nodePath ?? _nodePath;
        const { root = _nodePath.resolve(), dot = isExcludeMode, nodePath = _nodePath, nested = isExcludeMode, cwd = process.cwd(), nobrace } = options;
        const normalizedRoot = nodePath.resolve(nodePath.normalize(root));
        this.options = { root: normalizedRoot, dot, nodePath, nested, mode, nobrace, cwd };
        patterns = Array.isArray(patterns) ? patterns : typeof patterns === "string" ? patterns.split(/\r?\n/g) : [patterns];
        const globPatterns = (0, globHelper_js_1.normalizeGlobPatterns)(patterns, this.options);
        this.patternsNormalizedToRoot = globPatterns.map((g) => (0, globHelper_js_1.normalizeGlobToRoot)(g, normalizedRoot, nodePath)).filter((g) => nodePath.relative(g.root, normalizedRoot) === "");
        this.patterns = globPatterns;
        this.root = normalizedRoot;
        this.path = nodePath;
        this.dot = dot;
        this.matchEx = buildMatcherFn2(this.patterns, this.options);
      }
      /**
       * Check to see if a filename matches any of the globs.
       * If filename is relative, it is considered relative to the root.
       * If filename is absolute and contained within the root, it will be made relative before being tested for a glob match.
       * If filename is absolute and not contained within the root, it will be tested as is.
       * @param filename full path of the file to check.
       */
      match(filename) {
        return this.matchEx(filename).matched;
      }
    };
    exports.GlobMatcher = GlobMatcher2;
    function buildMatcherFn2(patterns, options) {
      const { nodePath: path16, dot, nobrace } = options;
      const makeReOptions = { dot, nobrace };
      const rules = patterns.map((pattern, index) => ({ pattern, index })).filter((r) => !!r.pattern.glob).filter((r) => !r.pattern.glob.startsWith("#")).map(({ pattern, index }) => {
        const matchNeg = pattern.glob.match(/^!/);
        const glob2 = pattern.glob.replace(/^!/, "");
        const isNeg = matchNeg && matchNeg[0].length & 1 && true || false;
        const reg = micromatch_1.default.makeRe(glob2, makeReOptions);
        const fn2 = (filename) => {
          const match = filename.match(reg);
          return !!match;
        };
        return { pattern, index, isNeg, fn: fn2, reg };
      });
      const negRules = rules.filter((r) => r.isNeg);
      const posRules = rules.filter((r) => !r.isNeg);
      const fn = (filename) => {
        filename = path16.resolve(path16.normalize(filename));
        function testRules(rules2, matched) {
          for (const rule of rules2) {
            const pattern = rule.pattern;
            const root = pattern.root;
            const isRelPat = !pattern.isGlobalPattern;
            if (isRelPat && !(0, globHelper_js_1.doesRootContainPath)(root, filename, path16)) {
              continue;
            }
            const relName = isRelPat ? path16.relative(root, filename) : filename;
            const fname = path16.sep === "\\" ? relName.replace(/\\/g, "/") : relName;
            if (rule.fn(fname)) {
              return {
                matched,
                glob: pattern.glob,
                root,
                pattern,
                index: rule.index,
                isNeg: rule.isNeg
              };
            }
          }
        }
        return testRules(negRules, false) || testRules(posRules, true) || { matched: false };
      };
      return fn;
    }
  }
});

// node_modules/cspell-glob/dist/cjs/GlobMatcherTypes.js
var require_GlobMatcherTypes = __commonJS({
  "node_modules/cspell-glob/dist/cjs/GlobMatcherTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/cspell-glob/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/cspell-glob/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GlobMatcher = exports.normalizeGlobPatterns = exports.isGlobPatternWithRoot = exports.isGlobPatternWithOptionalRoot = exports.isGlobPatternNormalized = exports.fileOrGlobToGlob = void 0;
    var globHelper_js_1 = require_globHelper();
    Object.defineProperty(exports, "fileOrGlobToGlob", { enumerable: true, get: function() {
      return globHelper_js_1.fileOrGlobToGlob;
    } });
    Object.defineProperty(exports, "isGlobPatternNormalized", { enumerable: true, get: function() {
      return globHelper_js_1.isGlobPatternNormalized;
    } });
    Object.defineProperty(exports, "isGlobPatternWithOptionalRoot", { enumerable: true, get: function() {
      return globHelper_js_1.isGlobPatternWithOptionalRoot;
    } });
    Object.defineProperty(exports, "isGlobPatternWithRoot", { enumerable: true, get: function() {
      return globHelper_js_1.isGlobPatternWithRoot;
    } });
    Object.defineProperty(exports, "normalizeGlobPatterns", { enumerable: true, get: function() {
      return globHelper_js_1.normalizeGlobPatterns;
    } });
    var GlobMatcher_js_1 = require_GlobMatcher();
    Object.defineProperty(exports, "GlobMatcher", { enumerable: true, get: function() {
      return GlobMatcher_js_1.GlobMatcher;
    } });
    __exportStar(require_GlobMatcherTypes(), exports);
  }
});

// node_modules/cspell-lib/dist/cjs/util/Uri.js
var require_Uri = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/Uri.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.from = exports.resolvePath = exports.joinPath = exports.extname = exports.dirname = exports.basename = exports.isUri = exports.normalizeDriveLetter = exports.parse = exports.file = exports.fromStdinFilePath = exports.fromFilePath = exports.uriToFilePath = exports.toUri = void 0;
    var assert_1 = __importDefault(require("assert"));
    var vscode_uri_1 = require_umd();
    var isFile = /^(?:[a-zA-Z]:|[/\\])/;
    var isPossibleUri = /\w:\/\//;
    var isUrl = /^(file:|stdin:|https?:|s?ftp:)/;
    var STDIN_PROTOCOL = "stdin:";
    function toUri(uriOrFile) {
      if (UriImpl.isUri(uriOrFile))
        return uriOrFile;
      if (vscode_uri_1.URI.isUri(uriOrFile))
        return UriImpl.from(uriOrFile);
      if (uriOrFile instanceof URL)
        return UriImpl.parse(uriOrFile.toString());
      if (isUrlLike2(uriOrFile))
        return UriImpl.parse(uriOrFile.href);
      if (isUri(uriOrFile))
        return UriImpl.from(uriOrFile);
      if (isUrl.test(uriOrFile))
        return UriImpl.parse(uriOrFile);
      return isFile.test(uriOrFile) && !isPossibleUri.test(uriOrFile) ? UriImpl.file(normalizeDriveLetter(uriOrFile)) : UriImpl.parse(uriOrFile);
    }
    exports.toUri = toUri;
    var hasDriveLetter = /^[A-Z]:/i;
    function uriToFilePath(uri) {
      const adj = uri.scheme === "stdin" ? { scheme: "file" } : {};
      return normalizeDriveLetter(vscode_uri_1.URI.from(UriImpl.from(uri, adj)).fsPath);
    }
    exports.uriToFilePath = uriToFilePath;
    function fromFilePath(file) {
      return UriImpl.file(file);
    }
    exports.fromFilePath = fromFilePath;
    function fromStdinFilePath(path16) {
      return UriImpl.stdin(path16);
    }
    exports.fromStdinFilePath = fromStdinFilePath;
    exports.file = fromFilePath;
    function parse3(uri) {
      return UriImpl.parse(uri);
    }
    exports.parse = parse3;
    function normalizeDriveLetter(path16) {
      return hasDriveLetter.test(path16) ? path16[0].toLowerCase() + path16.slice(1) : path16;
    }
    exports.normalizeDriveLetter = normalizeDriveLetter;
    function isUrlLike2(url) {
      return !!url && typeof url === "object" && typeof url.href === "string" || false;
    }
    function isUri(uri) {
      if (!uri || typeof uri !== "object")
        return false;
      if (UriImpl.isUri(uri))
        return true;
      if (vscode_uri_1.URI.isUri(uri))
        return true;
      const u = uri;
      return typeof u.path === "string" && typeof u.scheme === "string";
    }
    exports.isUri = isUri;
    function basename3(uri) {
      return vscode_uri_1.Utils.basename(vscode_uri_1.URI.from(uri));
    }
    exports.basename = basename3;
    function dirname6(uri) {
      return UriImpl.from(vscode_uri_1.Utils.dirname(vscode_uri_1.URI.from(uri)));
    }
    exports.dirname = dirname6;
    function extname(uri) {
      return vscode_uri_1.Utils.extname(vscode_uri_1.URI.from(uri));
    }
    exports.extname = extname;
    function joinPath(uri, ...paths) {
      return UriImpl.from(vscode_uri_1.Utils.joinPath(vscode_uri_1.URI.from(uri), ...paths));
    }
    exports.joinPath = joinPath;
    function resolvePath2(uri, ...paths) {
      return UriImpl.from(vscode_uri_1.Utils.resolvePath(vscode_uri_1.URI.from(uri), ...paths));
    }
    exports.resolvePath = resolvePath2;
    function from(uri, ...parts) {
      return UriImpl.from(uri, ...parts);
    }
    exports.from = from;
    var keys = ["scheme", "authority", "path", "query", "fragment"];
    var UriImpl = class _UriImpl {
      constructor(uri) {
        this.scheme = uri.scheme || "";
        uri.authority && (this.authority = uri.authority);
        this.path = uri.path || "";
        uri.query && (this.query = uri.query);
        uri.fragment && (this.fragment = uri.fragment);
      }
      toString() {
        const path16 = this.path;
        const base = `${this.scheme}://${this.authority || ""}${path16}`;
        const query = this.query && `?${this.query}` || "";
        const fragment = this.fragment && `#${this.fragment}` || "";
        const url = base + query + fragment;
        return encodeURI(url);
      }
      toJson() {
        const { scheme, authority, path: path16, query, fragment } = this;
        return { scheme, authority, path: path16, query, fragment };
      }
      with(change) {
        const { scheme, authority, path: path16, query, fragment } = this;
        const u = { scheme, authority, path: path16, query, fragment };
        for (const key of keys) {
          if (change[key] && typeof change[key] === "string") {
            u[key] = change[key];
          }
        }
        return new _UriImpl(u);
      }
      static isUri(uri) {
        return uri instanceof _UriImpl;
      }
      static from(uri, ...parts) {
        let u = new _UriImpl(uri);
        for (const part of parts) {
          u = u.with(part);
        }
        return u;
      }
      static parse(uri) {
        if (uri.startsWith(STDIN_PROTOCOL)) {
          return _UriImpl.from(parseStdinUri(uri));
        }
        const u = vscode_uri_1.URI.parse(uri);
        return _UriImpl.from(u);
      }
      static file(filename) {
        return _UriImpl.from(vscode_uri_1.URI.file(normalizeFilePath(filename)));
      }
      static stdin(filePath = "") {
        return _UriImpl.from(_UriImpl.file(filePath), { scheme: "stdin" });
      }
    };
    function normalizeFilePath(path16) {
      return normalizeDriveLetter(path16.replace(/\\/g, "/"));
    }
    function parseStdinUri(uri) {
      (0, assert_1.default)(uri.startsWith(STDIN_PROTOCOL));
      const idxSlash = STDIN_PROTOCOL.length;
      let idxSlashEnd = idxSlash;
      for (; uri[idxSlashEnd] === "/"; ++idxSlashEnd) {
      }
      const pathStart = idxSlashEnd;
      const iH = uri.indexOf("#", pathStart);
      const idxHash = iH > 0 ? iH : uri.length;
      const iQ = uri.indexOf("?", pathStart);
      const idxQ = iQ > 0 && iQ < idxHash ? iQ : idxHash;
      const pathEnd = idxQ;
      const path16 = uri.slice(pathStart, pathEnd);
      const query = idxQ < idxHash ? uri.slice(idxQ + 1, idxHash) : "";
      const hash = uri.slice(idxHash + 1);
      const pathPrefix = idxSlashEnd - idxSlash > 2 ? "/" : "";
      return {
        scheme: "stdin",
        path: pathPrefix + normalizeFilePath(decodeURI(path16)),
        query: decodeURI(query),
        fragment: decodeURI(hash)
      };
    }
    exports.__testing__ = {
      UriImpl,
      normalizeFilePath
    };
  }
});

// node_modules/cspell-lib/dist/cjs/exclusionHelper.js
var require_exclusionHelper = __commonJS({
  "node_modules/cspell-lib/dist/cjs/exclusionHelper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateExclusionFunctionForFiles = exports.generateExclusionFunctionForUri = exports.extractGlobsFromExcludeFilesGlobMap = void 0;
    var cspell_glob_1 = require_cjs();
    var Uri_js_1 = require_Uri();
    var defaultAllowedSchemes = /* @__PURE__ */ new Set(["file", "untitled"]);
    function extractGlobsFromExcludeFilesGlobMap(globMap) {
      const globs = Object.getOwnPropertyNames(globMap).filter((glob2) => globMap[glob2]);
      return globs;
    }
    exports.extractGlobsFromExcludeFilesGlobMap = extractGlobsFromExcludeFilesGlobMap;
    var leadingGlobPattern = /^\*\*\/([^/*{}]+)$/;
    function adjustGlobPatternForBackwardsCompatibility(g) {
      return g.replace(leadingGlobPattern, "**/{$1,$1/**}");
    }
    function adjustGlobPatternsForBackwardsCompatibility(globs) {
      return globs.map((g) => {
        if (typeof g === "string") {
          return adjustGlobPatternForBackwardsCompatibility(g);
        }
        return { ...g, glob: adjustGlobPatternForBackwardsCompatibility(g.glob) };
      });
    }
    function generateExclusionFunctionForUri(globs, root, allowedSchemes = defaultAllowedSchemes) {
      const adjustedGlobs = adjustGlobPatternsForBackwardsCompatibility(globs);
      const matchFn = generateExclusionFunctionForFiles(adjustedGlobs, root);
      function testUri(uri) {
        if (!allowedSchemes.has(uri.scheme)) {
          return true;
        }
        return matchFn(uri.scheme === "file" || uri.scheme === "stdin" ? (0, Uri_js_1.uriToFilePath)(uri) : uri.path);
      }
      function testUriPath(uriPath) {
        const uri = (0, Uri_js_1.toUri)(uriPath);
        return testUri(uri);
      }
      return testUriPath;
    }
    exports.generateExclusionFunctionForUri = generateExclusionFunctionForUri;
    function generateExclusionFunctionForFiles(globs, root) {
      const matcher = new cspell_glob_1.GlobMatcher(globs, { root, dot: true });
      return (file) => matcher.match(file);
    }
    exports.generateExclusionFunctionForFiles = generateExclusionFunctionForFiles;
  }
});

// node_modules/cspell-lib/dist/cjs/util/util.js
var require_util = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isRecordEqual = exports.doSetsIntersect = exports.isArrayEqual = exports.asyncIterableToArray = exports.isDefined = exports.scanMap = exports.clean = exports.unique = exports.uniqueFilterFnGenerator = exports.uniqueFn = void 0;
    exports.uniqueFn = uniqueFilterFnGenerator2;
    function uniqueFilterFnGenerator2(extractFn) {
      const values = /* @__PURE__ */ new Set();
      const extractor = extractFn || ((a) => a);
      return (v) => {
        const vv = extractor(v);
        const ret = !values.has(vv);
        values.add(vv);
        return ret;
      };
    }
    exports.uniqueFilterFnGenerator = uniqueFilterFnGenerator2;
    function unique(src) {
      return [...new Set(src)];
    }
    exports.unique = unique;
    function clean2(src) {
      const r = src;
      for (const key of Object.keys(r)) {
        if (r[key] === void 0 || r[key] === null) {
          delete r[key];
        }
      }
      return r;
    }
    exports.clean = clean2;
    function scanMap(accFn, init) {
      let acc = init;
      let first = true;
      return function(value) {
        if (first && acc === void 0) {
          first = false;
          acc = value;
          return acc;
        }
        acc = accFn(acc, value);
        return acc;
      };
    }
    exports.scanMap = scanMap;
    function isDefined2(v) {
      return v !== void 0;
    }
    exports.isDefined = isDefined2;
    async function asyncIterableToArray2(iter) {
      const acc = [];
      for await (const t of iter) {
        acc.push(t);
      }
      return acc;
    }
    exports.asyncIterableToArray = asyncIterableToArray2;
    function isArrayEqual(a, b) {
      if (a === b)
        return true;
      let isMatch = a.length === b.length;
      for (let i = 0; i < a.length && isMatch; ++i) {
        isMatch = a[i] === b[i];
      }
      return isMatch;
    }
    exports.isArrayEqual = isArrayEqual;
    function doSetsIntersect(a, b) {
      function compare2(a2, b2) {
        for (const item of a2) {
          if (b2.has(item))
            return true;
        }
        return false;
      }
      return a.size <= b.size ? compare2(a, b) : compare2(b, a);
    }
    exports.doSetsIntersect = doSetsIntersect;
    function isRecordEqual(a, b) {
      if (a === b)
        return true;
      if (a === void 0 || b === void 0)
        return false;
      for (const key of Object.keys(a)) {
        if (a[key] !== b[key])
          return false;
      }
      for (const key of Object.keys(b)) {
        if (a[key] !== b[key])
          return false;
      }
      return true;
    }
    exports.isRecordEqual = isRecordEqual;
  }
});

// node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS({
  "node_modules/esprima/dist/esprima.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["esprima"] = factory();
      else
        root["esprima"] = factory();
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module3 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.loaded = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var comment_handler_1 = __webpack_require__(1);
            var jsx_parser_1 = __webpack_require__(3);
            var parser_1 = __webpack_require__(8);
            var tokenizer_1 = __webpack_require__(15);
            function parse3(code, options, delegate) {
              var commentHandler = null;
              var proxyDelegate = function(node, metadata) {
                if (delegate) {
                  delegate(node, metadata);
                }
                if (commentHandler) {
                  commentHandler.visit(node, metadata);
                }
              };
              var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
              var collectComment = false;
              if (options) {
                collectComment = typeof options.comment === "boolean" && options.comment;
                var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
                if (collectComment || attachComment) {
                  commentHandler = new comment_handler_1.CommentHandler();
                  commentHandler.attach = attachComment;
                  options.comment = true;
                  parserDelegate = proxyDelegate;
                }
              }
              var isModule = false;
              if (options && typeof options.sourceType === "string") {
                isModule = options.sourceType === "module";
              }
              var parser;
              if (options && typeof options.jsx === "boolean" && options.jsx) {
                parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
              } else {
                parser = new parser_1.Parser(code, options, parserDelegate);
              }
              var program = isModule ? parser.parseModule() : parser.parseScript();
              var ast = program;
              if (collectComment && commentHandler) {
                ast.comments = commentHandler.comments;
              }
              if (parser.config.tokens) {
                ast.tokens = parser.tokens;
              }
              if (parser.config.tolerant) {
                ast.errors = parser.errorHandler.errors;
              }
              return ast;
            }
            exports2.parse = parse3;
            function parseModule(code, options, delegate) {
              var parsingOptions = options || {};
              parsingOptions.sourceType = "module";
              return parse3(code, parsingOptions, delegate);
            }
            exports2.parseModule = parseModule;
            function parseScript(code, options, delegate) {
              var parsingOptions = options || {};
              parsingOptions.sourceType = "script";
              return parse3(code, parsingOptions, delegate);
            }
            exports2.parseScript = parseScript;
            function tokenize(code, options, delegate) {
              var tokenizer = new tokenizer_1.Tokenizer(code, options);
              var tokens;
              tokens = [];
              try {
                while (true) {
                  var token = tokenizer.getNextToken();
                  if (!token) {
                    break;
                  }
                  if (delegate) {
                    token = delegate(token);
                  }
                  tokens.push(token);
                }
              } catch (e) {
                tokenizer.errorHandler.tolerate(e);
              }
              if (tokenizer.errorHandler.tolerant) {
                tokens.errors = tokenizer.errors();
              }
              return tokens;
            }
            exports2.tokenize = tokenize;
            var syntax_1 = __webpack_require__(2);
            exports2.Syntax = syntax_1.Syntax;
            exports2.version = "4.0.1";
          },
          /* 1 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var syntax_1 = __webpack_require__(2);
            var CommentHandler = function() {
              function CommentHandler2() {
                this.attach = false;
                this.comments = [];
                this.stack = [];
                this.leading = [];
                this.trailing = [];
              }
              CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
                if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                  var innerComments = [];
                  for (var i = this.leading.length - 1; i >= 0; --i) {
                    var entry = this.leading[i];
                    if (metadata.end.offset >= entry.start) {
                      innerComments.unshift(entry.comment);
                      this.leading.splice(i, 1);
                      this.trailing.splice(i, 1);
                    }
                  }
                  if (innerComments.length) {
                    node.innerComments = innerComments;
                  }
                }
              };
              CommentHandler2.prototype.findTrailingComments = function(metadata) {
                var trailingComments = [];
                if (this.trailing.length > 0) {
                  for (var i = this.trailing.length - 1; i >= 0; --i) {
                    var entry_1 = this.trailing[i];
                    if (entry_1.start >= metadata.end.offset) {
                      trailingComments.unshift(entry_1.comment);
                    }
                  }
                  this.trailing.length = 0;
                  return trailingComments;
                }
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.node.trailingComments) {
                  var firstComment = entry.node.trailingComments[0];
                  if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                    trailingComments = entry.node.trailingComments;
                    delete entry.node.trailingComments;
                  }
                }
                return trailingComments;
              };
              CommentHandler2.prototype.findLeadingComments = function(metadata) {
                var leadingComments = [];
                var target;
                while (this.stack.length > 0) {
                  var entry = this.stack[this.stack.length - 1];
                  if (entry && entry.start >= metadata.start.offset) {
                    target = entry.node;
                    this.stack.pop();
                  } else {
                    break;
                  }
                }
                if (target) {
                  var count = target.leadingComments ? target.leadingComments.length : 0;
                  for (var i = count - 1; i >= 0; --i) {
                    var comment = target.leadingComments[i];
                    if (comment.range[1] <= metadata.start.offset) {
                      leadingComments.unshift(comment);
                      target.leadingComments.splice(i, 1);
                    }
                  }
                  if (target.leadingComments && target.leadingComments.length === 0) {
                    delete target.leadingComments;
                  }
                  return leadingComments;
                }
                for (var i = this.leading.length - 1; i >= 0; --i) {
                  var entry = this.leading[i];
                  if (entry.start <= metadata.start.offset) {
                    leadingComments.unshift(entry.comment);
                    this.leading.splice(i, 1);
                  }
                }
                return leadingComments;
              };
              CommentHandler2.prototype.visitNode = function(node, metadata) {
                if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                  return;
                }
                this.insertInnerComments(node, metadata);
                var trailingComments = this.findTrailingComments(metadata);
                var leadingComments = this.findLeadingComments(metadata);
                if (leadingComments.length > 0) {
                  node.leadingComments = leadingComments;
                }
                if (trailingComments.length > 0) {
                  node.trailingComments = trailingComments;
                }
                this.stack.push({
                  node,
                  start: metadata.start.offset
                });
              };
              CommentHandler2.prototype.visitComment = function(node, metadata) {
                var type = node.type[0] === "L" ? "Line" : "Block";
                var comment = {
                  type,
                  value: node.value
                };
                if (node.range) {
                  comment.range = node.range;
                }
                if (node.loc) {
                  comment.loc = node.loc;
                }
                this.comments.push(comment);
                if (this.attach) {
                  var entry = {
                    comment: {
                      type,
                      value: node.value,
                      range: [metadata.start.offset, metadata.end.offset]
                    },
                    start: metadata.start.offset
                  };
                  if (node.loc) {
                    entry.comment.loc = node.loc;
                  }
                  node.type = type;
                  this.leading.push(entry);
                  this.trailing.push(entry);
                }
              };
              CommentHandler2.prototype.visit = function(node, metadata) {
                if (node.type === "LineComment") {
                  this.visitComment(node, metadata);
                } else if (node.type === "BlockComment") {
                  this.visitComment(node, metadata);
                } else if (this.attach) {
                  this.visitNode(node, metadata);
                }
              };
              return CommentHandler2;
            }();
            exports2.CommentHandler = CommentHandler;
          },
          /* 2 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.Syntax = {
              AssignmentExpression: "AssignmentExpression",
              AssignmentPattern: "AssignmentPattern",
              ArrayExpression: "ArrayExpression",
              ArrayPattern: "ArrayPattern",
              ArrowFunctionExpression: "ArrowFunctionExpression",
              AwaitExpression: "AwaitExpression",
              BlockStatement: "BlockStatement",
              BinaryExpression: "BinaryExpression",
              BreakStatement: "BreakStatement",
              CallExpression: "CallExpression",
              CatchClause: "CatchClause",
              ClassBody: "ClassBody",
              ClassDeclaration: "ClassDeclaration",
              ClassExpression: "ClassExpression",
              ConditionalExpression: "ConditionalExpression",
              ContinueStatement: "ContinueStatement",
              DoWhileStatement: "DoWhileStatement",
              DebuggerStatement: "DebuggerStatement",
              EmptyStatement: "EmptyStatement",
              ExportAllDeclaration: "ExportAllDeclaration",
              ExportDefaultDeclaration: "ExportDefaultDeclaration",
              ExportNamedDeclaration: "ExportNamedDeclaration",
              ExportSpecifier: "ExportSpecifier",
              ExpressionStatement: "ExpressionStatement",
              ForStatement: "ForStatement",
              ForOfStatement: "ForOfStatement",
              ForInStatement: "ForInStatement",
              FunctionDeclaration: "FunctionDeclaration",
              FunctionExpression: "FunctionExpression",
              Identifier: "Identifier",
              IfStatement: "IfStatement",
              ImportDeclaration: "ImportDeclaration",
              ImportDefaultSpecifier: "ImportDefaultSpecifier",
              ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
              ImportSpecifier: "ImportSpecifier",
              Literal: "Literal",
              LabeledStatement: "LabeledStatement",
              LogicalExpression: "LogicalExpression",
              MemberExpression: "MemberExpression",
              MetaProperty: "MetaProperty",
              MethodDefinition: "MethodDefinition",
              NewExpression: "NewExpression",
              ObjectExpression: "ObjectExpression",
              ObjectPattern: "ObjectPattern",
              Program: "Program",
              Property: "Property",
              RestElement: "RestElement",
              ReturnStatement: "ReturnStatement",
              SequenceExpression: "SequenceExpression",
              SpreadElement: "SpreadElement",
              Super: "Super",
              SwitchCase: "SwitchCase",
              SwitchStatement: "SwitchStatement",
              TaggedTemplateExpression: "TaggedTemplateExpression",
              TemplateElement: "TemplateElement",
              TemplateLiteral: "TemplateLiteral",
              ThisExpression: "ThisExpression",
              ThrowStatement: "ThrowStatement",
              TryStatement: "TryStatement",
              UnaryExpression: "UnaryExpression",
              UpdateExpression: "UpdateExpression",
              VariableDeclaration: "VariableDeclaration",
              VariableDeclarator: "VariableDeclarator",
              WhileStatement: "WhileStatement",
              WithStatement: "WithStatement",
              YieldExpression: "YieldExpression"
            };
          },
          /* 3 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var __extends = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b)
                  if (b.hasOwnProperty(p))
                    d[p] = b[p];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var character_1 = __webpack_require__(4);
            var JSXNode = __webpack_require__(5);
            var jsx_syntax_1 = __webpack_require__(6);
            var Node = __webpack_require__(7);
            var parser_1 = __webpack_require__(8);
            var token_1 = __webpack_require__(13);
            var xhtml_entities_1 = __webpack_require__(14);
            token_1.TokenName[
              100
              /* Identifier */
            ] = "JSXIdentifier";
            token_1.TokenName[
              101
              /* Text */
            ] = "JSXText";
            function getQualifiedElementName(elementName) {
              var qualifiedName;
              switch (elementName.type) {
                case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                  var id = elementName;
                  qualifiedName = id.name;
                  break;
                case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                  var ns = elementName;
                  qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                  break;
                case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                  var expr = elementName;
                  qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                  break;
                default:
                  break;
              }
              return qualifiedName;
            }
            var JSXParser = function(_super) {
              __extends(JSXParser2, _super);
              function JSXParser2(code, options, delegate) {
                return _super.call(this, code, options, delegate) || this;
              }
              JSXParser2.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
              };
              JSXParser2.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index;
                this.scanner.lineNumber = this.startMarker.line;
                this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              };
              JSXParser2.prototype.finishJSX = function() {
                this.nextToken();
              };
              JSXParser2.prototype.reenterJSX = function() {
                this.startJSX();
                this.expectJSX("}");
                if (this.config.tokens) {
                  this.tokens.pop();
                }
              };
              JSXParser2.prototype.createJSXNode = function() {
                this.collectComments();
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              };
              JSXParser2.prototype.createJSXChildNode = function() {
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              };
              JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                var result = "&";
                var valid = true;
                var terminated = false;
                var numeric = false;
                var hex = false;
                while (!this.scanner.eof() && valid && !terminated) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === quote) {
                    break;
                  }
                  terminated = ch === ";";
                  result += ch;
                  ++this.scanner.index;
                  if (!terminated) {
                    switch (result.length) {
                      case 2:
                        numeric = ch === "#";
                        break;
                      case 3:
                        if (numeric) {
                          hex = ch === "x";
                          valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                          numeric = numeric && !hex;
                        }
                        break;
                      default:
                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                        break;
                    }
                  }
                }
                if (valid && terminated && result.length > 2) {
                  var str = result.substr(1, result.length - 2);
                  if (numeric && str.length > 1) {
                    result = String.fromCharCode(parseInt(str.substr(1), 10));
                  } else if (hex && str.length > 2) {
                    result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                  } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                    result = xhtml_entities_1.XHTMLEntities[str];
                  }
                }
                return result;
              };
              JSXParser2.prototype.lexJSX = function() {
                var cp = this.scanner.source.charCodeAt(this.scanner.index);
                if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                  var value = this.scanner.source[this.scanner.index++];
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index - 1,
                    end: this.scanner.index
                  };
                }
                if (cp === 34 || cp === 39) {
                  var start = this.scanner.index;
                  var quote = this.scanner.source[this.scanner.index++];
                  var str = "";
                  while (!this.scanner.eof()) {
                    var ch = this.scanner.source[this.scanner.index++];
                    if (ch === quote) {
                      break;
                    } else if (ch === "&") {
                      str += this.scanXHTMLEntity(quote);
                    } else {
                      str += ch;
                    }
                  }
                  return {
                    type: 8,
                    value: str,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 46) {
                  var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                  var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                  var value = n1 === 46 && n2 === 46 ? "..." : ".";
                  var start = this.scanner.index;
                  this.scanner.index += value.length;
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 96) {
                  return {
                    type: 10,
                    value: "",
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index,
                    end: this.scanner.index
                  };
                }
                if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                  var start = this.scanner.index;
                  ++this.scanner.index;
                  while (!this.scanner.eof()) {
                    var ch = this.scanner.source.charCodeAt(this.scanner.index);
                    if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                      ++this.scanner.index;
                    } else if (ch === 45) {
                      ++this.scanner.index;
                    } else {
                      break;
                    }
                  }
                  var id = this.scanner.source.slice(start, this.scanner.index);
                  return {
                    type: 100,
                    value: id,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                return this.scanner.lex();
              };
              JSXParser2.prototype.nextJSXToken = function() {
                this.collectComments();
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var token = this.lexJSX();
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                if (this.config.tokens) {
                  this.tokens.push(this.convertToken(token));
                }
                return token;
              };
              JSXParser2.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var start = this.scanner.index;
                var text = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === "{" || ch === "<") {
                    break;
                  }
                  ++this.scanner.index;
                  text += ch;
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    ++this.scanner.lineNumber;
                    if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                      ++this.scanner.index;
                    }
                    this.scanner.lineStart = this.scanner.index;
                  }
                }
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var token = {
                  type: 101,
                  value: text,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
                if (text.length > 0 && this.config.tokens) {
                  this.tokens.push(this.convertToken(token));
                }
                return token;
              };
              JSXParser2.prototype.peekJSXToken = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.lexJSX();
                this.scanner.restoreState(state);
                return next;
              };
              JSXParser2.prototype.expectJSX = function(value) {
                var token = this.nextJSXToken();
                if (token.type !== 7 || token.value !== value) {
                  this.throwUnexpectedToken(token);
                }
              };
              JSXParser2.prototype.matchJSX = function(value) {
                var next = this.peekJSXToken();
                return next.type === 7 && next.value === value;
              };
              JSXParser2.prototype.parseJSXIdentifier = function() {
                var node = this.createJSXNode();
                var token = this.nextJSXToken();
                if (token.type !== 100) {
                  this.throwUnexpectedToken(token);
                }
                return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
              };
              JSXParser2.prototype.parseJSXElementName = function() {
                var node = this.createJSXNode();
                var elementName = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = elementName;
                  this.expectJSX(":");
                  var name_1 = this.parseJSXIdentifier();
                  elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
                } else if (this.matchJSX(".")) {
                  while (this.matchJSX(".")) {
                    var object = elementName;
                    this.expectJSX(".");
                    var property = this.parseJSXIdentifier();
                    elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                  }
                }
                return elementName;
              };
              JSXParser2.prototype.parseJSXAttributeName = function() {
                var node = this.createJSXNode();
                var attributeName;
                var identifier = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = identifier;
                  this.expectJSX(":");
                  var name_2 = this.parseJSXIdentifier();
                  attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
                } else {
                  attributeName = identifier;
                }
                return attributeName;
              };
              JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                var node = this.createJSXNode();
                var token = this.nextJSXToken();
                if (token.type !== 8) {
                  this.throwUnexpectedToken(token);
                }
                var raw = this.getTokenRaw(token);
                return this.finalize(node, new Node.Literal(token.value, raw));
              };
              JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                this.finishJSX();
                if (this.match("}")) {
                  this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                }
                var expression = this.parseAssignmentExpression();
                this.reenterJSX();
                return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              };
              JSXParser2.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              };
              JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                var node = this.createJSXNode();
                var name = this.parseJSXAttributeName();
                var value = null;
                if (this.matchJSX("=")) {
                  this.expectJSX("=");
                  value = this.parseJSXAttributeValue();
                }
                return this.finalize(node, new JSXNode.JSXAttribute(name, value));
              };
              JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                this.expectJSX("...");
                this.finishJSX();
                var argument = this.parseAssignmentExpression();
                this.reenterJSX();
                return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
              };
              JSXParser2.prototype.parseJSXAttributes = function() {
                var attributes = [];
                while (!this.matchJSX("/") && !this.matchJSX(">")) {
                  var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  attributes.push(attribute);
                }
                return attributes;
              };
              JSXParser2.prototype.parseJSXOpeningElement = function() {
                var node = this.createJSXNode();
                this.expectJSX("<");
                var name = this.parseJSXElementName();
                var attributes = this.parseJSXAttributes();
                var selfClosing = this.matchJSX("/");
                if (selfClosing) {
                  this.expectJSX("/");
                }
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              };
              JSXParser2.prototype.parseJSXBoundaryElement = function() {
                var node = this.createJSXNode();
                this.expectJSX("<");
                if (this.matchJSX("/")) {
                  this.expectJSX("/");
                  var name_3 = this.parseJSXElementName();
                  this.expectJSX(">");
                  return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
                }
                var name = this.parseJSXElementName();
                var attributes = this.parseJSXAttributes();
                var selfClosing = this.matchJSX("/");
                if (selfClosing) {
                  this.expectJSX("/");
                }
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              };
              JSXParser2.prototype.parseJSXEmptyExpression = function() {
                var node = this.createJSXChildNode();
                this.collectComments();
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                return this.finalize(node, new JSXNode.JSXEmptyExpression());
              };
              JSXParser2.prototype.parseJSXExpressionContainer = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                var expression;
                if (this.matchJSX("}")) {
                  expression = this.parseJSXEmptyExpression();
                  this.expectJSX("}");
                } else {
                  this.finishJSX();
                  expression = this.parseAssignmentExpression();
                  this.reenterJSX();
                }
                return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              };
              JSXParser2.prototype.parseJSXChildren = function() {
                var children = [];
                while (!this.scanner.eof()) {
                  var node = this.createJSXChildNode();
                  var token = this.nextJSXText();
                  if (token.start < token.end) {
                    var raw = this.getTokenRaw(token);
                    var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                    children.push(child);
                  }
                  if (this.scanner.source[this.scanner.index] === "{") {
                    var container = this.parseJSXExpressionContainer();
                    children.push(container);
                  } else {
                    break;
                  }
                }
                return children;
              };
              JSXParser2.prototype.parseComplexJSXElement = function(el) {
                var stack = [];
                while (!this.scanner.eof()) {
                  el.children = el.children.concat(this.parseJSXChildren());
                  var node = this.createJSXChildNode();
                  var element = this.parseJSXBoundaryElement();
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                    var opening = element;
                    if (opening.selfClosing) {
                      var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                      el.children.push(child);
                    } else {
                      stack.push(el);
                      el = { node, opening, closing: null, children: [] };
                    }
                  }
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                    el.closing = element;
                    var open_1 = getQualifiedElementName(el.opening.name);
                    var close_1 = getQualifiedElementName(el.closing.name);
                    if (open_1 !== close_1) {
                      this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                    }
                    if (stack.length > 0) {
                      var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                      el = stack[stack.length - 1];
                      el.children.push(child);
                      stack.pop();
                    } else {
                      break;
                    }
                  }
                }
                return el;
              };
              JSXParser2.prototype.parseJSXElement = function() {
                var node = this.createJSXNode();
                var opening = this.parseJSXOpeningElement();
                var children = [];
                var closing = null;
                if (!opening.selfClosing) {
                  var el = this.parseComplexJSXElement({ node, opening, closing, children });
                  children = el.children;
                  closing = el.closing;
                }
                return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
              };
              JSXParser2.prototype.parseJSXRoot = function() {
                if (this.config.tokens) {
                  this.tokens.pop();
                }
                this.startJSX();
                var element = this.parseJSXElement();
                this.finishJSX();
                return element;
              };
              JSXParser2.prototype.isStartOfExpression = function() {
                return _super.prototype.isStartOfExpression.call(this) || this.match("<");
              };
              return JSXParser2;
            }(parser_1.Parser);
            exports2.JSXParser = JSXParser;
          },
          /* 4 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var Regex = {
              // Unicode v8.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
              // Unicode v8.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            exports2.Character = {
              /* tslint:disable:no-bitwise */
              fromCodePoint: function(cp) {
                return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
              },
              // https://tc39.github.io/ecma262/#sec-white-space
              isWhiteSpace: function(cp) {
                return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
              },
              // https://tc39.github.io/ecma262/#sec-line-terminators
              isLineTerminator: function(cp) {
                return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
              },
              // https://tc39.github.io/ecma262/#sec-names-and-keywords
              isIdentifierStart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
              },
              isIdentifierPart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
              },
              // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
              isDecimalDigit: function(cp) {
                return cp >= 48 && cp <= 57;
              },
              isHexDigit: function(cp) {
                return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
              },
              isOctalDigit: function(cp) {
                return cp >= 48 && cp <= 55;
              }
            };
          },
          /* 5 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var jsx_syntax_1 = __webpack_require__(6);
            var JSXClosingElement = function() {
              function JSXClosingElement2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                this.name = name;
              }
              return JSXClosingElement2;
            }();
            exports2.JSXClosingElement = JSXClosingElement;
            var JSXElement = function() {
              function JSXElement2(openingElement, children, closingElement) {
                this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                this.openingElement = openingElement;
                this.children = children;
                this.closingElement = closingElement;
              }
              return JSXElement2;
            }();
            exports2.JSXElement = JSXElement;
            var JSXEmptyExpression = function() {
              function JSXEmptyExpression2() {
                this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
              }
              return JSXEmptyExpression2;
            }();
            exports2.JSXEmptyExpression = JSXEmptyExpression;
            var JSXExpressionContainer = function() {
              function JSXExpressionContainer2(expression) {
                this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                this.expression = expression;
              }
              return JSXExpressionContainer2;
            }();
            exports2.JSXExpressionContainer = JSXExpressionContainer;
            var JSXIdentifier = function() {
              function JSXIdentifier2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                this.name = name;
              }
              return JSXIdentifier2;
            }();
            exports2.JSXIdentifier = JSXIdentifier;
            var JSXMemberExpression = function() {
              function JSXMemberExpression2(object, property) {
                this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                this.object = object;
                this.property = property;
              }
              return JSXMemberExpression2;
            }();
            exports2.JSXMemberExpression = JSXMemberExpression;
            var JSXAttribute = function() {
              function JSXAttribute2(name, value) {
                this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                this.name = name;
                this.value = value;
              }
              return JSXAttribute2;
            }();
            exports2.JSXAttribute = JSXAttribute;
            var JSXNamespacedName = function() {
              function JSXNamespacedName2(namespace, name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                this.namespace = namespace;
                this.name = name;
              }
              return JSXNamespacedName2;
            }();
            exports2.JSXNamespacedName = JSXNamespacedName;
            var JSXOpeningElement = function() {
              function JSXOpeningElement2(name, selfClosing, attributes) {
                this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                this.name = name;
                this.selfClosing = selfClosing;
                this.attributes = attributes;
              }
              return JSXOpeningElement2;
            }();
            exports2.JSXOpeningElement = JSXOpeningElement;
            var JSXSpreadAttribute = function() {
              function JSXSpreadAttribute2(argument) {
                this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                this.argument = argument;
              }
              return JSXSpreadAttribute2;
            }();
            exports2.JSXSpreadAttribute = JSXSpreadAttribute;
            var JSXText = function() {
              function JSXText2(value, raw) {
                this.type = jsx_syntax_1.JSXSyntax.JSXText;
                this.value = value;
                this.raw = raw;
              }
              return JSXText2;
            }();
            exports2.JSXText = JSXText;
          },
          /* 6 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.JSXSyntax = {
              JSXAttribute: "JSXAttribute",
              JSXClosingElement: "JSXClosingElement",
              JSXElement: "JSXElement",
              JSXEmptyExpression: "JSXEmptyExpression",
              JSXExpressionContainer: "JSXExpressionContainer",
              JSXIdentifier: "JSXIdentifier",
              JSXMemberExpression: "JSXMemberExpression",
              JSXNamespacedName: "JSXNamespacedName",
              JSXOpeningElement: "JSXOpeningElement",
              JSXSpreadAttribute: "JSXSpreadAttribute",
              JSXText: "JSXText"
            };
          },
          /* 7 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var syntax_1 = __webpack_require__(2);
            var ArrayExpression = function() {
              function ArrayExpression2(elements) {
                this.type = syntax_1.Syntax.ArrayExpression;
                this.elements = elements;
              }
              return ArrayExpression2;
            }();
            exports2.ArrayExpression = ArrayExpression;
            var ArrayPattern = function() {
              function ArrayPattern2(elements) {
                this.type = syntax_1.Syntax.ArrayPattern;
                this.elements = elements;
              }
              return ArrayPattern2;
            }();
            exports2.ArrayPattern = ArrayPattern;
            var ArrowFunctionExpression = function() {
              function ArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression;
                this.id = null;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = expression;
                this.async = false;
              }
              return ArrowFunctionExpression2;
            }();
            exports2.ArrowFunctionExpression = ArrowFunctionExpression;
            var AssignmentExpression = function() {
              function AssignmentExpression2(operator, left, right) {
                this.type = syntax_1.Syntax.AssignmentExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
              }
              return AssignmentExpression2;
            }();
            exports2.AssignmentExpression = AssignmentExpression;
            var AssignmentPattern = function() {
              function AssignmentPattern2(left, right) {
                this.type = syntax_1.Syntax.AssignmentPattern;
                this.left = left;
                this.right = right;
              }
              return AssignmentPattern2;
            }();
            exports2.AssignmentPattern = AssignmentPattern;
            var AsyncArrowFunctionExpression = function() {
              function AsyncArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression;
                this.id = null;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = expression;
                this.async = true;
              }
              return AsyncArrowFunctionExpression2;
            }();
            exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
            var AsyncFunctionDeclaration = function() {
              function AsyncFunctionDeclaration2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionDeclaration;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = false;
                this.async = true;
              }
              return AsyncFunctionDeclaration2;
            }();
            exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
            var AsyncFunctionExpression = function() {
              function AsyncFunctionExpression2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionExpression;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = false;
                this.async = true;
              }
              return AsyncFunctionExpression2;
            }();
            exports2.AsyncFunctionExpression = AsyncFunctionExpression;
            var AwaitExpression = function() {
              function AwaitExpression2(argument) {
                this.type = syntax_1.Syntax.AwaitExpression;
                this.argument = argument;
              }
              return AwaitExpression2;
            }();
            exports2.AwaitExpression = AwaitExpression;
            var BinaryExpression = function() {
              function BinaryExpression2(operator, left, right) {
                var logical = operator === "||" || operator === "&&";
                this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
              }
              return BinaryExpression2;
            }();
            exports2.BinaryExpression = BinaryExpression;
            var BlockStatement = function() {
              function BlockStatement2(body) {
                this.type = syntax_1.Syntax.BlockStatement;
                this.body = body;
              }
              return BlockStatement2;
            }();
            exports2.BlockStatement = BlockStatement;
            var BreakStatement = function() {
              function BreakStatement2(label) {
                this.type = syntax_1.Syntax.BreakStatement;
                this.label = label;
              }
              return BreakStatement2;
            }();
            exports2.BreakStatement = BreakStatement;
            var CallExpression = function() {
              function CallExpression2(callee, args) {
                this.type = syntax_1.Syntax.CallExpression;
                this.callee = callee;
                this.arguments = args;
              }
              return CallExpression2;
            }();
            exports2.CallExpression = CallExpression;
            var CatchClause = function() {
              function CatchClause2(param, body) {
                this.type = syntax_1.Syntax.CatchClause;
                this.param = param;
                this.body = body;
              }
              return CatchClause2;
            }();
            exports2.CatchClause = CatchClause;
            var ClassBody = function() {
              function ClassBody2(body) {
                this.type = syntax_1.Syntax.ClassBody;
                this.body = body;
              }
              return ClassBody2;
            }();
            exports2.ClassBody = ClassBody;
            var ClassDeclaration = function() {
              function ClassDeclaration2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassDeclaration;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
              }
              return ClassDeclaration2;
            }();
            exports2.ClassDeclaration = ClassDeclaration;
            var ClassExpression = function() {
              function ClassExpression2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassExpression;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
              }
              return ClassExpression2;
            }();
            exports2.ClassExpression = ClassExpression;
            var ComputedMemberExpression = function() {
              function ComputedMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression;
                this.computed = true;
                this.object = object;
                this.property = property;
              }
              return ComputedMemberExpression2;
            }();
            exports2.ComputedMemberExpression = ComputedMemberExpression;
            var ConditionalExpression = function() {
              function ConditionalExpression2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.ConditionalExpression;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
              }
              return ConditionalExpression2;
            }();
            exports2.ConditionalExpression = ConditionalExpression;
            var ContinueStatement = function() {
              function ContinueStatement2(label) {
                this.type = syntax_1.Syntax.ContinueStatement;
                this.label = label;
              }
              return ContinueStatement2;
            }();
            exports2.ContinueStatement = ContinueStatement;
            var DebuggerStatement = function() {
              function DebuggerStatement2() {
                this.type = syntax_1.Syntax.DebuggerStatement;
              }
              return DebuggerStatement2;
            }();
            exports2.DebuggerStatement = DebuggerStatement;
            var Directive = function() {
              function Directive2(expression, directive) {
                this.type = syntax_1.Syntax.ExpressionStatement;
                this.expression = expression;
                this.directive = directive;
              }
              return Directive2;
            }();
            exports2.Directive = Directive;
            var DoWhileStatement = function() {
              function DoWhileStatement2(body, test) {
                this.type = syntax_1.Syntax.DoWhileStatement;
                this.body = body;
                this.test = test;
              }
              return DoWhileStatement2;
            }();
            exports2.DoWhileStatement = DoWhileStatement;
            var EmptyStatement = function() {
              function EmptyStatement2() {
                this.type = syntax_1.Syntax.EmptyStatement;
              }
              return EmptyStatement2;
            }();
            exports2.EmptyStatement = EmptyStatement;
            var ExportAllDeclaration = function() {
              function ExportAllDeclaration2(source) {
                this.type = syntax_1.Syntax.ExportAllDeclaration;
                this.source = source;
              }
              return ExportAllDeclaration2;
            }();
            exports2.ExportAllDeclaration = ExportAllDeclaration;
            var ExportDefaultDeclaration = function() {
              function ExportDefaultDeclaration2(declaration) {
                this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                this.declaration = declaration;
              }
              return ExportDefaultDeclaration2;
            }();
            exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
            var ExportNamedDeclaration = function() {
              function ExportNamedDeclaration2(declaration, specifiers, source) {
                this.type = syntax_1.Syntax.ExportNamedDeclaration;
                this.declaration = declaration;
                this.specifiers = specifiers;
                this.source = source;
              }
              return ExportNamedDeclaration2;
            }();
            exports2.ExportNamedDeclaration = ExportNamedDeclaration;
            var ExportSpecifier = function() {
              function ExportSpecifier2(local, exported) {
                this.type = syntax_1.Syntax.ExportSpecifier;
                this.exported = exported;
                this.local = local;
              }
              return ExportSpecifier2;
            }();
            exports2.ExportSpecifier = ExportSpecifier;
            var ExpressionStatement = function() {
              function ExpressionStatement2(expression) {
                this.type = syntax_1.Syntax.ExpressionStatement;
                this.expression = expression;
              }
              return ExpressionStatement2;
            }();
            exports2.ExpressionStatement = ExpressionStatement;
            var ForInStatement = function() {
              function ForInStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForInStatement;
                this.left = left;
                this.right = right;
                this.body = body;
                this.each = false;
              }
              return ForInStatement2;
            }();
            exports2.ForInStatement = ForInStatement;
            var ForOfStatement = function() {
              function ForOfStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForOfStatement;
                this.left = left;
                this.right = right;
                this.body = body;
              }
              return ForOfStatement2;
            }();
            exports2.ForOfStatement = ForOfStatement;
            var ForStatement = function() {
              function ForStatement2(init, test, update, body) {
                this.type = syntax_1.Syntax.ForStatement;
                this.init = init;
                this.test = test;
                this.update = update;
                this.body = body;
              }
              return ForStatement2;
            }();
            exports2.ForStatement = ForStatement;
            var FunctionDeclaration = function() {
              function FunctionDeclaration2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionDeclaration;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.async = false;
              }
              return FunctionDeclaration2;
            }();
            exports2.FunctionDeclaration = FunctionDeclaration;
            var FunctionExpression = function() {
              function FunctionExpression2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionExpression;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.async = false;
              }
              return FunctionExpression2;
            }();
            exports2.FunctionExpression = FunctionExpression;
            var Identifier = function() {
              function Identifier2(name) {
                this.type = syntax_1.Syntax.Identifier;
                this.name = name;
              }
              return Identifier2;
            }();
            exports2.Identifier = Identifier;
            var IfStatement = function() {
              function IfStatement2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.IfStatement;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
              }
              return IfStatement2;
            }();
            exports2.IfStatement = IfStatement;
            var ImportDeclaration = function() {
              function ImportDeclaration2(specifiers, source) {
                this.type = syntax_1.Syntax.ImportDeclaration;
                this.specifiers = specifiers;
                this.source = source;
              }
              return ImportDeclaration2;
            }();
            exports2.ImportDeclaration = ImportDeclaration;
            var ImportDefaultSpecifier = function() {
              function ImportDefaultSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                this.local = local;
              }
              return ImportDefaultSpecifier2;
            }();
            exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
            var ImportNamespaceSpecifier = function() {
              function ImportNamespaceSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                this.local = local;
              }
              return ImportNamespaceSpecifier2;
            }();
            exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            var ImportSpecifier = function() {
              function ImportSpecifier2(local, imported) {
                this.type = syntax_1.Syntax.ImportSpecifier;
                this.local = local;
                this.imported = imported;
              }
              return ImportSpecifier2;
            }();
            exports2.ImportSpecifier = ImportSpecifier;
            var LabeledStatement = function() {
              function LabeledStatement2(label, body) {
                this.type = syntax_1.Syntax.LabeledStatement;
                this.label = label;
                this.body = body;
              }
              return LabeledStatement2;
            }();
            exports2.LabeledStatement = LabeledStatement;
            var Literal = function() {
              function Literal2(value, raw) {
                this.type = syntax_1.Syntax.Literal;
                this.value = value;
                this.raw = raw;
              }
              return Literal2;
            }();
            exports2.Literal = Literal;
            var MetaProperty = function() {
              function MetaProperty2(meta, property) {
                this.type = syntax_1.Syntax.MetaProperty;
                this.meta = meta;
                this.property = property;
              }
              return MetaProperty2;
            }();
            exports2.MetaProperty = MetaProperty;
            var MethodDefinition = function() {
              function MethodDefinition2(key, computed, value, kind, isStatic) {
                this.type = syntax_1.Syntax.MethodDefinition;
                this.key = key;
                this.computed = computed;
                this.value = value;
                this.kind = kind;
                this.static = isStatic;
              }
              return MethodDefinition2;
            }();
            exports2.MethodDefinition = MethodDefinition;
            var Module = function() {
              function Module2(body) {
                this.type = syntax_1.Syntax.Program;
                this.body = body;
                this.sourceType = "module";
              }
              return Module2;
            }();
            exports2.Module = Module;
            var NewExpression = function() {
              function NewExpression2(callee, args) {
                this.type = syntax_1.Syntax.NewExpression;
                this.callee = callee;
                this.arguments = args;
              }
              return NewExpression2;
            }();
            exports2.NewExpression = NewExpression;
            var ObjectExpression = function() {
              function ObjectExpression2(properties) {
                this.type = syntax_1.Syntax.ObjectExpression;
                this.properties = properties;
              }
              return ObjectExpression2;
            }();
            exports2.ObjectExpression = ObjectExpression;
            var ObjectPattern = function() {
              function ObjectPattern2(properties) {
                this.type = syntax_1.Syntax.ObjectPattern;
                this.properties = properties;
              }
              return ObjectPattern2;
            }();
            exports2.ObjectPattern = ObjectPattern;
            var Property = function() {
              function Property2(kind, key, computed, value, method, shorthand) {
                this.type = syntax_1.Syntax.Property;
                this.key = key;
                this.computed = computed;
                this.value = value;
                this.kind = kind;
                this.method = method;
                this.shorthand = shorthand;
              }
              return Property2;
            }();
            exports2.Property = Property;
            var RegexLiteral = function() {
              function RegexLiteral2(value, raw, pattern, flags) {
                this.type = syntax_1.Syntax.Literal;
                this.value = value;
                this.raw = raw;
                this.regex = { pattern, flags };
              }
              return RegexLiteral2;
            }();
            exports2.RegexLiteral = RegexLiteral;
            var RestElement = function() {
              function RestElement2(argument) {
                this.type = syntax_1.Syntax.RestElement;
                this.argument = argument;
              }
              return RestElement2;
            }();
            exports2.RestElement = RestElement;
            var ReturnStatement = function() {
              function ReturnStatement2(argument) {
                this.type = syntax_1.Syntax.ReturnStatement;
                this.argument = argument;
              }
              return ReturnStatement2;
            }();
            exports2.ReturnStatement = ReturnStatement;
            var Script = function() {
              function Script2(body) {
                this.type = syntax_1.Syntax.Program;
                this.body = body;
                this.sourceType = "script";
              }
              return Script2;
            }();
            exports2.Script = Script;
            var SequenceExpression = function() {
              function SequenceExpression2(expressions) {
                this.type = syntax_1.Syntax.SequenceExpression;
                this.expressions = expressions;
              }
              return SequenceExpression2;
            }();
            exports2.SequenceExpression = SequenceExpression;
            var SpreadElement = function() {
              function SpreadElement2(argument) {
                this.type = syntax_1.Syntax.SpreadElement;
                this.argument = argument;
              }
              return SpreadElement2;
            }();
            exports2.SpreadElement = SpreadElement;
            var StaticMemberExpression = function() {
              function StaticMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression;
                this.computed = false;
                this.object = object;
                this.property = property;
              }
              return StaticMemberExpression2;
            }();
            exports2.StaticMemberExpression = StaticMemberExpression;
            var Super = function() {
              function Super2() {
                this.type = syntax_1.Syntax.Super;
              }
              return Super2;
            }();
            exports2.Super = Super;
            var SwitchCase = function() {
              function SwitchCase2(test, consequent) {
                this.type = syntax_1.Syntax.SwitchCase;
                this.test = test;
                this.consequent = consequent;
              }
              return SwitchCase2;
            }();
            exports2.SwitchCase = SwitchCase;
            var SwitchStatement = function() {
              function SwitchStatement2(discriminant, cases) {
                this.type = syntax_1.Syntax.SwitchStatement;
                this.discriminant = discriminant;
                this.cases = cases;
              }
              return SwitchStatement2;
            }();
            exports2.SwitchStatement = SwitchStatement;
            var TaggedTemplateExpression = function() {
              function TaggedTemplateExpression2(tag, quasi) {
                this.type = syntax_1.Syntax.TaggedTemplateExpression;
                this.tag = tag;
                this.quasi = quasi;
              }
              return TaggedTemplateExpression2;
            }();
            exports2.TaggedTemplateExpression = TaggedTemplateExpression;
            var TemplateElement = function() {
              function TemplateElement2(value, tail) {
                this.type = syntax_1.Syntax.TemplateElement;
                this.value = value;
                this.tail = tail;
              }
              return TemplateElement2;
            }();
            exports2.TemplateElement = TemplateElement;
            var TemplateLiteral = function() {
              function TemplateLiteral2(quasis, expressions) {
                this.type = syntax_1.Syntax.TemplateLiteral;
                this.quasis = quasis;
                this.expressions = expressions;
              }
              return TemplateLiteral2;
            }();
            exports2.TemplateLiteral = TemplateLiteral;
            var ThisExpression = function() {
              function ThisExpression2() {
                this.type = syntax_1.Syntax.ThisExpression;
              }
              return ThisExpression2;
            }();
            exports2.ThisExpression = ThisExpression;
            var ThrowStatement = function() {
              function ThrowStatement2(argument) {
                this.type = syntax_1.Syntax.ThrowStatement;
                this.argument = argument;
              }
              return ThrowStatement2;
            }();
            exports2.ThrowStatement = ThrowStatement;
            var TryStatement = function() {
              function TryStatement2(block, handler, finalizer) {
                this.type = syntax_1.Syntax.TryStatement;
                this.block = block;
                this.handler = handler;
                this.finalizer = finalizer;
              }
              return TryStatement2;
            }();
            exports2.TryStatement = TryStatement;
            var UnaryExpression = function() {
              function UnaryExpression2(operator, argument) {
                this.type = syntax_1.Syntax.UnaryExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = true;
              }
              return UnaryExpression2;
            }();
            exports2.UnaryExpression = UnaryExpression;
            var UpdateExpression = function() {
              function UpdateExpression2(operator, argument, prefix) {
                this.type = syntax_1.Syntax.UpdateExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = prefix;
              }
              return UpdateExpression2;
            }();
            exports2.UpdateExpression = UpdateExpression;
            var VariableDeclaration = function() {
              function VariableDeclaration2(declarations, kind) {
                this.type = syntax_1.Syntax.VariableDeclaration;
                this.declarations = declarations;
                this.kind = kind;
              }
              return VariableDeclaration2;
            }();
            exports2.VariableDeclaration = VariableDeclaration;
            var VariableDeclarator = function() {
              function VariableDeclarator2(id, init) {
                this.type = syntax_1.Syntax.VariableDeclarator;
                this.id = id;
                this.init = init;
              }
              return VariableDeclarator2;
            }();
            exports2.VariableDeclarator = VariableDeclarator;
            var WhileStatement = function() {
              function WhileStatement2(test, body) {
                this.type = syntax_1.Syntax.WhileStatement;
                this.test = test;
                this.body = body;
              }
              return WhileStatement2;
            }();
            exports2.WhileStatement = WhileStatement;
            var WithStatement = function() {
              function WithStatement2(object, body) {
                this.type = syntax_1.Syntax.WithStatement;
                this.object = object;
                this.body = body;
              }
              return WithStatement2;
            }();
            exports2.WithStatement = WithStatement;
            var YieldExpression = function() {
              function YieldExpression2(argument, delegate) {
                this.type = syntax_1.Syntax.YieldExpression;
                this.argument = argument;
                this.delegate = delegate;
              }
              return YieldExpression2;
            }();
            exports2.YieldExpression = YieldExpression;
          },
          /* 8 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var assert_1 = __webpack_require__(9);
            var error_handler_1 = __webpack_require__(10);
            var messages_1 = __webpack_require__(11);
            var Node = __webpack_require__(7);
            var scanner_1 = __webpack_require__(12);
            var syntax_1 = __webpack_require__(2);
            var token_1 = __webpack_require__(13);
            var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
            var Parser = function() {
              function Parser2(code, options, delegate) {
                if (options === void 0) {
                  options = {};
                }
                this.config = {
                  range: typeof options.range === "boolean" && options.range,
                  loc: typeof options.loc === "boolean" && options.loc,
                  source: null,
                  tokens: typeof options.tokens === "boolean" && options.tokens,
                  comment: typeof options.comment === "boolean" && options.comment,
                  tolerant: typeof options.tolerant === "boolean" && options.tolerant
                };
                if (this.config.loc && options.source && options.source !== null) {
                  this.config.source = String(options.source);
                }
                this.delegate = delegate;
                this.errorHandler = new error_handler_1.ErrorHandler();
                this.errorHandler.tolerant = this.config.tolerant;
                this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                this.scanner.trackComment = this.config.comment;
                this.operatorPrecedence = {
                  ")": 0,
                  ";": 0,
                  ",": 0,
                  "=": 0,
                  "]": 0,
                  "||": 1,
                  "&&": 2,
                  "|": 3,
                  "^": 4,
                  "&": 5,
                  "==": 6,
                  "!=": 6,
                  "===": 6,
                  "!==": 6,
                  "<": 7,
                  ">": 7,
                  "<=": 7,
                  ">=": 7,
                  "<<": 8,
                  ">>": 8,
                  ">>>": 8,
                  "+": 9,
                  "-": 9,
                  "*": 11,
                  "/": 11,
                  "%": 11
                };
                this.lookahead = {
                  type: 2,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: 0,
                  start: 0,
                  end: 0
                };
                this.hasLineTerminator = false;
                this.context = {
                  isModule: false,
                  await: false,
                  allowIn: true,
                  allowStrictDirective: true,
                  allowYield: true,
                  firstCoverInitializedNameError: null,
                  isAssignmentTarget: false,
                  isBindingElement: false,
                  inFunctionBody: false,
                  inIteration: false,
                  inSwitch: false,
                  labelSet: {},
                  strict: false
                };
                this.tokens = [];
                this.startMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                };
                this.lastMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                };
                this.nextToken();
                this.lastMarker = {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }
              Parser2.prototype.throwError = function(messageFormat) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  values[_i - 1] = arguments[_i];
                }
                var args = Array.prototype.slice.call(arguments, 1);
                var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                  assert_1.assert(idx < args.length, "Message reference must be in range");
                  return args[idx];
                });
                var index = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                throw this.errorHandler.createError(index, line, column, msg);
              };
              Parser2.prototype.tolerateError = function(messageFormat) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  values[_i - 1] = arguments[_i];
                }
                var args = Array.prototype.slice.call(arguments, 1);
                var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                  assert_1.assert(idx < args.length, "Message reference must be in range");
                  return args[idx];
                });
                var index = this.lastMarker.index;
                var line = this.scanner.lineNumber;
                var column = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(index, line, column, msg);
              };
              Parser2.prototype.unexpectedTokenError = function(token, message) {
                var msg = message || messages_1.Messages.UnexpectedToken;
                var value;
                if (token) {
                  if (!message) {
                    msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                    if (token.type === 4) {
                      if (this.scanner.isFutureReservedWord(token.value)) {
                        msg = messages_1.Messages.UnexpectedReserved;
                      } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                        msg = messages_1.Messages.StrictReservedWord;
                      }
                    }
                  }
                  value = token.value;
                } else {
                  value = "ILLEGAL";
                }
                msg = msg.replace("%0", value);
                if (token && typeof token.lineNumber === "number") {
                  var index = token.start;
                  var line = token.lineNumber;
                  var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                  var column = token.start - lastMarkerLineStart + 1;
                  return this.errorHandler.createError(index, line, column, msg);
                } else {
                  var index = this.lastMarker.index;
                  var line = this.lastMarker.line;
                  var column = this.lastMarker.column + 1;
                  return this.errorHandler.createError(index, line, column, msg);
                }
              };
              Parser2.prototype.throwUnexpectedToken = function(token, message) {
                throw this.unexpectedTokenError(token, message);
              };
              Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
                this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
              };
              Parser2.prototype.collectComments = function() {
                if (!this.config.comment) {
                  this.scanner.scanComments();
                } else {
                  var comments = this.scanner.scanComments();
                  if (comments.length > 0 && this.delegate) {
                    for (var i = 0; i < comments.length; ++i) {
                      var e = comments[i];
                      var node = void 0;
                      node = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
                      };
                      if (this.config.range) {
                        node.range = e.range;
                      }
                      if (this.config.loc) {
                        node.loc = e.loc;
                      }
                      var metadata = {
                        start: {
                          line: e.loc.start.line,
                          column: e.loc.start.column,
                          offset: e.range[0]
                        },
                        end: {
                          line: e.loc.end.line,
                          column: e.loc.end.column,
                          offset: e.range[1]
                        }
                      };
                      this.delegate(node, metadata);
                    }
                  }
                }
              };
              Parser2.prototype.getTokenRaw = function(token) {
                return this.scanner.source.slice(token.start, token.end);
              };
              Parser2.prototype.convertToken = function(token) {
                var t = {
                  type: token_1.TokenName[token.type],
                  value: this.getTokenRaw(token)
                };
                if (this.config.range) {
                  t.range = [token.start, token.end];
                }
                if (this.config.loc) {
                  t.loc = {
                    start: {
                      line: this.startMarker.line,
                      column: this.startMarker.column
                    },
                    end: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    }
                  };
                }
                if (token.type === 9) {
                  var pattern = token.pattern;
                  var flags = token.flags;
                  t.regex = { pattern, flags };
                }
                return t;
              };
              Parser2.prototype.nextToken = function() {
                var token = this.lookahead;
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                this.collectComments();
                if (this.scanner.index !== this.startMarker.index) {
                  this.startMarker.index = this.scanner.index;
                  this.startMarker.line = this.scanner.lineNumber;
                  this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                }
                var next = this.scanner.lex();
                this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                if (next && this.context.strict && next.type === 3) {
                  if (this.scanner.isStrictModeReservedWord(next.value)) {
                    next.type = 4;
                  }
                }
                this.lookahead = next;
                if (this.config.tokens && next.type !== 2) {
                  this.tokens.push(this.convertToken(next));
                }
                return token;
              };
              Parser2.prototype.nextRegexToken = function() {
                this.collectComments();
                var token = this.scanner.scanRegExp();
                if (this.config.tokens) {
                  this.tokens.pop();
                  this.tokens.push(this.convertToken(token));
                }
                this.lookahead = token;
                this.nextToken();
                return token;
              };
              Parser2.prototype.createNode = function() {
                return {
                  index: this.startMarker.index,
                  line: this.startMarker.line,
                  column: this.startMarker.column
                };
              };
              Parser2.prototype.startNode = function(token, lastLineStart) {
                if (lastLineStart === void 0) {
                  lastLineStart = 0;
                }
                var column = token.start - token.lineStart;
                var line = token.lineNumber;
                if (column < 0) {
                  column += lastLineStart;
                  line--;
                }
                return {
                  index: token.start,
                  line,
                  column
                };
              };
              Parser2.prototype.finalize = function(marker, node) {
                if (this.config.range) {
                  node.range = [marker.index, this.lastMarker.index];
                }
                if (this.config.loc) {
                  node.loc = {
                    start: {
                      line: marker.line,
                      column: marker.column
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column
                    }
                  };
                  if (this.config.source) {
                    node.loc.source = this.config.source;
                  }
                }
                if (this.delegate) {
                  var metadata = {
                    start: {
                      line: marker.line,
                      column: marker.column,
                      offset: marker.index
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column,
                      offset: this.lastMarker.index
                    }
                  };
                  this.delegate(node, metadata);
                }
                return node;
              };
              Parser2.prototype.expect = function(value) {
                var token = this.nextToken();
                if (token.type !== 7 || token.value !== value) {
                  this.throwUnexpectedToken(token);
                }
              };
              Parser2.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var token = this.lookahead;
                  if (token.type === 7 && token.value === ",") {
                    this.nextToken();
                  } else if (token.type === 7 && token.value === ";") {
                    this.nextToken();
                    this.tolerateUnexpectedToken(token);
                  } else {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                  }
                } else {
                  this.expect(",");
                }
              };
              Parser2.prototype.expectKeyword = function(keyword) {
                var token = this.nextToken();
                if (token.type !== 4 || token.value !== keyword) {
                  this.throwUnexpectedToken(token);
                }
              };
              Parser2.prototype.match = function(value) {
                return this.lookahead.type === 7 && this.lookahead.value === value;
              };
              Parser2.prototype.matchKeyword = function(keyword) {
                return this.lookahead.type === 4 && this.lookahead.value === keyword;
              };
              Parser2.prototype.matchContextualKeyword = function(keyword) {
                return this.lookahead.type === 3 && this.lookahead.value === keyword;
              };
              Parser2.prototype.matchAssign = function() {
                if (this.lookahead.type !== 7) {
                  return false;
                }
                var op = this.lookahead.value;
                return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
              };
              Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement;
                var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true;
                this.context.isAssignmentTarget = true;
                this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                if (this.context.firstCoverInitializedNameError !== null) {
                  this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                }
                this.context.isBindingElement = previousIsBindingElement;
                this.context.isAssignmentTarget = previousIsAssignmentTarget;
                this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                return result;
              };
              Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement;
                var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true;
                this.context.isAssignmentTarget = true;
                this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                return result;
              };
              Parser2.prototype.consumeSemicolon = function() {
                if (this.match(";")) {
                  this.nextToken();
                } else if (!this.hasLineTerminator) {
                  if (this.lookahead.type !== 2 && !this.match("}")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  this.lastMarker.index = this.startMarker.index;
                  this.lastMarker.line = this.startMarker.line;
                  this.lastMarker.column = this.startMarker.column;
                }
              };
              Parser2.prototype.parsePrimaryExpression = function() {
                var node = this.createNode();
                var expr;
                var token, raw;
                switch (this.lookahead.type) {
                  case 3:
                    if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    if (this.context.strict && this.lookahead.octal) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(token.value, raw));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(null, raw));
                    break;
                  case 10:
                    expr = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = false;
                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        this.scanner.index = this.startMarker.index;
                        token = this.nextRegexToken();
                        raw = this.getTokenRaw(token);
                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                        break;
                      default:
                        expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                      expr = this.parseIdentifierName();
                    } else if (!this.context.strict && this.matchKeyword("let")) {
                      expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                    } else {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      if (this.matchKeyword("function")) {
                        expr = this.parseFunctionExpression();
                      } else if (this.matchKeyword("this")) {
                        this.nextToken();
                        expr = this.finalize(node, new Node.ThisExpression());
                      } else if (this.matchKeyword("class")) {
                        expr = this.parseClassExpression();
                      } else {
                        expr = this.throwUnexpectedToken(this.nextToken());
                      }
                    }
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                return expr;
              };
              Parser2.prototype.parseSpreadElement = function() {
                var node = this.createNode();
                this.expect("...");
                var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(node, new Node.SpreadElement(arg));
              };
              Parser2.prototype.parseArrayInitializer = function() {
                var node = this.createNode();
                var elements = [];
                this.expect("[");
                while (!this.match("]")) {
                  if (this.match(",")) {
                    this.nextToken();
                    elements.push(null);
                  } else if (this.match("...")) {
                    var element = this.parseSpreadElement();
                    if (!this.match("]")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.expect(",");
                    }
                    elements.push(element);
                  } else {
                    elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                    if (!this.match("]")) {
                      this.expect(",");
                    }
                  }
                }
                this.expect("]");
                return this.finalize(node, new Node.ArrayExpression(elements));
              };
              Parser2.prototype.parsePropertyMethod = function(params) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = params.simple;
                var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                if (this.context.strict && params.firstRestricted) {
                  this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                }
                if (this.context.strict && params.stricted) {
                  this.tolerateUnexpectedToken(params.stricted, params.message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                return body;
              };
              Parser2.prototype.parsePropertyMethodFunction = function() {
                var isGenerator = false;
                var node = this.createNode();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var params = this.parseFormalParameters();
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              };
              Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
                var node = this.createNode();
                var previousAllowYield = this.context.allowYield;
                var previousAwait = this.context.await;
                this.context.allowYield = false;
                this.context.await = true;
                var params = this.parseFormalParameters();
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                this.context.await = previousAwait;
                return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
              };
              Parser2.prototype.parseObjectPropertyKey = function() {
                var node = this.createNode();
                var token = this.nextToken();
                var key;
                switch (token.type) {
                  case 8:
                  case 6:
                    if (this.context.strict && token.octal) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                    }
                    var raw = this.getTokenRaw(token);
                    key = this.finalize(node, new Node.Literal(token.value, raw));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    key = this.finalize(node, new Node.Identifier(token.value));
                    break;
                  case 7:
                    if (token.value === "[") {
                      key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      this.expect("]");
                    } else {
                      key = this.throwUnexpectedToken(token);
                    }
                    break;
                  default:
                    key = this.throwUnexpectedToken(token);
                }
                return key;
              };
              Parser2.prototype.isPropertyKey = function(key, value) {
                return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
              };
              Parser2.prototype.parseObjectProperty = function(hasProto) {
                var node = this.createNode();
                var token = this.lookahead;
                var kind;
                var key = null;
                var value = null;
                var computed = false;
                var method = false;
                var shorthand = false;
                var isAsync = false;
                if (token.type === 3) {
                  var id = token.value;
                  this.nextToken();
                  computed = this.match("[");
                  isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                  key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
                } else if (this.match("*")) {
                  this.nextToken();
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value = this.parseGetterMethod();
                } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseSetterMethod();
                } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                  kind = "init";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseGeneratorMethod();
                  method = true;
                } else {
                  if (!key) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  kind = "init";
                  if (this.match(":") && !isAsync) {
                    if (!computed && this.isPropertyKey(key, "__proto__")) {
                      if (hasProto.value) {
                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                      }
                      hasProto.value = true;
                    }
                    this.nextToken();
                    value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  } else if (this.match("(")) {
                    value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                    method = true;
                  } else if (token.type === 3) {
                    var id = this.finalize(node, new Node.Identifier(token.value));
                    if (this.match("=")) {
                      this.context.firstCoverInitializedNameError = this.lookahead;
                      this.nextToken();
                      shorthand = true;
                      var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      value = this.finalize(node, new Node.AssignmentPattern(id, init));
                    } else {
                      shorthand = true;
                      value = id;
                    }
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                }
                return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
              };
              Parser2.prototype.parseObjectInitializer = function() {
                var node = this.createNode();
                this.expect("{");
                var properties = [];
                var hasProto = { value: false };
                while (!this.match("}")) {
                  properties.push(this.parseObjectProperty(hasProto));
                  if (!this.match("}")) {
                    this.expectCommaSeparator();
                  }
                }
                this.expect("}");
                return this.finalize(node, new Node.ObjectExpression(properties));
              };
              Parser2.prototype.parseTemplateHead = function() {
                assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
                var node = this.createNode();
                var token = this.nextToken();
                var raw = token.value;
                var cooked = token.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
              };
              Parser2.prototype.parseTemplateElement = function() {
                if (this.lookahead.type !== 10) {
                  this.throwUnexpectedToken();
                }
                var node = this.createNode();
                var token = this.nextToken();
                var raw = token.value;
                var cooked = token.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
              };
              Parser2.prototype.parseTemplateLiteral = function() {
                var node = this.createNode();
                var expressions = [];
                var quasis = [];
                var quasi = this.parseTemplateHead();
                quasis.push(quasi);
                while (!quasi.tail) {
                  expressions.push(this.parseExpression());
                  quasi = this.parseTemplateElement();
                  quasis.push(quasi);
                }
                return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
              };
              Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                  case syntax_1.Syntax.MemberExpression:
                  case syntax_1.Syntax.RestElement:
                  case syntax_1.Syntax.AssignmentPattern:
                    break;
                  case syntax_1.Syntax.SpreadElement:
                    expr.type = syntax_1.Syntax.RestElement;
                    this.reinterpretExpressionAsPattern(expr.argument);
                    break;
                  case syntax_1.Syntax.ArrayExpression:
                    expr.type = syntax_1.Syntax.ArrayPattern;
                    for (var i = 0; i < expr.elements.length; i++) {
                      if (expr.elements[i] !== null) {
                        this.reinterpretExpressionAsPattern(expr.elements[i]);
                      }
                    }
                    break;
                  case syntax_1.Syntax.ObjectExpression:
                    expr.type = syntax_1.Syntax.ObjectPattern;
                    for (var i = 0; i < expr.properties.length; i++) {
                      this.reinterpretExpressionAsPattern(expr.properties[i].value);
                    }
                    break;
                  case syntax_1.Syntax.AssignmentExpression:
                    expr.type = syntax_1.Syntax.AssignmentPattern;
                    delete expr.operator;
                    this.reinterpretExpressionAsPattern(expr.left);
                    break;
                  default:
                    break;
                }
              };
              Parser2.prototype.parseGroupExpression = function() {
                var expr;
                this.expect("(");
                if (this.match(")")) {
                  this.nextToken();
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [],
                    async: false
                  };
                } else {
                  var startToken = this.lookahead;
                  var params = [];
                  if (this.match("...")) {
                    expr = this.parseRestElement(params);
                    this.expect(")");
                    if (!this.match("=>")) {
                      this.expect("=>");
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [expr],
                      async: false
                    };
                  } else {
                    var arrow = false;
                    this.context.isBindingElement = true;
                    expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    if (this.match(",")) {
                      var expressions = [];
                      this.context.isAssignmentTarget = false;
                      expressions.push(expr);
                      while (this.lookahead.type !== 2) {
                        if (!this.match(",")) {
                          break;
                        }
                        this.nextToken();
                        if (this.match(")")) {
                          this.nextToken();
                          for (var i = 0; i < expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          }
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: false
                          };
                        } else if (this.match("...")) {
                          if (!this.context.isBindingElement) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          expressions.push(this.parseRestElement(params));
                          this.expect(")");
                          if (!this.match("=>")) {
                            this.expect("=>");
                          }
                          this.context.isBindingElement = false;
                          for (var i = 0; i < expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          }
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: false
                          };
                        } else {
                          expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        }
                        if (arrow) {
                          break;
                        }
                      }
                      if (!arrow) {
                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                      }
                    }
                    if (!arrow) {
                      this.expect(")");
                      if (this.match("=>")) {
                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: [expr],
                            async: false
                          };
                        }
                        if (!arrow) {
                          if (!this.context.isBindingElement) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          if (expr.type === syntax_1.Syntax.SequenceExpression) {
                            for (var i = 0; i < expr.expressions.length; i++) {
                              this.reinterpretExpressionAsPattern(expr.expressions[i]);
                            }
                          } else {
                            this.reinterpretExpressionAsPattern(expr);
                          }
                          var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: parameters,
                            async: false
                          };
                        }
                      }
                      this.context.isBindingElement = false;
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")")) {
                  while (true) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                    args.push(expr);
                    if (this.match(")")) {
                      break;
                    }
                    this.expectCommaSeparator();
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return args;
              };
              Parser2.prototype.isIdentifierName = function(token) {
                return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
              };
              Parser2.prototype.parseIdentifierName = function() {
                var node = this.createNode();
                var token = this.nextToken();
                if (!this.isIdentifierName(token)) {
                  this.throwUnexpectedToken(token);
                }
                return this.finalize(node, new Node.Identifier(token.value));
              };
              Parser2.prototype.parseNewExpression = function() {
                var node = this.createNode();
                var id = this.parseIdentifierName();
                assert_1.assert(id.name === "new", "New expression must start with `new`");
                var expr;
                if (this.match(".")) {
                  this.nextToken();
                  if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                    var property = this.parseIdentifierName();
                    expr = new Node.MetaProperty(id, property);
                  } else {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                } else {
                  var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                  var args = this.match("(") ? this.parseArguments() : [];
                  expr = new Node.NewExpression(callee, args);
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                }
                return this.finalize(node, expr);
              };
              Parser2.prototype.parseAsyncArgument = function() {
                var arg = this.parseAssignmentExpression();
                this.context.firstCoverInitializedNameError = null;
                return arg;
              };
              Parser2.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")")) {
                  while (true) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                    args.push(expr);
                    if (this.match(")")) {
                      break;
                    }
                    this.expectCommaSeparator();
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return args;
              };
              Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var startToken = this.lookahead;
                var maybeAsync = this.matchContextualKeyword("async");
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var expr;
                if (this.matchKeyword("super") && this.context.inFunctionBody) {
                  expr = this.createNode();
                  this.nextToken();
                  expr = this.finalize(expr, new Node.Super());
                  if (!this.match("(") && !this.match(".") && !this.match("[")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                } else {
                  expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                }
                while (true) {
                  if (this.match(".")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                  } else if (this.match("(")) {
                    var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = false;
                    var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                    expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                    if (asyncArrow && this.match("=>")) {
                      for (var i = 0; i < args.length; ++i) {
                        this.reinterpretExpressionAsPattern(args[i]);
                      }
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: args,
                        async: true
                      };
                    }
                  } else if (this.match("[")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]");
                    expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                  } else {
                    break;
                  }
                }
                this.context.allowIn = previousAllowIn;
                return expr;
              };
              Parser2.prototype.parseSuper = function() {
                var node = this.createNode();
                this.expectKeyword("super");
                if (!this.match("[") && !this.match(".")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                return this.finalize(node, new Node.Super());
              };
              Parser2.prototype.parseLeftHandSideExpression = function() {
                assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                var node = this.startNode(this.lookahead);
                var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                while (true) {
                  if (this.match("[")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]");
                    expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                  } else if (this.match(".")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                  } else {
                    break;
                  }
                }
                return expr;
              };
              Parser2.prototype.parseUpdateExpression = function() {
                var expr;
                var startToken = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var node = this.startNode(startToken);
                  var token = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                    this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                  }
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  var prefix = true;
                  expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                } else {
                  expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                  if (!this.hasLineTerminator && this.lookahead.type === 7) {
                    if (this.match("++") || this.match("--")) {
                      if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                      }
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var operator = this.nextToken().value;
                      var prefix = false;
                      expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseAwaitExpression = function() {
                var node = this.createNode();
                this.nextToken();
                var argument = this.parseUnaryExpression();
                return this.finalize(node, new Node.AwaitExpression(argument));
              };
              Parser2.prototype.parseUnaryExpression = function() {
                var expr;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var node = this.startNode(this.lookahead);
                  var token = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                  expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
                  if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                    this.tolerateError(messages_1.Messages.StrictDelete);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                } else if (this.context.await && this.matchContextualKeyword("await")) {
                  expr = this.parseAwaitExpression();
                } else {
                  expr = this.parseUpdateExpression();
                }
                return expr;
              };
              Parser2.prototype.parseExponentiationExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken();
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var left = expr;
                  var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
                }
                return expr;
              };
              Parser2.prototype.binaryPrecedence = function(token) {
                var op = token.value;
                var precedence;
                if (token.type === 7) {
                  precedence = this.operatorPrecedence[op] || 0;
                } else if (token.type === 4) {
                  precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                } else {
                  precedence = 0;
                }
                return precedence;
              };
              Parser2.prototype.parseBinaryExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
                var token = this.lookahead;
                var prec = this.binaryPrecedence(token);
                if (prec > 0) {
                  this.nextToken();
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var markers = [startToken, this.lookahead];
                  var left = expr;
                  var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  var stack = [left, token.value, right];
                  var precedences = [prec];
                  while (true) {
                    prec = this.binaryPrecedence(this.lookahead);
                    if (prec <= 0) {
                      break;
                    }
                    while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                      right = stack.pop();
                      var operator = stack.pop();
                      precedences.pop();
                      left = stack.pop();
                      markers.pop();
                      var node = this.startNode(markers[markers.length - 1]);
                      stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                    }
                    stack.push(this.nextToken().value);
                    precedences.push(prec);
                    markers.push(this.lookahead);
                    stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var i = stack.length - 1;
                  expr = stack[i];
                  var lastMarker = markers.pop();
                  while (i > 1) {
                    var marker = markers.pop();
                    var lastLineStart = lastMarker && lastMarker.lineStart;
                    var node = this.startNode(marker, lastLineStart);
                    var operator = stack[i - 1];
                    expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                    i -= 2;
                    lastMarker = marker;
                  }
                }
                return expr;
              };
              Parser2.prototype.parseConditionalExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = true;
                  var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  this.expect(":");
                  var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                }
                return expr;
              };
              Parser2.prototype.checkPatternParam = function(options, param) {
                switch (param.type) {
                  case syntax_1.Syntax.Identifier:
                    this.validateParam(options, param, param.name);
                    break;
                  case syntax_1.Syntax.RestElement:
                    this.checkPatternParam(options, param.argument);
                    break;
                  case syntax_1.Syntax.AssignmentPattern:
                    this.checkPatternParam(options, param.left);
                    break;
                  case syntax_1.Syntax.ArrayPattern:
                    for (var i = 0; i < param.elements.length; i++) {
                      if (param.elements[i] !== null) {
                        this.checkPatternParam(options, param.elements[i]);
                      }
                    }
                    break;
                  case syntax_1.Syntax.ObjectPattern:
                    for (var i = 0; i < param.properties.length; i++) {
                      this.checkPatternParam(options, param.properties[i].value);
                    }
                    break;
                  default:
                    break;
                }
                options.simple = options.simple && param instanceof Node.Identifier;
              };
              Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
                var params = [expr];
                var options;
                var asyncArrow = false;
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                    break;
                  case ArrowParameterPlaceHolder:
                    params = expr.params;
                    asyncArrow = expr.async;
                    break;
                  default:
                    return null;
                }
                options = {
                  simple: true,
                  paramSet: {}
                };
                for (var i = 0; i < params.length; ++i) {
                  var param = params[i];
                  if (param.type === syntax_1.Syntax.AssignmentPattern) {
                    if (param.right.type === syntax_1.Syntax.YieldExpression) {
                      if (param.right.argument) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      param.right.type = syntax_1.Syntax.Identifier;
                      param.right.name = "yield";
                      delete param.right.argument;
                      delete param.right.delegate;
                    }
                  } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  this.checkPatternParam(options, param);
                  params[i] = param;
                }
                if (this.context.strict || !this.context.allowYield) {
                  for (var i = 0; i < params.length; ++i) {
                    var param = params[i];
                    if (param.type === syntax_1.Syntax.YieldExpression) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                }
                if (options.message === messages_1.Messages.StrictParamDupe) {
                  var token = this.context.strict ? options.stricted : options.firstRestricted;
                  this.throwUnexpectedToken(token, options.message);
                }
                return {
                  simple: options.simple,
                  params,
                  stricted: options.stricted,
                  firstRestricted: options.firstRestricted,
                  message: options.message
                };
              };
              Parser2.prototype.parseAssignmentExpression = function() {
                var expr;
                if (!this.context.allowYield && this.matchKeyword("yield")) {
                  expr = this.parseYieldExpression();
                } else {
                  var startToken = this.lookahead;
                  var token = startToken;
                  expr = this.parseConditionalExpression();
                  if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                    if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                      var arg = this.parsePrimaryExpression();
                      this.reinterpretExpressionAsPattern(arg);
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [arg],
                        async: true
                      };
                    }
                  }
                  if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var isAsync = expr.async;
                    var list = this.reinterpretAsCoverFormalsList(expr);
                    if (list) {
                      if (this.hasLineTerminator) {
                        this.tolerateUnexpectedToken(this.lookahead);
                      }
                      this.context.firstCoverInitializedNameError = null;
                      var previousStrict = this.context.strict;
                      var previousAllowStrictDirective = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = list.simple;
                      var previousAllowYield = this.context.allowYield;
                      var previousAwait = this.context.await;
                      this.context.allowYield = true;
                      this.context.await = isAsync;
                      var node = this.startNode(startToken);
                      this.expect("=>");
                      var body = void 0;
                      if (this.match("{")) {
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = true;
                        body = this.parseFunctionSourceElements();
                        this.context.allowIn = previousAllowIn;
                      } else {
                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      }
                      var expression = body.type !== syntax_1.Syntax.BlockStatement;
                      if (this.context.strict && list.firstRestricted) {
                        this.throwUnexpectedToken(list.firstRestricted, list.message);
                      }
                      if (this.context.strict && list.stricted) {
                        this.tolerateUnexpectedToken(list.stricted, list.message);
                      }
                      expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                      this.context.strict = previousStrict;
                      this.context.allowStrictDirective = previousAllowStrictDirective;
                      this.context.allowYield = previousAllowYield;
                      this.context.await = previousAwait;
                    }
                  } else {
                    if (this.matchAssign()) {
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                        var id = expr;
                        if (this.scanner.isRestrictedWord(id.name)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                        }
                        if (this.scanner.isStrictModeReservedWord(id.name)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        }
                      }
                      if (!this.match("=")) {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                      } else {
                        this.reinterpretExpressionAsPattern(expr);
                      }
                      token = this.nextToken();
                      var operator = token.value;
                      var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                      this.context.firstCoverInitializedNameError = null;
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseExpression = function() {
                var startToken = this.lookahead;
                var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  expressions.push(expr);
                  while (this.lookahead.type !== 2) {
                    if (!this.match(",")) {
                      break;
                    }
                    this.nextToken();
                    expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  }
                  expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                }
                return expr;
              };
              Parser2.prototype.parseStatementListItem = function() {
                var statement;
                this.context.isAssignmentTarget = true;
                this.context.isBindingElement = true;
                if (this.lookahead.type === 4) {
                  switch (this.lookahead.value) {
                    case "export":
                      if (!this.context.isModule) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                      }
                      statement = this.parseExportDeclaration();
                      break;
                    case "import":
                      if (!this.context.isModule) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                      }
                      statement = this.parseImportDeclaration();
                      break;
                    case "const":
                      statement = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "class":
                      statement = this.parseClassDeclaration();
                      break;
                    case "let":
                      statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                      break;
                    default:
                      statement = this.parseStatement();
                      break;
                  }
                } else {
                  statement = this.parseStatement();
                }
                return statement;
              };
              Parser2.prototype.parseBlock = function() {
                var node = this.createNode();
                this.expect("{");
                var block = [];
                while (true) {
                  if (this.match("}")) {
                    break;
                  }
                  block.push(this.parseStatementListItem());
                }
                this.expect("}");
                return this.finalize(node, new Node.BlockStatement(block));
              };
              Parser2.prototype.parseLexicalBinding = function(kind, options) {
                var node = this.createNode();
                var params = [];
                var id = this.parsePattern(params, kind);
                if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(id.name)) {
                    this.tolerateError(messages_1.Messages.StrictVarName);
                  }
                }
                var init = null;
                if (kind === "const") {
                  if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                    if (this.match("=")) {
                      this.nextToken();
                      init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    } else {
                      this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                    }
                  }
                } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                  this.expect("=");
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                }
                return this.finalize(node, new Node.VariableDeclarator(id, init));
              };
              Parser2.prototype.parseBindingList = function(kind, options) {
                var list = [this.parseLexicalBinding(kind, options)];
                while (this.match(",")) {
                  this.nextToken();
                  list.push(this.parseLexicalBinding(kind, options));
                }
                return list;
              };
              Parser2.prototype.isLexicalDeclaration = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                this.scanner.restoreState(state);
                return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
              };
              Parser2.prototype.parseLexicalDeclaration = function(options) {
                var node = this.createNode();
                var kind = this.nextToken().value;
                assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                var declarations = this.parseBindingList(kind, options);
                this.consumeSemicolon();
                return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
              };
              Parser2.prototype.parseBindingRestElement = function(params, kind) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params, kind);
                return this.finalize(node, new Node.RestElement(arg));
              };
              Parser2.prototype.parseArrayPattern = function(params, kind) {
                var node = this.createNode();
                this.expect("[");
                var elements = [];
                while (!this.match("]")) {
                  if (this.match(",")) {
                    this.nextToken();
                    elements.push(null);
                  } else {
                    if (this.match("...")) {
                      elements.push(this.parseBindingRestElement(params, kind));
                      break;
                    } else {
                      elements.push(this.parsePatternWithDefault(params, kind));
                    }
                    if (!this.match("]")) {
                      this.expect(",");
                    }
                  }
                }
                this.expect("]");
                return this.finalize(node, new Node.ArrayPattern(elements));
              };
              Parser2.prototype.parsePropertyPattern = function(params, kind) {
                var node = this.createNode();
                var computed = false;
                var shorthand = false;
                var method = false;
                var key;
                var value;
                if (this.lookahead.type === 3) {
                  var keyToken = this.lookahead;
                  key = this.parseVariableIdentifier();
                  var init = this.finalize(node, new Node.Identifier(keyToken.value));
                  if (this.match("=")) {
                    params.push(keyToken);
                    shorthand = true;
                    this.nextToken();
                    var expr = this.parseAssignmentExpression();
                    value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
                  } else if (!this.match(":")) {
                    params.push(keyToken);
                    shorthand = true;
                    value = init;
                  } else {
                    this.expect(":");
                    value = this.parsePatternWithDefault(params, kind);
                  }
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.expect(":");
                  value = this.parsePatternWithDefault(params, kind);
                }
                return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
              };
              Parser2.prototype.parseObjectPattern = function(params, kind) {
                var node = this.createNode();
                var properties = [];
                this.expect("{");
                while (!this.match("}")) {
                  properties.push(this.parsePropertyPattern(params, kind));
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                return this.finalize(node, new Node.ObjectPattern(properties));
              };
              Parser2.prototype.parsePattern = function(params, kind) {
                var pattern;
                if (this.match("[")) {
                  pattern = this.parseArrayPattern(params, kind);
                } else if (this.match("{")) {
                  pattern = this.parseObjectPattern(params, kind);
                } else {
                  if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                  }
                  params.push(this.lookahead);
                  pattern = this.parseVariableIdentifier(kind);
                }
                return pattern;
              };
              Parser2.prototype.parsePatternWithDefault = function(params, kind) {
                var startToken = this.lookahead;
                var pattern = this.parsePattern(params, kind);
                if (this.match("=")) {
                  this.nextToken();
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = true;
                  var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = previousAllowYield;
                  pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
                }
                return pattern;
              };
              Parser2.prototype.parseVariableIdentifier = function(kind) {
                var node = this.createNode();
                var token = this.nextToken();
                if (token.type === 4 && token.value === "yield") {
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                  } else if (!this.context.allowYield) {
                    this.throwUnexpectedToken(token);
                  }
                } else if (token.type !== 3) {
                  if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                  } else {
                    if (this.context.strict || token.value !== "let" || kind !== "var") {
                      this.throwUnexpectedToken(token);
                    }
                  }
                } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                  this.tolerateUnexpectedToken(token);
                }
                return this.finalize(node, new Node.Identifier(token.value));
              };
              Parser2.prototype.parseVariableDeclaration = function(options) {
                var node = this.createNode();
                var params = [];
                var id = this.parsePattern(params, "var");
                if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(id.name)) {
                    this.tolerateError(messages_1.Messages.StrictVarName);
                  }
                }
                var init = null;
                if (this.match("=")) {
                  this.nextToken();
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                  this.expect("=");
                }
                return this.finalize(node, new Node.VariableDeclarator(id, init));
              };
              Parser2.prototype.parseVariableDeclarationList = function(options) {
                var opt = { inFor: options.inFor };
                var list = [];
                list.push(this.parseVariableDeclaration(opt));
                while (this.match(",")) {
                  this.nextToken();
                  list.push(this.parseVariableDeclaration(opt));
                }
                return list;
              };
              Parser2.prototype.parseVariableStatement = function() {
                var node = this.createNode();
                this.expectKeyword("var");
                var declarations = this.parseVariableDeclarationList({ inFor: false });
                this.consumeSemicolon();
                return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
              };
              Parser2.prototype.parseEmptyStatement = function() {
                var node = this.createNode();
                this.expect(";");
                return this.finalize(node, new Node.EmptyStatement());
              };
              Parser2.prototype.parseExpressionStatement = function() {
                var node = this.createNode();
                var expr = this.parseExpression();
                this.consumeSemicolon();
                return this.finalize(node, new Node.ExpressionStatement(expr));
              };
              Parser2.prototype.parseIfClause = function() {
                if (this.context.strict && this.matchKeyword("function")) {
                  this.tolerateError(messages_1.Messages.StrictFunction);
                }
                return this.parseStatement();
              };
              Parser2.prototype.parseIfStatement = function() {
                var node = this.createNode();
                var consequent;
                var alternate = null;
                this.expectKeyword("if");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  consequent = this.parseIfClause();
                  if (this.matchKeyword("else")) {
                    this.nextToken();
                    alternate = this.parseIfClause();
                  }
                }
                return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
              };
              Parser2.prototype.parseDoWhileStatement = function() {
                var node = this.createNode();
                this.expectKeyword("do");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                var body = this.parseStatement();
                this.context.inIteration = previousInIteration;
                this.expectKeyword("while");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                } else {
                  this.expect(")");
                  if (this.match(";")) {
                    this.nextToken();
                  }
                }
                return this.finalize(node, new Node.DoWhileStatement(body, test));
              };
              Parser2.prototype.parseWhileStatement = function() {
                var node = this.createNode();
                var body;
                this.expectKeyword("while");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = true;
                  body = this.parseStatement();
                  this.context.inIteration = previousInIteration;
                }
                return this.finalize(node, new Node.WhileStatement(test, body));
              };
              Parser2.prototype.parseForStatement = function() {
                var init = null;
                var test = null;
                var update = null;
                var forIn = true;
                var left, right;
                var node = this.createNode();
                this.expectKeyword("for");
                this.expect("(");
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  if (this.matchKeyword("var")) {
                    init = this.createNode();
                    this.nextToken();
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseVariableDeclarationList({ inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && this.matchKeyword("in")) {
                      var decl = declarations[0];
                      if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                      }
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.nextToken();
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.nextToken();
                      left = init;
                      right = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.expect(";");
                    }
                  } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                    init = this.createNode();
                    var kind = this.nextToken().value;
                    if (!this.context.strict && this.lookahead.value === "in") {
                      init = this.finalize(init, new Node.Identifier(kind));
                      this.nextToken();
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = false;
                      var declarations = this.parseBindingList(kind, { inFor: true });
                      this.context.allowIn = previousAllowIn;
                      if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseExpression();
                        init = null;
                      } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseAssignmentExpression();
                        init = null;
                        forIn = false;
                      } else {
                        this.consumeSemicolon();
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                      }
                    }
                  } else {
                    var initStartToken = this.lookahead;
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    this.context.allowIn = previousAllowIn;
                    if (this.matchKeyword("in")) {
                      if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                      }
                      this.nextToken();
                      this.reinterpretExpressionAsPattern(init);
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else if (this.matchContextualKeyword("of")) {
                      if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                      }
                      this.nextToken();
                      this.reinterpretExpressionAsPattern(init);
                      left = init;
                      right = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      if (this.match(",")) {
                        var initSeq = [init];
                        while (this.match(",")) {
                          this.nextToken();
                          initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                        }
                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                      }
                      this.expect(";");
                    }
                  }
                }
                if (typeof left === "undefined") {
                  if (!this.match(";")) {
                    test = this.parseExpression();
                  }
                  this.expect(";");
                  if (!this.match(")")) {
                    update = this.parseExpression();
                  }
                }
                var body;
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = true;
                  body = this.isolateCoverGrammar(this.parseStatement);
                  this.context.inIteration = previousInIteration;
                }
                return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
              };
              Parser2.prototype.parseContinueStatement = function() {
                var node = this.createNode();
                this.expectKeyword("continue");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  label = id;
                  var key = "$" + id.name;
                  if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.UnknownLabel, id.name);
                  }
                }
                this.consumeSemicolon();
                if (label === null && !this.context.inIteration) {
                  this.throwError(messages_1.Messages.IllegalContinue);
                }
                return this.finalize(node, new Node.ContinueStatement(label));
              };
              Parser2.prototype.parseBreakStatement = function() {
                var node = this.createNode();
                this.expectKeyword("break");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  var key = "$" + id.name;
                  if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.UnknownLabel, id.name);
                  }
                  label = id;
                }
                this.consumeSemicolon();
                if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                  this.throwError(messages_1.Messages.IllegalBreak);
                }
                return this.finalize(node, new Node.BreakStatement(label));
              };
              Parser2.prototype.parseReturnStatement = function() {
                if (!this.context.inFunctionBody) {
                  this.tolerateError(messages_1.Messages.IllegalReturn);
                }
                var node = this.createNode();
                this.expectKeyword("return");
                var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
                var argument = hasArgument ? this.parseExpression() : null;
                this.consumeSemicolon();
                return this.finalize(node, new Node.ReturnStatement(argument));
              };
              Parser2.prototype.parseWithStatement = function() {
                if (this.context.strict) {
                  this.tolerateError(messages_1.Messages.StrictModeWith);
                }
                var node = this.createNode();
                var body;
                this.expectKeyword("with");
                this.expect("(");
                var object = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  body = this.parseStatement();
                }
                return this.finalize(node, new Node.WithStatement(object, body));
              };
              Parser2.prototype.parseSwitchCase = function() {
                var node = this.createNode();
                var test;
                if (this.matchKeyword("default")) {
                  this.nextToken();
                  test = null;
                } else {
                  this.expectKeyword("case");
                  test = this.parseExpression();
                }
                this.expect(":");
                var consequent = [];
                while (true) {
                  if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                    break;
                  }
                  consequent.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.SwitchCase(test, consequent));
              };
              Parser2.prototype.parseSwitchStatement = function() {
                var node = this.createNode();
                this.expectKeyword("switch");
                this.expect("(");
                var discriminant = this.parseExpression();
                this.expect(")");
                var previousInSwitch = this.context.inSwitch;
                this.context.inSwitch = true;
                var cases = [];
                var defaultFound = false;
                this.expect("{");
                while (true) {
                  if (this.match("}")) {
                    break;
                  }
                  var clause = this.parseSwitchCase();
                  if (clause.test === null) {
                    if (defaultFound) {
                      this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                    }
                    defaultFound = true;
                  }
                  cases.push(clause);
                }
                this.expect("}");
                this.context.inSwitch = previousInSwitch;
                return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
              };
              Parser2.prototype.parseLabelledStatement = function() {
                var node = this.createNode();
                var expr = this.parseExpression();
                var statement;
                if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var id = expr;
                  var key = "$" + id.name;
                  if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                  }
                  this.context.labelSet[key] = true;
                  var body = void 0;
                  if (this.matchKeyword("class")) {
                    this.tolerateUnexpectedToken(this.lookahead);
                    body = this.parseClassDeclaration();
                  } else if (this.matchKeyword("function")) {
                    var token = this.lookahead;
                    var declaration = this.parseFunctionDeclaration();
                    if (this.context.strict) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                    } else if (declaration.generator) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                    }
                    body = declaration;
                  } else {
                    body = this.parseStatement();
                  }
                  delete this.context.labelSet[key];
                  statement = new Node.LabeledStatement(id, body);
                } else {
                  this.consumeSemicolon();
                  statement = new Node.ExpressionStatement(expr);
                }
                return this.finalize(node, statement);
              };
              Parser2.prototype.parseThrowStatement = function() {
                var node = this.createNode();
                this.expectKeyword("throw");
                if (this.hasLineTerminator) {
                  this.throwError(messages_1.Messages.NewlineAfterThrow);
                }
                var argument = this.parseExpression();
                this.consumeSemicolon();
                return this.finalize(node, new Node.ThrowStatement(argument));
              };
              Parser2.prototype.parseCatchClause = function() {
                var node = this.createNode();
                this.expectKeyword("catch");
                this.expect("(");
                if (this.match(")")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                var params = [];
                var param = this.parsePattern(params);
                var paramMap = {};
                for (var i = 0; i < params.length; i++) {
                  var key = "$" + params[i].value;
                  if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                    this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                  }
                  paramMap[key] = true;
                }
                if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(param.name)) {
                    this.tolerateError(messages_1.Messages.StrictCatchVariable);
                  }
                }
                this.expect(")");
                var body = this.parseBlock();
                return this.finalize(node, new Node.CatchClause(param, body));
              };
              Parser2.prototype.parseFinallyClause = function() {
                this.expectKeyword("finally");
                return this.parseBlock();
              };
              Parser2.prototype.parseTryStatement = function() {
                var node = this.createNode();
                this.expectKeyword("try");
                var block = this.parseBlock();
                var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                if (!handler && !finalizer) {
                  this.throwError(messages_1.Messages.NoCatchOrFinally);
                }
                return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
              };
              Parser2.prototype.parseDebuggerStatement = function() {
                var node = this.createNode();
                this.expectKeyword("debugger");
                this.consumeSemicolon();
                return this.finalize(node, new Node.DebuggerStatement());
              };
              Parser2.prototype.parseStatement = function() {
                var statement;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    statement = this.parseExpressionStatement();
                    break;
                  case 7:
                    var value = this.lookahead.value;
                    if (value === "{") {
                      statement = this.parseBlock();
                    } else if (value === "(") {
                      statement = this.parseExpressionStatement();
                    } else if (value === ";") {
                      statement = this.parseEmptyStatement();
                    } else {
                      statement = this.parseExpressionStatement();
                    }
                    break;
                  case 3:
                    statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        statement = this.parseBreakStatement();
                        break;
                      case "continue":
                        statement = this.parseContinueStatement();
                        break;
                      case "debugger":
                        statement = this.parseDebuggerStatement();
                        break;
                      case "do":
                        statement = this.parseDoWhileStatement();
                        break;
                      case "for":
                        statement = this.parseForStatement();
                        break;
                      case "function":
                        statement = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        statement = this.parseIfStatement();
                        break;
                      case "return":
                        statement = this.parseReturnStatement();
                        break;
                      case "switch":
                        statement = this.parseSwitchStatement();
                        break;
                      case "throw":
                        statement = this.parseThrowStatement();
                        break;
                      case "try":
                        statement = this.parseTryStatement();
                        break;
                      case "var":
                        statement = this.parseVariableStatement();
                        break;
                      case "while":
                        statement = this.parseWhileStatement();
                        break;
                      case "with":
                        statement = this.parseWithStatement();
                        break;
                      default:
                        statement = this.parseExpressionStatement();
                        break;
                    }
                    break;
                  default:
                    statement = this.throwUnexpectedToken(this.lookahead);
                }
                return statement;
              };
              Parser2.prototype.parseFunctionSourceElements = function() {
                var node = this.createNode();
                this.expect("{");
                var body = this.parseDirectivePrologues();
                var previousLabelSet = this.context.labelSet;
                var previousInIteration = this.context.inIteration;
                var previousInSwitch = this.context.inSwitch;
                var previousInFunctionBody = this.context.inFunctionBody;
                this.context.labelSet = {};
                this.context.inIteration = false;
                this.context.inSwitch = false;
                this.context.inFunctionBody = true;
                while (this.lookahead.type !== 2) {
                  if (this.match("}")) {
                    break;
                  }
                  body.push(this.parseStatementListItem());
                }
                this.expect("}");
                this.context.labelSet = previousLabelSet;
                this.context.inIteration = previousInIteration;
                this.context.inSwitch = previousInSwitch;
                this.context.inFunctionBody = previousInFunctionBody;
                return this.finalize(node, new Node.BlockStatement(body));
              };
              Parser2.prototype.validateParam = function(options, param, name) {
                var key = "$" + name;
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(name)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamName;
                  }
                  if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamDupe;
                  }
                } else if (!options.firstRestricted) {
                  if (this.scanner.isRestrictedWord(name)) {
                    options.firstRestricted = param;
                    options.message = messages_1.Messages.StrictParamName;
                  } else if (this.scanner.isStrictModeReservedWord(name)) {
                    options.firstRestricted = param;
                    options.message = messages_1.Messages.StrictReservedWord;
                  } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamDupe;
                  }
                }
                if (typeof Object.defineProperty === "function") {
                  Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
                } else {
                  options.paramSet[key] = true;
                }
              };
              Parser2.prototype.parseRestElement = function(params) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params);
                if (this.match("=")) {
                  this.throwError(messages_1.Messages.DefaultRestParameter);
                }
                if (!this.match(")")) {
                  this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                }
                return this.finalize(node, new Node.RestElement(arg));
              };
              Parser2.prototype.parseFormalParameter = function(options) {
                var params = [];
                var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                for (var i = 0; i < params.length; i++) {
                  this.validateParam(options, params[i], params[i].value);
                }
                options.simple = options.simple && param instanceof Node.Identifier;
                options.params.push(param);
              };
              Parser2.prototype.parseFormalParameters = function(firstRestricted) {
                var options;
                options = {
                  simple: true,
                  params: [],
                  firstRestricted
                };
                this.expect("(");
                if (!this.match(")")) {
                  options.paramSet = {};
                  while (this.lookahead.type !== 2) {
                    this.parseFormalParameter(options);
                    if (this.match(")")) {
                      break;
                    }
                    this.expect(",");
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return {
                  simple: options.simple,
                  params: options.params,
                  stricted: options.stricted,
                  firstRestricted: options.firstRestricted,
                  message: options.message
                };
              };
              Parser2.prototype.matchAsyncFunction = function() {
                var match = this.matchContextualKeyword("async");
                if (match) {
                  var state = this.scanner.saveState();
                  this.scanner.scanComments();
                  var next = this.scanner.lex();
                  this.scanner.restoreState(state);
                  match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                }
                return match;
              };
              Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                var node = this.createNode();
                var isAsync = this.matchContextualKeyword("async");
                if (isAsync) {
                  this.nextToken();
                }
                this.expectKeyword("function");
                var isGenerator = isAsync ? false : this.match("*");
                if (isGenerator) {
                  this.nextToken();
                }
                var message;
                var id = null;
                var firstRestricted = null;
                if (!identifierIsOptional || !this.match("(")) {
                  var token = this.lookahead;
                  id = this.parseVariableIdentifier();
                  if (this.context.strict) {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                    }
                  } else {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictFunctionName;
                    } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                var previousAllowAwait = this.context.await;
                var previousAllowYield = this.context.allowYield;
                this.context.await = isAsync;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters(firstRestricted);
                var params = formalParameters.params;
                var stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted;
                if (formalParameters.message) {
                  message = formalParameters.message;
                }
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                if (this.context.strict && firstRestricted) {
                  this.throwUnexpectedToken(firstRestricted, message);
                }
                if (this.context.strict && stricted) {
                  this.tolerateUnexpectedToken(stricted, message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                this.context.await = previousAllowAwait;
                this.context.allowYield = previousAllowYield;
                return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
              };
              Parser2.prototype.parseFunctionExpression = function() {
                var node = this.createNode();
                var isAsync = this.matchContextualKeyword("async");
                if (isAsync) {
                  this.nextToken();
                }
                this.expectKeyword("function");
                var isGenerator = isAsync ? false : this.match("*");
                if (isGenerator) {
                  this.nextToken();
                }
                var message;
                var id = null;
                var firstRestricted;
                var previousAllowAwait = this.context.await;
                var previousAllowYield = this.context.allowYield;
                this.context.await = isAsync;
                this.context.allowYield = !isGenerator;
                if (!this.match("(")) {
                  var token = this.lookahead;
                  id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                  if (this.context.strict) {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                    }
                  } else {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictFunctionName;
                    } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                var formalParameters = this.parseFormalParameters(firstRestricted);
                var params = formalParameters.params;
                var stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted;
                if (formalParameters.message) {
                  message = formalParameters.message;
                }
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                if (this.context.strict && firstRestricted) {
                  this.throwUnexpectedToken(firstRestricted, message);
                }
                if (this.context.strict && stricted) {
                  this.tolerateUnexpectedToken(stricted, message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                this.context.await = previousAllowAwait;
                this.context.allowYield = previousAllowYield;
                return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
              };
              Parser2.prototype.parseDirective = function() {
                var token = this.lookahead;
                var node = this.createNode();
                var expr = this.parseExpression();
                var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                this.consumeSemicolon();
                return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
              };
              Parser2.prototype.parseDirectivePrologues = function() {
                var firstRestricted = null;
                var body = [];
                while (true) {
                  var token = this.lookahead;
                  if (token.type !== 8) {
                    break;
                  }
                  var statement = this.parseDirective();
                  body.push(statement);
                  var directive = statement.directive;
                  if (typeof directive !== "string") {
                    break;
                  }
                  if (directive === "use strict") {
                    this.context.strict = true;
                    if (firstRestricted) {
                      this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                    }
                    if (!this.context.allowStrictDirective) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                    }
                  } else {
                    if (!firstRestricted && token.octal) {
                      firstRestricted = token;
                    }
                  }
                }
                return body;
              };
              Parser2.prototype.qualifiedPropertyName = function(token) {
                switch (token.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return true;
                  case 7:
                    return token.value === "[";
                  default:
                    break;
                }
                return false;
              };
              Parser2.prototype.parseGetterMethod = function() {
                var node = this.createNode();
                var isGenerator = false;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                if (formalParameters.params.length > 0) {
                  this.tolerateError(messages_1.Messages.BadGetterArity);
                }
                var method = this.parsePropertyMethod(formalParameters);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              };
              Parser2.prototype.parseSetterMethod = function() {
                var node = this.createNode();
                var isGenerator = false;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                if (formalParameters.params.length !== 1) {
                  this.tolerateError(messages_1.Messages.BadSetterArity);
                } else if (formalParameters.params[0] instanceof Node.RestElement) {
                  this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                }
                var method = this.parsePropertyMethod(formalParameters);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              };
              Parser2.prototype.parseGeneratorMethod = function() {
                var node = this.createNode();
                var isGenerator = true;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var params = this.parseFormalParameters();
                this.context.allowYield = false;
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              };
              Parser2.prototype.isStartOfExpression = function() {
                var start = true;
                var value = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                    break;
                  case 4:
                    start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                    break;
                  default:
                    break;
                }
                return start;
              };
              Parser2.prototype.parseYieldExpression = function() {
                var node = this.createNode();
                this.expectKeyword("yield");
                var argument = null;
                var delegate = false;
                if (!this.hasLineTerminator) {
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = false;
                  delegate = this.match("*");
                  if (delegate) {
                    this.nextToken();
                    argument = this.parseAssignmentExpression();
                  } else if (this.isStartOfExpression()) {
                    argument = this.parseAssignmentExpression();
                  }
                  this.context.allowYield = previousAllowYield;
                }
                return this.finalize(node, new Node.YieldExpression(argument, delegate));
              };
              Parser2.prototype.parseClassElement = function(hasConstructor) {
                var token = this.lookahead;
                var node = this.createNode();
                var kind = "";
                var key = null;
                var value = null;
                var computed = false;
                var method = false;
                var isStatic = false;
                var isAsync = false;
                if (this.match("*")) {
                  this.nextToken();
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  var id = key;
                  if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                    token = this.lookahead;
                    isStatic = true;
                    computed = this.match("[");
                    if (this.match("*")) {
                      this.nextToken();
                    } else {
                      key = this.parseObjectPropertyKey();
                    }
                  }
                  if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                    var punctuator = this.lookahead.value;
                    if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                      isAsync = true;
                      token = this.lookahead;
                      key = this.parseObjectPropertyKey();
                      if (token.type === 3 && token.value === "constructor") {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                      }
                    }
                  }
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token.type === 3) {
                  if (token.value === "get" && lookaheadPropertyKey) {
                    kind = "get";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    this.context.allowYield = false;
                    value = this.parseGetterMethod();
                  } else if (token.value === "set" && lookaheadPropertyKey) {
                    kind = "set";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    value = this.parseSetterMethod();
                  }
                } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                  kind = "init";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseGeneratorMethod();
                  method = true;
                }
                if (!kind && key && this.match("(")) {
                  kind = "init";
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                }
                if (!kind) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                if (kind === "init") {
                  kind = "method";
                }
                if (!computed) {
                  if (isStatic && this.isPropertyKey(key, "prototype")) {
                    this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                  }
                  if (!isStatic && this.isPropertyKey(key, "constructor")) {
                    if (kind !== "method" || !method || value && value.generator) {
                      this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                    }
                    if (hasConstructor.value) {
                      this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                    } else {
                      hasConstructor.value = true;
                    }
                    kind = "constructor";
                  }
                }
                return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
              };
              Parser2.prototype.parseClassElementList = function() {
                var body = [];
                var hasConstructor = { value: false };
                this.expect("{");
                while (!this.match("}")) {
                  if (this.match(";")) {
                    this.nextToken();
                  } else {
                    body.push(this.parseClassElement(hasConstructor));
                  }
                }
                this.expect("}");
                return body;
              };
              Parser2.prototype.parseClassBody = function() {
                var node = this.createNode();
                var elementList = this.parseClassElementList();
                return this.finalize(node, new Node.ClassBody(elementList));
              };
              Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
                var node = this.createNode();
                var previousStrict = this.context.strict;
                this.context.strict = true;
                this.expectKeyword("class");
                var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
                var superClass = null;
                if (this.matchKeyword("extends")) {
                  this.nextToken();
                  superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                }
                var classBody = this.parseClassBody();
                this.context.strict = previousStrict;
                return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
              };
              Parser2.prototype.parseClassExpression = function() {
                var node = this.createNode();
                var previousStrict = this.context.strict;
                this.context.strict = true;
                this.expectKeyword("class");
                var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
                var superClass = null;
                if (this.matchKeyword("extends")) {
                  this.nextToken();
                  superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                }
                var classBody = this.parseClassBody();
                this.context.strict = previousStrict;
                return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
              };
              Parser2.prototype.parseModule = function() {
                this.context.strict = true;
                this.context.isModule = true;
                this.scanner.isModule = true;
                var node = this.createNode();
                var body = this.parseDirectivePrologues();
                while (this.lookahead.type !== 2) {
                  body.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.Module(body));
              };
              Parser2.prototype.parseScript = function() {
                var node = this.createNode();
                var body = this.parseDirectivePrologues();
                while (this.lookahead.type !== 2) {
                  body.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.Script(body));
              };
              Parser2.prototype.parseModuleSpecifier = function() {
                var node = this.createNode();
                if (this.lookahead.type !== 8) {
                  this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                }
                var token = this.nextToken();
                var raw = this.getTokenRaw(token);
                return this.finalize(node, new Node.Literal(token.value, raw));
              };
              Parser2.prototype.parseImportSpecifier = function() {
                var node = this.createNode();
                var imported;
                var local;
                if (this.lookahead.type === 3) {
                  imported = this.parseVariableIdentifier();
                  local = imported;
                  if (this.matchContextualKeyword("as")) {
                    this.nextToken();
                    local = this.parseVariableIdentifier();
                  }
                } else {
                  imported = this.parseIdentifierName();
                  local = imported;
                  if (this.matchContextualKeyword("as")) {
                    this.nextToken();
                    local = this.parseVariableIdentifier();
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                }
                return this.finalize(node, new Node.ImportSpecifier(local, imported));
              };
              Parser2.prototype.parseNamedImports = function() {
                this.expect("{");
                var specifiers = [];
                while (!this.match("}")) {
                  specifiers.push(this.parseImportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                return specifiers;
              };
              Parser2.prototype.parseImportDefaultSpecifier = function() {
                var node = this.createNode();
                var local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportDefaultSpecifier(local));
              };
              Parser2.prototype.parseImportNamespaceSpecifier = function() {
                var node = this.createNode();
                this.expect("*");
                if (!this.matchContextualKeyword("as")) {
                  this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                }
                this.nextToken();
                var local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
              };
              Parser2.prototype.parseImportDeclaration = function() {
                if (this.context.inFunctionBody) {
                  this.throwError(messages_1.Messages.IllegalImportDeclaration);
                }
                var node = this.createNode();
                this.expectKeyword("import");
                var src;
                var specifiers = [];
                if (this.lookahead.type === 8) {
                  src = this.parseModuleSpecifier();
                } else {
                  if (this.match("{")) {
                    specifiers = specifiers.concat(this.parseNamedImports());
                  } else if (this.match("*")) {
                    specifiers.push(this.parseImportNamespaceSpecifier());
                  } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                    specifiers.push(this.parseImportDefaultSpecifier());
                    if (this.match(",")) {
                      this.nextToken();
                      if (this.match("*")) {
                        specifiers.push(this.parseImportNamespaceSpecifier());
                      } else if (this.match("{")) {
                        specifiers = specifiers.concat(this.parseNamedImports());
                      } else {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    }
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                  if (!this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  src = this.parseModuleSpecifier();
                }
                this.consumeSemicolon();
                return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
              };
              Parser2.prototype.parseExportSpecifier = function() {
                var node = this.createNode();
                var local = this.parseIdentifierName();
                var exported = local;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  exported = this.parseIdentifierName();
                }
                return this.finalize(node, new Node.ExportSpecifier(local, exported));
              };
              Parser2.prototype.parseExportDeclaration = function() {
                if (this.context.inFunctionBody) {
                  this.throwError(messages_1.Messages.IllegalExportDeclaration);
                }
                var node = this.createNode();
                this.expectKeyword("export");
                var exportDeclaration;
                if (this.matchKeyword("default")) {
                  this.nextToken();
                  if (this.matchKeyword("function")) {
                    var declaration = this.parseFunctionDeclaration(true);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchKeyword("class")) {
                    var declaration = this.parseClassDeclaration(true);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchContextualKeyword("async")) {
                    var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else {
                    if (this.matchContextualKeyword("from")) {
                      this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                    }
                    var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                    this.consumeSemicolon();
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  }
                } else if (this.match("*")) {
                  this.nextToken();
                  if (!this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  var src = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
                } else if (this.lookahead.type === 4) {
                  var declaration = void 0;
                  switch (this.lookahead.value) {
                    case "let":
                    case "const":
                      declaration = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      declaration = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else if (this.matchAsyncFunction()) {
                  var declaration = this.parseFunctionDeclaration();
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else {
                  var specifiers = [];
                  var source = null;
                  var isExportFromIdentifier = false;
                  this.expect("{");
                  while (!this.match("}")) {
                    isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                    specifiers.push(this.parseExportSpecifier());
                    if (!this.match("}")) {
                      this.expect(",");
                    }
                  }
                  this.expect("}");
                  if (this.matchContextualKeyword("from")) {
                    this.nextToken();
                    source = this.parseModuleSpecifier();
                    this.consumeSemicolon();
                  } else if (isExportFromIdentifier) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  } else {
                    this.consumeSemicolon();
                  }
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
                }
                return exportDeclaration;
              };
              return Parser2;
            }();
            exports2.Parser = Parser;
          },
          /* 9 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            function assert7(condition, message) {
              if (!condition) {
                throw new Error("ASSERT: " + message);
              }
            }
            exports2.assert = assert7;
          },
          /* 10 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var ErrorHandler = function() {
              function ErrorHandler2() {
                this.errors = [];
                this.tolerant = false;
              }
              ErrorHandler2.prototype.recordError = function(error2) {
                this.errors.push(error2);
              };
              ErrorHandler2.prototype.tolerate = function(error2) {
                if (this.tolerant) {
                  this.recordError(error2);
                } else {
                  throw error2;
                }
              };
              ErrorHandler2.prototype.constructError = function(msg, column) {
                var error2 = new Error(msg);
                try {
                  throw error2;
                } catch (base) {
                  if (Object.create && Object.defineProperty) {
                    error2 = Object.create(base);
                    Object.defineProperty(error2, "column", { value: column });
                  }
                }
                return error2;
              };
              ErrorHandler2.prototype.createError = function(index, line, col, description) {
                var msg = "Line " + line + ": " + description;
                var error2 = this.constructError(msg, col);
                error2.index = index;
                error2.lineNumber = line;
                error2.description = description;
                return error2;
              };
              ErrorHandler2.prototype.throwError = function(index, line, col, description) {
                throw this.createError(index, line, col, description);
              };
              ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
                var error2 = this.createError(index, line, col, description);
                if (this.tolerant) {
                  this.recordError(error2);
                } else {
                  throw error2;
                }
              };
              return ErrorHandler2;
            }();
            exports2.ErrorHandler = ErrorHandler;
          },
          /* 11 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.Messages = {
              BadGetterArity: "Getter must not have any formal parameters",
              BadSetterArity: "Setter must have exactly one formal parameter",
              BadSetterRestParameter: "Setter function argument must not be a rest parameter",
              ConstructorIsAsync: "Class constructor may not be an async method",
              ConstructorSpecialMethod: "Class constructor may not be an accessor",
              DeclarationMissingInitializer: "Missing initializer in %0 declaration",
              DefaultRestParameter: "Unexpected token =",
              DuplicateBinding: "Duplicate binding %0",
              DuplicateConstructor: "A class may only have one constructor",
              DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
              ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
              GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
              IllegalBreak: "Illegal break statement",
              IllegalContinue: "Illegal continue statement",
              IllegalExportDeclaration: "Unexpected token",
              IllegalImportDeclaration: "Unexpected token",
              IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
              IllegalReturn: "Illegal return statement",
              InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
              InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
              InvalidLHSInAssignment: "Invalid left-hand side in assignment",
              InvalidLHSInForIn: "Invalid left-hand side in for-in",
              InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
              InvalidModuleSpecifier: "Unexpected token",
              InvalidRegExp: "Invalid regular expression",
              LetInLexicalBinding: "let is disallowed as a lexically bound name",
              MissingFromClause: "Unexpected token",
              MultipleDefaultsInSwitch: "More than one default clause in switch statement",
              NewlineAfterThrow: "Illegal newline after throw",
              NoAsAfterImportNamespace: "Unexpected token",
              NoCatchOrFinally: "Missing catch or finally after try",
              ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
              Redeclaration: "%0 '%1' has already been declared",
              StaticPrototype: "Classes may not have static property named prototype",
              StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
              StrictDelete: "Delete of an unqualified identifier in strict mode.",
              StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
              StrictFunctionName: "Function name may not be eval or arguments in strict mode",
              StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
              StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
              StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
              StrictModeWith: "Strict mode code may not include a with statement",
              StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
              StrictParamDupe: "Strict mode function may not have duplicate parameter names",
              StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
              StrictReservedWord: "Use of future reserved word in strict mode",
              StrictVarName: "Variable name may not be eval or arguments in strict mode",
              TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
              UnexpectedEOS: "Unexpected end of input",
              UnexpectedIdentifier: "Unexpected identifier",
              UnexpectedNumber: "Unexpected number",
              UnexpectedReserved: "Unexpected reserved word",
              UnexpectedString: "Unexpected string",
              UnexpectedTemplate: "Unexpected quasi %0",
              UnexpectedToken: "Unexpected token %0",
              UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
              UnknownLabel: "Undefined label '%0'",
              UnterminatedRegExp: "Invalid regular expression: missing /"
            };
          },
          /* 12 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var assert_1 = __webpack_require__(9);
            var character_1 = __webpack_require__(4);
            var messages_1 = __webpack_require__(11);
            function hexValue(ch) {
              return "0123456789abcdef".indexOf(ch.toLowerCase());
            }
            function octalValue(ch) {
              return "01234567".indexOf(ch);
            }
            var Scanner = function() {
              function Scanner2(code, handler) {
                this.source = code;
                this.errorHandler = handler;
                this.trackComment = false;
                this.isModule = false;
                this.length = code.length;
                this.index = 0;
                this.lineNumber = code.length > 0 ? 1 : 0;
                this.lineStart = 0;
                this.curlyStack = [];
              }
              Scanner2.prototype.saveState = function() {
                return {
                  index: this.index,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart
                };
              };
              Scanner2.prototype.restoreState = function(state) {
                this.index = state.index;
                this.lineNumber = state.lineNumber;
                this.lineStart = state.lineStart;
              };
              Scanner2.prototype.eof = function() {
                return this.index >= this.length;
              };
              Scanner2.prototype.throwUnexpectedToken = function(message) {
                if (message === void 0) {
                  message = messages_1.Messages.UnexpectedTokenIllegal;
                }
                return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              };
              Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                if (message === void 0) {
                  message = messages_1.Messages.UnexpectedTokenIllegal;
                }
                this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              };
              Scanner2.prototype.skipSingleLineComment = function(offset) {
                var comments = [];
                var start, loc;
                if (this.trackComment) {
                  comments = [];
                  start = this.index - offset;
                  loc = {
                    start: {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - offset
                    },
                    end: {}
                  };
                }
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  ++this.index;
                  if (character_1.Character.isLineTerminator(ch)) {
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart - 1
                      };
                      var entry = {
                        multiLine: false,
                        slice: [start + offset, this.index - 1],
                        range: [start, this.index - 1],
                        loc
                      };
                      comments.push(entry);
                    }
                    if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    this.lineStart = this.index;
                    return comments;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: false,
                    slice: [start + offset, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments.push(entry);
                }
                return comments;
              };
              Scanner2.prototype.skipMultiLineComment = function() {
                var comments = [];
                var start, loc;
                if (this.trackComment) {
                  comments = [];
                  start = this.index - 2;
                  loc = {
                    start: {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 2
                    },
                    end: {}
                  };
                }
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isLineTerminator(ch)) {
                    if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    ++this.index;
                    this.lineStart = this.index;
                  } else if (ch === 42) {
                    if (this.source.charCodeAt(this.index + 1) === 47) {
                      this.index += 2;
                      if (this.trackComment) {
                        loc.end = {
                          line: this.lineNumber,
                          column: this.index - this.lineStart
                        };
                        var entry = {
                          multiLine: true,
                          slice: [start + 2, this.index - 2],
                          range: [start, this.index],
                          loc
                        };
                        comments.push(entry);
                      }
                      return comments;
                    }
                    ++this.index;
                  } else {
                    ++this.index;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: true,
                    slice: [start + 2, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments.push(entry);
                }
                this.tolerateUnexpectedToken();
                return comments;
              };
              Scanner2.prototype.scanComments = function() {
                var comments;
                if (this.trackComment) {
                  comments = [];
                }
                var start = this.index === 0;
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isWhiteSpace(ch)) {
                    ++this.index;
                  } else if (character_1.Character.isLineTerminator(ch)) {
                    ++this.index;
                    if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    this.lineStart = this.index;
                    start = true;
                  } else if (ch === 47) {
                    ch = this.source.charCodeAt(this.index + 1);
                    if (ch === 47) {
                      this.index += 2;
                      var comment = this.skipSingleLineComment(2);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                      start = true;
                    } else if (ch === 42) {
                      this.index += 2;
                      var comment = this.skipMultiLineComment();
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else if (start && ch === 45) {
                    if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                      this.index += 3;
                      var comment = this.skipSingleLineComment(3);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else if (ch === 60 && !this.isModule) {
                    if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                      this.index += 4;
                      var comment = this.skipSingleLineComment(4);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                }
                return comments;
              };
              Scanner2.prototype.isFutureReservedWord = function(id) {
                switch (id) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return true;
                  default:
                    return false;
                }
              };
              Scanner2.prototype.isStrictModeReservedWord = function(id) {
                switch (id) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              };
              Scanner2.prototype.isRestrictedWord = function(id) {
                return id === "eval" || id === "arguments";
              };
              Scanner2.prototype.isKeyword = function(id) {
                switch (id.length) {
                  case 2:
                    return id === "if" || id === "in" || id === "do";
                  case 3:
                    return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                  case 4:
                    return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                  case 5:
                    return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                  case 6:
                    return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                  case 7:
                    return id === "default" || id === "finally" || id === "extends";
                  case 8:
                    return id === "function" || id === "continue" || id === "debugger";
                  case 10:
                    return id === "instanceof";
                  default:
                    return false;
                }
              };
              Scanner2.prototype.codePointAt = function(i) {
                var cp = this.source.charCodeAt(i);
                if (cp >= 55296 && cp <= 56319) {
                  var second = this.source.charCodeAt(i + 1);
                  if (second >= 56320 && second <= 57343) {
                    var first = cp;
                    cp = (first - 55296) * 1024 + second - 56320 + 65536;
                  }
                }
                return cp;
              };
              Scanner2.prototype.scanHexEscape = function(prefix) {
                var len = prefix === "u" ? 4 : 2;
                var code = 0;
                for (var i = 0; i < len; ++i) {
                  if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                    code = code * 16 + hexValue(this.source[this.index++]);
                  } else {
                    return null;
                  }
                }
                return String.fromCharCode(code);
              };
              Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                var ch = this.source[this.index];
                var code = 0;
                if (ch === "}") {
                  this.throwUnexpectedToken();
                }
                while (!this.eof()) {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                    break;
                  }
                  code = code * 16 + hexValue(ch);
                }
                if (code > 1114111 || ch !== "}") {
                  this.throwUnexpectedToken();
                }
                return character_1.Character.fromCodePoint(code);
              };
              Scanner2.prototype.getIdentifier = function() {
                var start = this.index++;
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (ch === 92) {
                    this.index = start;
                    return this.getComplexIdentifier();
                  } else if (ch >= 55296 && ch < 57343) {
                    this.index = start;
                    return this.getComplexIdentifier();
                  }
                  if (character_1.Character.isIdentifierPart(ch)) {
                    ++this.index;
                  } else {
                    break;
                  }
                }
                return this.source.slice(start, this.index);
              };
              Scanner2.prototype.getComplexIdentifier = function() {
                var cp = this.codePointAt(this.index);
                var id = character_1.Character.fromCodePoint(cp);
                this.index += id.length;
                var ch;
                if (cp === 92) {
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id = ch;
                }
                while (!this.eof()) {
                  cp = this.codePointAt(this.index);
                  if (!character_1.Character.isIdentifierPart(cp)) {
                    break;
                  }
                  ch = character_1.Character.fromCodePoint(cp);
                  id += ch;
                  this.index += ch.length;
                  if (cp === 92) {
                    id = id.substr(0, id.length - 1);
                    if (this.source.charCodeAt(this.index) !== 117) {
                      this.throwUnexpectedToken();
                    }
                    ++this.index;
                    if (this.source[this.index] === "{") {
                      ++this.index;
                      ch = this.scanUnicodeCodePointEscape();
                    } else {
                      ch = this.scanHexEscape("u");
                      if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken();
                      }
                    }
                    id += ch;
                  }
                }
                return id;
              };
              Scanner2.prototype.octalToDecimal = function(ch) {
                var octal = ch !== "0";
                var code = octalValue(ch);
                if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  octal = true;
                  code = code * 8 + octalValue(this.source[this.index++]);
                  if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                    code = code * 8 + octalValue(this.source[this.index++]);
                  }
                }
                return {
                  code,
                  octal
                };
              };
              Scanner2.prototype.scanIdentifier = function() {
                var type;
                var start = this.index;
                var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                if (id.length === 1) {
                  type = 3;
                } else if (this.isKeyword(id)) {
                  type = 4;
                } else if (id === "null") {
                  type = 5;
                } else if (id === "true" || id === "false") {
                  type = 1;
                } else {
                  type = 3;
                }
                if (type !== 3 && start + id.length !== this.index) {
                  var restore = this.index;
                  this.index = start;
                  this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                  this.index = restore;
                }
                return {
                  type,
                  value: id,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanPunctuator = function() {
                var start = this.index;
                var str = this.source[this.index];
                switch (str) {
                  case "(":
                  case "{":
                    if (str === "{") {
                      this.curlyStack.push("{");
                    }
                    ++this.index;
                    break;
                  case ".":
                    ++this.index;
                    if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                      this.index += 2;
                      str = "...";
                    }
                    break;
                  case "}":
                    ++this.index;
                    this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    str = this.source.substr(this.index, 4);
                    if (str === ">>>=") {
                      this.index += 4;
                    } else {
                      str = str.substr(0, 3);
                      if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                        this.index += 3;
                      } else {
                        str = str.substr(0, 2);
                        if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                          this.index += 2;
                        } else {
                          str = this.source[this.index];
                          if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                            ++this.index;
                          }
                        }
                      }
                    }
                }
                if (this.index === start) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 7,
                  value: str,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanHexLiteral = function(start) {
                var num = "";
                while (!this.eof()) {
                  if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseInt("0x" + num, 16),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanBinaryLiteral = function(start) {
                var num = "";
                var ch;
                while (!this.eof()) {
                  ch = this.source[this.index];
                  if (ch !== "0" && ch !== "1") {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (!this.eof()) {
                  ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                    this.throwUnexpectedToken();
                  }
                }
                return {
                  type: 6,
                  value: parseInt(num, 2),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
                var num = "";
                var octal = false;
                if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                  octal = true;
                  num = "0" + this.source[this.index++];
                } else {
                  ++this.index;
                }
                while (!this.eof()) {
                  if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (!octal && num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseInt(num, 8),
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.isImplicitOctalLiteral = function() {
                for (var i = this.index + 1; i < this.length; ++i) {
                  var ch = this.source[i];
                  if (ch === "8" || ch === "9") {
                    return false;
                  }
                  if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    return true;
                  }
                }
                return true;
              };
              Scanner2.prototype.scanNumericLiteral = function() {
                var start = this.index;
                var ch = this.source[start];
                assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                var num = "";
                if (ch !== ".") {
                  num = this.source[this.index++];
                  ch = this.source[this.index];
                  if (num === "0") {
                    if (ch === "x" || ch === "X") {
                      ++this.index;
                      return this.scanHexLiteral(start);
                    }
                    if (ch === "b" || ch === "B") {
                      ++this.index;
                      return this.scanBinaryLiteral(start);
                    }
                    if (ch === "o" || ch === "O") {
                      return this.scanOctalLiteral(ch, start);
                    }
                    if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                      if (this.isImplicitOctalLiteral()) {
                        return this.scanOctalLiteral(ch, start);
                      }
                    }
                  }
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                  ch = this.source[this.index];
                }
                if (ch === ".") {
                  num += this.source[this.index++];
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                  ch = this.source[this.index];
                }
                if (ch === "e" || ch === "E") {
                  num += this.source[this.index++];
                  ch = this.source[this.index];
                  if (ch === "+" || ch === "-") {
                    num += this.source[this.index++];
                  }
                  if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      num += this.source[this.index++];
                    }
                  } else {
                    this.throwUnexpectedToken();
                  }
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseFloat(num),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanStringLiteral = function() {
                var start = this.index;
                var quote = this.source[start];
                assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                ++this.index;
                var octal = false;
                var str = "";
                while (!this.eof()) {
                  var ch = this.source[this.index++];
                  if (ch === quote) {
                    quote = "";
                    break;
                  } else if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      switch (ch) {
                        case "u":
                          if (this.source[this.index] === "{") {
                            ++this.index;
                            str += this.scanUnicodeCodePointEscape();
                          } else {
                            var unescaped_1 = this.scanHexEscape(ch);
                            if (unescaped_1 === null) {
                              this.throwUnexpectedToken();
                            }
                            str += unescaped_1;
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          if (unescaped === null) {
                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                          }
                          str += unescaped;
                          break;
                        case "n":
                          str += "\n";
                          break;
                        case "r":
                          str += "\r";
                          break;
                        case "t":
                          str += "	";
                          break;
                        case "b":
                          str += "\b";
                          break;
                        case "f":
                          str += "\f";
                          break;
                        case "v":
                          str += "\v";
                          break;
                        case "8":
                        case "9":
                          str += ch;
                          this.tolerateUnexpectedToken();
                          break;
                        default:
                          if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            var octToDec = this.octalToDecimal(ch);
                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                          } else {
                            str += ch;
                          }
                          break;
                      }
                    } else {
                      ++this.lineNumber;
                      if (ch === "\r" && this.source[this.index] === "\n") {
                        ++this.index;
                      }
                      this.lineStart = this.index;
                    }
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    break;
                  } else {
                    str += ch;
                  }
                }
                if (quote !== "") {
                  this.index = start;
                  this.throwUnexpectedToken();
                }
                return {
                  type: 8,
                  value: str,
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanTemplate = function() {
                var cooked = "";
                var terminated = false;
                var start = this.index;
                var head = this.source[start] === "`";
                var tail = false;
                var rawOffset = 2;
                ++this.index;
                while (!this.eof()) {
                  var ch = this.source[this.index++];
                  if (ch === "`") {
                    rawOffset = 1;
                    tail = true;
                    terminated = true;
                    break;
                  } else if (ch === "$") {
                    if (this.source[this.index] === "{") {
                      this.curlyStack.push("${");
                      ++this.index;
                      terminated = true;
                      break;
                    }
                    cooked += ch;
                  } else if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      switch (ch) {
                        case "n":
                          cooked += "\n";
                          break;
                        case "r":
                          cooked += "\r";
                          break;
                        case "t":
                          cooked += "	";
                          break;
                        case "u":
                          if (this.source[this.index] === "{") {
                            ++this.index;
                            cooked += this.scanUnicodeCodePointEscape();
                          } else {
                            var restore = this.index;
                            var unescaped_2 = this.scanHexEscape(ch);
                            if (unescaped_2 !== null) {
                              cooked += unescaped_2;
                            } else {
                              this.index = restore;
                              cooked += ch;
                            }
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          if (unescaped === null) {
                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                          }
                          cooked += unescaped;
                          break;
                        case "b":
                          cooked += "\b";
                          break;
                        case "f":
                          cooked += "\f";
                          break;
                        case "v":
                          cooked += "\v";
                          break;
                        default:
                          if (ch === "0") {
                            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                              this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                            }
                            cooked += "\0";
                          } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          } else {
                            cooked += ch;
                          }
                          break;
                      }
                    } else {
                      ++this.lineNumber;
                      if (ch === "\r" && this.source[this.index] === "\n") {
                        ++this.index;
                      }
                      this.lineStart = this.index;
                    }
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                    cooked += "\n";
                  } else {
                    cooked += ch;
                  }
                }
                if (!terminated) {
                  this.throwUnexpectedToken();
                }
                if (!head) {
                  this.curlyStack.pop();
                }
                return {
                  type: 10,
                  value: this.source.slice(start + 1, this.index - rawOffset),
                  cooked,
                  head,
                  tail,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.testRegExp = function(pattern, flags) {
                var astralSubstitute = "\uFFFF";
                var tmp = pattern;
                var self = this;
                if (flags.indexOf("u") >= 0) {
                  tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 1114111) {
                      self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                    }
                    if (codePoint <= 65535) {
                      return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                  }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                }
                try {
                  RegExp(tmp);
                } catch (e) {
                  this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(pattern, flags);
                } catch (exception) {
                  return null;
                }
              };
              Scanner2.prototype.scanRegExpBody = function() {
                var ch = this.source[this.index];
                assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
                var str = this.source[this.index++];
                var classMarker = false;
                var terminated = false;
                while (!this.eof()) {
                  ch = this.source[this.index++];
                  str += ch;
                  if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    }
                    str += ch;
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  } else if (classMarker) {
                    if (ch === "]") {
                      classMarker = false;
                    }
                  } else {
                    if (ch === "/") {
                      terminated = true;
                      break;
                    } else if (ch === "[") {
                      classMarker = true;
                    }
                  }
                }
                if (!terminated) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                return str.substr(1, str.length - 2);
              };
              Scanner2.prototype.scanRegExpFlags = function() {
                var str = "";
                var flags = "";
                while (!this.eof()) {
                  var ch = this.source[this.index];
                  if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                    break;
                  }
                  ++this.index;
                  if (ch === "\\" && !this.eof()) {
                    ch = this.source[this.index];
                    if (ch === "u") {
                      ++this.index;
                      var restore = this.index;
                      var char = this.scanHexEscape("u");
                      if (char !== null) {
                        flags += char;
                        for (str += "\\u"; restore < this.index; ++restore) {
                          str += this.source[restore];
                        }
                      } else {
                        this.index = restore;
                        flags += "u";
                        str += "\\u";
                      }
                      this.tolerateUnexpectedToken();
                    } else {
                      str += "\\";
                      this.tolerateUnexpectedToken();
                    }
                  } else {
                    flags += ch;
                    str += ch;
                  }
                }
                return flags;
              };
              Scanner2.prototype.scanRegExp = function() {
                var start = this.index;
                var pattern = this.scanRegExpBody();
                var flags = this.scanRegExpFlags();
                var value = this.testRegExp(pattern, flags);
                return {
                  type: 9,
                  value: "",
                  pattern,
                  flags,
                  regex: value,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.lex = function() {
                if (this.eof()) {
                  return {
                    type: 2,
                    value: "",
                    lineNumber: this.lineNumber,
                    lineStart: this.lineStart,
                    start: this.index,
                    end: this.index
                  };
                }
                var cp = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(cp)) {
                  return this.scanIdentifier();
                }
                if (cp === 40 || cp === 41 || cp === 59) {
                  return this.scanPunctuator();
                }
                if (cp === 39 || cp === 34) {
                  return this.scanStringLiteral();
                }
                if (cp === 46) {
                  if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                    return this.scanNumericLiteral();
                  }
                  return this.scanPunctuator();
                }
                if (character_1.Character.isDecimalDigit(cp)) {
                  return this.scanNumericLiteral();
                }
                if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                  return this.scanTemplate();
                }
                if (cp >= 55296 && cp < 57343) {
                  if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                    return this.scanIdentifier();
                  }
                }
                return this.scanPunctuator();
              };
              return Scanner2;
            }();
            exports2.Scanner = Scanner;
          },
          /* 13 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.TokenName = {};
            exports2.TokenName[
              1
              /* BooleanLiteral */
            ] = "Boolean";
            exports2.TokenName[
              2
              /* EOF */
            ] = "<end>";
            exports2.TokenName[
              3
              /* Identifier */
            ] = "Identifier";
            exports2.TokenName[
              4
              /* Keyword */
            ] = "Keyword";
            exports2.TokenName[
              5
              /* NullLiteral */
            ] = "Null";
            exports2.TokenName[
              6
              /* NumericLiteral */
            ] = "Numeric";
            exports2.TokenName[
              7
              /* Punctuator */
            ] = "Punctuator";
            exports2.TokenName[
              8
              /* StringLiteral */
            ] = "String";
            exports2.TokenName[
              9
              /* RegularExpression */
            ] = "RegularExpression";
            exports2.TokenName[
              10
              /* Template */
            ] = "Template";
          },
          /* 14 */
          /***/
          function(module3, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.XHTMLEntities = {
              quot: '"',
              amp: "&",
              apos: "'",
              gt: ">",
              nbsp: "\xA0",
              iexcl: "\xA1",
              cent: "\xA2",
              pound: "\xA3",
              curren: "\xA4",
              yen: "\xA5",
              brvbar: "\xA6",
              sect: "\xA7",
              uml: "\xA8",
              copy: "\xA9",
              ordf: "\xAA",
              laquo: "\xAB",
              not: "\xAC",
              shy: "\xAD",
              reg: "\xAE",
              macr: "\xAF",
              deg: "\xB0",
              plusmn: "\xB1",
              sup2: "\xB2",
              sup3: "\xB3",
              acute: "\xB4",
              micro: "\xB5",
              para: "\xB6",
              middot: "\xB7",
              cedil: "\xB8",
              sup1: "\xB9",
              ordm: "\xBA",
              raquo: "\xBB",
              frac14: "\xBC",
              frac12: "\xBD",
              frac34: "\xBE",
              iquest: "\xBF",
              Agrave: "\xC0",
              Aacute: "\xC1",
              Acirc: "\xC2",
              Atilde: "\xC3",
              Auml: "\xC4",
              Aring: "\xC5",
              AElig: "\xC6",
              Ccedil: "\xC7",
              Egrave: "\xC8",
              Eacute: "\xC9",
              Ecirc: "\xCA",
              Euml: "\xCB",
              Igrave: "\xCC",
              Iacute: "\xCD",
              Icirc: "\xCE",
              Iuml: "\xCF",
              ETH: "\xD0",
              Ntilde: "\xD1",
              Ograve: "\xD2",
              Oacute: "\xD3",
              Ocirc: "\xD4",
              Otilde: "\xD5",
              Ouml: "\xD6",
              times: "\xD7",
              Oslash: "\xD8",
              Ugrave: "\xD9",
              Uacute: "\xDA",
              Ucirc: "\xDB",
              Uuml: "\xDC",
              Yacute: "\xDD",
              THORN: "\xDE",
              szlig: "\xDF",
              agrave: "\xE0",
              aacute: "\xE1",
              acirc: "\xE2",
              atilde: "\xE3",
              auml: "\xE4",
              aring: "\xE5",
              aelig: "\xE6",
              ccedil: "\xE7",
              egrave: "\xE8",
              eacute: "\xE9",
              ecirc: "\xEA",
              euml: "\xEB",
              igrave: "\xEC",
              iacute: "\xED",
              icirc: "\xEE",
              iuml: "\xEF",
              eth: "\xF0",
              ntilde: "\xF1",
              ograve: "\xF2",
              oacute: "\xF3",
              ocirc: "\xF4",
              otilde: "\xF5",
              ouml: "\xF6",
              divide: "\xF7",
              oslash: "\xF8",
              ugrave: "\xF9",
              uacute: "\xFA",
              ucirc: "\xFB",
              uuml: "\xFC",
              yacute: "\xFD",
              thorn: "\xFE",
              yuml: "\xFF",
              OElig: "\u0152",
              oelig: "\u0153",
              Scaron: "\u0160",
              scaron: "\u0161",
              Yuml: "\u0178",
              fnof: "\u0192",
              circ: "\u02C6",
              tilde: "\u02DC",
              Alpha: "\u0391",
              Beta: "\u0392",
              Gamma: "\u0393",
              Delta: "\u0394",
              Epsilon: "\u0395",
              Zeta: "\u0396",
              Eta: "\u0397",
              Theta: "\u0398",
              Iota: "\u0399",
              Kappa: "\u039A",
              Lambda: "\u039B",
              Mu: "\u039C",
              Nu: "\u039D",
              Xi: "\u039E",
              Omicron: "\u039F",
              Pi: "\u03A0",
              Rho: "\u03A1",
              Sigma: "\u03A3",
              Tau: "\u03A4",
              Upsilon: "\u03A5",
              Phi: "\u03A6",
              Chi: "\u03A7",
              Psi: "\u03A8",
              Omega: "\u03A9",
              alpha: "\u03B1",
              beta: "\u03B2",
              gamma: "\u03B3",
              delta: "\u03B4",
              epsilon: "\u03B5",
              zeta: "\u03B6",
              eta: "\u03B7",
              theta: "\u03B8",
              iota: "\u03B9",
              kappa: "\u03BA",
              lambda: "\u03BB",
              mu: "\u03BC",
              nu: "\u03BD",
              xi: "\u03BE",
              omicron: "\u03BF",
              pi: "\u03C0",
              rho: "\u03C1",
              sigmaf: "\u03C2",
              sigma: "\u03C3",
              tau: "\u03C4",
              upsilon: "\u03C5",
              phi: "\u03C6",
              chi: "\u03C7",
              psi: "\u03C8",
              omega: "\u03C9",
              thetasym: "\u03D1",
              upsih: "\u03D2",
              piv: "\u03D6",
              ensp: "\u2002",
              emsp: "\u2003",
              thinsp: "\u2009",
              zwnj: "\u200C",
              zwj: "\u200D",
              lrm: "\u200E",
              rlm: "\u200F",
              ndash: "\u2013",
              mdash: "\u2014",
              lsquo: "\u2018",
              rsquo: "\u2019",
              sbquo: "\u201A",
              ldquo: "\u201C",
              rdquo: "\u201D",
              bdquo: "\u201E",
              dagger: "\u2020",
              Dagger: "\u2021",
              bull: "\u2022",
              hellip: "\u2026",
              permil: "\u2030",
              prime: "\u2032",
              Prime: "\u2033",
              lsaquo: "\u2039",
              rsaquo: "\u203A",
              oline: "\u203E",
              frasl: "\u2044",
              euro: "\u20AC",
              image: "\u2111",
              weierp: "\u2118",
              real: "\u211C",
              trade: "\u2122",
              alefsym: "\u2135",
              larr: "\u2190",
              uarr: "\u2191",
              rarr: "\u2192",
              darr: "\u2193",
              harr: "\u2194",
              crarr: "\u21B5",
              lArr: "\u21D0",
              uArr: "\u21D1",
              rArr: "\u21D2",
              dArr: "\u21D3",
              hArr: "\u21D4",
              forall: "\u2200",
              part: "\u2202",
              exist: "\u2203",
              empty: "\u2205",
              nabla: "\u2207",
              isin: "\u2208",
              notin: "\u2209",
              ni: "\u220B",
              prod: "\u220F",
              sum: "\u2211",
              minus: "\u2212",
              lowast: "\u2217",
              radic: "\u221A",
              prop: "\u221D",
              infin: "\u221E",
              ang: "\u2220",
              and: "\u2227",
              or: "\u2228",
              cap: "\u2229",
              cup: "\u222A",
              int: "\u222B",
              there4: "\u2234",
              sim: "\u223C",
              cong: "\u2245",
              asymp: "\u2248",
              ne: "\u2260",
              equiv: "\u2261",
              le: "\u2264",
              ge: "\u2265",
              sub: "\u2282",
              sup: "\u2283",
              nsub: "\u2284",
              sube: "\u2286",
              supe: "\u2287",
              oplus: "\u2295",
              otimes: "\u2297",
              perp: "\u22A5",
              sdot: "\u22C5",
              lceil: "\u2308",
              rceil: "\u2309",
              lfloor: "\u230A",
              rfloor: "\u230B",
              loz: "\u25CA",
              spades: "\u2660",
              clubs: "\u2663",
              hearts: "\u2665",
              diams: "\u2666",
              lang: "\u27E8",
              rang: "\u27E9"
            };
          },
          /* 15 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var error_handler_1 = __webpack_require__(10);
            var scanner_1 = __webpack_require__(12);
            var token_1 = __webpack_require__(13);
            var Reader = function() {
              function Reader2() {
                this.values = [];
                this.curly = this.paren = -1;
              }
              Reader2.prototype.beforeFunctionExpression = function(t) {
                return [
                  "(",
                  "{",
                  "[",
                  "in",
                  "typeof",
                  "instanceof",
                  "new",
                  "return",
                  "case",
                  "delete",
                  "throw",
                  "void",
                  // assignment operators
                  "=",
                  "+=",
                  "-=",
                  "*=",
                  "**=",
                  "/=",
                  "%=",
                  "<<=",
                  ">>=",
                  ">>>=",
                  "&=",
                  "|=",
                  "^=",
                  ",",
                  // binary/unary operators
                  "+",
                  "-",
                  "*",
                  "**",
                  "/",
                  "%",
                  "++",
                  "--",
                  "<<",
                  ">>",
                  ">>>",
                  "&",
                  "|",
                  "^",
                  "!",
                  "~",
                  "&&",
                  "||",
                  "?",
                  ":",
                  "===",
                  "==",
                  ">=",
                  "<=",
                  "<",
                  ">",
                  "!=",
                  "!=="
                ].indexOf(t) >= 0;
              };
              Reader2.prototype.isRegexStart = function() {
                var previous = this.values[this.values.length - 1];
                var regex = previous !== null;
                switch (previous) {
                  case "this":
                  case "]":
                    regex = false;
                    break;
                  case ")":
                    var keyword = this.values[this.paren - 1];
                    regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                    break;
                  case "}":
                    regex = false;
                    if (this.values[this.curly - 3] === "function") {
                      var check = this.values[this.curly - 4];
                      regex = check ? !this.beforeFunctionExpression(check) : false;
                    } else if (this.values[this.curly - 4] === "function") {
                      var check = this.values[this.curly - 5];
                      regex = check ? !this.beforeFunctionExpression(check) : true;
                    }
                    break;
                  default:
                    break;
                }
                return regex;
              };
              Reader2.prototype.push = function(token) {
                if (token.type === 7 || token.type === 4) {
                  if (token.value === "{") {
                    this.curly = this.values.length;
                  } else if (token.value === "(") {
                    this.paren = this.values.length;
                  }
                  this.values.push(token.value);
                } else {
                  this.values.push(null);
                }
              };
              return Reader2;
            }();
            var Tokenizer = function() {
              function Tokenizer2(code, config) {
                this.errorHandler = new error_handler_1.ErrorHandler();
                this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
                this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
                this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
                this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
                this.buffer = [];
                this.reader = new Reader();
              }
              Tokenizer2.prototype.errors = function() {
                return this.errorHandler.errors;
              };
              Tokenizer2.prototype.getNextToken = function() {
                if (this.buffer.length === 0) {
                  var comments = this.scanner.scanComments();
                  if (this.scanner.trackComment) {
                    for (var i = 0; i < comments.length; ++i) {
                      var e = comments[i];
                      var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                      var comment = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value
                      };
                      if (this.trackRange) {
                        comment.range = e.range;
                      }
                      if (this.trackLoc) {
                        comment.loc = e.loc;
                      }
                      this.buffer.push(comment);
                    }
                  }
                  if (!this.scanner.eof()) {
                    var loc = void 0;
                    if (this.trackLoc) {
                      loc = {
                        start: {
                          line: this.scanner.lineNumber,
                          column: this.scanner.index - this.scanner.lineStart
                        },
                        end: {}
                      };
                    }
                    var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                    var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(token);
                    var entry = {
                      type: token_1.TokenName[token.type],
                      value: this.scanner.source.slice(token.start, token.end)
                    };
                    if (this.trackRange) {
                      entry.range = [token.start, token.end];
                    }
                    if (this.trackLoc) {
                      loc.end = {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      };
                      entry.loc = loc;
                    }
                    if (token.type === 9) {
                      var pattern = token.pattern;
                      var flags = token.flags;
                      entry.regex = { pattern, flags };
                    }
                    this.buffer.push(entry);
                  }
                }
                return this.buffer.shift();
              };
              return Tokenizer2;
            }();
            exports2.Tokenizer = Tokenizer;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError4(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError4;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/array-timsort/src/index.js
var require_src = __commonJS({
  "node_modules/array-timsort/src/index.js"(exports, module2) {
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    var results;
    var log10 = (x) => x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
    function alphabeticalCompare(a, b) {
      if (a === b) {
        return 0;
      }
      if (~~a === a && ~~b === b) {
        if (a === 0 || b === 0) {
          return a < b ? -1 : 1;
        }
        if (a < 0 || b < 0) {
          if (b >= 0) {
            return -1;
          }
          if (a >= 0) {
            return 1;
          }
          a = -a;
          b = -b;
        }
        const al = log10(a);
        const bl = log10(b);
        let t = 0;
        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }
        if (a === b) {
          return t;
        }
        return a < b ? -1 : 1;
      }
      const aStr = String(a);
      const bStr = String(b);
      if (aStr === bStr) {
        return 0;
      }
      return aStr < bStr ? -1 : 1;
    }
    function minRunLength(n) {
      let r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare2) {
      let runHi = lo + 1;
      if (runHi === hi) {
        return 1;
      }
      if (compare2(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }
        reverseRun(array, lo, runHi);
        reverseRun(results, lo, runHi);
      } else {
        while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        const t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare2) {
      if (start === lo) {
        start++;
      }
      for (; start < hi; start++) {
        const pivot = array[start];
        const pivotIndex = results[start];
        let left = lo;
        let right = start;
        while (left < right) {
          const mid = left + right >>> 1;
          if (compare2(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }
        let n = start - left;
        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];
            results[left + 3] = results[left + 2];
          case 2:
            array[left + 2] = array[left + 1];
            results[left + 2] = results[left + 1];
          case 1:
            array[left + 1] = array[left];
            results[left + 1] = results[left];
            break;
          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              results[left + n] = results[left + n - 1];
              n--;
            }
        }
        array[left] = pivot;
        results[left] = pivotIndex;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare2) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare2(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare2(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare2(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare2(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare2) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare2(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare2(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare2(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare2(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }
      return offset;
    }
    var TimSort = class {
      constructor(array, compare2) {
        this.array = array;
        this.compare = compare2;
        const { length } = array;
        this.length = length;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH ? length >>> 1 : DEFAULT_TMP_STORAGE_LENGTH;
        this.tmp = new Array(this.tmpStorageLength);
        this.tmpIndex = new Array(this.tmpStorageLength);
        this.stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
        this.stackSize = 0;
      }
      /**
       * Push a new run on TimSort's stack.
       *
       * @param {number} runStart - Start index of the run in the original array.
       * @param {number} runLength - Length of the run;
       */
      pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      }
      /**
       * Merge runs on TimSort's stack so that the following holds for all i:
       * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
       * 2) runLength[i - 2] > runLength[i - 1]
       */
      mergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
            if (this.runLength[n - 1] < this.runLength[n + 1]) {
              n--;
            }
          } else if (this.runLength[n] > this.runLength[n + 1]) {
            break;
          }
          this.mergeAt(n);
        }
      }
      /**
       * Merge all runs on TimSort's stack until only one remains.
       */
      forceMergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
          this.mergeAt(n);
        }
      }
      /**
       * Merge the runs on the stack at positions i and i+1. Must be always be called
       * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
       *
       * @param {number} i - Index of the run to merge in TimSort's stack.
       */
      mergeAt(i) {
        const { compare: compare2 } = this;
        const { array } = this;
        let start1 = this.runStart[i];
        let length1 = this.runLength[i];
        const start2 = this.runStart[i + 1];
        let length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;
        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }
        this.stackSize--;
        const k = gallopRight(array[start2], array, start1, length1, 0, compare2);
        start1 += k;
        length1 -= k;
        if (length1 === 0) {
          return;
        }
        length2 = gallopLeft(
          array[start1 + length1 - 1],
          array,
          start2,
          length2,
          length2 - 1,
          compare2
        );
        if (length2 === 0) {
          return;
        }
        if (length1 <= length2) {
          this.mergeLow(start1, length1, start2, length2);
        } else {
          this.mergeHigh(start1, length1, start2, length2);
        }
      }
      /**
       * Merge two adjacent runs in a stable way. The runs must be such that the
       * first element of run1 is bigger than the first element in run2 and the
       * last element of run1 is greater than all the elements in run2.
       * The method should be called when run1.length <= run2.length as it uses
       * TimSort temporary array to store run1. Use mergeHigh if run1.length >
       * run2.length.
       *
       * @param {number} start1 - First element in run1.
       * @param {number} length1 - Length of run1.
       * @param {number} start2 - First element in run2.
       * @param {number} length2 - Length of run2.
       */
      mergeLow(start1, length1, start2, length2) {
        const { compare: compare2 } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
          tmpIndex[i] = results[start1 + i];
        }
        let cursor1 = 0;
        let cursor2 = start2;
        let dest = start1;
        array[dest] = array[cursor2];
        results[dest] = results[cursor2];
        dest++;
        cursor2++;
        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
          return;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count2 = 0;
          let exit = false;
          do {
            if (compare2(array[cursor2], tmp[cursor1]) < 0) {
              array[dest] = array[cursor2];
              results[dest] = results[cursor2];
              dest++;
              cursor2++;
              count2++;
              count1 = 0;
              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor1];
              results[dest] = tmpIndex[cursor1];
              dest++;
              cursor1++;
              count1++;
              count2 = 0;
              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
                results[dest + i] = tmpIndex[cursor1 + i];
              }
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor2];
            results[dest] = results[cursor2];
            dest++;
            cursor2++;
            if (--length2 === 0) {
              exit = true;
              break;
            }
            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
                results[dest + i] = results[cursor2 + i];
              }
              dest += count2;
              cursor2 += count2;
              length2 -= count2;
              if (length2 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor1];
            results[dest] = tmpIndex[cursor1];
            dest++;
            cursor1++;
            if (--length1 === 1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
        } else if (length1 === 0) {
          throw new Error("mergeLow preconditions were not respected");
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
        }
      }
      /**
       * Merge two adjacent runs in a stable way. The runs must be such that the
       * first element of run1 is bigger than the first element in run2 and the
       * last element of run1 is greater than all the elements in run2.
       * The method should be called when run1.length > run2.length as it uses
       * TimSort temporary array to store run2. Use mergeLow if run1.length <=
       * run2.length.
       *
       * @param {number} start1 - First element in run1.
       * @param {number} length1 - Length of run1.
       * @param {number} start2 - First element in run2.
       * @param {number} length2 - Length of run2.
       */
      mergeHigh(start1, length1, start2, length2) {
        const { compare: compare2 } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
          tmpIndex[i] = results[start2 + i];
        }
        let cursor1 = start1 + length1 - 1;
        let cursor2 = length2 - 1;
        let dest = start2 + length2 - 1;
        let customCursor = 0;
        let customDest = 0;
        array[dest] = array[cursor1];
        results[dest] = results[cursor1];
        dest--;
        cursor1--;
        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
          return;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count2 = 0;
          let exit = false;
          do {
            if (compare2(tmp[cursor2], array[cursor1]) < 0) {
              array[dest] = array[cursor1];
              results[dest] = results[cursor1];
              dest--;
              cursor1--;
              count1++;
              count2 = 0;
              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor2];
              results[dest] = tmpIndex[cursor2];
              dest--;
              cursor2--;
              count2++;
              count1 = 0;
              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = length1 - gallopRight(
              tmp[cursor2],
              array,
              start1,
              length1,
              length1 - 1,
              compare2
            );
            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
                results[customDest + i] = results[customCursor + i];
              }
              if (length1 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor2];
            results[dest] = tmpIndex[cursor2];
            dest--;
            cursor2--;
            if (--length2 === 1) {
              exit = true;
              break;
            }
            count2 = length2 - gallopLeft(
              array[cursor1],
              tmp,
              0,
              length2,
              length2 - 1,
              compare2
            );
            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
                results[customDest + i] = tmpIndex[customCursor + i];
              }
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor1];
            results[dest] = results[cursor1];
            dest--;
            cursor1--;
            if (--length1 === 0) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
        } else if (length2 === 0) {
          throw new Error("mergeHigh preconditions were not respected");
        } else {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
        }
      }
    };
    function sort(array, compare2, lo, hi) {
      if (!Array.isArray(array)) {
        throw new TypeError(
          `The "array" argument must be an array. Received ${array}`
        );
      }
      results = [];
      const { length } = array;
      let i = 0;
      while (i < length) {
        results[i] = i++;
      }
      if (!compare2) {
        compare2 = alphabeticalCompare;
      } else if (typeof compare2 !== "function") {
        hi = lo;
        lo = compare2;
        compare2 = alphabeticalCompare;
      }
      if (!lo) {
        lo = 0;
      }
      if (!hi) {
        hi = length;
      }
      let remaining = hi - lo;
      if (remaining < 2) {
        return results;
      }
      let runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare2);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
        return results;
      }
      const ts = new TimSort(array, compare2);
      const minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare2);
        if (runLength < minRun) {
          let force = remaining;
          if (force > minRun) {
            force = minRun;
          }
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);
      ts.forceMergeRuns();
      return results;
    }
    module2.exports = {
      sort
    };
  }
});

// node_modules/has-own-prop/index.js
var require_has_own_prop = __commonJS({
  "node_modules/has-own-prop/index.js"(exports, module2) {
    "use strict";
    var hasOwnProp = Object.prototype.hasOwnProperty;
    module2.exports = (object, property) => hasOwnProp.call(object, property);
  }
});

// node_modules/comment-json/src/common.js
var require_common = __commonJS({
  "node_modules/comment-json/src/common.js"(exports, module2) {
    var hasOwnProperty2 = require_has_own_prop();
    var {
      isObject,
      isArray,
      isString: isString2,
      isNumber
    } = require_util2();
    var PREFIX_BEFORE = "before";
    var PREFIX_AFTER_PROP = "after-prop";
    var PREFIX_AFTER_COLON = "after-colon";
    var PREFIX_AFTER_VALUE = "after-value";
    var PREFIX_AFTER = "after";
    var PREFIX_BEFORE_ALL = "before-all";
    var PREFIX_AFTER_ALL = "after-all";
    var BRACKET_OPEN = "[";
    var BRACKET_CLOSE = "]";
    var CURLY_BRACKET_OPEN = "{";
    var CURLY_BRACKET_CLOSE = "}";
    var COMMA = ",";
    var EMPTY = "";
    var MINUS = "-";
    var SYMBOL_PREFIXES = [
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER
    ];
    var NON_PROP_SYMBOL_KEYS = [
      PREFIX_BEFORE,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL
    ].map(Symbol.for);
    var COLON = ":";
    var UNDEFINED = void 0;
    var symbol = (prefix, key) => Symbol.for(prefix + COLON + key);
    var define2 = (target, key, value) => Object.defineProperty(target, key, {
      value,
      writable: true,
      configurable: true
    });
    var copy_comments_by_kind = (target, source, target_key, source_key, prefix, remove_source) => {
      const source_prop = symbol(prefix, source_key);
      if (!hasOwnProperty2(source, source_prop)) {
        return;
      }
      const target_prop = target_key === source_key ? source_prop : symbol(prefix, target_key);
      define2(target, target_prop, source[source_prop]);
      if (remove_source) {
        delete source[source_prop];
      }
    };
    var copy_comments = (target, source, target_key, source_key, remove_source) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        copy_comments_by_kind(
          target,
          source,
          target_key,
          source_key,
          prefix,
          remove_source
        );
      });
    };
    var swap_comments = (array, from, to) => {
      if (from === to) {
        return;
      }
      SYMBOL_PREFIXES.forEach((prefix) => {
        const target_prop = symbol(prefix, to);
        if (!hasOwnProperty2(array, target_prop)) {
          copy_comments_by_kind(array, array, to, from, prefix, true);
          return;
        }
        const comments = array[target_prop];
        delete array[target_prop];
        copy_comments_by_kind(array, array, to, from, prefix, true);
        define2(array, symbol(prefix, from), comments);
      });
    };
    var assign_non_prop_comments = (target, source) => {
      NON_PROP_SYMBOL_KEYS.forEach((key) => {
        const comments = source[key];
        if (comments) {
          define2(target, key, comments);
        }
      });
    };
    var assign = (target, source, keys) => {
      keys.forEach((key) => {
        if (!isString2(key) && !isNumber(key)) {
          return;
        }
        if (!hasOwnProperty2(source, key)) {
          return;
        }
        target[key] = source[key];
        copy_comments(target, source, key, key);
      });
      return target;
    };
    module2.exports = {
      SYMBOL_PREFIXES,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      symbol,
      define: define2,
      copy_comments,
      swap_comments,
      assign_non_prop_comments,
      assign(target, source, keys) {
        if (!isObject(target)) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        if (!isObject(source)) {
          return target;
        }
        if (keys === UNDEFINED) {
          keys = Object.keys(source);
          assign_non_prop_comments(target, source);
        } else if (!isArray(keys)) {
          throw new TypeError("keys must be array or undefined");
        } else if (keys.length === 0) {
          assign_non_prop_comments(target, source);
        }
        return assign(target, source, keys);
      }
    };
  }
});

// node_modules/comment-json/src/array.js
var require_array = __commonJS({
  "node_modules/comment-json/src/array.js"(exports, module2) {
    var { isArray } = require_util2();
    var { sort } = require_src();
    var {
      SYMBOL_PREFIXES,
      UNDEFINED,
      symbol,
      copy_comments,
      swap_comments
    } = require_common();
    var reverse_comments = (array) => {
      const { length } = array;
      let i = 0;
      const max = length / 2;
      for (; i < max; i++) {
        swap_comments(array, i, length - i - 1);
      }
    };
    var move_comment = (target, source, i, offset, remove) => {
      copy_comments(target, source, i + offset, i, remove);
    };
    var move_comments = (target, source, start, count, offset, remove) => {
      if (offset > 0) {
        let i2 = count;
        while (i2-- > 0) {
          move_comment(target, source, start + i2, offset, remove);
        }
        return;
      }
      let i = 0;
      while (i < count) {
        const ii = i++;
        move_comment(target, source, start + ii, offset, remove);
      }
    };
    var remove_comments = (array, key) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        const prop = symbol(prefix, key);
        delete array[prop];
      });
    };
    var get_mapped = (map, key) => {
      let mapped = key;
      while (mapped in map) {
        mapped = map[mapped];
      }
      return mapped;
    };
    var CommentArray = class _CommentArray extends Array {
      // - deleteCount + items.length
      // We should avoid `splice(begin, deleteCount, ...items)`,
      // because `splice(0, undefined)` is not equivalent to `splice(0)`,
      // as well as:
      // - slice
      splice(...args) {
        const { length } = this;
        const ret = super.splice(...args);
        let [begin, deleteCount, ...items] = args;
        if (begin < 0) {
          begin += length;
        }
        if (arguments.length === 1) {
          deleteCount = length - begin;
        } else {
          deleteCount = Math.min(length - begin, deleteCount);
        }
        const {
          length: item_length
        } = items;
        const offset = item_length - deleteCount;
        const start = begin + deleteCount;
        const count = length - start;
        move_comments(this, this, start, count, offset, true);
        return ret;
      }
      slice(...args) {
        const { length } = this;
        const array = super.slice(...args);
        if (!array.length) {
          return new _CommentArray();
        }
        let [begin, before] = args;
        if (before === UNDEFINED) {
          before = length;
        } else if (before < 0) {
          before += length;
        }
        if (begin < 0) {
          begin += length;
        } else if (begin === UNDEFINED) {
          begin = 0;
        }
        move_comments(array, this, begin, before - begin, -begin);
        return array;
      }
      unshift(...items) {
        const { length } = this;
        const ret = super.unshift(...items);
        const {
          length: items_length
        } = items;
        if (items_length > 0) {
          move_comments(this, this, 0, length, items_length, true);
        }
        return ret;
      }
      shift() {
        const ret = super.shift();
        const { length } = this;
        remove_comments(this, 0);
        move_comments(this, this, 1, length, -1, true);
        return ret;
      }
      reverse() {
        super.reverse();
        reverse_comments(this);
        return this;
      }
      pop() {
        const ret = super.pop();
        remove_comments(this, this.length);
        return ret;
      }
      concat(...items) {
        let { length } = this;
        const ret = super.concat(...items);
        if (!items.length) {
          return ret;
        }
        move_comments(ret, this, 0, this.length, 0);
        items.forEach((item) => {
          const prev = length;
          length += isArray(item) ? item.length : 1;
          if (!(item instanceof _CommentArray)) {
            return;
          }
          move_comments(ret, item, 0, item.length, prev);
        });
        return ret;
      }
      sort(...args) {
        const result = sort(
          this,
          ...args.slice(0, 1)
        );
        const map = /* @__PURE__ */ Object.create(null);
        result.forEach((source_index, index) => {
          if (source_index === index) {
            return;
          }
          const real_source_index = get_mapped(map, source_index);
          if (real_source_index === index) {
            return;
          }
          map[index] = real_source_index;
          swap_comments(this, index, real_source_index);
        });
        return this;
      }
    };
    module2.exports = {
      CommentArray
    };
  }
});

// node_modules/comment-json/src/parse.js
var require_parse3 = __commonJS({
  "node_modules/comment-json/src/parse.js"(exports, module2) {
    var esprima = require_esprima();
    var {
      CommentArray
    } = require_array();
    var {
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      define: define2,
      assign_non_prop_comments
    } = require_common();
    var tokenize = (code) => esprima.tokenize(code, {
      comment: true,
      loc: true
    });
    var previous_hosts = [];
    var comments_host = null;
    var unassigned_comments = null;
    var previous_props = [];
    var last_prop;
    var remove_comments = false;
    var inline = false;
    var tokens = null;
    var last = null;
    var current = null;
    var index;
    var reviver = null;
    var clean2 = () => {
      previous_props.length = previous_hosts.length = 0;
      last = null;
      last_prop = UNDEFINED;
    };
    var free = () => {
      clean2();
      tokens.length = 0;
      unassigned_comments = comments_host = tokens = last = current = reviver = null;
    };
    var symbolFor = (prefix) => Symbol.for(
      last_prop !== UNDEFINED ? prefix + COLON + last_prop : prefix
    );
    var transform = (k, v) => reviver ? reviver(k, v) : v;
    var unexpected = () => {
      const error2 = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`);
      Object.assign(error2, current.loc.start);
      throw error2;
    };
    var unexpected_end = () => {
      const error2 = new SyntaxError("Unexpected end of JSON input");
      Object.assign(error2, last ? last.loc.end : {
        line: 1,
        column: 0
      });
      throw error2;
    };
    var next = () => {
      const new_token = tokens[++index];
      inline = current && new_token && current.loc.end.line === new_token.loc.start.line || false;
      last = current;
      current = new_token;
    };
    var type = () => {
      if (!current) {
        unexpected_end();
      }
      return current.type === "Punctuator" ? current.value : current.type;
    };
    var is = (t) => type() === t;
    var expect = (a) => {
      if (!is(a)) {
        unexpected();
      }
    };
    var set_comments_host = (new_host) => {
      previous_hosts.push(comments_host);
      comments_host = new_host;
    };
    var restore_comments_host = () => {
      comments_host = previous_hosts.pop();
    };
    var assign_after_comments = () => {
      if (!unassigned_comments) {
        return;
      }
      const after_comments = [];
      for (const comment of unassigned_comments) {
        if (comment.inline) {
          after_comments.push(comment);
        } else {
          break;
        }
      }
      const { length } = after_comments;
      if (!length) {
        return;
      }
      if (length === unassigned_comments.length) {
        unassigned_comments = null;
      } else {
        unassigned_comments.splice(0, length);
      }
      define2(comments_host, symbolFor(PREFIX_AFTER), after_comments);
    };
    var assign_comments = (prefix) => {
      if (!unassigned_comments) {
        return;
      }
      define2(comments_host, symbolFor(prefix), unassigned_comments);
      unassigned_comments = null;
    };
    var parse_comments = (prefix) => {
      const comments = [];
      while (current && (is("LineComment") || is("BlockComment"))) {
        const comment = {
          ...current,
          inline
        };
        comments.push(comment);
        next();
      }
      if (remove_comments) {
        return;
      }
      if (!comments.length) {
        return;
      }
      if (prefix) {
        define2(comments_host, symbolFor(prefix), comments);
        return;
      }
      unassigned_comments = comments;
    };
    var set_prop = (prop, push) => {
      if (push) {
        previous_props.push(last_prop);
      }
      last_prop = prop;
    };
    var restore_prop = () => {
      last_prop = previous_props.pop();
    };
    var parse_object = () => {
      const obj = {};
      set_comments_host(obj);
      set_prop(UNDEFINED, true);
      let started = false;
      let name;
      parse_comments();
      while (!is(CURLY_BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(CURLY_BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        expect("String");
        name = JSON.parse(current.value);
        set_prop(name);
        assign_comments(PREFIX_BEFORE);
        next();
        parse_comments(PREFIX_AFTER_PROP);
        expect(COLON);
        next();
        parse_comments(PREFIX_AFTER_COLON);
        obj[name] = transform(name, walk());
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return obj;
    };
    var parse_array = () => {
      const array = new CommentArray();
      set_comments_host(array);
      set_prop(UNDEFINED, true);
      let started = false;
      let i = 0;
      parse_comments();
      while (!is(BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        set_prop(i);
        assign_comments(PREFIX_BEFORE);
        array[i] = transform(i, walk());
        i++;
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return array;
    };
    function walk() {
      let tt = type();
      if (tt === CURLY_BRACKET_OPEN) {
        next();
        return parse_object();
      }
      if (tt === BRACKET_OPEN) {
        next();
        return parse_array();
      }
      let negative = EMPTY;
      if (tt === MINUS) {
        next();
        tt = type();
        negative = MINUS;
      }
      let v;
      switch (tt) {
        case "String":
        case "Boolean":
        case "Null":
        case "Numeric":
          v = current.value;
          next();
          return JSON.parse(negative + v);
        default:
      }
    }
    var isObject = (subject) => Object(subject) === subject;
    var parse3 = (code, rev, no_comments) => {
      clean2();
      tokens = tokenize(code);
      reviver = rev;
      remove_comments = no_comments;
      if (!tokens.length) {
        unexpected_end();
      }
      index = -1;
      next();
      set_comments_host({});
      parse_comments(PREFIX_BEFORE_ALL);
      let result = walk();
      parse_comments(PREFIX_AFTER_ALL);
      if (current) {
        unexpected();
      }
      if (!no_comments && result !== null) {
        if (!isObject(result)) {
          result = new Object(result);
        }
        assign_non_prop_comments(result, comments_host);
      }
      restore_comments_host();
      result = transform("", result);
      free();
      return result;
    };
    module2.exports = {
      parse: parse3,
      tokenize
    };
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports, module2) {
    "use strict";
    var res = "";
    var cache;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/comment-json/src/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/comment-json/src/stringify.js"(exports, module2) {
    var {
      isArray,
      isObject,
      isFunction,
      isNumber,
      isString: isString2
    } = require_util2();
    var repeat = require_repeat_string();
    var {
      PREFIX_BEFORE_ALL,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      EMPTY,
      UNDEFINED
    } = require_common();
    var ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var SPACE = " ";
    var LF = "\n";
    var STR_NULL = "null";
    var BEFORE = (prop) => `${PREFIX_BEFORE}:${prop}`;
    var AFTER_PROP = (prop) => `${PREFIX_AFTER_PROP}:${prop}`;
    var AFTER_COLON = (prop) => `${PREFIX_AFTER_COLON}:${prop}`;
    var AFTER_VALUE = (prop) => `${PREFIX_AFTER_VALUE}:${prop}`;
    var AFTER = (prop) => `${PREFIX_AFTER}:${prop}`;
    var meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var escape = (string) => {
      ESCAPABLE.lastIndex = 0;
      if (!ESCAPABLE.test(string)) {
        return string;
      }
      return string.replace(ESCAPABLE, (a) => {
        const c = meta[a];
        return typeof c === "string" ? c : a;
      });
    };
    var quote = (string) => `"${escape(string)}"`;
    var comment_stringify = (value, line) => line ? `//${value}` : `/*${value}*/`;
    var process_comments = (host, symbol_tag, deeper_gap, display_block) => {
      const comments = host[Symbol.for(symbol_tag)];
      if (!comments || !comments.length) {
        return EMPTY;
      }
      let is_line_comment = false;
      const str = comments.reduce((prev, {
        inline,
        type,
        value
      }) => {
        const delimiter = inline ? SPACE : LF + deeper_gap;
        is_line_comment = type === "LineComment";
        return prev + delimiter + comment_stringify(value, is_line_comment);
      }, EMPTY);
      return display_block || is_line_comment ? str + LF + deeper_gap : str;
    };
    var replacer = null;
    var indent = EMPTY;
    var clean2 = () => {
      replacer = null;
      indent = EMPTY;
    };
    var join2 = (one, two, gap) => one ? two ? one + two.trim() + LF + gap : one.trimRight() + LF + gap : two ? two.trimRight() + LF + gap : EMPTY;
    var join_content = (inside, value, gap) => {
      const comment = process_comments(value, PREFIX_BEFORE, gap + indent, true);
      return join2(comment, inside, gap);
    };
    var array_stringify = (value, gap) => {
      const deeper_gap = gap + indent;
      const { length } = value;
      let inside = EMPTY;
      let after_comma = EMPTY;
      for (let i = 0; i < length; i++) {
        if (i !== 0) {
          inside += COMMA;
        }
        const before = join2(
          after_comma,
          process_comments(value, BEFORE(i), deeper_gap),
          deeper_gap
        );
        inside += before || LF + deeper_gap;
        inside += stringify2(i, value, deeper_gap) || STR_NULL;
        inside += process_comments(value, AFTER_VALUE(i), deeper_gap);
        after_comma = process_comments(value, AFTER(i), deeper_gap);
      }
      inside += join2(
        after_comma,
        process_comments(value, PREFIX_AFTER, deeper_gap),
        deeper_gap
      );
      return BRACKET_OPEN + join_content(inside, value, gap) + BRACKET_CLOSE;
    };
    var object_stringify = (value, gap) => {
      if (!value) {
        return "null";
      }
      const deeper_gap = gap + indent;
      let inside = EMPTY;
      let after_comma = EMPTY;
      let first = true;
      const keys = isArray(replacer) ? replacer : Object.keys(value);
      const iteratee = (key) => {
        const sv = stringify2(key, value, deeper_gap);
        if (sv === UNDEFINED) {
          return;
        }
        if (!first) {
          inside += COMMA;
        }
        first = false;
        const before = join2(
          after_comma,
          process_comments(value, BEFORE(key), deeper_gap),
          deeper_gap
        );
        inside += before || LF + deeper_gap;
        inside += quote(key) + process_comments(value, AFTER_PROP(key), deeper_gap) + COLON + process_comments(value, AFTER_COLON(key), deeper_gap) + SPACE + sv + process_comments(value, AFTER_VALUE(key), deeper_gap);
        after_comma = process_comments(value, AFTER(key), deeper_gap);
      };
      keys.forEach(iteratee);
      inside += join2(
        after_comma,
        process_comments(value, PREFIX_AFTER, deeper_gap),
        deeper_gap
      );
      return CURLY_BRACKET_OPEN + join_content(inside, value, gap) + CURLY_BRACKET_CLOSE;
    };
    function stringify2(key, holder, gap) {
      let value = holder[key];
      if (isObject(value) && isFunction(value.toJSON)) {
        value = value.toJSON(key);
      }
      if (isFunction(replacer)) {
        value = replacer.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return Number.isFinite(value) ? String(value) : STR_NULL;
        case "boolean":
        case "null":
          return String(value);
        case "object":
          return isArray(value) ? array_stringify(value, gap) : object_stringify(value, gap);
        default:
      }
    }
    var get_indent = (space) => isString2(space) ? space : isNumber(space) ? repeat(SPACE, space) : EMPTY;
    var { toString } = Object.prototype;
    var PRIMITIVE_OBJECT_TYPES = [
      "[object Number]",
      "[object String]",
      "[object Boolean]"
    ];
    var is_primitive_object = (subject) => {
      if (typeof subject !== "object") {
        return false;
      }
      const str = toString.call(subject);
      return PRIMITIVE_OBJECT_TYPES.includes(str);
    };
    module2.exports = (value, replacer_, space) => {
      const indent_ = get_indent(space);
      if (!indent_) {
        return JSON.stringify(value, replacer_);
      }
      if (!isFunction(replacer_) && !isArray(replacer_)) {
        replacer_ = null;
      }
      replacer = replacer_;
      indent = indent_;
      const str = is_primitive_object(value) ? JSON.stringify(value) : stringify2("", { "": value }, EMPTY);
      clean2();
      return isObject(value) ? process_comments(value, PREFIX_BEFORE_ALL, EMPTY).trimLeft() + str + process_comments(value, PREFIX_AFTER_ALL, EMPTY).trimRight() : str;
    };
  }
});

// node_modules/comment-json/src/index.js
var require_src2 = __commonJS({
  "node_modules/comment-json/src/index.js"(exports, module2) {
    var { parse: parse3, tokenize } = require_parse3();
    var stringify2 = require_stringify2();
    var { CommentArray } = require_array();
    var { assign } = require_common();
    module2.exports = {
      parse: parse3,
      stringify: stringify2,
      tokenize,
      CommentArray,
      assign
    };
  }
});

// node_modules/cosmiconfig/dist/cacheWrapper.js
var require_cacheWrapper = __commonJS({
  "node_modules/cosmiconfig/dist/cacheWrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cacheWrapper = cacheWrapper;
    exports.cacheWrapperSync = cacheWrapperSync;
    async function cacheWrapper(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = await fn();
      cache.set(key, result);
      return result;
    }
    function cacheWrapperSync(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = fn();
      cache.set(key, result);
      return result;
    }
  }
});

// node_modules/import-fresh/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "node_modules/import-fresh/node_modules/resolve-from/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var Module = require("module");
    var fs6 = require("fs");
    var resolveFrom = (fromDir, moduleId, silent) => {
      if (typeof fromDir !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDir = fs6.realpathSync(fromDir);
      } catch (err) {
        if (err.code === "ENOENT") {
          fromDir = path16.resolve(fromDir);
        } else if (silent) {
          return null;
        } else {
          throw err;
        }
      }
      const fromFile = path16.join(fromDir, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (err) {
          return null;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId);
    module2.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true);
  }
});

// node_modules/callsites/index.js
var require_callsites = __commonJS({
  "node_modules/callsites/index.js"(exports, module2) {
    "use strict";
    var callsites = () => {
      const _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = _prepareStackTrace;
      return stack;
    };
    module2.exports = callsites;
    module2.exports.default = callsites;
  }
});

// node_modules/parent-module/index.js
var require_parent_module = __commonJS({
  "node_modules/parent-module/index.js"(exports, module2) {
    "use strict";
    var callsites = require_callsites();
    module2.exports = (filepath) => {
      const stacks = callsites();
      if (!filepath) {
        return stacks[2].getFileName();
      }
      let seenVal = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilepath = stack.getFileName();
        if (typeof parentFilepath !== "string") {
          continue;
        }
        if (parentFilepath === filepath) {
          seenVal = true;
          continue;
        }
        if (parentFilepath === "module.js") {
          continue;
        }
        if (seenVal && parentFilepath !== filepath) {
          return parentFilepath;
        }
      }
    };
  }
});

// node_modules/import-fresh/index.js
var require_import_fresh = __commonJS({
  "node_modules/import-fresh/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var resolveFrom = require_resolve_from();
    var parentModule = require_parent_module();
    module2.exports = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError("Expected a string");
      }
      const parentPath = parentModule(__filename);
      const cwd = parentPath ? path16.dirname(parentPath) : __dirname;
      const filePath = resolveFrom(cwd, moduleId);
      const oldModule = require.cache[filePath];
      if (oldModule && oldModule.parent) {
        let i = oldModule.parent.children.length;
        while (i--) {
          if (oldModule.parent.children[i].id === filePath) {
            oldModule.parent.children.splice(i, 1);
          }
        }
      }
      delete require.cache[filePath];
      const parent = require.cache[parentPath];
      return parent === void 0 ? require(filePath) : parent.require(filePath);
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module2) {
    "use strict";
    module2.exports = function isArrayish(obj) {
      if (!obj) {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
    };
  }
});

// node_modules/error-ex/index.js
var require_error_ex = __commonJS({
  "node_modules/error-ex/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var isArrayish = require_is_arrayish();
    var errorEx = function errorEx2(name, properties) {
      if (!name || name.constructor !== String) {
        properties = name || {};
        name = Error.name;
      }
      var errorExError = function ErrorEXError(message) {
        if (!this) {
          return new ErrorEXError(message);
        }
        message = message instanceof Error ? message.message : message || this.message;
        Error.call(this, message);
        Error.captureStackTrace(this, errorExError);
        this.name = name;
        Object.defineProperty(this, "message", {
          configurable: true,
          enumerable: false,
          get: function() {
            var newMessage = message.split(/\r?\n/g);
            for (var key in properties) {
              if (!properties.hasOwnProperty(key)) {
                continue;
              }
              var modifier = properties[key];
              if ("message" in modifier) {
                newMessage = modifier.message(this[key], newMessage) || newMessage;
                if (!isArrayish(newMessage)) {
                  newMessage = [newMessage];
                }
              }
            }
            return newMessage.join("\n");
          },
          set: function(v) {
            message = v;
          }
        });
        var overwrittenStack = null;
        var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
        var stackGetter = stackDescriptor.get;
        var stackValue = stackDescriptor.value;
        delete stackDescriptor.value;
        delete stackDescriptor.writable;
        stackDescriptor.set = function(newstack) {
          overwrittenStack = newstack;
        };
        stackDescriptor.get = function() {
          var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
          if (!overwrittenStack) {
            stack[0] = this.name + ": " + this.message;
          }
          var lineCount = 1;
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("line" in modifier) {
              var line = modifier.line(this[key]);
              if (line) {
                stack.splice(lineCount++, 0, "    " + line);
              }
            }
            if ("stack" in modifier) {
              modifier.stack(this[key], stack);
            }
          }
          return stack.join("\n");
        };
        Object.defineProperty(this, "stack", stackDescriptor);
      };
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(errorExError.prototype, Error.prototype);
        Object.setPrototypeOf(errorExError, Error);
      } else {
        util.inherits(errorExError, Error);
      }
      return errorExError;
    };
    errorEx.append = function(str, def) {
      return {
        message: function(v, message) {
          v = v || def;
          if (v) {
            message[0] += " " + str.replace("%s", v.toString());
          }
          return message;
        }
      };
    };
    errorEx.line = function(str, def) {
      return {
        line: function(v) {
          v = v || def;
          if (v) {
            return str.replace("%s", v.toString());
          }
          return null;
        }
      };
    };
    module2.exports = errorEx;
  }
});

// node_modules/json-parse-even-better-errors/index.js
var require_json_parse_even_better_errors = __commonJS({
  "node_modules/json-parse-even-better-errors/index.js"(exports, module2) {
    "use strict";
    var hexify = (char) => {
      const h = char.charCodeAt(0).toString(16).toUpperCase();
      return "0x" + (h.length % 2 ? "0" : "") + h;
    };
    var parseError = (e, txt, context) => {
      if (!txt) {
        return {
          message: e.message + " while parsing empty string",
          position: 0
        };
      }
      const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
      const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
      const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
      if (errIdx !== null && errIdx !== void 0) {
        const start = errIdx <= context ? 0 : errIdx - context;
        const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        const slice = (start === 0 ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
        const near = txt === slice ? "" : "near ";
        return {
          message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,
          position: errIdx
        };
      } else {
        return {
          message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
          position: 0
        };
      }
    };
    var JSONParseError = class extends SyntaxError {
      constructor(er, txt, context, caller) {
        context = context || 20;
        const metadata = parseError(er, txt, context);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = "EJSONPARSE";
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var kIndent = Symbol.for("indent");
    var kNewline = Symbol.for("newline");
    var formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
    var emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
    var parseJson = (txt, reviver, context) => {
      const parseText = stripBOM(txt);
      context = context || 20;
      try {
        const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [, "", ""];
        const result = JSON.parse(parseText, reviver);
        if (result && typeof result === "object") {
          result[kNewline] = newline;
          result[kIndent] = indent;
        }
        return result;
      } catch (e) {
        if (typeof txt !== "string" && !Buffer.isBuffer(txt)) {
          const isEmptyArray = Array.isArray(txt) && txt.length === 0;
          throw Object.assign(new TypeError(
            `Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`
          ), {
            code: "EJSONPARSE",
            systemError: e
          });
        }
        throw new JSONParseError(e, parseText, context, parseJson);
      }
    };
    var stripBOM = (txt) => String(txt).replace(/^\uFEFF/, "");
    module2.exports = parseJson;
    parseJson.JSONParseError = JSONParseError;
    parseJson.noExceptions = (txt, reviver) => {
      try {
        return JSON.parse(stripBOM(txt), reviver);
      } catch (e) {
      }
    };
  }
});

// node_modules/lines-and-columns/build/index.js
var require_build = __commonJS({
  "node_modules/lines-and-columns/build/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.LinesAndColumns = void 0;
    var LF = "\n";
    var CR = "\r";
    var LinesAndColumns = (
      /** @class */
      function() {
        function LinesAndColumns2(string) {
          this.string = string;
          var offsets = [0];
          for (var offset = 0; offset < string.length; ) {
            switch (string[offset]) {
              case LF:
                offset += LF.length;
                offsets.push(offset);
                break;
              case CR:
                offset += CR.length;
                if (string[offset] === LF) {
                  offset += LF.length;
                }
                offsets.push(offset);
                break;
              default:
                offset++;
                break;
            }
          }
          this.offsets = offsets;
        }
        LinesAndColumns2.prototype.locationForIndex = function(index) {
          if (index < 0 || index > this.string.length) {
            return null;
          }
          var line = 0;
          var offsets = this.offsets;
          while (offsets[line + 1] <= index) {
            line++;
          }
          var column = index - offsets[line];
          return { line, column };
        };
        LinesAndColumns2.prototype.indexForLocation = function(location) {
          var line = location.line, column = location.column;
          if (line < 0 || line >= this.offsets.length) {
            return null;
          }
          if (column < 0 || column > this.lengthOfLine(line)) {
            return null;
          }
          return this.offsets[line] + column;
        };
        LinesAndColumns2.prototype.lengthOfLine = function(line) {
          var offset = this.offsets[line];
          var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
          return nextOffset - offset;
        };
        return LinesAndColumns2;
      }()
    );
    exports.LinesAndColumns = LinesAndColumns;
    exports["default"] = LinesAndColumns;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path16 = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path16.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path16;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/@babel/highlight/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/@babel/highlight/node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/@babel/highlight/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes2 = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes2.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes2,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/@babel/highlight/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@babel/highlight/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape2(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk3, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk3;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk3, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape2(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk3, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk3, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color().stdout;
    var template2 = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk3 = {};
        applyOptions(chalk3, options);
        chalk3.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk3.template].concat(args));
        };
        Object.setPrototypeOf(chalk3, Chalk.prototype);
        Object.setPrototypeOf(chalk3.template, chalk3);
        chalk3.template.constructor = Chalk;
        return chalk3.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes2 = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes2 = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes2 = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self.level;
        },
        set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self.enabled;
        },
        set(enabled) {
          self.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk3, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template2(chalk3, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = highlight;
    exports.getChalk = getChalk;
    exports.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib4();
    var _chalk = require_chalk();
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk3) {
      return {
        keyword: chalk3.cyan,
        capitalized: chalk3.yellow,
        jsxIdentifier: chalk3.yellow,
        punctuator: chalk3.yellow,
        number: chalk3.magenta,
        string: chalk3.green,
        regex: chalk3.magenta,
        comment: chalk3.grey,
        invalid: chalk3.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return !!_chalk.supportsColor || options.forceColor;
    }
    function getChalk(options) {
      return options.forceColor ? new _chalk.constructor({
        enabled: true,
        level: 1
      }) : _chalk;
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const chalk3 = getChalk(options);
        const defs = getDefs(chalk3);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = _default;
    var _highlight = require_lib5();
    var deprecationWarningShown = false;
    function getDefs(chalk3) {
      return {
        gutter: chalk3.grey,
        marker: chalk3.red.bold,
        message: chalk3.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk3 = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk3);
      const maybeHighlight = (chalkFn, string) => {
        return highlighted ? chalkFn(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk3.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// node_modules/parse-json/index.js
var require_parse_json = __commonJS({
  "node_modules/parse-json/index.js"(exports, module2) {
    "use strict";
    var errorEx = require_error_ex();
    var fallback = require_json_parse_even_better_errors();
    var { default: LinesAndColumns } = require_build();
    var { codeFrameColumns } = require_lib6();
    var JSONError = errorEx("JSONError", {
      fileName: errorEx.append("in %s"),
      codeFrame: errorEx.append("\n\n%s\n")
    });
    var parseJson = (string, reviver, filename) => {
      if (typeof reviver === "string") {
        filename = reviver;
        reviver = null;
      }
      try {
        try {
          return JSON.parse(string, reviver);
        } catch (error2) {
          fallback(string, reviver);
          throw error2;
        }
      } catch (error2) {
        error2.message = error2.message.replace(/\n/g, "");
        const indexMatch = error2.message.match(/in JSON at position (\d+) while parsing/);
        const jsonError = new JSONError(error2);
        if (filename) {
          jsonError.fileName = filename;
        }
        if (indexMatch && indexMatch.length > 0) {
          const lines = new LinesAndColumns(string);
          const index = Number(indexMatch[1]);
          const location = lines.locationForIndex(index);
          const codeFrame = codeFrameColumns(
            string,
            { start: { line: location.line + 1, column: location.column + 1 } },
            { highlightCode: true }
          );
          jsonError.codeFrame = codeFrame;
        }
        throw jsonError;
      }
    };
    parseJson.JSONError = JSONError;
    module2.exports = parseJson;
  }
});

// node_modules/js-yaml/lib/common.js
var require_common2 = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray3(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray3;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports, module2) {
    "use strict";
    function formatError(exception, compact) {
      var where = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark)
        return message;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module2.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports, module2) {
    "use strict";
    var common = require_common2();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart(string, max) {
      return common.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo - i],
          lineEnds[foundLineNo - i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
          maxLineLength
        );
        result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo + i],
          lineEnds[foundLineNo + i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
          maxLineLength
        );
        result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module2.exports = makeSnippet;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports, module2) {
    "use strict";
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name) {
      var result = [];
      schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      return this.extend(definition);
    }
    Schema.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module2.exports = Schema;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports, module2) {
    "use strict";
    var common = require_common2();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o")
          return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports, module2) {
    "use strict";
    var common = require_common2();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports, module2) {
    "use strict";
    module2.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core2 = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports, module2) {
    "use strict";
    module2.exports = require_json();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports, module2) {
    "use strict";
    module2.exports = require_core2().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports, module2) {
    "use strict";
    var common = require_common2();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports, module2) {
    "use strict";
    var common = require_common2();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos) {
      var first = string.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(
          string,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string[i];
          if (char >= 65536)
            result += string[i + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true))
        return state.dump + "\n";
      return "";
    }
    module2.exports.dump = dump;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core2();
    module2.exports.DEFAULT_SCHEMA = require_default();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.YAMLException = require_exception();
    module2.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module2.exports.safeLoad = renamed("safeLoad", "load");
    module2.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module2.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/cosmiconfig/dist/loaders.js
var require_loaders = __commonJS({
  "node_modules/cosmiconfig/dist/loaders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.loaders = void 0;
    var importFresh;
    var loadJs = function loadJs2(filepath) {
      if (importFresh === void 0) {
        importFresh = require_import_fresh();
      }
      const result = importFresh(filepath);
      return result;
    };
    var parseJson;
    var loadJson = function loadJson2(filepath, content) {
      if (parseJson === void 0) {
        parseJson = require_parse_json();
      }
      try {
        const result = parseJson(content);
        return result;
      } catch (error2) {
        error2.message = `JSON Error in ${filepath}:
${error2.message}`;
        throw error2;
      }
    };
    var yaml;
    var loadYaml = function loadYaml2(filepath, content) {
      if (yaml === void 0) {
        yaml = require_js_yaml();
      }
      try {
        const result = yaml.load(content);
        return result;
      } catch (error2) {
        error2.message = `YAML Error in ${filepath}:
${error2.message}`;
        throw error2;
      }
    };
    var loaders = {
      loadJs,
      loadJson,
      loadYaml
    };
    exports.loaders = loaders;
  }
});

// node_modules/cosmiconfig/dist/getPropertyByPath.js
var require_getPropertyByPath = __commonJS({
  "node_modules/cosmiconfig/dist/getPropertyByPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPropertyByPath = getPropertyByPath;
    function getPropertyByPath(source, path16) {
      if (typeof path16 === "string" && Object.prototype.hasOwnProperty.call(source, path16)) {
        return source[path16];
      }
      const parsedPath = typeof path16 === "string" ? path16.split(".") : path16;
      return parsedPath.reduce((previous, key) => {
        if (previous === void 0) {
          return previous;
        }
        return previous[key];
      }, source);
    }
  }
});

// node_modules/cosmiconfig/dist/ExplorerBase.js
var require_ExplorerBase = __commonJS({
  "node_modules/cosmiconfig/dist/ExplorerBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExplorerBase = void 0;
    exports.getExtensionDescription = getExtensionDescription;
    var _path = _interopRequireDefault(require("path"));
    var _loaders = require_loaders();
    var _getPropertyByPath = require_getPropertyByPath();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerBase = class {
      constructor(options) {
        if (options.cache === true) {
          this.loadCache = /* @__PURE__ */ new Map();
          this.searchCache = /* @__PURE__ */ new Map();
        }
        this.config = options;
        this.validateConfig();
      }
      clearLoadCache() {
        if (this.loadCache) {
          this.loadCache.clear();
        }
      }
      clearSearchCache() {
        if (this.searchCache) {
          this.searchCache.clear();
        }
      }
      clearCaches() {
        this.clearLoadCache();
        this.clearSearchCache();
      }
      validateConfig() {
        const config = this.config;
        config.searchPlaces.forEach((place) => {
          const loaderKey = _path.default.extname(place) || "noExt";
          const loader = config.loaders[loaderKey];
          if (!loader) {
            throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item "${place}" is invalid`);
          }
          if (typeof loader !== "function") {
            throw new Error(`loader for ${getExtensionDescription(place)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
          }
        });
      }
      shouldSearchStopWithResult(result) {
        if (result === null)
          return false;
        if (result.isEmpty && this.config.ignoreEmptySearchPlaces)
          return false;
        return true;
      }
      nextDirectoryToSearch(currentDir, currentResult) {
        if (this.shouldSearchStopWithResult(currentResult)) {
          return null;
        }
        const nextDir = nextDirUp(currentDir);
        if (nextDir === currentDir || currentDir === this.config.stopDir) {
          return null;
        }
        return nextDir;
      }
      loadPackageProp(filepath, content) {
        const parsedContent = _loaders.loaders.loadJson(filepath, content);
        const packagePropValue = (0, _getPropertyByPath.getPropertyByPath)(parsedContent, this.config.packageProp);
        return packagePropValue || null;
      }
      getLoaderEntryForFile(filepath) {
        if (_path.default.basename(filepath) === "package.json") {
          const loader2 = this.loadPackageProp.bind(this);
          return loader2;
        }
        const loaderKey = _path.default.extname(filepath) || "noExt";
        const loader = this.config.loaders[loaderKey];
        if (!loader) {
          throw new Error(`No loader specified for ${getExtensionDescription(filepath)}`);
        }
        return loader;
      }
      loadedContentToCosmiconfigResult(filepath, loadedContent) {
        if (loadedContent === null) {
          return null;
        }
        if (loadedContent === void 0) {
          return {
            filepath,
            config: void 0,
            isEmpty: true
          };
        }
        return {
          config: loadedContent,
          filepath
        };
      }
      validateFilePath(filepath) {
        if (!filepath) {
          throw new Error("load must pass a non-empty string");
        }
      }
    };
    exports.ExplorerBase = ExplorerBase;
    function nextDirUp(dir) {
      return _path.default.dirname(dir);
    }
    function getExtensionDescription(filepath) {
      const ext = _path.default.extname(filepath);
      return ext ? `extension "${ext}"` : "files without extensions";
    }
  }
});

// node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/path-type/index.js"(exports) {
    "use strict";
    var { promisify: promisify3 } = require("util");
    var fs6 = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify3(fs6[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error2) {
        if (error2.code === "ENOENT") {
          return false;
        }
        throw error2;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs6[fsStatType](filePath)[statsMethodName]();
      } catch (error2) {
        if (error2.code === "ENOENT") {
          return false;
        }
        throw error2;
      }
    }
    exports.isFile = isType.bind(null, "stat", "isFile");
    exports.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/cosmiconfig/dist/getDirectory.js
var require_getDirectory = __commonJS({
  "node_modules/cosmiconfig/dist/getDirectory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getDirectory = getDirectory;
    exports.getDirectorySync = getDirectorySync;
    var _path = _interopRequireDefault(require("path"));
    var _pathType = require_path_type();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function getDirectory(filepath) {
      const filePathIsDirectory = await (0, _pathType.isDirectory)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
    function getDirectorySync(filepath) {
      const filePathIsDirectory = (0, _pathType.isDirectorySync)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
  }
});

// node_modules/cosmiconfig/dist/readFile.js
var require_readFile = __commonJS({
  "node_modules/cosmiconfig/dist/readFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readFile = readFile4;
    exports.readFileSync = readFileSync5;
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function fsReadFileAsync(pathname, encoding) {
      return new Promise((resolve10, reject) => {
        _fs.default.readFile(pathname, encoding, (error2, contents) => {
          if (error2) {
            reject(error2);
            return;
          }
          resolve10(contents);
        });
      });
    }
    async function readFile4(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = await fsReadFileAsync(filepath, "utf8");
        return content;
      } catch (error2) {
        if (throwNotFound === false && (error2.code === "ENOENT" || error2.code === "EISDIR")) {
          return null;
        }
        throw error2;
      }
    }
    function readFileSync5(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = _fs.default.readFileSync(filepath, "utf8");
        return content;
      } catch (error2) {
        if (throwNotFound === false && (error2.code === "ENOENT" || error2.code === "EISDIR")) {
          return null;
        }
        throw error2;
      }
    }
  }
});

// node_modules/cosmiconfig/dist/Explorer.js
var require_Explorer = __commonJS({
  "node_modules/cosmiconfig/dist/Explorer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Explorer = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _cacheWrapper = require_cacheWrapper();
    var _ExplorerBase = require_ExplorerBase();
    var _getDirectory = require_getDirectory();
    var _readFile = require_readFile();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Explorer = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      async search(searchFrom = process.cwd()) {
        const startDirectory = await (0, _getDirectory.getDirectory)(searchFrom);
        const result = await this.searchFromDirectory(startDirectory);
        return result;
      }
      async searchFromDirectory(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run2 = async () => {
          const result = await this.searchDirectory(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectory(nextDir);
          }
          const transformResult = await this.config.transform(result);
          return transformResult;
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.searchCache, absoluteDir, run2);
        }
        return run2();
      }
      async searchDirectory(dir) {
        for await (const place of this.config.searchPlaces) {
          const placeResult = await this.loadSearchPlace(dir, place);
          if (this.shouldSearchStopWithResult(placeResult) === true) {
            return placeResult;
          }
        }
        return null;
      }
      async loadSearchPlace(dir, place) {
        const filepath = _path.default.join(dir, place);
        const fileContents = await (0, _readFile.readFile)(filepath);
        const result = await this.createCosmiconfigResult(filepath, fileContents);
        return result;
      }
      async loadFileContent(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        try {
          return await loader(filepath, content);
        } catch (e) {
          e.filepath = filepath;
          throw e;
        }
      }
      async createCosmiconfigResult(filepath, content) {
        const fileContent = await this.loadFileContent(filepath, content);
        const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);
        return result;
      }
      async load(filepath) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoad = async () => {
          const fileContents = await (0, _readFile.readFile)(absoluteFilePath, {
            throwNotFound: true
          });
          const result = await this.createCosmiconfigResult(absoluteFilePath, fileContents);
          const transformResult = await this.config.transform(result);
          return transformResult;
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.loadCache, absoluteFilePath, runLoad);
        }
        return runLoad();
      }
    };
    exports.Explorer = Explorer;
  }
});

// node_modules/cosmiconfig/dist/ExplorerSync.js
var require_ExplorerSync = __commonJS({
  "node_modules/cosmiconfig/dist/ExplorerSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExplorerSync = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _cacheWrapper = require_cacheWrapper();
    var _ExplorerBase = require_ExplorerBase();
    var _getDirectory = require_getDirectory();
    var _readFile = require_readFile();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerSync = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      searchSync(searchFrom = process.cwd()) {
        const startDirectory = (0, _getDirectory.getDirectorySync)(searchFrom);
        const result = this.searchFromDirectorySync(startDirectory);
        return result;
      }
      searchFromDirectorySync(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run2 = () => {
          const result = this.searchDirectorySync(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectorySync(nextDir);
          }
          const transformResult = this.config.transform(result);
          return transformResult;
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.searchCache, absoluteDir, run2);
        }
        return run2();
      }
      searchDirectorySync(dir) {
        for (const place of this.config.searchPlaces) {
          const placeResult = this.loadSearchPlaceSync(dir, place);
          if (this.shouldSearchStopWithResult(placeResult) === true) {
            return placeResult;
          }
        }
        return null;
      }
      loadSearchPlaceSync(dir, place) {
        const filepath = _path.default.join(dir, place);
        const content = (0, _readFile.readFileSync)(filepath);
        const result = this.createCosmiconfigResultSync(filepath, content);
        return result;
      }
      loadFileContentSync(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        try {
          return loader(filepath, content);
        } catch (e) {
          e.filepath = filepath;
          throw e;
        }
      }
      createCosmiconfigResultSync(filepath, content) {
        const fileContent = this.loadFileContentSync(filepath, content);
        const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);
        return result;
      }
      loadSync(filepath) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoadSync = () => {
          const content = (0, _readFile.readFileSync)(absoluteFilePath, {
            throwNotFound: true
          });
          const cosmiconfigResult = this.createCosmiconfigResultSync(absoluteFilePath, content);
          const transformResult = this.config.transform(cosmiconfigResult);
          return transformResult;
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.loadCache, absoluteFilePath, runLoadSync);
        }
        return runLoadSync();
      }
    };
    exports.ExplorerSync = ExplorerSync;
  }
});

// node_modules/cosmiconfig/dist/types.js
var require_types = __commonJS({
  "node_modules/cosmiconfig/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/cosmiconfig/dist/index.js
var require_dist = __commonJS({
  "node_modules/cosmiconfig/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cosmiconfig = cosmiconfig;
    exports.cosmiconfigSync = cosmiconfigSync;
    exports.defaultLoaders = void 0;
    var _os = _interopRequireDefault(require("os"));
    var _Explorer = require_Explorer();
    var _ExplorerSync = require_ExplorerSync();
    var _loaders = require_loaders();
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function cosmiconfig(moduleName, options = {}) {
      const normalizedOptions = normalizeOptions(moduleName, options);
      const explorer = new _Explorer.Explorer(normalizedOptions);
      return {
        search: explorer.search.bind(explorer),
        load: explorer.load.bind(explorer),
        clearLoadCache: explorer.clearLoadCache.bind(explorer),
        clearSearchCache: explorer.clearSearchCache.bind(explorer),
        clearCaches: explorer.clearCaches.bind(explorer)
      };
    }
    function cosmiconfigSync(moduleName, options = {}) {
      const normalizedOptions = normalizeOptions(moduleName, options);
      const explorerSync = new _ExplorerSync.ExplorerSync(normalizedOptions);
      return {
        search: explorerSync.searchSync.bind(explorerSync),
        load: explorerSync.loadSync.bind(explorerSync),
        clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),
        clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),
        clearCaches: explorerSync.clearCaches.bind(explorerSync)
      };
    }
    var defaultLoaders = Object.freeze({
      ".cjs": _loaders.loaders.loadJs,
      ".js": _loaders.loaders.loadJs,
      ".json": _loaders.loaders.loadJson,
      ".yaml": _loaders.loaders.loadYaml,
      ".yml": _loaders.loaders.loadYaml,
      noExt: _loaders.loaders.loadYaml
    });
    exports.defaultLoaders = defaultLoaders;
    var identity = function identity2(x) {
      return x;
    };
    function normalizeOptions(moduleName, options) {
      const defaults = {
        packageProp: moduleName,
        searchPlaces: ["package.json", `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.${moduleName}rc.js`, `.${moduleName}rc.cjs`, `.config/${moduleName}rc`, `.config/${moduleName}rc.json`, `.config/${moduleName}rc.yaml`, `.config/${moduleName}rc.yml`, `.config/${moduleName}rc.js`, `.config/${moduleName}rc.cjs`, `${moduleName}.config.js`, `${moduleName}.config.cjs`],
        ignoreEmptySearchPlaces: true,
        stopDir: _os.default.homedir(),
        cache: true,
        transform: identity,
        loaders: defaultLoaders
      };
      const normalizedOptions = {
        ...defaults,
        ...options,
        loaders: {
          ...defaults.loaders,
          ...options.loaders
        }
      };
      return normalizedOptions;
    }
  }
});

// node_modules/cspell-io/dist/cjs/async/asyncIterable.js
var require_asyncIterable = __commonJS({
  "node_modules/cspell-io/dist/cjs/async/asyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toArray = void 0;
    async function toArray3(asyncIterable) {
      const data = [];
      for await (const item of asyncIterable) {
        data.push(item);
      }
      return data;
    }
    exports.toArray = toArray3;
  }
});

// node_modules/@cspell/cspell-service-bus/dist/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@cspell/cspell-service-bus/dist/cjs/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorDuplicateSubsystem = exports.UnhandledHandlerError = exports.ErrorServiceRequestDepthExceeded = exports.ErrorUnhandledRequest = void 0;
    var ErrorUnhandledRequest2 = class extends Error {
      constructor(request) {
        super(`Unhandled Request: ${request.type}`);
        this.request = request;
      }
    };
    exports.ErrorUnhandledRequest = ErrorUnhandledRequest2;
    var ErrorServiceRequestDepthExceeded2 = class extends Error {
      constructor(request, depth) {
        super(`Service Request Depth ${depth} Exceeded: ${request.type}`);
        this.request = request;
        this.depth = depth;
      }
    };
    exports.ErrorServiceRequestDepthExceeded = ErrorServiceRequestDepthExceeded2;
    var UnhandledHandlerError2 = class extends Error {
      constructor(handlerName, handlerDescription, cause) {
        super(`Unhandled Error in Handler: ${handlerName}`);
        this.handlerName = handlerName;
        this.handlerDescription = handlerDescription;
        this.cause = cause;
      }
    };
    exports.UnhandledHandlerError = UnhandledHandlerError2;
    var ErrorDuplicateSubsystem = class extends Error {
      constructor(subsystemName) {
        super(`Duplicate subsystem: ${subsystemName}`);
        this.subsystemName = subsystemName;
      }
    };
    exports.ErrorDuplicateSubsystem = ErrorDuplicateSubsystem;
  }
});

// node_modules/@cspell/cspell-service-bus/dist/cjs/request.js
var require_request = __commonJS({
  "node_modules/@cspell/cspell-service-bus/dist/cjs/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.isInstanceOfFn = exports.isServiceResponseFailure = exports.isServiceResponseSuccess = exports.createResponseFail = exports.createResponse = exports.ServiceRequestCls = void 0;
    var BaseServiceRequest2 = class {
      constructor(type, params) {
        this.type = type;
        this.params = params;
      }
    };
    var ServiceRequestCls2 = class extends BaseServiceRequest2 {
      constructor(type, params) {
        super(type, params);
      }
    };
    exports.ServiceRequestCls = ServiceRequestCls2;
    function createResponse2(value, _req) {
      return { value };
    }
    exports.createResponse = createResponse2;
    function createResponseFail2(_request, error2) {
      return { error: error2 };
    }
    exports.createResponseFail = createResponseFail2;
    function isServiceResponseSuccess2(res) {
      return "value" in res && res.error === void 0;
    }
    exports.isServiceResponseSuccess = isServiceResponseSuccess2;
    function isServiceResponseFailure2(res) {
      return res.error !== void 0;
    }
    exports.isServiceResponseFailure = isServiceResponseFailure2;
    function isInstanceOfFn(constructor) {
      return (t) => t instanceof constructor;
    }
    exports.isInstanceOfFn = isInstanceOfFn;
    exports.__testing__ = {
      BaseServiceRequest: BaseServiceRequest2
    };
  }
});

// node_modules/@cspell/cspell-service-bus/dist/cjs/bus.js
var require_bus = __commonJS({
  "node_modules/@cspell/cspell-service-bus/dist/cjs/bus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createServiceBus = exports.ServiceBus = void 0;
    var errors_js_1 = require_errors();
    var request_js_1 = require_request();
    var MAX_DEPTH2 = 10;
    var ServiceBus2 = class {
      constructor(handlers = []) {
        this.handlers = [];
        handlers.forEach((h) => this.addHandler(h));
      }
      addHandler(handler, name = "anonymous", description) {
        const h = typeof handler === "function" ? { fn: handler, name, description } : handler;
        const { fn, name: _name, description: _description } = h;
        this.handlers.push({ fn, name: _name, description: _description });
        return this;
      }
      dispatch(request) {
        let depth = 0;
        const dispatcher = { dispatch };
        const handler = this.reduceHandlers(this.handlers, request, dispatcher, this.defaultHandler);
        function dispatch(request2) {
          ++depth;
          if (depth >= MAX_DEPTH2) {
            return (0, request_js_1.createResponseFail)(request2, new errors_js_1.ErrorServiceRequestDepthExceeded(request2, depth));
          }
          const response = handler(request2);
          --depth;
          return response;
        }
        return dispatch(request);
      }
      defaultHandler(request) {
        return (0, request_js_1.createResponseFail)(request, new errors_js_1.ErrorUnhandledRequest(request));
      }
      reduceHandlers(handlers, request, dispatcher, defaultHandler) {
        const _handlers = handlers.map((m) => ({ ...m, fn: m.fn(dispatcher) }));
        const handler = _handlers.reduce((next, h) => {
          const fn = h.fn(next);
          return (req) => {
            try {
              return fn(req);
            } catch (e) {
              return (0, request_js_1.createResponseFail)(request, new errors_js_1.UnhandledHandlerError(h.name, h.description, e));
            }
          };
        }, defaultHandler);
        return handler;
      }
    };
    exports.ServiceBus = ServiceBus2;
    function createServiceBus2(handlers = []) {
      return new ServiceBus2(handlers);
    }
    exports.createServiceBus = createServiceBus2;
  }
});

// node_modules/@cspell/cspell-service-bus/dist/cjs/createRequestHandler.js
var require_createRequestHandler = __commonJS({
  "node_modules/@cspell/cspell-service-bus/dist/cjs/createRequestHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIsRequestHandler = exports.createIsRequestHandlerFn = exports.createRequestHandler = void 0;
    function createRequestHandler2(requestDef, fn, name, description) {
      return createIsRequestHandler2(requestDef.is, fn, name ?? requestDef.type, description);
    }
    exports.createRequestHandler = createRequestHandler2;
    function createIsRequestHandlerFn2(isA, fn) {
      return (dispatcher) => (next) => (request) => isA(request) ? fn(request, next, dispatcher) : next(request);
    }
    exports.createIsRequestHandlerFn = createIsRequestHandlerFn2;
    function createIsRequestHandler2(isA, fn, name, description) {
      return {
        fn: createIsRequestHandlerFn2(isA, fn),
        name,
        description
      };
    }
    exports.createIsRequestHandler = createIsRequestHandler2;
  }
});

// node_modules/@cspell/cspell-service-bus/dist/cjs/requestFactory.js
var require_requestFactory = __commonJS({
  "node_modules/@cspell/cspell-service-bus/dist/cjs/requestFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestFactory = void 0;
    var createRequestHandler_js_1 = require_createRequestHandler();
    var request_js_1 = require_request();
    function requestFactory2(requestType) {
      class RequestClass extends request_js_1.ServiceRequestCls {
        constructor(params) {
          super(requestType, params);
        }
        static is(req) {
          return req instanceof RequestClass && req.type === requestType;
        }
        static create(params) {
          return new RequestClass(params);
        }
        static createRequestHandler(fn, name, description) {
          return (0, createRequestHandler_js_1.createRequestHandler)(RequestClass, fn, name, description);
        }
      }
      RequestClass.type = requestType;
      return RequestClass;
    }
    exports.requestFactory = requestFactory2;
  }
});

// node_modules/@cspell/cspell-service-bus/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@cspell/cspell-service-bus/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestFactory = exports.ServiceRequestCls = exports.isServiceResponseSuccess = exports.isServiceResponseFailure = exports.createResponseFail = exports.createResponse = exports.createRequestHandler = exports.createIsRequestHandler = exports.ServiceBus = exports.createServiceBus = void 0;
    var bus_js_1 = require_bus();
    Object.defineProperty(exports, "createServiceBus", { enumerable: true, get: function() {
      return bus_js_1.createServiceBus;
    } });
    Object.defineProperty(exports, "ServiceBus", { enumerable: true, get: function() {
      return bus_js_1.ServiceBus;
    } });
    var createRequestHandler_js_1 = require_createRequestHandler();
    Object.defineProperty(exports, "createIsRequestHandler", { enumerable: true, get: function() {
      return createRequestHandler_js_1.createIsRequestHandler;
    } });
    Object.defineProperty(exports, "createRequestHandler", { enumerable: true, get: function() {
      return createRequestHandler_js_1.createRequestHandler;
    } });
    var request_js_1 = require_request();
    Object.defineProperty(exports, "createResponse", { enumerable: true, get: function() {
      return request_js_1.createResponse;
    } });
    Object.defineProperty(exports, "createResponseFail", { enumerable: true, get: function() {
      return request_js_1.createResponseFail;
    } });
    Object.defineProperty(exports, "isServiceResponseFailure", { enumerable: true, get: function() {
      return request_js_1.isServiceResponseFailure;
    } });
    Object.defineProperty(exports, "isServiceResponseSuccess", { enumerable: true, get: function() {
      return request_js_1.isServiceResponseSuccess;
    } });
    Object.defineProperty(exports, "ServiceRequestCls", { enumerable: true, get: function() {
      return request_js_1.ServiceRequestCls;
    } });
    var requestFactory_js_1 = require_requestFactory();
    Object.defineProperty(exports, "requestFactory", { enumerable: true, get: function() {
      return requestFactory_js_1.requestFactory;
    } });
  }
});

// node_modules/cspell-io/dist/cjs/common/stat.js
var require_stat = __commonJS({
  "node_modules/cspell-io/dist/cjs/common/stat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compareStats = void 0;
    function compareStats2(left, right) {
      if (left === right)
        return 0;
      if (left.eTag || right.eTag)
        return left.eTag === right.eTag ? 0 : (left.eTag || "") < (right.eTag || "") ? -1 : 1;
      const diff = left.size - right.size || left.mtimeMs - right.mtimeMs;
      return diff < 0 ? -1 : diff > 0 ? 1 : 0;
    }
    exports.compareStats = compareStats2;
  }
});

// node_modules/cspell-io/dist/cjs/errors/ErrorNotImplemented.js
var require_ErrorNotImplemented = __commonJS({
  "node_modules/cspell-io/dist/cjs/errors/ErrorNotImplemented.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorNotImplemented = void 0;
    var ErrorNotImplemented2 = class extends Error {
      constructor(method) {
        super(`Method ${method} is not supported.`);
        this.method = method;
      }
    };
    exports.ErrorNotImplemented = ErrorNotImplemented2;
  }
});

// node_modules/cspell-io/dist/cjs/common/encode-decode.js
var require_encode_decode = __commonJS({
  "node_modules/cspell-io/dist/cjs/common/encode-decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calcEncodingFromBom = exports.encodeUtf16BE = exports.encodeUtf16LE = exports.encodeString = exports.swapBytes = exports.swapBytesInPlace = exports.decode = exports.decodeUtf16BE = exports.decodeUtf16LE = void 0;
    var BOM_BE2 = 65279;
    var BOM_LE2 = 65534;
    function decodeUtf16LE2(buf) {
      const bom = buf[0] << 8 | buf[1];
      buf = bom === BOM_LE2 ? buf.subarray(2) : buf;
      return buf.toString("utf16le");
    }
    exports.decodeUtf16LE = decodeUtf16LE2;
    function decodeUtf16BE2(buf) {
      return decodeUtf16LE2(swapBytes2(buf));
    }
    exports.decodeUtf16BE = decodeUtf16BE2;
    function decode2(buf, encoding) {
      switch (encoding) {
        case "utf16be":
          return decodeUtf16BE2(buf);
        case "utf16le":
          return decodeUtf16LE2(buf);
      }
      if (buf.length < 2 || encoding && !encoding.startsWith("utf"))
        return buf.toString(encoding);
      const bom = buf[0] << 8 | buf[1];
      if (bom === BOM_BE2 || buf[0] === 0 && buf[1] !== 0)
        return decodeUtf16BE2(buf);
      if (bom === BOM_LE2 || buf[0] !== 0 && buf[1] === 0)
        return decodeUtf16LE2(buf);
      return buf.toString(encoding);
    }
    exports.decode = decode2;
    function swapBytesInPlace2(buf) {
      for (let i = 0; i < buf.length - 1; i += 2) {
        const v = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = v;
      }
      return buf;
    }
    exports.swapBytesInPlace = swapBytesInPlace2;
    function swapBytes2(buf) {
      const tBuf = Buffer.from(buf);
      return swapBytesInPlace2(tBuf);
    }
    exports.swapBytes = swapBytes2;
    function encodeString2(str, encoding, bom) {
      switch (encoding) {
        case "utf16be":
          return encodeUtf16BE(str, bom);
        case "utf16le":
          return encodeUtf16LE(str, bom);
      }
      return Buffer.from(str, encoding);
    }
    exports.encodeString = encodeString2;
    function encodeUtf16LE(str, bom = true) {
      const buf = Buffer.from(str, "utf16le");
      if (bom) {
        const target = Buffer.alloc(buf.length + 2);
        target.writeUint16LE(BOM_BE2);
        buf.copy(target, 2);
        return target;
      }
      return buf;
    }
    exports.encodeUtf16LE = encodeUtf16LE;
    function encodeUtf16BE(str, bom = true) {
      return swapBytesInPlace2(encodeUtf16LE(str, bom));
    }
    exports.encodeUtf16BE = encodeUtf16BE;
    function calcEncodingFromBom2(buf) {
      if (buf.length < 2)
        return void 0;
      switch (buf[0] << 8 | buf[1]) {
        case BOM_BE2:
          return "utf16be";
        case BOM_LE2:
          return "utf16le";
      }
      return void 0;
    }
    exports.calcEncodingFromBom = calcEncodingFromBom2;
  }
});

// node_modules/cspell-io/dist/cjs/errors/error.js
var require_error = __commonJS({
  "node_modules/cspell-io/dist/cjs/errors/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toError = void 0;
    function toError4(e) {
      if (e instanceof Error)
        return e;
      if (typeof e === "object" && e && typeof e.message === "string") {
        return e;
      }
      return Error(e && e.toString());
    }
    exports.toError = toError4;
  }
});

// node_modules/cspell-io/dist/cjs/errors/index.js
var require_errors2 = __commonJS({
  "node_modules/cspell-io/dist/cjs/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorNotImplemented = exports.toError = void 0;
    var error_js_1 = require_error();
    Object.defineProperty(exports, "toError", { enumerable: true, get: function() {
      return error_js_1.toError;
    } });
    var ErrorNotImplemented_js_1 = require_ErrorNotImplemented();
    Object.defineProperty(exports, "ErrorNotImplemented", { enumerable: true, get: function() {
      return ErrorNotImplemented_js_1.ErrorNotImplemented;
    } });
  }
});

// node_modules/cspell-io/dist/cjs/node/file/util.js
var require_util3 = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/file/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.basename = exports.urlDirname = exports.urlBasename = exports.toURL = exports.isFileURL = exports.isSupportedURL = exports.isUrlLike = exports.isZipped = void 0;
    var url_1 = require("url");
    var isZippedRegExp = /\.gz($|[?#])/i;
    var isURLRegExp2 = /^(\w{2,64}:\/\/|data:)/i;
    var supportedProtocols = { "file:": true, "http:": true, "https:": true };
    function isZipped2(filename) {
      const path16 = typeof filename === "string" ? filename : filename.pathname;
      return isZippedRegExp.test(path16);
    }
    exports.isZipped = isZipped2;
    function isUrlLike2(filename) {
      return filename instanceof URL || isURLRegExp2.test(filename);
    }
    exports.isUrlLike = isUrlLike2;
    function isSupportedURL2(url) {
      return !!supportedProtocols[url.protocol];
    }
    exports.isSupportedURL = isSupportedURL2;
    function isFileURL2(url) {
      return url.protocol === "file:";
    }
    exports.isFileURL = isFileURL2;
    function toURL2(filename) {
      return filename instanceof URL || typeof filename !== "string" ? filename : isUrlLike2(filename) ? new URL(filename) : (0, url_1.pathToFileURL)(filename);
    }
    exports.toURL = toURL2;
    var regMatchFilename2 = /filename=([^;,]*)/;
    function urlBasename2(url) {
      function guessDataUrlName(header) {
        const filenameMatch = header.match(regMatchFilename2);
        if (filenameMatch)
          return filenameMatch[1];
        const mime = header.split(";", 1)[0];
        return mime.replace(/\W/g, ".");
      }
      if (typeof url === "string" && url.startsWith("data:")) {
        return guessDataUrlName(url.split(",", 1)[0].split(":", 2)[1]);
      }
      url = toURL2(url);
      if (url.protocol === "data:") {
        return guessDataUrlName(url.pathname.split(",", 1)[0]);
      }
      return basename3(url.pathname);
    }
    exports.urlBasename = urlBasename2;
    function urlDirname2(url) {
      if (typeof url === "string" && url.startsWith("data:")) {
        return toURL2("data:");
      }
      url = toURL2(url);
      if (url.protocol === "data:") {
        return toURL2("data:");
      }
      return new URL(url.pathname.endsWith("/") ? ".." : ".", url);
    }
    exports.urlDirname = urlDirname2;
    function basename3(path16) {
      path16 = path16.endsWith("/") ? path16.slice(0, path16.length - 1) : path16;
      const idx = path16.lastIndexOf("/");
      return idx >= 0 ? path16.slice(idx + 1) || "" : path16;
    }
    exports.basename = basename3;
  }
});

// node_modules/cspell-io/dist/cjs/node/dataUrl.js
var require_dataUrl = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/dataUrl.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.guessMimeType = exports.encodeDataUrlFromFile = exports.decodeDataUrl = exports.toDataUrl = exports.encodeDataUrl = void 0;
    var fs_1 = require("fs");
    var fsPath = __importStar(require("path"));
    var util_js_1 = require_util3();
    function encodeDataUrl2(data, mediaType, attributes) {
      if (typeof data === "string")
        return encodeString2(data, mediaType, attributes);
      const attribs = encodeAttributes(attributes || []);
      return `data:${mediaType}${attribs};base64,${data.toString("base64url")}`;
    }
    exports.encodeDataUrl = encodeDataUrl2;
    function toDataUrl2(data, mediaType, attributes) {
      return new URL(encodeDataUrl2(data, mediaType, attributes));
    }
    exports.toDataUrl = toDataUrl2;
    function encodeString2(data, mediaType, attributes) {
      mediaType = mediaType || "text/plain";
      attributes = attributes || [];
      const asUrlComp = encodeURIComponent(data);
      const asBase64 = Buffer.from(data).toString("base64url");
      const useBase64 = asBase64.length < asUrlComp.length - 7;
      const encoded = useBase64 ? asBase64 : asUrlComp;
      const attribMap = new Map([["charset", "utf8"]].concat([...attributes]));
      attribMap.set("charset", "utf8");
      const attribs = encodeAttributes(attribMap);
      return `data:${mediaType}${attribs}${useBase64 ? ";base64" : ""},${encoded}`;
    }
    function encodeAttributes(attributes) {
      return [...attributes].map(([key, value]) => `;${key}=${encodeURIComponent(value)}`).join("");
    }
    var dataUrlRegExHead2 = /^data:(?<mediaType>[^;,]*)(?<attributes>(?:;[^=]+=[^;,]*)*)(?<base64>;base64)?$/;
    function decodeDataUrl2(url) {
      url = url.toString();
      const [head, encodedData] = url.split(",", 2);
      if (!head || encodedData === void 0)
        throw Error("Not a data url");
      const match = head.match(dataUrlRegExHead2);
      if (!match || !match.groups)
        throw Error("Not a data url");
      const mediaType = match.groups["mediaType"] || "";
      const rawAttributes = (match.groups["attributes"] || "").split(";").filter((a) => !!a).map((entry) => entry.split("=", 2)).map(([key, value]) => [key, decodeURIComponent(value)]);
      const attributes = new Map(rawAttributes);
      const encoding = attributes.get("charset");
      const isBase64 = !!match.groups["base64"];
      const data = isBase64 ? Buffer.from(encodedData, "base64url") : Buffer.from(decodeURIComponent(encodedData));
      return { mediaType, data, encoding, attributes };
    }
    exports.decodeDataUrl = decodeDataUrl2;
    async function encodeDataUrlFromFile(path16, mediaType, attributes) {
      const url = (0, util_js_1.toURL)(path16);
      const filename = fsPath.basename(url.pathname);
      const guess = guessMimeType(filename);
      mediaType = mediaType || guess?.mimeType || "text/plain";
      const _attributes = new Map(attributes || []);
      filename && _attributes.set("filename", filename);
      const content = guess?.encoding ? await fs_1.promises.readFile(url, guess?.encoding) : await fs_1.promises.readFile(url);
      return encodeDataUrl2(content, mediaType, _attributes);
    }
    exports.encodeDataUrlFromFile = encodeDataUrlFromFile;
    function guessMimeType(filename) {
      if (filename.endsWith(".trie"))
        return { mimeType: "application/vnd.cspell.dictionary+trie", encoding: "utf-8" };
      if (filename.endsWith(".trie.gz"))
        return { mimeType: "application/vnd.cspell.dictionary+trie.gz" };
      if (filename.endsWith(".txt"))
        return { mimeType: "text/plain", encoding: "utf-8" };
      if (filename.endsWith(".gz"))
        return { mimeType: "application/gzip" };
      if (filename.endsWith(".json"))
        return { mimeType: "application/json", encoding: "utf-8" };
      if (filename.endsWith(".yaml") || filename.endsWith(".yml"))
        return { mimeType: "application/x-yaml", encoding: "utf-8" };
      return void 0;
    }
    exports.guessMimeType = guessMimeType;
  }
});

// node_modules/cspell-io/dist/cjs/node/file/FetchError.js
var require_FetchError = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/file/FetchError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchUrlError = void 0;
    var FetchUrlError2 = class _FetchUrlError extends Error {
      constructor(message, code, status, url) {
        super(message);
        this.code = code;
        this.status = status;
        this.url = url;
        this.name = "FetchUrlError";
      }
      static create(url, status, message) {
        if (status === 404)
          return new _FetchUrlError(message || "URL not found.", "ENOENT", status, url);
        if (status >= 400 && status < 500)
          return new _FetchUrlError(message || "Permission denied.", "EACCES", status, url);
        return new _FetchUrlError(message || "Fatal Error", "ECONNREFUSED", status, url);
      }
    };
    exports.FetchUrlError = FetchUrlError2;
  }
});

// node_modules/cspell-io/dist/cjs/node/file/fetch.js
var require_fetch = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/file/fetch.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fetchURL = exports.fetchHead = exports.fetch = void 0;
    var node_fetch_1 = __importDefault(require_lib3());
    var FetchError_js_1 = require_FetchError();
    exports.fetch = node_fetch_1.default;
    async function fetchHead2(request) {
      const r = await (0, exports.fetch)(request, { method: "HEAD" });
      return r.headers;
    }
    exports.fetchHead = fetchHead2;
    async function fetchURL2(url) {
      const response = await (0, exports.fetch)(url);
      if (!response.ok) {
        throw FetchError_js_1.FetchUrlError.create(url, response.status);
      }
      return Buffer.from(await response.arrayBuffer());
    }
    exports.fetchURL = fetchURL2;
  }
});

// node_modules/cspell-io/dist/cjs/node/file/stat.js
var require_stat2 = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/file/stat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStatHttp = exports.getStatSync = exports.getStat = void 0;
    var fs_1 = require("fs");
    var util_1 = require("util");
    var fetch_js_1 = require_fetch();
    var util_js_1 = require_util3();
    async function getStat3(filenameOrUri) {
      if ((0, util_js_1.isUrlLike)(filenameOrUri)) {
        const url = (0, util_js_1.toURL)(filenameOrUri);
        if (!(0, util_js_1.isFileURL)(url)) {
          try {
            return await getStatHttp2(url);
          } catch (e) {
            return toError4(e);
          }
        }
      }
      return fs_1.promises.stat(filenameOrUri).catch((e) => toError4(e));
    }
    exports.getStat = getStat3;
    function getStatSync3(uri) {
      try {
        return (0, fs_1.statSync)(uri);
      } catch (e) {
        return toError4(e);
      }
    }
    exports.getStatSync = getStatSync3;
    async function getStatHttp2(url) {
      const headers = await (0, fetch_js_1.fetchHead)(url);
      const eTag = headers.get("etag") || void 0;
      const guessSize = Number.parseInt(headers.get("content-length") || "0", 10);
      return {
        size: eTag ? -1 : guessSize,
        mtimeMs: 0,
        eTag
      };
    }
    exports.getStatHttp = getStatHttp2;
    function toError4(e) {
      if (isErrnoException(e) || e instanceof Error)
        return e;
      return new Error((0, util_1.format)(e));
    }
    function isErrnoException(e) {
      if (!e || typeof e !== "object")
        return false;
      const err = e;
      return err.message !== void 0 && err.name !== void 0;
    }
  }
});

// node_modules/cspell-io/dist/cjs/requests/RequestFsReadBinaryFile.js
var require_RequestFsReadBinaryFile = __commonJS({
  "node_modules/cspell-io/dist/cjs/requests/RequestFsReadBinaryFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestFsReadBinaryFileSync = exports.RequestFsReadBinaryFile = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var RequestType6 = "fs:readBinaryFile";
    exports.RequestFsReadBinaryFile = (0, cspell_service_bus_1.requestFactory)(RequestType6);
    var RequestTypeSync2 = "fs:readBinaryFileSync";
    exports.RequestFsReadBinaryFileSync = (0, cspell_service_bus_1.requestFactory)(RequestTypeSync2);
  }
});

// node_modules/cspell-io/dist/cjs/requests/RequestFsReadFile.js
var require_RequestFsReadFile = __commonJS({
  "node_modules/cspell-io/dist/cjs/requests/RequestFsReadFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestFsReadFile = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var RequestType6 = "fs:readFile";
    exports.RequestFsReadFile = (0, cspell_service_bus_1.requestFactory)(RequestType6);
  }
});

// node_modules/cspell-io/dist/cjs/requests/RequestFsReadFileSync.js
var require_RequestFsReadFileSync = __commonJS({
  "node_modules/cspell-io/dist/cjs/requests/RequestFsReadFileSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestFsReadFileSync = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var RequestType6 = "fs:readFileSync";
    exports.RequestFsReadFileSync = (0, cspell_service_bus_1.requestFactory)(RequestType6);
  }
});

// node_modules/cspell-io/dist/cjs/requests/RequestFsStat.js
var require_RequestFsStat = __commonJS({
  "node_modules/cspell-io/dist/cjs/requests/RequestFsStat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestFsStatSync = exports.RequestFsStat = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var RequestTypeStat2 = "fs:stat";
    exports.RequestFsStat = (0, cspell_service_bus_1.requestFactory)(RequestTypeStat2);
    var RequestTypeStatSync2 = "fs:statSync";
    exports.RequestFsStatSync = (0, cspell_service_bus_1.requestFactory)(RequestTypeStatSync2);
  }
});

// node_modules/cspell-io/dist/cjs/requests/RequestFsWriteFile.js
var require_RequestFsWriteFile = __commonJS({
  "node_modules/cspell-io/dist/cjs/requests/RequestFsWriteFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestFsWriteFile = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var RequestType6 = "fs:writeFile";
    exports.RequestFsWriteFile = (0, cspell_service_bus_1.requestFactory)(RequestType6);
  }
});

// node_modules/cspell-io/dist/cjs/requests/RequestZlibInflate.js
var require_RequestZlibInflate = __commonJS({
  "node_modules/cspell-io/dist/cjs/requests/RequestZlibInflate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestZlibInflate = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var RequestType6 = "zlib:inflate";
    exports.RequestZlibInflate = (0, cspell_service_bus_1.requestFactory)(RequestType6);
  }
});

// node_modules/cspell-io/dist/cjs/requests/index.js
var require_requests = __commonJS({
  "node_modules/cspell-io/dist/cjs/requests/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestZlibInflate = exports.RequestFsWriteFile = exports.RequestFsStatSync = exports.RequestFsStat = exports.RequestFsReadFileSync = exports.RequestFsReadFile = exports.RequestFsReadBinaryFileSync = exports.RequestFsReadBinaryFile = void 0;
    var RequestFsReadBinaryFile_js_1 = require_RequestFsReadBinaryFile();
    Object.defineProperty(exports, "RequestFsReadBinaryFile", { enumerable: true, get: function() {
      return RequestFsReadBinaryFile_js_1.RequestFsReadBinaryFile;
    } });
    Object.defineProperty(exports, "RequestFsReadBinaryFileSync", { enumerable: true, get: function() {
      return RequestFsReadBinaryFile_js_1.RequestFsReadBinaryFileSync;
    } });
    var RequestFsReadFile_js_1 = require_RequestFsReadFile();
    Object.defineProperty(exports, "RequestFsReadFile", { enumerable: true, get: function() {
      return RequestFsReadFile_js_1.RequestFsReadFile;
    } });
    var RequestFsReadFileSync_js_1 = require_RequestFsReadFileSync();
    Object.defineProperty(exports, "RequestFsReadFileSync", { enumerable: true, get: function() {
      return RequestFsReadFileSync_js_1.RequestFsReadFileSync;
    } });
    var RequestFsStat_js_1 = require_RequestFsStat();
    Object.defineProperty(exports, "RequestFsStat", { enumerable: true, get: function() {
      return RequestFsStat_js_1.RequestFsStat;
    } });
    Object.defineProperty(exports, "RequestFsStatSync", { enumerable: true, get: function() {
      return RequestFsStat_js_1.RequestFsStatSync;
    } });
    var RequestFsWriteFile_js_1 = require_RequestFsWriteFile();
    Object.defineProperty(exports, "RequestFsWriteFile", { enumerable: true, get: function() {
      return RequestFsWriteFile_js_1.RequestFsWriteFile;
    } });
    var RequestZlibInflate_js_1 = require_RequestZlibInflate();
    Object.defineProperty(exports, "RequestZlibInflate", { enumerable: true, get: function() {
      return RequestZlibInflate_js_1.RequestZlibInflate;
    } });
  }
});

// node_modules/cspell-io/dist/cjs/handlers/node/file.js
var require_file = __commonJS({
  "node_modules/cspell-io/dist/cjs/handlers/node/file.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.registerHandlers = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var assert_1 = __importDefault(require("assert"));
    var fs_1 = require("fs");
    var url_1 = require("url");
    var zlib_1 = require("zlib");
    var encode_decode_js_1 = require_encode_decode();
    var index_js_1 = require_errors2();
    var dataUrl_js_1 = require_dataUrl();
    var fetch_js_1 = require_fetch();
    var stat_js_1 = require_stat2();
    var index_js_2 = require_requests();
    var isGzFileRegExp2 = /\.gz($|[?#])/;
    function isGzFile2(url) {
      return isGzFileRegExp2.test(url.pathname);
    }
    var handleRequestFsReadBinaryFile2 = index_js_2.RequestFsReadBinaryFile.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.readFile((0, url_1.fileURLToPath)(params.url)).then((content) => ({ url: params.url, content }))), void 0, "Node: Read Binary File.");
    var handleRequestFsReadBinaryFileSync2 = index_js_2.RequestFsReadBinaryFileSync.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)({ url: params.url, content: (0, fs_1.readFileSync)((0, url_1.fileURLToPath)(params.url)) }), void 0, "Node: Sync Read Binary File.");
    var handleRequestFsReadFile2 = index_js_2.RequestFsReadFile.createRequestHandler((req, _, dispatcher) => {
      const { url, encoding } = req.params;
      const res = dispatcher.dispatch(index_js_2.RequestFsReadBinaryFile.create({ url }));
      if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
        (0, assert_1.default)((0, cspell_service_bus_1.isServiceResponseFailure)(res));
        return (0, cspell_service_bus_1.createResponseFail)(req, res.error);
      }
      return (0, cspell_service_bus_1.createResponse)(res.value.then((res2) => ({
        url,
        content: bufferToText2(res2.content, encoding),
        baseFilename: res2.baseFilename
      })));
    }, void 0, "Node: Read Text File.");
    var handleRequestFsReadFileSync2 = index_js_2.RequestFsReadFileSync.createRequestHandler((req, _, dispatcher) => {
      const { url, encoding } = req.params;
      const res = dispatcher.dispatch(index_js_2.RequestFsReadBinaryFileSync.create({ url }));
      if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
        (0, assert_1.default)((0, cspell_service_bus_1.isServiceResponseFailure)(res));
        return (0, cspell_service_bus_1.createResponseFail)(req, res.error);
      }
      return (0, cspell_service_bus_1.createResponse)({
        ...res.value,
        content: bufferToText2(res.value.content, encoding)
      });
    }, void 0, "Node: Sync Read Text File.");
    var handleRequestZlibInflate2 = index_js_2.RequestZlibInflate.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)((0, zlib_1.gunzipSync)(params.data).toString("utf-8")), void 0, "Node: gz deflate.");
    var supportedFetchProtocols2 = { "http:": true, "https:": true };
    var handleRequestFsReadBinaryFileHttp2 = index_js_2.RequestFsReadBinaryFile.createRequestHandler((req, next) => {
      const { url } = req.params;
      if (!(url.protocol in supportedFetchProtocols2))
        return next(req);
      return (0, cspell_service_bus_1.createResponse)((0, fetch_js_1.fetchURL)(url).then((content) => ({ url, content })));
    }, void 0, "Node: Read Http(s) file.");
    var handleRequestFsReadBinaryFileSyncData2 = index_js_2.RequestFsReadBinaryFileSync.createRequestHandler((req, next) => {
      const { url } = req.params;
      if (url.protocol !== "data:")
        return next(req);
      const data = (0, dataUrl_js_1.decodeDataUrl)(url);
      return (0, cspell_service_bus_1.createResponse)({ url, content: data.data, baseFilename: data.attributes.get("filename") });
    }, void 0, "Node: Read data: urls.");
    var handleRequestFsReadBinaryFileData2 = index_js_2.RequestFsReadBinaryFile.createRequestHandler((req, next, dispatcher) => {
      const { url } = req.params;
      if (url.protocol !== "data:")
        return next(req);
      const res = dispatcher.dispatch(index_js_2.RequestFsReadBinaryFileSync.create(req.params));
      if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res))
        return res;
      return (0, cspell_service_bus_1.createResponse)(Promise.resolve(res.value));
    }, void 0, "Node: Read data: urls.");
    function bufferToText2(buf, encoding) {
      return buf[0] === 31 && buf[1] === 139 ? (0, encode_decode_js_1.decode)((0, zlib_1.gunzipSync)(buf), encoding) : (0, encode_decode_js_1.decode)(buf, encoding);
    }
    var handleRequestFsStat2 = index_js_2.RequestFsStat.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.stat((0, url_1.fileURLToPath)(params.url))), void 0, "Node: fs.stat.");
    var handleRequestFsStatSync2 = index_js_2.RequestFsStatSync.createRequestHandler((req) => {
      const { params } = req;
      try {
        return (0, cspell_service_bus_1.createResponse)((0, fs_1.statSync)((0, url_1.fileURLToPath)(params.url)));
      } catch (e) {
        return (0, cspell_service_bus_1.createResponseFail)(req, (0, index_js_1.toError)(e));
      }
    }, void 0, "Node: fs.stat.");
    var handleRequestFsStatHttp2 = index_js_2.RequestFsStat.createRequestHandler((req, next) => {
      const { url } = req.params;
      if (!(url.protocol in supportedFetchProtocols2))
        return next(req);
      return (0, cspell_service_bus_1.createResponse)((0, stat_js_1.getStatHttp)(url));
    }, void 0, "Node: http get stat");
    var handleRequestFsWriteFile2 = index_js_2.RequestFsWriteFile.createRequestHandler(({ params }) => (0, cspell_service_bus_1.createResponse)(fs_1.promises.writeFile(params.url, params.content)), void 0, "Node: fs.writeFile");
    var handleRequestFsWriteFileGz2 = index_js_2.RequestFsWriteFile.createRequestHandler((req, next) => {
      const { url, content } = req.params;
      if (!isGzFile2(url))
        return next(req);
      return (0, cspell_service_bus_1.createResponse)(fs_1.promises.writeFile(url, (0, zlib_1.gzipSync)(content)));
    }, void 0, "Node: http get stat");
    function registerHandlers2(serviceBus) {
      const handlers = [
        handleRequestFsWriteFile2,
        handleRequestFsWriteFileGz2,
        handleRequestFsReadBinaryFile2,
        handleRequestFsReadBinaryFileSync2,
        handleRequestFsReadBinaryFileHttp2,
        handleRequestFsReadBinaryFileData2,
        handleRequestFsReadBinaryFileSyncData2,
        handleRequestFsReadFile2,
        handleRequestFsReadFileSync2,
        handleRequestZlibInflate2,
        handleRequestFsStatSync2,
        handleRequestFsStat2,
        handleRequestFsStatHttp2
      ];
      handlers.forEach((handler) => serviceBus.addHandler(handler));
    }
    exports.registerHandlers = registerHandlers2;
  }
});

// node_modules/cspell-io/dist/cjs/CSpellIONode.js
var require_CSpellIONode = __commonJS({
  "node_modules/cspell-io/dist/cjs/CSpellIONode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultCSpellIO = exports.CSpellIONode = void 0;
    var cspell_service_bus_1 = require_cjs2();
    var stat_js_1 = require_stat();
    var ErrorNotImplemented_js_1 = require_ErrorNotImplemented();
    var file_js_1 = require_file();
    var util_js_1 = require_util3();
    var index_js_1 = require_requests();
    var defaultCSpellIONode2 = void 0;
    var CSpellIONode2 = class {
      constructor(serviceBus = new cspell_service_bus_1.ServiceBus()) {
        this.serviceBus = serviceBus;
        (0, file_js_1.registerHandlers)(serviceBus);
      }
      readFile(uriOrFilename, encoding = "utf8") {
        const url = (0, util_js_1.toURL)(uriOrFilename);
        const res = this.serviceBus.dispatch(index_js_1.RequestFsReadFile.create({ url, encoding }));
        if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
          throw genError2(res.error, "readFile");
        }
        return res.value;
      }
      readFileSync(uriOrFilename, encoding = "utf8") {
        const url = (0, util_js_1.toURL)(uriOrFilename);
        const res = this.serviceBus.dispatch(index_js_1.RequestFsReadFileSync.create({ url, encoding }));
        if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
          throw genError2(res.error, "readFileSync");
        }
        return res.value;
      }
      writeFile(uriOrFilename, content) {
        const url = (0, util_js_1.toURL)(uriOrFilename);
        const res = this.serviceBus.dispatch(index_js_1.RequestFsWriteFile.create({ url, content }));
        if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
          throw genError2(res.error, "writeFile");
        }
        return res.value;
      }
      getStat(uriOrFilename) {
        const url = (0, util_js_1.toURL)(uriOrFilename);
        const res = this.serviceBus.dispatch(index_js_1.RequestFsStat.create({ url }));
        if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
          throw genError2(res.error, "getStat");
        }
        return res.value;
      }
      getStatSync(uriOrFilename) {
        const url = (0, util_js_1.toURL)(uriOrFilename);
        const res = this.serviceBus.dispatch(index_js_1.RequestFsStatSync.create({ url }));
        if (!(0, cspell_service_bus_1.isServiceResponseSuccess)(res)) {
          throw genError2(res.error, "getStatSync");
        }
        return res.value;
      }
      compareStats(left, right) {
        return (0, stat_js_1.compareStats)(left, right);
      }
      toURL(uriOrFilename) {
        return (0, util_js_1.toURL)(uriOrFilename);
      }
      uriBasename(uriOrFilename) {
        return (0, util_js_1.urlBasename)(uriOrFilename);
      }
      uriDirname(uriOrFilename) {
        return (0, util_js_1.urlDirname)(uriOrFilename);
      }
    };
    exports.CSpellIONode = CSpellIONode2;
    function genError2(err, alt) {
      return err || new ErrorNotImplemented_js_1.ErrorNotImplemented(alt);
    }
    function getDefaultCSpellIO2() {
      if (defaultCSpellIONode2)
        return defaultCSpellIONode2;
      const cspellIO = new CSpellIONode2();
      defaultCSpellIONode2 = cspellIO;
      return cspellIO;
    }
    exports.getDefaultCSpellIO = getDefaultCSpellIO2;
  }
});

// node_modules/cspell-io/dist/cjs/common/transformers.js
var require_transformers = __commonJS({
  "node_modules/cspell-io/dist/cjs/common/transformers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encoderTransformer = exports.createDecoderTransformer = void 0;
    var encode_decode_js_1 = require_encode_decode();
    function createDecoderTransformer2(encoding) {
      function standardDecoder(buf) {
        return (0, encode_decode_js_1.decode)(buf, encoding);
      }
      let decoder = void 0;
      if (encoding && !encoding.startsWith("utf"))
        return decoderNonUtf;
      return decoderUtf;
      async function* decoderNonUtf(iterable) {
        for await (const buf of iterable) {
          yield typeof buf === "string" ? buf : (0, encode_decode_js_1.decode)(buf, encoding);
        }
      }
      async function* decoderUtf(iterable) {
        for await (const sb of iterable) {
          if (typeof sb === "string") {
            yield sb;
            continue;
          }
          if (sb.length < 2) {
            yield standardDecoder(sb);
            continue;
          }
          if (decoder) {
            yield decoder(sb);
            continue;
          }
          decoder = standardDecoder;
          const _encoding = (0, encode_decode_js_1.calcEncodingFromBom)(sb);
          if (_encoding === "utf16le") {
            decoder = encode_decode_js_1.decodeUtf16LE;
            yield decoder(sb.subarray(2));
            continue;
          }
          if (_encoding === "utf16be") {
            decoder = encode_decode_js_1.decodeUtf16BE;
            yield decoder(sb.subarray(2));
            continue;
          }
          yield decoder(sb);
        }
      }
    }
    exports.createDecoderTransformer = createDecoderTransformer2;
    function encoderTransformer2(iterable, encoding) {
      return isAsyncIterable3(iterable) ? encoderAsyncIterable(iterable, encoding) : encoderIterable(iterable, encoding);
    }
    exports.encoderTransformer = encoderTransformer2;
    function* encoderIterable(iterable, encoding) {
      let useBom = true;
      for (const chunk of iterable) {
        yield (0, encode_decode_js_1.encodeString)(chunk, encoding, useBom);
        useBom = false;
      }
    }
    async function* encoderAsyncIterable(iterable, encoding) {
      let useBom = true;
      for await (const chunk of iterable) {
        yield (0, encode_decode_js_1.encodeString)(chunk, encoding, useBom);
        useBom = false;
      }
    }
    function isAsyncIterable3(v) {
      return v && typeof v === "object" && !!v[Symbol.asyncIterator];
    }
  }
});

// node_modules/cspell-io/dist/cjs/node/file/fileReader.js
var require_fileReader = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/file/fileReader.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readFileSync = exports.readFile = void 0;
    var fs6 = __importStar(require("fs"));
    var Stream3 = __importStar(require("stream"));
    var url_1 = require("url");
    var util_1 = require("util");
    var zlib = __importStar(require("zlib"));
    var encode_decode_js_1 = require_encode_decode();
    var transformers_js_1 = require_transformers();
    var fetch_js_1 = require_fetch();
    var FetchError_js_1 = require_FetchError();
    var util_js_1 = require_util3();
    var defaultEncoding = "utf8";
    var pipeline5 = (0, util_1.promisify)(Stream3.pipeline);
    async function readFile4(filename, encoding) {
      const url = (0, util_js_1.toURL)(filename);
      if (!(0, util_js_1.isSupportedURL)(url)) {
        throw new Error("Unsupported network protocol");
      }
      return (0, util_js_1.isFileURL)(url) ? _readFile(url, encoding) : _fetchURL(url, encoding);
    }
    exports.readFile = readFile4;
    function _readFile(url, encoding) {
      const filename = (0, url_1.fileURLToPath)(url);
      return _read(() => fs6.createReadStream(filename), (0, util_js_1.isZipped)(filename), encoding);
    }
    async function _fetchURL(url, encoding) {
      const response = await (0, fetch_js_1.fetch)(url);
      if (!response.ok) {
        throw FetchError_js_1.FetchUrlError.create(url, response.status);
      }
      return _read(() => response.body, (0, util_js_1.isZipped)(url), encoding);
    }
    async function _read(getStream, isZipped2, encoding) {
      const stream = getStream();
      const decoder = (0, transformers_js_1.createDecoderTransformer)(encoding);
      const collector = createCollector(encoding || defaultEncoding);
      return isZipped2 ? pipeline5(stream, zlib.createGunzip(), decoder, collector) : pipeline5(stream, decoder, collector);
    }
    function readFileSync5(filename, encoding) {
      const rawData = fs6.readFileSync(filename);
      const data = (0, util_js_1.isZipped)(filename) ? zlib.gunzipSync(rawData) : rawData;
      return !encoding || encoding.startsWith("utf") ? (0, encode_decode_js_1.decode)(data) : data.toString(encoding);
    }
    exports.readFileSync = readFileSync5;
    function createCollector(encoding) {
      async function collect(iterable) {
        const buf = [];
        for await (const sb of iterable) {
          buf.push(typeof sb === "string" ? sb : sb.toString(encoding));
        }
        return buf.join("");
      }
      return collect;
    }
  }
});

// node_modules/cspell-io/dist/cjs/node/file/fileWriter.js
var require_fileWriter = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/file/fileWriter.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeToFileIterable = exports.writeToFile = void 0;
    var fs6 = __importStar(require("fs"));
    var Stream3 = __importStar(require("stream"));
    var util_1 = require("util");
    var zlib = __importStar(require("zlib"));
    var transformers_js_1 = require_transformers();
    var pipeline5 = (0, util_1.promisify)(Stream3.pipeline);
    function writeToFile2(filename, data, encoding) {
      return writeToFileIterable2(filename, typeof data === "string" ? [data] : data, encoding);
    }
    exports.writeToFile = writeToFile2;
    function writeToFileIterable2(filename, data, encoding) {
      const stream = Stream3.Readable.from((0, transformers_js_1.encoderTransformer)(data, encoding));
      const zip = filename.match(/\.gz$/) ? zlib.createGzip() : new Stream3.PassThrough();
      return pipeline5(stream, zip, fs6.createWriteStream(filename));
    }
    exports.writeToFileIterable = writeToFileIterable2;
  }
});

// node_modules/cspell-io/dist/cjs/node/file/index.js
var require_file2 = __commonJS({
  "node_modules/cspell-io/dist/cjs/node/file/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStatSync = exports.getStat = exports.writeToFileIterable = exports.writeToFile = exports.readFileSync = exports.readFile = void 0;
    var fileReader_js_1 = require_fileReader();
    Object.defineProperty(exports, "readFile", { enumerable: true, get: function() {
      return fileReader_js_1.readFile;
    } });
    Object.defineProperty(exports, "readFileSync", { enumerable: true, get: function() {
      return fileReader_js_1.readFileSync;
    } });
    var fileWriter_js_1 = require_fileWriter();
    Object.defineProperty(exports, "writeToFile", { enumerable: true, get: function() {
      return fileWriter_js_1.writeToFile;
    } });
    Object.defineProperty(exports, "writeToFileIterable", { enumerable: true, get: function() {
      return fileWriter_js_1.writeToFileIterable;
    } });
    var stat_js_1 = require_stat2();
    Object.defineProperty(exports, "getStat", { enumerable: true, get: function() {
      return stat_js_1.getStat;
    } });
    Object.defineProperty(exports, "getStatSync", { enumerable: true, get: function() {
      return stat_js_1.getStatSync;
    } });
  }
});

// node_modules/cspell-io/dist/cjs/file/file.js
var require_file3 = __commonJS({
  "node_modules/cspell-io/dist/cjs/file/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStatSync = exports.getStat = exports.readFileSync = exports.readFile = void 0;
    var CSpellIONode_js_1 = require_CSpellIONode();
    var index_js_1 = require_errors2();
    var readFile4 = function(filename, encoding) {
      return (0, CSpellIONode_js_1.getDefaultCSpellIO)().readFile(filename, encoding).then((fr) => fr.content);
    };
    exports.readFile = readFile4;
    var readFileSync5 = function(filename, encoding) {
      return (0, CSpellIONode_js_1.getDefaultCSpellIO)().readFileSync(filename, encoding).content;
    };
    exports.readFileSync = readFileSync5;
    var getStat3 = function(filenameOrUri) {
      return (0, CSpellIONode_js_1.getDefaultCSpellIO)().getStat(filenameOrUri).catch(index_js_1.toError);
    };
    exports.getStat = getStat3;
    var getStatSync3 = function(filenameOrUri) {
      try {
        return (0, CSpellIONode_js_1.getDefaultCSpellIO)().getStatSync(filenameOrUri);
      } catch (e) {
        return (0, index_js_1.toError)(e);
      }
    };
    exports.getStatSync = getStatSync3;
  }
});

// node_modules/cspell-io/dist/cjs/file/index.js
var require_file4 = __commonJS({
  "node_modules/cspell-io/dist/cjs/file/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readFileSync = exports.readFile = exports.getStatSync = exports.getStat = exports.writeToFileIterableP = exports.writeToFileIterable = exports.writeToFile = void 0;
    var index_js_1 = require_file2();
    Object.defineProperty(exports, "writeToFile", { enumerable: true, get: function() {
      return index_js_1.writeToFile;
    } });
    Object.defineProperty(exports, "writeToFileIterable", { enumerable: true, get: function() {
      return index_js_1.writeToFileIterable;
    } });
    Object.defineProperty(exports, "writeToFileIterableP", { enumerable: true, get: function() {
      return index_js_1.writeToFileIterable;
    } });
    var file_js_1 = require_file3();
    Object.defineProperty(exports, "getStat", { enumerable: true, get: function() {
      return file_js_1.getStat;
    } });
    Object.defineProperty(exports, "getStatSync", { enumerable: true, get: function() {
      return file_js_1.getStatSync;
    } });
    Object.defineProperty(exports, "readFile", { enumerable: true, get: function() {
      return file_js_1.readFile;
    } });
    Object.defineProperty(exports, "readFileSync", { enumerable: true, get: function() {
      return file_js_1.readFileSync;
    } });
  }
});

// node_modules/cspell-io/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/cspell-io/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toDataUrl = exports.encodeDataUrl = exports.writeToFileIterableP = exports.writeToFileIterable = exports.writeToFile = exports.readFileSync = exports.readFile = exports.getStatSync = exports.getStat = exports.getDefaultCSpellIO = exports.CSpellIONode = exports.asyncIterableToArray = void 0;
    var asyncIterable_js_1 = require_asyncIterable();
    Object.defineProperty(exports, "asyncIterableToArray", { enumerable: true, get: function() {
      return asyncIterable_js_1.toArray;
    } });
    var CSpellIONode_js_1 = require_CSpellIONode();
    Object.defineProperty(exports, "CSpellIONode", { enumerable: true, get: function() {
      return CSpellIONode_js_1.CSpellIONode;
    } });
    Object.defineProperty(exports, "getDefaultCSpellIO", { enumerable: true, get: function() {
      return CSpellIONode_js_1.getDefaultCSpellIO;
    } });
    var index_js_1 = require_file4();
    Object.defineProperty(exports, "getStat", { enumerable: true, get: function() {
      return index_js_1.getStat;
    } });
    Object.defineProperty(exports, "getStatSync", { enumerable: true, get: function() {
      return index_js_1.getStatSync;
    } });
    Object.defineProperty(exports, "readFile", { enumerable: true, get: function() {
      return index_js_1.readFile;
    } });
    Object.defineProperty(exports, "readFileSync", { enumerable: true, get: function() {
      return index_js_1.readFileSync;
    } });
    Object.defineProperty(exports, "writeToFile", { enumerable: true, get: function() {
      return index_js_1.writeToFile;
    } });
    Object.defineProperty(exports, "writeToFileIterable", { enumerable: true, get: function() {
      return index_js_1.writeToFileIterable;
    } });
    Object.defineProperty(exports, "writeToFileIterableP", { enumerable: true, get: function() {
      return index_js_1.writeToFileIterableP;
    } });
    var dataUrl_js_1 = require_dataUrl();
    Object.defineProperty(exports, "encodeDataUrl", { enumerable: true, get: function() {
      return dataUrl_js_1.encodeDataUrl;
    } });
    Object.defineProperty(exports, "toDataUrl", { enumerable: true, get: function() {
      return dataUrl_js_1.toDataUrl;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/Models/CSpellSettingsInternalDef.js
var require_CSpellSettingsInternalDef = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Models/CSpellSettingsInternalDef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDictionaryDefinitionInlineInternal = exports.isCSpellSettingsInternal = exports.createCSpellSettingsInternal = exports.cleanCSpellSettingsInternal = exports.SymbolCSpellSettingsInternal = void 0;
    var util_js_1 = require_util();
    exports.SymbolCSpellSettingsInternal = Symbol("CSpellSettingsInternal");
    function cleanCSpellSettingsInternal(parts = {}) {
      const csi = (0, util_js_1.clean)(parts);
      Object.assign(csi, { [exports.SymbolCSpellSettingsInternal]: true });
      return csi;
    }
    exports.cleanCSpellSettingsInternal = cleanCSpellSettingsInternal;
    function createCSpellSettingsInternal(parts = {}) {
      return (0, util_js_1.clean)({
        ...parts,
        [exports.SymbolCSpellSettingsInternal]: true
      });
    }
    exports.createCSpellSettingsInternal = createCSpellSettingsInternal;
    function isCSpellSettingsInternal(cs) {
      return !!cs[exports.SymbolCSpellSettingsInternal];
    }
    exports.isCSpellSettingsInternal = isCSpellSettingsInternal;
    function isDictionaryDefinitionInlineInternal(def) {
      if (def.path)
        return false;
      const defInline = def;
      return !!(defInline.words || defInline.flagWords || defInline.ignoreWords || defInline.suggestWords);
    }
    exports.isDictionaryDefinitionInlineInternal = isDictionaryDefinitionInlineInternal;
  }
});

// node_modules/cspell-lib/dist/cjs/util/AutoResolveLRUCache.js
var require_AutoResolveLRUCache = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/AutoResolveLRUCache.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoResolveLastNCalls = exports.assertValidateLL = exports.AutoResolveLRUCache = void 0;
    var assert_1 = __importDefault(require("assert"));
    var util_js_1 = require_util();
    var AutoResolveLRUCache = class {
      constructor(maxSize, isEqual) {
        this.maxSize = maxSize;
        this.isEqual = isEqual;
        this.list = {};
        this.count = 0;
        this._misses = 0;
        this._hits = 0;
        this._added = 0;
        this._removed = 0;
        (0, assert_1.default)(maxSize > 0);
      }
      get(params, fn) {
        const isEqual = this.isEqual;
        for (let n = this.list.n; n; n = n.n) {
          if (isEqual(n.value.p, params)) {
            this.addToHead(n);
            ++this._hits;
            return n.value.r;
          }
        }
        ++this._misses;
        if (!fn)
          return void 0;
        const value = {
          p: params,
          r: fn(params)
        };
        this.addToHead({ value, n: void 0, p: void 0 });
        return value.r;
      }
      get size() {
        return this.count;
      }
      get hits() {
        return this._hits;
      }
      get misses() {
        return this._misses;
      }
      get added() {
        return this._added;
      }
      get removed() {
        return this._removed;
      }
      clear() {
        this._added = 0;
        this._hits = 0;
        this._misses = 0;
        this._removed = 0;
        this.list.n = void 0;
        this.list.p = void 0;
        this.count = 0;
      }
      addToHead(n) {
        if (!this.list.n) {
          this.list.n = n;
          this.list.p = n;
          n.n = void 0;
          n.p = void 0;
          this.count = 1;
          this._added = 1;
          return;
        }
        if (this.list.n === n)
          return;
        if (this.list.p === n) {
          this.list.p = n.p;
        }
        const isNew = !n.n && !n.p;
        n.p && (n.p.n = n.n);
        n.n && (n.n.p = n.p);
        n.p = void 0;
        n.n = this.list.n;
        n.n && (n.n.p = n);
        this.list.n = n;
        const add = isNew && 1 || 0;
        this._added += add;
        this.count += add;
        if (this.count > this.maxSize) {
          const prev = this.list.p?.p;
          (0, assert_1.default)(prev);
          prev.n = void 0;
          this.list.p = prev;
          ++this._removed;
          --this.count;
        }
      }
      stats() {
        return { size: this.count, hits: this.hits, misses: this.misses, added: this.added, removed: this.removed };
      }
      toJSON() {
        return this.stats();
      }
      static assertValid(cache) {
        assertValidateLL(cache.list);
      }
    };
    exports.AutoResolveLRUCache = AutoResolveLRUCache;
    function assertValidateLL(list) {
      if (!list.n && !list.p)
        return;
      (0, assert_1.default)(list.n, "Bad Next");
      (0, assert_1.default)(list.p, "Bad Prev");
      const visited = /* @__PURE__ */ new Set();
      let n = list;
      for (; n.n; n = n.n) {
        (0, assert_1.default)(!visited.has(n.n), "Circular");
        visited.add(n.n);
      }
      (0, assert_1.default)(list.p === n, "Tail matches");
      visited.clear();
      n = list;
      for (; n.p; n = n.p) {
        (0, assert_1.default)(!visited.has(n.p), "Circular");
        visited.add(n.p);
      }
      (0, assert_1.default)(list.n === n, "Head matches");
    }
    exports.assertValidateLL = assertValidateLL;
    var AutoResolveLastNCalls = class extends AutoResolveLRUCache {
      constructor(maxSize) {
        super(maxSize, util_js_1.isArrayEqual);
      }
    };
    exports.AutoResolveLastNCalls = AutoResolveLastNCalls;
  }
});

// node_modules/cspell-lib/dist/cjs/util/logger.js
var require_logger = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLogger = exports.setLogger = exports.log = exports.logWarning = exports.logError = void 0;
    var _logger = console;
    function logError(...args) {
      _logger.error(...args);
    }
    exports.logError = logError;
    function logWarning(...args) {
      _logger.warn(...args);
    }
    exports.logWarning = logWarning;
    function log(...args) {
      _logger.log(...args);
    }
    exports.log = log;
    function setLogger2(logger) {
      const oldLogger = _logger;
      _logger = logger;
      return oldLogger;
    }
    exports.setLogger = setLogger2;
    function getLogger() {
      return _logger;
    }
    exports.getLogger = getLogger;
  }
});

// node_modules/resolve-from/index.js
var require_resolve_from2 = __commonJS({
  "node_modules/resolve-from/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var Module = require("module");
    var fs6 = require("fs");
    var resolveFrom = (fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs6.realpathSync(fromDirectory);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          fromDirectory = path16.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error2;
        }
      }
      const fromFile = path16.join(fromDirectory, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error2) {
          return;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);
    module2.exports.silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, true);
  }
});

// node_modules/ini/ini.js
var require_ini = __commonJS({
  "node_modules/ini/ini.js"(exports) {
    exports.parse = exports.decode = decode2;
    exports.stringify = exports.encode = encode;
    exports.safe = safe;
    exports.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode2(str) {
      var out = {};
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match[2]);
        if (key === "__proto__")
          return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _2, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// node_modules/global-dirs/index.js
var require_global_dirs = __commonJS({
  "node_modules/global-dirs/index.js"(exports) {
    "use strict";
    var path16 = require("path");
    var os = require("os");
    var fs6 = require("fs");
    var ini = require_ini();
    var readRc = (fp) => {
      try {
        return ini.parse(fs6.readFileSync(fp, "utf8")).prefix;
      } catch (err) {
      }
    };
    var defaultNpmPrefix = (() => {
      if (process.env.PREFIX) {
        return process.env.PREFIX;
      }
      if (process.platform === "win32") {
        return path16.dirname(process.execPath);
      }
      return path16.dirname(path16.dirname(process.execPath));
    })();
    var getNpmPrefix = () => {
      if (process.env.PREFIX) {
        return process.env.PREFIX;
      }
      const homePrefix = readRc(path16.join(os.homedir(), ".npmrc"));
      if (homePrefix) {
        return homePrefix;
      }
      const globalConfigPrefix = readRc(path16.resolve(defaultNpmPrefix, "etc", "npmrc"));
      if (globalConfigPrefix) {
        return globalConfigPrefix;
      }
      if (process.platform === "win32" && process.env.APPDATA) {
        const prefix = path16.join(process.env.APPDATA, "npm");
        if (fs6.existsSync(prefix)) {
          return prefix;
        }
      }
      return defaultNpmPrefix;
    };
    var npmPrefix = path16.resolve(getNpmPrefix());
    var getYarnPrefix = () => {
      if (process.env.PREFIX) {
        return process.env.PREFIX;
      }
      if (process.platform === "win32" && process.env.LOCALAPPDATA) {
        const prefix = path16.join(process.env.LOCALAPPDATA, "Yarn");
        if (fs6.existsSync(prefix)) {
          return prefix;
        }
      }
      const configPrefix = path16.join(os.homedir(), ".config/yarn");
      if (fs6.existsSync(configPrefix)) {
        return configPrefix;
      }
      const homePrefix = path16.join(os.homedir(), ".yarn-config");
      if (fs6.existsSync(homePrefix)) {
        return homePrefix;
      }
      return npmPrefix;
    };
    exports.npm = {};
    exports.npm.prefix = npmPrefix;
    exports.npm.packages = path16.join(npmPrefix, process.platform === "win32" ? "node_modules" : "lib/node_modules");
    exports.npm.binaries = process.platform === "win32" ? npmPrefix : path16.join(npmPrefix, "bin");
    var yarnPrefix = path16.resolve(getYarnPrefix());
    exports.yarn = {};
    exports.yarn.prefix = yarnPrefix;
    exports.yarn.packages = path16.join(yarnPrefix, process.platform === "win32" ? "config/global/node_modules" : "global/node_modules");
    exports.yarn.binaries = path16.join(exports.yarn.packages, ".bin");
  }
});

// node_modules/resolve-global/index.js
var require_resolve_global = __commonJS({
  "node_modules/resolve-global/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var globalDirs = require_global_dirs();
    var resolveGlobal = (moduleId) => {
      try {
        return require.resolve(path16.join(globalDirs.yarn.packages, moduleId));
      } catch (_) {
        return require.resolve(path16.join(globalDirs.npm.packages, moduleId));
      }
    };
    module2.exports = resolveGlobal;
    module2.exports.silent = (moduleId) => {
      try {
        return resolveGlobal(moduleId);
      } catch (_) {
        return void 0;
      }
    };
  }
});

// node_modules/cspell-lib/dist/cjs/util/resolveFile.js
var require_resolveFile = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/resolveFile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveFile = void 0;
    var fs6 = __importStar(require("fs"));
    var os = __importStar(require("os"));
    var path16 = __importStar(require("path"));
    var resolve_from_1 = __importDefault(require_resolve_from2());
    var resolve_global_1 = __importDefault(require_resolve_global());
    var testNodeModules = /^node_modules\//;
    function resolveFile(filename, relativeTo) {
      filename = filename.replace(/^~/, os.homedir());
      const steps = [
        { filename, fn: tryUrl },
        { filename, fn: tryNodeResolve },
        { filename: path16.resolve(relativeTo, filename), fn: tryResolveExists },
        { filename: path16.resolve(filename), fn: tryResolveExists },
        { filename, fn: tryNodeResolveDefaultPaths },
        { filename, fn: tryResolveFrom },
        { filename: filename.replace(testNodeModules, ""), fn: tryResolveFrom },
        { filename, fn: tryResolveGlobal }
      ];
      for (const step of steps) {
        const r = step.fn(step.filename, relativeTo);
        if (r.found)
          return r;
      }
      return { filename: path16.resolve(relativeTo, filename), relativeTo, found: false };
    }
    exports.resolveFile = resolveFile;
    var isUrlRegExp = /^\w+:\/\//i;
    function tryUrl(filename, relativeTo) {
      if (isUrlRegExp.test(filename)) {
        return { filename, relativeTo: void 0, found: true };
      }
      if (isUrlRegExp.test(relativeTo)) {
        const url = new URL(filename, relativeTo);
        return { filename: url.href, relativeTo, found: true };
      }
      return { filename, relativeTo: void 0, found: false };
    }
    function tryNodeResolveDefaultPaths(filename) {
      try {
        const r = require.resolve(filename);
        return { filename: r, relativeTo: void 0, found: true };
      } catch (_) {
        return { filename, relativeTo: void 0, found: false };
      }
    }
    function tryNodeResolve(filename, relativeTo) {
      const home = os.homedir();
      function calcPaths(p) {
        const paths2 = [p];
        if (filename.startsWith(".") && (filename.startsWith("./") || filename.startsWith("." + path16.sep) || filename.startsWith(".."))) {
          return paths2;
        }
        for (; p && path16.dirname(p) !== p && p !== home; p = path16.dirname(p)) {
          paths2.push(p);
        }
        return paths2;
      }
      const paths = calcPaths(path16.resolve(relativeTo));
      try {
        const r = require.resolve(filename, { paths });
        return { filename: r, relativeTo, found: true };
      } catch (_) {
        return { filename, relativeTo, found: false };
      }
    }
    function tryResolveGlobal(filename) {
      const r = resolve_global_1.default.silent(filename);
      return { filename: r || filename, relativeTo: void 0, found: !!r };
    }
    function tryResolveExists(filename) {
      return { filename, relativeTo: void 0, found: fs6.existsSync(filename) };
    }
    function tryResolveFrom(filename, relativeTo) {
      try {
        return { filename: (0, resolve_from_1.default)(relativeTo, filename), relativeTo, found: true };
      } catch (error2) {
        return { filename, relativeTo, found: false };
      }
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/constants.js
var require_constants3 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ENV_CSPELL_GLOB_ROOT = exports.currentSettingsFileVersion = exports.configSettingsFileVersion0_2 = exports.configSettingsFileVersion0_1 = void 0;
    exports.configSettingsFileVersion0_1 = "0.1";
    exports.configSettingsFileVersion0_2 = "0.2";
    exports.currentSettingsFileVersion = exports.configSettingsFileVersion0_2;
    exports.ENV_CSPELL_GLOB_ROOT = "CSPELL_GLOB_ROOT";
  }
});

// node_modules/cspell-lib/dist/cjs/util/AutoResolve.js
var require_AutoResolve = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/AutoResolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAutoResolveWeakCache = exports.AutoResolveWeakCache = exports.autoResolveWeak = exports.createAutoResolveCache = exports.AutoResolveCache = exports.autoResolve = void 0;
    function autoResolve(map, key, resolve10) {
      const found = map.get(key);
      if (found !== void 0 || map.has(key))
        return found;
      const value = resolve10(key);
      map.set(key, value);
      return value;
    }
    exports.autoResolve = autoResolve;
    var AutoResolveCache = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      get(k, resolve10) {
        return resolve10 ? autoResolve(this.map, k, resolve10) : this.map.get(k);
      }
      has(k) {
        return this.map.has(k);
      }
      set(k, v) {
        this.map.set(k, v);
        return this;
      }
    };
    exports.AutoResolveCache = AutoResolveCache;
    function createAutoResolveCache() {
      return new AutoResolveCache();
    }
    exports.createAutoResolveCache = createAutoResolveCache;
    function autoResolveWeak(map, key, resolve10) {
      const found = map.get(key);
      if (found !== void 0 || map.has(key))
        return found;
      const value = resolve10(key);
      map.set(key, value);
      return value;
    }
    exports.autoResolveWeak = autoResolveWeak;
    var AutoResolveWeakCache = class {
      constructor() {
        this.map = /* @__PURE__ */ new WeakMap();
      }
      get(k, resolve10) {
        return resolve10 ? autoResolveWeak(this.map, k, resolve10) : this.map.get(k);
      }
      has(k) {
        return this.map.has(k);
      }
      set(k, v) {
        this.map.set(k, v);
        return this;
      }
    };
    exports.AutoResolveWeakCache = AutoResolveWeakCache;
    function createAutoResolveWeakCache() {
      return new AutoResolveWeakCache();
    }
    exports.createAutoResolveWeakCache = createAutoResolveWeakCache;
  }
});

// node_modules/gensequence/dist/util/util.js
var require_util4 = __commonJS({
  "node_modules/gensequence/dist/util/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toIterableIterator = exports.toIterator = void 0;
    function toIterator(values) {
      let iter;
      const rangeIterator = {
        next: function() {
          if (!iter) {
            iter = values[Symbol.iterator]();
          }
          return iter.next();
        }
      };
      return rangeIterator;
    }
    exports.toIterator = toIterator;
    function* toIterableIterator(i) {
      yield* i;
    }
    exports.toIterableIterator = toIterableIterator;
  }
});

// node_modules/gensequence/dist/operators/operatorsBase.js
var require_operatorsBase = __commonJS({
  "node_modules/gensequence/dist/operators/operatorsBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scanMap = exports.isAsyncIterableIterator = exports.isAsyncIterable = exports.makeAsyncIterable = exports.isIterableIterator = exports.isIterable = exports.makeIterable = exports.reduceAsyncForAsyncIterator = exports.reduceAsync = exports.reduce = exports.min = exports.max = exports.forEach = exports.first = exports.count = exports.any = exports.all = exports.scan = exports.map = exports.combine = exports.concatMap = exports.concat = exports.take = exports.skip = exports.filter = void 0;
    function* filter(i, fnFilter) {
      for (const v of i) {
        if (fnFilter(v)) {
          yield v;
        }
      }
    }
    exports.filter = filter;
    function* skip(i, n) {
      let a = 0;
      for (const t of i) {
        if (a >= n) {
          yield t;
        }
        a += 1;
      }
    }
    exports.skip = skip;
    function* take(i, n) {
      let a = 0;
      if (n) {
        for (const t of i) {
          if (a >= n) {
            break;
          }
          yield t;
          a += 1;
        }
      }
    }
    exports.take = take;
    function* concat(i, j) {
      yield* i;
      yield* j;
    }
    exports.concat = concat;
    function* concatMap(i, fn) {
      for (const t of i) {
        yield* fn(t);
      }
    }
    exports.concatMap = concatMap;
    function* combine(i, j, fnMap) {
      const jit = j[Symbol.iterator]();
      for (const r of i) {
        const s = jit.next().value;
        yield fnMap(r, s);
      }
    }
    exports.combine = combine;
    function map(i, fnMap) {
      function* fn(i2, fnMap2) {
        for (const v of i2) {
          yield fnMap2(v);
        }
      }
      return fn(i, fnMap);
    }
    exports.map = map;
    function* scan(i, fnReduce, initValue) {
      let index = 0;
      if (initValue === void 0) {
        index = 1;
        const iter = i[Symbol.iterator]();
        let r = iter.next();
        if (!r.done)
          yield r.value;
        initValue = r.value;
        i = makeIterable(iter);
      }
      let prevValue = initValue;
      for (const t of i) {
        const nextValue = fnReduce(prevValue, t, index);
        yield nextValue;
        prevValue = nextValue;
        index += 1;
      }
    }
    exports.scan = scan;
    function all(i, fn) {
      for (const t of i) {
        if (!fn(t)) {
          return false;
        }
      }
      return true;
    }
    exports.all = all;
    function any(i, fn) {
      for (const t of i) {
        if (fn(t)) {
          return true;
        }
      }
      return false;
    }
    exports.any = any;
    function count(i) {
      return reduce2(i, (p) => p + 1, 0);
    }
    exports.count = count;
    function first(i, fn, defaultValue) {
      fn = fn || (() => true);
      for (const t of i) {
        if (fn(t)) {
          return t;
        }
      }
      return defaultValue;
    }
    exports.first = first;
    function forEach(i, fn) {
      let index = 0;
      for (const t of i) {
        fn(t, index);
        index += 1;
      }
    }
    exports.forEach = forEach;
    function max(i, selector = (t) => t) {
      return reduce2(i, (p, c) => selector(c) > selector(p) ? c : p, void 0);
    }
    exports.max = max;
    function min(i, selector = (t) => t) {
      return reduce2(i, (p, c) => selector(c) < selector(p) ? c : p, void 0);
    }
    exports.min = min;
    function reduce2(i, fnReduce, initialValue) {
      const iter = makeIterable(i[Symbol.iterator]());
      let index = 0;
      if (initialValue === void 0) {
        index = 1;
        const r = iter.next();
        initialValue = r.value;
      }
      let prevValue = initialValue;
      for (const t of iter) {
        const nextValue = fnReduce(prevValue, t, index);
        prevValue = nextValue;
        index += 1;
      }
      return prevValue;
    }
    exports.reduce = reduce2;
    async function reduceAsync2(i, fnReduce, initialValue) {
      const iter = makeIterable(i[Symbol.iterator]());
      let index = 0;
      if (initialValue === void 0) {
        index = 1;
        const r = iter.next();
        initialValue = r.value;
      }
      let previousValue = await initialValue;
      for (const p of iter) {
        const t = await p;
        const nextValue = await fnReduce(previousValue, t, index);
        previousValue = nextValue;
        index += 1;
      }
      return previousValue;
    }
    exports.reduceAsync = reduceAsync2;
    async function reduceAsyncForAsyncIterator(i, fnReduce, initialValue) {
      const iter = makeAsyncIterable(i[Symbol.asyncIterator]());
      let index = 0;
      if (initialValue === void 0) {
        index = 1;
        const r = await iter.next();
        initialValue = r.value;
      }
      let previousValue = await initialValue;
      for await (const t of iter) {
        const nextValue = await fnReduce(previousValue, t, index);
        previousValue = nextValue;
        index += 1;
      }
      return previousValue;
    }
    exports.reduceAsyncForAsyncIterator = reduceAsyncForAsyncIterator;
    function makeIterable(i) {
      function* fromIterator(i2) {
        for (let r = i2.next(); !r.done; r = i2.next()) {
          yield r.value;
        }
      }
      function* fromIterable(i2) {
        yield* i2;
      }
      return isIterable2(i) ? isIterableIterator(i) ? i : fromIterable(i) : fromIterator(i);
    }
    exports.makeIterable = makeIterable;
    function isIterable2(i) {
      return !!i[Symbol.iterator];
    }
    exports.isIterable = isIterable2;
    function isIterableIterator(i) {
      return typeof i.next == "function";
    }
    exports.isIterableIterator = isIterableIterator;
    function makeAsyncIterable(i) {
      async function* fromIterable(i2) {
        for (const v of i2) {
          yield v;
        }
      }
      async function* fromIterator(i2) {
        for (let r = await i2.next(); !r.done; r = await i2.next()) {
          yield r.value;
        }
      }
      async function* fromAsyncIterable(i2) {
        yield* i2;
      }
      return isAsyncIterable3(i) ? isAsyncIterableIterator(i) ? i : fromAsyncIterable(i) : isIterable2(i) ? fromIterable(i) : fromIterator(i);
    }
    exports.makeAsyncIterable = makeAsyncIterable;
    function isAsyncIterable3(i) {
      return !!i[Symbol.asyncIterator];
    }
    exports.isAsyncIterable = isAsyncIterable3;
    function isAsyncIterableIterator(i) {
      return typeof i.next == "function";
    }
    exports.isAsyncIterableIterator = isAsyncIterableIterator;
    function scanMap(accFn, init) {
      let acc = init;
      let first2 = true;
      return function(value) {
        if (first2 && acc === void 0) {
          first2 = false;
          acc = value;
          return acc;
        }
        acc = accFn(acc, value);
        return acc;
      };
    }
    exports.scanMap = scanMap;
  }
});

// node_modules/gensequence/dist/operators/operators.js
var require_operators = __commonJS({
  "node_modules/gensequence/dist/operators/operators.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pipe = exports.reduceAsyncForAsyncIterator = exports.reduceAsync = exports.reduce = exports.min = exports.max = exports.forEach = exports.first = exports.count = exports.any = exports.all = exports.scan = exports.map = exports.combine = exports.concatMap = exports.concat = exports.take = exports.skip = exports.filter = void 0;
    var op = __importStar(require_operatorsBase());
    function filter(fnFilter) {
      return (i) => op.filter(i, fnFilter);
    }
    exports.filter = filter;
    function skip(n) {
      return (i) => op.skip(i, n);
    }
    exports.skip = skip;
    function take(n) {
      return (i) => op.take(i, n);
    }
    exports.take = take;
    function concat(j) {
      return (i) => op.concat(i, j);
    }
    exports.concat = concat;
    function concatMap(fn) {
      return (i) => op.concatMap(i, fn);
    }
    exports.concatMap = concatMap;
    function combine(fnMap, j) {
      return (i) => op.combine(i, j, fnMap);
    }
    exports.combine = combine;
    function map(fnMap) {
      return (i) => op.map(i, fnMap);
    }
    exports.map = map;
    function scan(fnReduce, initValue) {
      return (i) => op.scan(i, fnReduce, initValue);
    }
    exports.scan = scan;
    function all(fn) {
      return (i) => op.all(i, fn);
    }
    exports.all = all;
    function any(fn) {
      return (i) => op.any(i, fn);
    }
    exports.any = any;
    function count() {
      return (i) => op.count(i);
    }
    exports.count = count;
    function first(fn, defaultValue) {
      return (i) => op.first(i, fn, defaultValue);
    }
    exports.first = first;
    function forEach(fn) {
      return (i) => op.forEach(i, fn);
    }
    exports.forEach = forEach;
    function max(selector) {
      return (i) => op.max(i, selector);
    }
    exports.max = max;
    function min(selector) {
      return (i) => op.min(i, selector);
    }
    exports.min = min;
    function reduce2(fnReduce, initialValue) {
      return (i) => op.reduce(i, fnReduce, initialValue);
    }
    exports.reduce = reduce2;
    function reduceAsync2(fnReduceAsync, initialValue) {
      return (i) => op.reduceAsync(i, fnReduceAsync, initialValue);
    }
    exports.reduceAsync = reduceAsync2;
    function reduceAsyncForAsyncIterator(fnReduceAsync, initialValue) {
      return (i) => op.reduceAsyncForAsyncIterator(i, fnReduceAsync, initialValue);
    }
    exports.reduceAsyncForAsyncIterator = reduceAsyncForAsyncIterator;
    function pipe(...fns) {
      return (i) => {
        for (const fn of fns) {
          i = fn ? fn(i) : i;
        }
        return i;
      };
    }
    exports.pipe = pipe;
  }
});

// node_modules/gensequence/dist/operators/index.js
var require_operators2 = __commonJS({
  "node_modules/gensequence/dist/operators/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_operators(), exports);
  }
});

// node_modules/gensequence/dist/ImplSequence.js
var require_ImplSequence = __commonJS({
  "node_modules/gensequence/dist/ImplSequence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplSequence = void 0;
    var index_js_1 = require_operators2();
    var util_js_1 = require_util4();
    var ImplSequence = class _ImplSequence {
      constructor(i) {
        this.i = i;
      }
      get iter() {
        return typeof this.i === "function" ? this.i() : this.i;
      }
      get iterator() {
        if (!this._iterator) {
          this._iterator = this.iter[Symbol.iterator]();
        }
        return this._iterator;
      }
      inject(fn) {
        const iter = this.i;
        return () => fn(typeof iter === "function" ? iter() : iter);
      }
      chain(fn) {
        return new _ImplSequence(this.inject(fn));
      }
      [Symbol.iterator]() {
        return this.iter[Symbol.iterator]();
      }
      next() {
        return this.iterator.next();
      }
      //// Filters
      filter(fnFilter) {
        return this.chain((0, index_js_1.filter)(fnFilter));
      }
      skip(n) {
        return this.chain((0, index_js_1.skip)(n));
      }
      take(n) {
        return this.chain((0, index_js_1.take)(n));
      }
      //// Extenders
      concat(j) {
        return this.chain((0, index_js_1.concat)(j));
      }
      concatMap(fn) {
        return this.chain((0, index_js_1.concatMap)(fn));
      }
      //// Mappers
      combine(fn, j) {
        return this.chain((0, index_js_1.combine)(fn, j));
      }
      map(fn) {
        return this.chain((0, index_js_1.map)(fn));
      }
      scan(fnReduce, initValue) {
        return this.chain((0, index_js_1.scan)(fnReduce, initValue));
      }
      pipe(...fns) {
        if (!fns.length)
          return this;
        return this.chain(index_js_1.pipe.apply(null, fns));
      }
      // Reducers
      all(fnFilter) {
        return (0, index_js_1.all)(fnFilter)(this.iter);
      }
      any(fnFilter) {
        return (0, index_js_1.any)(fnFilter)(this.iter);
      }
      count() {
        return (0, index_js_1.count)()(this.iter);
      }
      first(fnFilter, defaultValue) {
        return (0, index_js_1.first)(fnFilter, defaultValue)(this.iter);
      }
      forEach(fn) {
        return (0, index_js_1.forEach)(fn)(this.iter);
      }
      max(fnSelector) {
        return (0, index_js_1.max)(fnSelector)(this.iter);
      }
      min(fnSelector) {
        return (0, index_js_1.min)(fnSelector)(this.iter);
      }
      reduce(fnReduce, initValue) {
        return (0, index_js_1.reduce)(fnReduce, initValue)(this.iter);
      }
      reduceAsync(fnReduceAsync, initialValue) {
        return (0, index_js_1.reduceAsync)(fnReduceAsync, initialValue)(this.iter);
      }
      reduceToSequence(fnReduce, initialValue) {
        return this.chain((0, index_js_1.reduce)(fnReduce, initialValue));
      }
      //// Cast
      toArray() {
        return [...this.iter];
      }
      toIterable() {
        return (0, util_js_1.toIterableIterator)(this.iter);
      }
    };
    exports.ImplSequence = ImplSequence;
  }
});

// node_modules/gensequence/dist/GenSequence.js
var require_GenSequence = __commonJS({
  "node_modules/gensequence/dist/GenSequence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceFromRegExpMatch = exports.sequenceFromObject = exports.objectToSequence = exports.objectIterator = exports.toIterator = exports.GenSequence = exports.genSequence = exports.toIterableIterator = void 0;
    var util_js_1 = require_util4();
    var ImplSequence_js_1 = require_ImplSequence();
    var util_js_2 = require_util4();
    Object.defineProperty(exports, "toIterableIterator", { enumerable: true, get: function() {
      return util_js_2.toIterableIterator;
    } });
    function genSequence(i) {
      return new ImplSequence_js_1.ImplSequence(i);
    }
    exports.genSequence = genSequence;
    exports.GenSequence = {
      genSequence,
      sequenceFromRegExpMatch,
      sequenceFromObject
    };
    exports.toIterator = util_js_1.toIterableIterator;
    function* objectIterator(t) {
      const keys = new Set(Object.keys(t));
      for (const k in t) {
        if (keys.has(k)) {
          yield [k, t[k]];
        }
      }
    }
    exports.objectIterator = objectIterator;
    function objectToSequence(t) {
      return sequenceFromObject(t);
    }
    exports.objectToSequence = objectToSequence;
    function sequenceFromObject(t) {
      return genSequence(() => objectIterator(t));
    }
    exports.sequenceFromObject = sequenceFromObject;
    function sequenceFromRegExpMatch(pattern, text) {
      function* doMatch() {
        const regex = new RegExp(pattern);
        let match;
        let lastIndex = void 0;
        while (match = regex.exec(text)) {
          if (match.index === lastIndex) {
            break;
          }
          lastIndex = match.index;
          yield match;
        }
      }
      return genSequence(() => doMatch());
    }
    exports.sequenceFromRegExpMatch = sequenceFromRegExpMatch;
    exports.default = genSequence;
  }
});

// node_modules/gensequence/dist/ImplAsyncSequence.js
var require_ImplAsyncSequence = __commonJS({
  "node_modules/gensequence/dist/ImplAsyncSequence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplAsyncSequence = void 0;
    var index_js_1 = require_operators2();
    var ImplAsyncSequence = class {
      constructor(i) {
        this.i = i;
      }
      get iter() {
        return typeof this.i === "function" ? this.i() : this.i;
      }
      [Symbol.asyncIterator]() {
        return this.iter[Symbol.asyncIterator]();
      }
      reduceAsync(fnReduceAsync, initialValue) {
        return (0, index_js_1.reduceAsyncForAsyncIterator)(fnReduceAsync, initialValue)(this.iter);
      }
    };
    exports.ImplAsyncSequence = ImplAsyncSequence;
  }
});

// node_modules/gensequence/dist/AsyncGenSequence.js
var require_AsyncGenSequence = __commonJS({
  "node_modules/gensequence/dist/AsyncGenSequence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncGenSequence = void 0;
    var ImplAsyncSequence_js_1 = require_ImplAsyncSequence();
    function asyncGenSequence(i) {
      return new ImplAsyncSequence_js_1.ImplAsyncSequence(i);
    }
    exports.asyncGenSequence = asyncGenSequence;
  }
});

// node_modules/gensequence/dist/ImplSequenceBuilder.js
var require_ImplSequenceBuilder = __commonJS({
  "node_modules/gensequence/dist/ImplSequenceBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplSequenceBuilder = void 0;
    var index_js_1 = require_operators2();
    var ImplSequence_js_1 = require_ImplSequence();
    var ImplSequenceBuilder = class _ImplSequenceBuilder {
      constructor(operators2 = []) {
        this.operators = [];
        this.operators = operators2;
      }
      build(i) {
        return new ImplSequence_js_1.ImplSequence(i).pipe(index_js_1.pipe.apply(null, this.operators));
      }
      pipe(...fns) {
        return new _ImplSequenceBuilder([...this.operators, ...fns]);
      }
      //// Filters
      /** keep values where the fnFilter(t) returns true */
      filter(fnFilter) {
        return this.pipe((0, index_js_1.filter)(fnFilter));
      }
      skip(n) {
        return this.pipe((0, index_js_1.skip)(n));
      }
      take(n) {
        return this.pipe((0, index_js_1.take)(n));
      }
      //// Extenders
      concat(j) {
        return this.pipe((0, index_js_1.concat)(j));
      }
      concatMap(fn) {
        return this.pipe((0, index_js_1.concatMap)(fn));
      }
      //// Mappers
      combine(fn, j) {
        return this.pipe((0, index_js_1.combine)(fn, j));
      }
      /** map values from type T to type U */
      map(fnMap) {
        return this.pipe((0, index_js_1.map)(fnMap));
      }
      scan(fnReduce, initialValue) {
        return this.pipe((0, index_js_1.scan)(fnReduce, initialValue));
      }
    };
    exports.ImplSequenceBuilder = ImplSequenceBuilder;
  }
});

// node_modules/gensequence/dist/builder.js
var require_builder = __commonJS({
  "node_modules/gensequence/dist/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.builder = void 0;
    var ImplSequenceBuilder_js_1 = require_ImplSequenceBuilder();
    var index_js_1 = require_operators2();
    function makeBuilder(fn) {
      return new ImplSequenceBuilder_js_1.ImplSequenceBuilder([fn]);
    }
    exports.builder = Object.freeze({
      pipe: (fn) => {
        return makeBuilder(fn);
      },
      //// Filters
      /** keep values where the fnFilter(t) returns true */
      filter: (fnFilter) => {
        return makeBuilder((0, index_js_1.filter)(fnFilter));
      },
      skip: (n) => {
        return makeBuilder((0, index_js_1.skip)(n));
      },
      take: (n) => {
        return makeBuilder((0, index_js_1.take)(n));
      },
      //// Extenders
      concat: (j) => {
        return makeBuilder((0, index_js_1.concat)(j));
      },
      concatMap: (fn) => {
        return makeBuilder((0, index_js_1.concatMap)(fn));
      },
      //// Mappers
      combine: (fn, j) => {
        return makeBuilder((0, index_js_1.combine)(fn, j));
      },
      /** map values from type T to type U */
      map: (fnMap) => {
        return makeBuilder((0, index_js_1.map)(fnMap));
      },
      scan: (fnReduce, initialValue) => {
        return makeBuilder((0, index_js_1.scan)(fnReduce, initialValue));
      }
    });
  }
});

// node_modules/gensequence/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/gensequence/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.operators = void 0;
    __exportStar(require_GenSequence(), exports);
    __exportStar(require_AsyncGenSequence(), exports);
    __exportStar(require_builder(), exports);
    var _operators = __importStar(require_operators2());
    exports.operators = _operators;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/TrieNode.js
var require_TrieNode = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/TrieNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChildMap = exports.FLAG_WORD = void 0;
    exports.FLAG_WORD = 1;
    var ChildMap = class extends Map {
    };
    exports.ChildMap = ChildMap;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/constants.js
var require_constants4 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultTrieOptions = exports.IDENTITY_PREFIX = exports.LINE_COMMENT = exports.FORBID_PREFIX = exports.CASE_INSENSITIVE_PREFIX = exports.OPTIONAL_COMPOUND_FIX = exports.COMPOUND_FIX = void 0;
    exports.COMPOUND_FIX = "+";
    exports.OPTIONAL_COMPOUND_FIX = "*";
    exports.CASE_INSENSITIVE_PREFIX = "~";
    exports.FORBID_PREFIX = "!";
    exports.LINE_COMMENT = "#";
    exports.IDENTITY_PREFIX = "=";
    exports.defaultTrieOptions = Object.freeze({
      compoundCharacter: exports.COMPOUND_FIX,
      forbiddenWordPrefix: exports.FORBID_PREFIX,
      stripCaseAndAccentsPrefix: exports.CASE_INSENSITIVE_PREFIX
    });
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/mergeDefaults.js
var require_mergeDefaults = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/mergeDefaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDefaults = void 0;
    function mergeDefaults(value, defaultValue) {
      const result = { ...defaultValue };
      if (value) {
        for (const [k, v] of Object.entries(value)) {
          if (k in result) {
            result[k] = v ?? result[k];
          }
        }
      }
      return result;
    }
    exports.mergeDefaults = mergeDefaults;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/mergeOptionalWithDefaults.js
var require_mergeOptionalWithDefaults = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/mergeOptionalWithDefaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeOptionalWithDefaults = void 0;
    var constants_js_1 = require_constants4();
    var mergeDefaults_js_1 = require_mergeDefaults();
    function mergeOptionalWithDefaults(options) {
      return (0, mergeDefaults_js_1.mergeDefaults)(options, constants_js_1.defaultTrieOptions);
    }
    exports.mergeOptionalWithDefaults = mergeOptionalWithDefaults;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/walker/walkerTypes.js
var require_walkerTypes = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/walker/walkerTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompoundWordsMethod = exports.WORD_SEPARATOR = exports.JOIN_SEPARATOR = void 0;
    exports.JOIN_SEPARATOR = "+";
    exports.WORD_SEPARATOR = " ";
    var CompoundWordsMethod;
    (function(CompoundWordsMethod2) {
      CompoundWordsMethod2[CompoundWordsMethod2["NONE"] = 0] = "NONE";
      CompoundWordsMethod2[CompoundWordsMethod2["SEPARATE_WORDS"] = 1] = "SEPARATE_WORDS";
      CompoundWordsMethod2[CompoundWordsMethod2["JOIN_WORDS"] = 2] = "JOIN_WORDS";
    })(CompoundWordsMethod || (exports.CompoundWordsMethod = CompoundWordsMethod = {}));
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/walker/walker.js
var require_walker = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/walker/walker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walker = void 0;
    var walkerTypes_js_1 = require_walkerTypes();
    function* walker(root, compoundingMethod = walkerTypes_js_1.CompoundWordsMethod.NONE) {
      const roots = {
        [walkerTypes_js_1.CompoundWordsMethod.NONE]: [],
        [walkerTypes_js_1.CompoundWordsMethod.JOIN_WORDS]: [[walkerTypes_js_1.JOIN_SEPARATOR, root]],
        [walkerTypes_js_1.CompoundWordsMethod.SEPARATE_WORDS]: [[walkerTypes_js_1.WORD_SEPARATOR, root]]
      };
      function* children(n) {
        if (n.c) {
          yield* n.c;
        }
        if (n.f) {
          yield* roots[compoundingMethod];
        }
      }
      let depth = 0;
      const stack = [];
      stack[depth] = { t: "", c: children(root) };
      let ir;
      while (depth >= 0) {
        let baseText = stack[depth].t;
        while (!(ir = stack[depth].c.next()).done) {
          const [char, node] = ir.value;
          const text = baseText + char;
          const goDeeper = yield { text, node, depth };
          if (goDeeper || goDeeper === void 0) {
            depth++;
            baseText = text;
            stack[depth] = { t: text, c: children(node) };
          }
        }
        depth -= 1;
      }
    }
    exports.walker = walker;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/trie-util.js
var require_trie_util = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/trie-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trieNodeToRoot = exports.isCircular = exports.countWords = exports.countNodes = exports.findNode = exports.has = exports.createTriFromList = exports.createTrieRoot = exports.iteratorTrieWords = exports.iterateTrie = exports.walk = exports.orderTrie = exports.isWordTerminationNode = exports.insert = void 0;
    var gensequence_1 = require_dist2();
    var TrieNode_js_1 = require_TrieNode();
    var mergeOptionalWithDefaults_js_1 = require_mergeOptionalWithDefaults();
    var walker_js_1 = require_walker();
    function insert(text, node = {}) {
      if (text.length) {
        const head = text[0];
        const tail = text.slice(1);
        node.c = node.c || new TrieNode_js_1.ChildMap();
        node.c.set(head, insert(tail, node.c.get(head)));
      } else {
        node.f = (node.f || 0) | TrieNode_js_1.FLAG_WORD;
      }
      return node;
    }
    exports.insert = insert;
    function isWordTerminationNode(node) {
      return ((node.f || 0) & TrieNode_js_1.FLAG_WORD) === TrieNode_js_1.FLAG_WORD;
    }
    exports.isWordTerminationNode = isWordTerminationNode;
    function orderTrie(node) {
      if (!node.c)
        return;
      const nodes = [...node.c].sort(([a], [b]) => a < b ? -1 : 1);
      node.c = new Map(nodes);
      for (const n of node.c) {
        orderTrie(n[1]);
      }
    }
    exports.orderTrie = orderTrie;
    function walk(node) {
      return (0, gensequence_1.genSequence)((0, walker_js_1.walker)(node));
    }
    exports.walk = walk;
    exports.iterateTrie = walk;
    function iteratorTrieWords(node) {
      return walk(node).filter((r) => isWordTerminationNode(r.node)).map((r) => r.text);
    }
    exports.iteratorTrieWords = iteratorTrieWords;
    function createTrieRoot(options) {
      const fullOptions = (0, mergeOptionalWithDefaults_js_1.mergeOptionalWithDefaults)(options);
      return {
        ...fullOptions,
        c: /* @__PURE__ */ new Map()
      };
    }
    exports.createTrieRoot = createTrieRoot;
    function createTriFromList(words, options) {
      const root = createTrieRoot(options);
      for (const word of words) {
        if (word.length) {
          insert(word, root);
        }
      }
      return root;
    }
    exports.createTriFromList = createTriFromList;
    function has(node, word) {
      let h = word.slice(0, 1);
      let t = word.slice(1);
      while (node.c && node.c.has(h)) {
        node = node.c.get(h);
        h = t.slice(0, 1);
        t = t.slice(1);
      }
      return !h.length && !!((node.f || 0) & TrieNode_js_1.FLAG_WORD);
    }
    exports.has = has;
    function findNode(node, prefix) {
      let h = prefix.slice(0, 1);
      let t = prefix.slice(1);
      let n = node;
      while (h.length && n && n.c) {
        n = n.c.get(h);
        h = t.slice(0, 1);
        t = t.slice(1);
      }
      return n;
    }
    exports.findNode = findNode;
    function countNodes(root) {
      const seen = /* @__PURE__ */ new Set();
      function walk2(n) {
        if (seen.has(n))
          return;
        seen.add(n);
        if (n.c) {
          [...n.c.values()].forEach((n2) => walk2(n2));
        }
      }
      walk2(root);
      return seen.size;
    }
    exports.countNodes = countNodes;
    function countWords(root) {
      const visited = /* @__PURE__ */ new Map();
      function walk2(n) {
        if (visited.has(n)) {
          return visited.get(n);
        }
        let cnt = n.f ? 1 : 0;
        visited.set(n, cnt);
        if (!n.c) {
          return cnt;
        }
        for (const c of n.c.values()) {
          cnt += walk2(c);
        }
        visited.set(n, cnt);
        return cnt;
      }
      return walk2(root);
    }
    exports.countWords = countWords;
    function isCircular(root) {
      const seen = /* @__PURE__ */ new Set();
      const inStack = /* @__PURE__ */ new Set();
      function walk2(n) {
        if (seen.has(n))
          return { isCircular: false, allSeen: true };
        if (inStack.has(n))
          return { isCircular: true, allSeen: false };
        inStack.add(n);
        let r = { isCircular: false, allSeen: true };
        if (n.c) {
          r = [...n.c.values()].reduce((acc, n2) => {
            if (acc.isCircular)
              return acc;
            const r2 = walk2(n2);
            r2.allSeen = r2.allSeen && acc.allSeen;
            return r2;
          }, r);
        }
        if (r.allSeen) {
          seen.add(n);
        }
        inStack.delete(n);
        return r;
      }
      return walk2(root).isCircular;
    }
    exports.isCircular = isCircular;
    function trieNodeToRoot(node, options) {
      const newOptions = (0, mergeOptionalWithDefaults_js_1.mergeOptionalWithDefaults)(options);
      return {
        ...newOptions,
        c: node.c || /* @__PURE__ */ new Map()
      };
    }
    exports.trieNodeToRoot = trieNodeToRoot;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/consolidate.js
var require_consolidate = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/consolidate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.consolidate = void 0;
    var trie_util_js_1 = require_trie_util();
    var TrieNode_js_1 = require_TrieNode();
    function consolidate(root) {
      let count = 0;
      const signatures = /* @__PURE__ */ new Map();
      const cached = /* @__PURE__ */ new Map();
      const knownMap = /* @__PURE__ */ new Map();
      function signature(n) {
        const isWord = n.f ? "*" : "";
        const ref = n.c ? JSON.stringify([...n.c.entries()].map(([k, n2]) => [k, cached.get(n2)])) : "";
        return isWord + ref;
      }
      function findEow(n) {
        if (n.f && !n.c)
          return n;
        let r;
        if (n.c) {
          for (const c of n.c.values()) {
            r = findEow(c);
            if (r)
              break;
          }
        }
        return r;
      }
      function compareMaps(a, b) {
        for (const e of a) {
          if (b.get(e[0]) !== e[1])
            return false;
        }
        return a.length === b.size;
      }
      function deepCopy(n) {
        const k = knownMap.get(n);
        if (k) {
          return k;
        }
        const orig = n;
        if (n.c) {
          const children = [...n.c].map((c) => [c[0], deepCopy(c[1])]);
          if (!compareMaps(children, n.c)) {
            n = { f: n.f, c: new Map(children) };
          }
        }
        const sig = signature(n);
        const ref = signatures.get(sig);
        if (ref) {
          knownMap.set(orig, ref);
          return ref;
        }
        Object.freeze(n);
        signatures.set(sig, n);
        cached.set(n, count++);
        knownMap.set(orig, n);
        return n;
      }
      function process4(n) {
        if (cached.has(n)) {
          return n;
        }
        if (Object.isFrozen(n)) {
          return knownMap.get(n) || deepCopy(n);
        }
        if (n.c) {
          const children = [...n.c].sort((a, b) => a[0] < b[0] ? -1 : 1).map((c) => [c[0], process4(c[1])]);
          n.c = new Map(children);
        }
        const sig = signature(n);
        const ref = signatures.get(sig);
        if (ref) {
          return ref;
        }
        signatures.set(sig, n);
        cached.set(n, count++);
        return n;
      }
      const eow = findEow(root) || { f: TrieNode_js_1.FLAG_WORD, c: void 0 };
      signatures.set(signature(eow), eow);
      cached.set(eow, count++);
      return (0, trie_util_js_1.trieNodeToRoot)(process4(root), root);
    }
    exports.consolidate = consolidate;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/PairingHeap.js
var require_PairingHeap = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/PairingHeap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.heapMethods = exports.PairingHeap = void 0;
    var PairingHeap = class {
      constructor(compare2) {
        this.compare = compare2;
        this._size = 0;
      }
      add(v) {
        this._heap = insert(this.compare, this._heap, v);
        ++this._size;
        return this;
      }
      dequeue() {
        const n = this.next();
        if (n.done)
          return void 0;
        return n.value;
      }
      concat(i) {
        for (const v of i) {
          this.add(v);
        }
        return this;
      }
      next() {
        if (!this._heap) {
          return { value: void 0, done: true };
        }
        const value = this._heap.v;
        --this._size;
        this._heap = removeHead(this.compare, this._heap);
        return { value };
      }
      peek() {
        return this._heap?.v;
      }
      [Symbol.iterator]() {
        return this;
      }
      get length() {
        return this._size;
      }
    };
    exports.PairingHeap = PairingHeap;
    function removeHead(compare2, heap) {
      if (!heap || !heap.c)
        return void 0;
      return mergeSiblings(compare2, heap.c);
    }
    function insert(compare2, heap, v) {
      const n = {
        v,
        s: void 0,
        c: void 0
      };
      if (!heap || compare2(v, heap.v) <= 0) {
        n.c = heap;
        return n;
      }
      n.s = heap.c;
      heap.c = n;
      return heap;
    }
    function merge(compare2, a, b) {
      if (compare2(a.v, b.v) <= 0) {
        a.s = void 0;
        b.s = a.c;
        a.c = b;
        return a;
      }
      b.s = void 0;
      a.s = b.c;
      b.c = a;
      return b;
    }
    function mergeSiblings(compare2, n) {
      if (!n.s)
        return n;
      const s = n.s;
      const ss = s.s;
      const m = merge(compare2, n, s);
      return ss ? merge(compare2, m, mergeSiblings(compare2, ss)) : m;
    }
    exports.heapMethods = {
      insert,
      merge,
      mergeSiblings
    };
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/distance/distanceAStarWeighted.js
var require_distanceAStarWeighted = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/distance/distanceAStarWeighted.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distanceAStarWeightedEx = exports.distanceAStarWeighted = void 0;
    var assert_1 = __importDefault(require("assert"));
    var PairingHeap_js_1 = require_PairingHeap();
    function distanceAStarWeighted(wordA, wordB, map, cost = 100) {
      const best = _distanceAStarWeightedEx(wordA, wordB, map, cost);
      const penalty = map.calcAdjustment(wordB);
      return best.c + best.p + penalty;
    }
    exports.distanceAStarWeighted = distanceAStarWeighted;
    function distanceAStarWeightedEx(wordA, wordB, map, cost = 100) {
      const best = _distanceAStarWeightedEx(wordA, wordB, map, cost);
      const aa = "^" + wordA + "$";
      const bb = "^" + wordB + "$";
      const penalty = map.calcAdjustment(wordB);
      const result = {
        a: aa,
        b: bb,
        cost: best.c + best.p + penalty,
        penalty,
        segments: []
      };
      const segments = result.segments;
      for (let n = best; n.f; n = n.f) {
        const f = n.f;
        const a = aa.slice(f.ai, n.ai);
        const b = bb.slice(f.bi, n.bi);
        const c = n.c - f.c;
        const p = n.p - f.p;
        segments.push({ a, b, c, p });
      }
      segments.reverse();
      return result;
    }
    exports.distanceAStarWeightedEx = distanceAStarWeightedEx;
    function _distanceAStarWeightedEx(wordA, wordB, map, cost = 100) {
      const a = "^" + wordA + "$";
      const b = "^" + wordB + "$";
      const aN = a.length;
      const bN = b.length;
      const candidates = new CandidatePool(aN, bN);
      candidates.add({ ai: 0, bi: 0, c: 0, p: 0, f: void 0 });
      function opSub(n) {
        const { ai, bi, c, p } = n;
        if (ai < aN && bi < bN) {
          const cc = a[ai] === b[bi] ? c : c + cost;
          candidates.add({ ai: ai + 1, bi: bi + 1, c: cc, p, f: n });
        }
      }
      function opIns(n) {
        const { ai, bi, c, p } = n;
        if (bi < bN) {
          candidates.add({ ai, bi: bi + 1, c: c + cost, p, f: n });
        }
      }
      function opDel(n) {
        const { ai, bi, c, p } = n;
        if (ai < aN) {
          candidates.add({ ai: ai + 1, bi, c: c + cost, p, f: n });
        }
      }
      function opSwap(n) {
        const { ai, bi, c, p } = n;
        if (a[ai] === b[bi + 1] && a[ai + 1] === b[bi]) {
          candidates.add({ ai: ai + 2, bi: bi + 2, c: c + cost, p, f: n });
        }
      }
      function opMap2(n) {
        const { ai, bi, c, p } = n;
        const pos = { a, b, ai, bi, c, p };
        const costCalculations = [map.calcInsDelCosts(pos), map.calcSwapCosts(pos), map.calcReplaceCosts(pos)];
        costCalculations.forEach((iter) => {
          for (const nn of iter) {
            candidates.add({ ...nn, f: n });
          }
        });
      }
      let best;
      while (best = candidates.next()) {
        if (best.ai === aN && best.bi === bN)
          break;
        opSwap(best);
        opIns(best);
        opDel(best);
        opMap2(best);
        opSub(best);
      }
      (0, assert_1.default)(best);
      return best;
    }
    var CandidatePool = class {
      constructor(aN, bN) {
        this.aN = aN;
        this.bN = bN;
        this.pool = new PairingHeap_js_1.PairingHeap(compare2);
        this.grid = [];
      }
      next() {
        let n;
        while (n = this.pool.dequeue()) {
          if (!n.d)
            return n;
        }
        return void 0;
      }
      add(n) {
        const i = idx(n.ai, n.bi, this.bN);
        const g = this.grid[i];
        if (!g) {
          this.grid[i] = n;
          this.pool.add(n);
          return;
        }
        if (g.c <= n.c)
          return;
        g.d = true;
        this.grid[i] = n;
        this.pool.add(n);
      }
    };
    function idx(r, c, cols) {
      return r * cols + c;
    }
    function compare2(a, b) {
      return a.c - b.c || b.ai + b.bi - a.ai - a.bi;
    }
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/distance/levenshtein.js
var require_levenshtein = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/distance/levenshtein.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.levenshteinDistance = void 0;
    function levenshteinDistance(a, b) {
      const aa = "  " + a;
      const bb = "  " + b;
      const nA = a.length + 1;
      const nB = b.length + 1;
      const firstRow = [];
      for (let i = 0; i <= nA; ++i) {
        firstRow[i] = i;
      }
      const matrix = [firstRow, [1].concat(firstRow), [2, 1].concat(firstRow)];
      let ppRow = matrix[0];
      let pRow = matrix[1];
      for (let j = 2; j <= nB; ++j) {
        const row = matrix[j % 3];
        row[0] = pRow[0] + 1;
        row[1] = pRow[1] + 1;
        const bp = bb[j - 1];
        const bc = bb[j];
        let ap = aa[0];
        for (let i = 2, i1 = 1; i <= nA; i1 = i, ++i) {
          const ac = aa[i];
          const c = pRow[i1] + (ac == bc ? 0 : 1);
          const ct = ac == bp && ap == bc ? ppRow[i1 - 1] + 1 : c;
          row[i] = Math.min(
            c,
            // substitute
            ct,
            // transpose
            pRow[i] + 1,
            // insert
            row[i1] + 1
            // delete
          );
          ap = ac;
        }
        ppRow = pRow;
        pRow = row;
      }
      return pRow[nA];
    }
    exports.levenshteinDistance = levenshteinDistance;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/constants.js
var require_constants5 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_COMPOUNDED_WORD_SEPARATOR = void 0;
    exports.DEFAULT_COMPOUNDED_WORD_SEPARATOR = "\u2219";
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/distance/weightedMaps.js
var require_weightedMaps = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/distance/weightedMaps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.lookupReplaceCost = exports.prettyPrintWeightMap = exports.prettyPrintSwap = exports.prettyPrintReplace = exports.splitMapSubstrings = exports.splitMapSubstringsIterable = exports.addDefsToWeightMap = exports.addAdjustment = exports.addDefToWeightMap = exports.createWeightMap = void 0;
    var constants_js_1 = require_constants5();
    var matchPossibleWordSeparators = /[+]/g;
    function createWeightMap(...defs) {
      const map = _createWeightMap();
      addDefsToWeightMap(map, defs);
      return map;
    }
    exports.createWeightMap = createWeightMap;
    function addDefToWeightMap(map, ...defs) {
      return addDefsToWeightMap(map, defs);
    }
    exports.addDefToWeightMap = addDefToWeightMap;
    function addAdjustment(map, ...adjustments) {
      for (const adj of adjustments) {
        map.adjustments.set(adj.id, adj);
      }
      return map;
    }
    exports.addAdjustment = addAdjustment;
    function addDefsToWeightMap(map, defs) {
      function addSet(set, def) {
        addSetToTrieCost(map.insDel, set, def.insDel, def.penalty);
        addSetToTrieTrieCost(map.replace, set, def.replace, def.penalty);
        addSetToTrieTrieCost(map.swap, set, def.swap, def.penalty);
      }
      for (const _def of defs) {
        const def = normalizeDef(_def);
        const mapSets = splitMap(def);
        mapSets.forEach((s) => addSet(s, def));
      }
      return map;
    }
    exports.addDefsToWeightMap = addDefsToWeightMap;
    function _createWeightMap() {
      return new _WeightedMap();
    }
    function lowest(a, b) {
      if (a === void 0)
        return b;
      if (b === void 0)
        return a;
      return a <= b ? a : b;
    }
    function highest(a, b) {
      if (a === void 0)
        return b;
      if (b === void 0)
        return a;
      return a >= b ? a : b;
    }
    function normalize(s) {
      const f = /* @__PURE__ */ new Set([s]);
      f.add(s.normalize("NFC"));
      f.add(s.normalize("NFD"));
      return f;
    }
    function* splitMapSubstringsIterable(map) {
      let seq = "";
      let mode = 0;
      for (const char of map) {
        if (mode && char === ")") {
          yield* normalize(seq);
          mode = 0;
          continue;
        }
        if (mode) {
          seq += char;
          continue;
        }
        if (char === "(") {
          mode = 1;
          seq = "";
          continue;
        }
        yield* normalize(char);
      }
    }
    exports.splitMapSubstringsIterable = splitMapSubstringsIterable;
    function splitMapSubstrings(map) {
      return [...splitMapSubstringsIterable(map)];
    }
    exports.splitMapSubstrings = splitMapSubstrings;
    function splitMap(def) {
      const { map } = def;
      const sets = map.split("|");
      return sets.map(splitMapSubstrings).filter((s) => s.length > 0);
    }
    function addToTrieCost(trie, str, cost, penalties) {
      if (!str)
        return;
      let t = trie;
      for (const c of str) {
        const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
        t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
      }
      t.c = lowest(t.c, cost);
      t.p = highest(t.p, penalties);
    }
    function addToTrieTrieCost(trie, left, right, cost, penalties) {
      let t = trie;
      for (const c of left) {
        const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
        t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
      }
      const trieCost = t.t = t.t || /* @__PURE__ */ Object.create(null);
      addToTrieCost(trieCost, right, cost, penalties);
    }
    function addSetToTrieCost(trie, set, cost, penalties) {
      if (cost === void 0)
        return;
      for (const str of set) {
        addToTrieCost(trie, str, cost, penalties);
      }
    }
    function addSetToTrieTrieCost(trie, set, cost, penalties) {
      if (cost === void 0)
        return;
      for (const left of set) {
        for (const right of set) {
          if (left === right)
            continue;
          addToTrieTrieCost(trie, left, right, cost, penalties);
        }
      }
    }
    function* searchTrieNodes(trie, str, i) {
      const len = str.length;
      for (let n = trie.n; i < len && n; ) {
        const t = n[str[i]];
        if (!t)
          return;
        ++i;
        yield { i, t };
        n = t.n;
      }
    }
    function* walkTrieNodes(t, s) {
      if (!t)
        return;
      yield { s, t };
      if (!t.n)
        return;
      for (const [k, v] of Object.entries(t.n)) {
        yield* walkTrieNodes(v, s + k);
      }
    }
    function* walkTrieCost(trie) {
      for (const { s, t } of walkTrieNodes(trie, "")) {
        if (t.c) {
          yield { s, c: t.c, p: t.p };
        }
      }
    }
    function* walkTrieTrieCost(trie) {
      for (const { s: a, t } of walkTrieNodes(trie, "")) {
        if (t.t) {
          for (const { s: b, c, p } of walkTrieCost(t.t)) {
            yield { a, b, c, p };
          }
        }
      }
    }
    function* findTrieCostPrefixes(trie, str, i) {
      for (const n of searchTrieNodes(trie, str, i)) {
        const { c, p } = n.t;
        if (c !== void 0) {
          yield { i: n.i, c, p: p || 0 };
        }
      }
    }
    function* findTrieTrieCostPrefixes(trie, str, i) {
      for (const n of searchTrieNodes(trie, str, i)) {
        const t = n.t.t;
        if (t !== void 0) {
          yield { i: n.i, t };
        }
      }
    }
    var _WeightedMap = class {
      constructor() {
        this.insDel = {};
        this.replace = {};
        this.swap = {};
        this.adjustments = /* @__PURE__ */ new Map();
      }
      *calcInsDelCosts(pos) {
        const { a, ai, b, bi, c, p } = pos;
        for (const del of findTrieCostPrefixes(this.insDel, a, ai)) {
          yield { a, b, ai: del.i, bi, c: c + del.c, p: p + del.p };
        }
        for (const ins of findTrieCostPrefixes(this.insDel, b, bi)) {
          yield { a, b, ai, bi: ins.i, c: c + ins.c, p: p + ins.p };
        }
      }
      *calcReplaceCosts(pos) {
        const { a, ai, b, bi, c, p } = pos;
        for (const del of findTrieTrieCostPrefixes(this.replace, a, ai)) {
          for (const ins of findTrieCostPrefixes(del.t, b, bi)) {
            yield { a, b, ai: del.i, bi: ins.i, c: c + ins.c, p: p + ins.p };
          }
        }
      }
      *calcSwapCosts(pos) {
        const { a, ai, b, bi, c, p } = pos;
        const swap = this.swap;
        for (const left of findTrieTrieCostPrefixes(swap, a, ai)) {
          for (const right of findTrieCostPrefixes(left.t, a, left.i)) {
            const sw = a.slice(left.i, right.i) + a.slice(ai, left.i);
            if (b.slice(bi).startsWith(sw)) {
              const len = sw.length;
              yield { a, b, ai: ai + len, bi: bi + len, c: c + right.c, p: p + right.p };
            }
          }
        }
      }
      calcAdjustment(word) {
        let penalty = 0;
        for (const adj of this.adjustments.values()) {
          if (adj.regexp.global) {
            for (const _m of word.matchAll(adj.regexp)) {
              penalty += adj.penalty;
            }
          } else if (adj.regexp.test(word)) {
            penalty += adj.penalty;
          }
        }
        return penalty;
      }
    };
    function prettyPrintInsDel(trie, pfx = "", indent = "  ") {
      function* walk() {
        for (const { s, c, p } of walkTrieCost(trie)) {
          const pm = p ? ` + ${p}` : "";
          yield indent + `(${s}) = ${c}${pm}`;
        }
      }
      return ["InsDel:", ...[...walk()].sort()].map((line) => pfx + line + "\n").join("");
    }
    function prettyPrintReplace(trie, pfx = "", indent = "  ") {
      function* walk() {
        for (const { a, b, c, p } of walkTrieTrieCost(trie)) {
          const pm = p ? ` + ${p}` : "";
          yield indent + `(${a}) -> (${b}) = ${c}${pm}`;
        }
      }
      return ["Replace:", ...[...walk()].sort()].map((line) => pfx + line + "\n").join("");
    }
    exports.prettyPrintReplace = prettyPrintReplace;
    function prettyPrintSwap(trie, pfx = "", indent = "  ") {
      function* walk() {
        for (const { a, b, c, p } of walkTrieTrieCost(trie)) {
          const pm = p ? ` + ${p}` : "";
          yield indent + `(${a}) <-> (${b}) = ${c}${pm}`;
        }
      }
      return ["Swap:", ...[...walk()].sort()].map((line) => pfx + line + "\n").join("");
    }
    exports.prettyPrintSwap = prettyPrintSwap;
    function prettyPrintWeightMap(map) {
      return [prettyPrintInsDel(map.insDel), prettyPrintReplace(map.replace), prettyPrintSwap(map.swap)].join("\n");
    }
    exports.prettyPrintWeightMap = prettyPrintWeightMap;
    function lookupReplaceCost(map, a, b) {
      const trie = map.replace;
      let tt = trie;
      for (let ai = 0; ai < a.length && tt; ++ai) {
        tt = tt.n?.[a[ai]];
      }
      if (!tt)
        return void 0;
      let t = tt.t;
      for (let bi = 0; bi < b.length && t; ++bi) {
        t = t.n?.[b[bi]];
      }
      return t?.c;
    }
    exports.lookupReplaceCost = lookupReplaceCost;
    function normalizeDef(def) {
      const { map, ...rest } = def;
      return { ...rest, map: normalizeMap(map) };
    }
    function normalizeMap(map) {
      return map.replace(matchPossibleWordSeparators, constants_js_1.DEFAULT_COMPOUNDED_WORD_SEPARATOR);
    }
    exports.__testing__ = {
      findTrieCostPrefixes,
      findTrieTrieCostPrefixes,
      normalizeDef,
      splitMap,
      splitMapSubstrings
    };
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/distance/distance.js
var require_distance = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/distance/distance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updatedWeightedMap = exports.createWeightedMap = exports.editDistanceWeighted = exports.editDistance = void 0;
    var distanceAStarWeighted_js_1 = require_distanceAStarWeighted();
    var levenshtein_js_1 = require_levenshtein();
    var weightedMaps_js_1 = require_weightedMaps();
    var defaultCost = 100;
    function editDistance(wordA, wordB, editCost = defaultCost) {
      return (0, levenshtein_js_1.levenshteinDistance)(wordA, wordB) * editCost;
    }
    exports.editDistance = editDistance;
    function editDistanceWeighted(wordA, wordB, weights, editCost = defaultCost) {
      return (0, distanceAStarWeighted_js_1.distanceAStarWeighted)(wordA, wordB, weights, editCost);
    }
    exports.editDistanceWeighted = editDistanceWeighted;
    function createWeightedMap(defs) {
      return (0, weightedMaps_js_1.createWeightMap)(...defs);
    }
    exports.createWeightedMap = createWeightedMap;
    function updatedWeightedMap(weightedMap, def) {
      (0, weightedMaps_js_1.addDefToWeightMap)(weightedMap, def);
    }
    exports.updatedWeightedMap = updatedWeightedMap;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/distance/index.js
var require_distance2 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/distance/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.editDistanceWeighted = exports.editDistance = exports.createWeightedMap = void 0;
    var distance_js_1 = require_distance();
    Object.defineProperty(exports, "createWeightedMap", { enumerable: true, get: function() {
      return distance_js_1.createWeightedMap;
    } });
    Object.defineProperty(exports, "editDistance", { enumerable: true, get: function() {
      return distance_js_1.editDistance;
    } });
    Object.defineProperty(exports, "editDistanceWeighted", { enumerable: true, get: function() {
      return distance_js_1.editDistanceWeighted;
    } });
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/helpers/distribute.js
var require_distribute = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/helpers/distribute.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toDistributableIterable = exports.toDistributableIterableSync = void 0;
    function toDistributableIterableSync(iterable) {
      let lastValue;
      let iter;
      function getNext() {
        if (lastValue && lastValue.done) {
          return { ...lastValue };
        }
        iter = iter || iterable[Symbol.iterator]();
        lastValue = iter.next();
        return lastValue;
      }
      function* iterableFn() {
        let next;
        while (!(next = getNext()).done) {
          yield next.value;
        }
      }
      return {
        [Symbol.iterator]: iterableFn
      };
    }
    exports.toDistributableIterableSync = toDistributableIterableSync;
    exports.toDistributableIterable = toDistributableIterableSync;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/helpers/interleave.js
var require_interleave = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/helpers/interleave.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interleave = void 0;
    function* interleave2(a, b) {
      const ai = a[Symbol.iterator]();
      const bi = b[Symbol.iterator]();
      for (let aNext = ai.next(); !aNext.done; aNext = ai.next()) {
        yield aNext.value;
        const bNext = bi.next();
        if (bNext.done)
          break;
        yield bNext.value;
      }
      for (let aNext = ai.next(); !aNext.done; aNext = ai.next()) {
        yield aNext.value;
      }
      for (let bNext = bi.next(); !bNext.done; bNext = bi.next()) {
        yield bNext.value;
      }
    }
    exports.interleave = interleave2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/helpers/iteratorToIterable.js
var require_iteratorToIterable = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/helpers/iteratorToIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncIteratorToAsyncIterable = exports.iteratorToIterable = void 0;
    function* iteratorToIterable2(iterator) {
      let n;
      while (!(n = iterator.next()).done) {
        yield n.value;
      }
    }
    exports.iteratorToIterable = iteratorToIterable2;
    async function* asyncIteratorToAsyncIterable2(iterator) {
      let n;
      while (!(n = await iterator.next()).done) {
        yield n.value;
      }
    }
    exports.asyncIteratorToAsyncIterable = asyncIteratorToAsyncIterable2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/helpers/util.js
var require_util5 = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/helpers/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsyncIterable = exports.toPipeFn = void 0;
    function toPipeFn2(syncFn, asyncFn) {
      function _(i) {
        return isAsyncIterable3(i) ? asyncFn(i) : syncFn(i);
      }
      return _;
    }
    exports.toPipeFn = toPipeFn2;
    function isAsyncIterable3(i) {
      return typeof i[Symbol.asyncIterator] === "function";
    }
    exports.isAsyncIterable = isAsyncIterable3;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/helpers/toArray.js
var require_toArray = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/helpers/toArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toArrayAsync = exports.toArraySync = exports.toArray = void 0;
    var util_js_1 = require_util5();
    function toArray3(i) {
      return (0, util_js_1.isAsyncIterable)(i) ? toArrayAsync2(i) : toArraySync2(i);
    }
    exports.toArray = toArray3;
    function toArraySync2(iter) {
      return [...iter];
    }
    exports.toArraySync = toArraySync2;
    async function toArrayAsync2(iter) {
      const collection = [];
      for await (const i of iter) {
        collection.push(i);
      }
      return collection;
    }
    exports.toArrayAsync = toArrayAsync2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/helpers/toAsyncIterable.js
var require_toAsyncIterable = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/helpers/toAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAsyncIterable = exports.mergeAsyncIterables = void 0;
    async function* mergeAsyncIterables2(iter, ...rest) {
      for await (const i of [iter, ...rest]) {
        yield* i;
      }
    }
    exports.mergeAsyncIterables = mergeAsyncIterables2;
    exports.toAsyncIterable = mergeAsyncIterables2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/helpers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsyncIterable = exports.toAsyncIterable = exports.toArray = exports.iteratorToIterable = exports.asyncIteratorToAsyncIterable = exports.interleave = exports.toDistributableIterable = void 0;
    var distribute_js_1 = require_distribute();
    Object.defineProperty(exports, "toDistributableIterable", { enumerable: true, get: function() {
      return distribute_js_1.toDistributableIterable;
    } });
    var interleave_js_1 = require_interleave();
    Object.defineProperty(exports, "interleave", { enumerable: true, get: function() {
      return interleave_js_1.interleave;
    } });
    var iteratorToIterable_js_1 = require_iteratorToIterable();
    Object.defineProperty(exports, "asyncIteratorToAsyncIterable", { enumerable: true, get: function() {
      return iteratorToIterable_js_1.asyncIteratorToAsyncIterable;
    } });
    Object.defineProperty(exports, "iteratorToIterable", { enumerable: true, get: function() {
      return iteratorToIterable_js_1.iteratorToIterable;
    } });
    var toArray_js_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_js_1.toArray;
    } });
    var toAsyncIterable_js_1 = require_toAsyncIterable();
    Object.defineProperty(exports, "toAsyncIterable", { enumerable: true, get: function() {
      return toAsyncIterable_js_1.toAsyncIterable;
    } });
    var util_js_1 = require_util5();
    Object.defineProperty(exports, "isAsyncIterable", { enumerable: true, get: function() {
      return util_js_1.isAsyncIterable;
    } });
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/append.js
var require_append = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/append.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opAppend = exports.opAppendSync = exports.opAppendAsync = void 0;
    var index_js_1 = require_helpers();
    function opAppendAsync2(...iterablesToAppend) {
      async function* fn(iter) {
        yield* iter;
        for (const i of iterablesToAppend) {
          yield* i;
        }
      }
      return fn;
    }
    exports.opAppendAsync = opAppendAsync2;
    function opAppendSync2(...iterablesToAppend) {
      function* fn(iter) {
        yield* iter;
        for (const i of iterablesToAppend) {
          yield* i;
        }
      }
      return fn;
    }
    exports.opAppendSync = opAppendSync2;
    function opAppend2(...iterablesToAppend) {
      function _(i) {
        return (0, index_js_1.isAsyncIterable)(i) ? opAppendAsync2(...iterablesToAppend)(i) : opAppendSync2(...iterablesToAppend)(i);
      }
      return _;
    }
    exports.opAppend = opAppend2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/await.js
var require_await = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/await.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opAwaitAsync = void 0;
    async function* _asyncAwait2(iter) {
      for await (const v of iter) {
        yield v;
      }
    }
    function opAwaitAsync2() {
      return _asyncAwait2;
    }
    exports.opAwaitAsync = opAwaitAsync2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/combine.js
var require_combine = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/combine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opCombineSync = exports.opCombineAsync = void 0;
    function opCombineAsync2(...fns) {
      function combine(iter) {
        for (const fn of fns) {
          iter = fn(iter);
        }
        return iter;
      }
      return combine;
    }
    exports.opCombineAsync = opCombineAsync2;
    function opCombineSync2(...fns) {
      function combine(iter) {
        for (const fn of fns) {
          iter = fn(iter);
        }
        return iter;
      }
      return combine;
    }
    exports.opCombineSync = opCombineSync2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/concatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opConcatMap = exports.opConcatMapSync = exports.opConcatMapAsync = void 0;
    var util_js_1 = require_util5();
    function opConcatMapAsync2(mapFn) {
      async function* fn(iter) {
        for await (const v of iter) {
          yield* mapFn(v);
        }
      }
      return fn;
    }
    exports.opConcatMapAsync = opConcatMapAsync2;
    function opConcatMapSync2(mapFn) {
      function* fn(iter) {
        for (const v of iter) {
          yield* mapFn(v);
        }
      }
      return fn;
    }
    exports.opConcatMapSync = opConcatMapSync2;
    var opConcatMap2 = (fn) => (0, util_js_1.toPipeFn)(opConcatMapSync2(fn), opConcatMapAsync2(fn));
    exports.opConcatMap = opConcatMap2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/filter.js
var require_filter = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opFilter = exports.opFilterSync = exports.opFilterAsync = void 0;
    var util_js_1 = require_util5();
    function opFilterAsync3(filterFn) {
      async function* fn(iter) {
        for await (const v of iter) {
          const pass = await filterFn(v);
          if (pass)
            yield v;
        }
      }
      return fn;
    }
    exports.opFilterAsync = opFilterAsync3;
    function opFilterSync2(filterFn) {
      function* fn(iter) {
        for (const v of iter) {
          if (filterFn(v))
            yield v;
        }
      }
      return fn;
    }
    exports.opFilterSync = opFilterSync2;
    function opFilter2(fn) {
      const asyncFn = opFilterAsync3(fn);
      const syncFn = opFilterSync2(fn);
      function _(i) {
        return (0, util_js_1.isAsyncIterable)(i) ? asyncFn(i) : syncFn(i);
      }
      return _;
    }
    exports.opFilter = opFilter2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/first.js
var require_first = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/first.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opFirst = exports.opFirstSync = exports.opFirstAsync = void 0;
    var util_js_1 = require_util5();
    function opFirstAsync2(firstFn) {
      async function* fn(iter) {
        for await (const v of iter) {
          const pass = await firstFn(v);
          if (pass) {
            yield v;
            break;
          }
        }
      }
      return fn;
    }
    exports.opFirstAsync = opFirstAsync2;
    function opFirstSync2(firstFn) {
      function* fn(iter) {
        for (const v of iter) {
          if (firstFn(v)) {
            yield v;
            break;
          }
        }
      }
      return fn;
    }
    exports.opFirstSync = opFirstSync2;
    function opFirst2(fn) {
      const asyncFn = opFirstAsync2(fn);
      const syncFn = opFirstSync2(fn);
      function _(i) {
        return (0, util_js_1.isAsyncIterable)(i) ? asyncFn(i) : syncFn(i);
      }
      return _;
    }
    exports.opFirst = opFirst2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/flatten.js
var require_flatten = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/flatten.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opFlatten = exports.opFlattenSync = exports.opFlattenAsync = void 0;
    var util_js_1 = require_util5();
    function opFlattenAsync2() {
      async function* fn(iter) {
        for await (const v of iter) {
          yield* v;
        }
      }
      return fn;
    }
    exports.opFlattenAsync = opFlattenAsync2;
    function opFlattenSync2() {
      function* fn(iter) {
        for (const v of iter) {
          yield* v;
        }
      }
      return fn;
    }
    exports.opFlattenSync = opFlattenSync2;
    var opFlatten2 = () => (0, util_js_1.toPipeFn)(opFlattenSync2(), opFlattenAsync2());
    exports.opFlatten = opFlatten2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/joinStrings.js
var require_joinStrings = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/joinStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opJoinStrings = exports.opJoinStringsSync = exports.opJoinStringsAsync = void 0;
    var toArray_js_1 = require_toArray();
    var util_js_1 = require_util5();
    function opJoinStringsAsync2(joinCharacter = ",") {
      async function* fn(iter) {
        for await (const v of iter) {
          const a = await (0, toArray_js_1.toArray)(v);
          yield a.join(joinCharacter);
        }
      }
      return fn;
    }
    exports.opJoinStringsAsync = opJoinStringsAsync2;
    function opJoinStringsSync2(joinCharacter = ",") {
      function* fn(iter) {
        for (const v of iter) {
          const a = (0, toArray_js_1.toArray)(v);
          yield a.join(joinCharacter);
        }
      }
      return fn;
    }
    exports.opJoinStringsSync = opJoinStringsSync2;
    var opJoinStrings2 = (joinCharacter) => (0, util_js_1.toPipeFn)(opJoinStringsSync2(joinCharacter), opJoinStringsAsync2(joinCharacter));
    exports.opJoinStrings = opJoinStrings2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/last.js
var require_last = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/last.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opLast = exports.opLastSync = exports.opLastAsync = void 0;
    var util_js_1 = require_util5();
    var symNotFound2 = Symbol("LastNotFound");
    function opLastAsync2(lastFn) {
      async function* fn(iter) {
        let last = symNotFound2;
        for await (const v of iter) {
          const pass = await lastFn(v);
          if (pass) {
            last = v;
          }
        }
        if (last !== symNotFound2)
          yield last;
      }
      return fn;
    }
    exports.opLastAsync = opLastAsync2;
    function opLastSync2(lastFn) {
      function* fn(iter) {
        let last = symNotFound2;
        for (const v of iter) {
          if (lastFn(v)) {
            last = v;
          }
        }
        if (last !== symNotFound2)
          yield last;
      }
      return fn;
    }
    exports.opLastSync = opLastSync2;
    function opLast2(fn) {
      const asyncFn = opLastAsync2(fn);
      const syncFn = opLastSync2(fn);
      function _(i) {
        return (0, util_js_1.isAsyncIterable)(i) ? asyncFn(i) : syncFn(i);
      }
      return _;
    }
    exports.opLast = opLast2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/map.js
var require_map2 = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opMap = exports.opMapSync = exports.opMapAsync = void 0;
    var util_js_1 = require_util5();
    function opMapAsync2(mapFn) {
      async function* fn(iter) {
        for await (const v of iter) {
          yield mapFn(v);
        }
      }
      return fn;
    }
    exports.opMapAsync = opMapAsync2;
    function opMapSync2(mapFn) {
      function* fn(iter) {
        for (const v of iter) {
          yield mapFn(v);
        }
      }
      return fn;
    }
    exports.opMapSync = opMapSync2;
    var opMap2 = (fn) => (0, util_js_1.toPipeFn)(opMapSync2(fn), opMapAsync2(fn));
    exports.opMap = opMap2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/reduce.js
var require_reduce = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opReduceSync = exports.opReduceAsync = void 0;
    var index_js_1 = require_helpers();
    function opReduceAsync2(reduceFn, initialValue) {
      async function* reduce2(head, tail) {
        for await (const v of tail) {
          head = reduceFn(head, v);
        }
        yield head;
      }
      async function* fn(iter) {
        const ht = initialValue === void 0 ? await headTailAsync2(iter) : { head: await initialValue, tail: iter };
        if (!ht)
          return;
        yield* reduce2(ht.head, ht.tail);
      }
      return fn;
    }
    exports.opReduceAsync = opReduceAsync2;
    function opReduceSync2(reduceFn, initialValue) {
      function* reduce2(head, tail) {
        for (const v of tail) {
          head = reduceFn(head, v);
        }
        yield head;
      }
      function* fn(iter) {
        const ht = initialValue === void 0 ? headTail2(iter) : { head: initialValue, tail: iter };
        if (!ht)
          return;
        yield* reduce2(ht.head, ht.tail);
      }
      return fn;
    }
    exports.opReduceSync = opReduceSync2;
    function headTail2(iter) {
      const iterator = iter[Symbol.iterator]();
      const first = iterator.next();
      if (first.done)
        return void 0;
      return { head: first.value, tail: (0, index_js_1.iteratorToIterable)(iterator) };
    }
    async function headTailAsync2(iter) {
      const iterator = isIterable2(iter) ? iter[Symbol.iterator]() : iter[Symbol.asyncIterator]();
      const first = await iterator.next();
      if (first.done)
        return void 0;
      return { head: first.value, tail: (0, index_js_1.asyncIteratorToAsyncIterable)(iterator) };
    }
    function isIterable2(i) {
      return typeof i[Symbol.iterator] === "function";
    }
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/skip.js
var require_skip = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/skip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opSkip = exports.opSkipSync = exports.opSkipAsync = void 0;
    var util_js_1 = require_util5();
    function opSkipAsync2(count) {
      async function* fn(iter) {
        for await (const v of iter) {
          if (count > 0) {
            --count;
            continue;
          }
          yield v;
        }
      }
      return fn;
    }
    exports.opSkipAsync = opSkipAsync2;
    function opSkipSync2(count) {
      function* fn(iter) {
        for (const v of iter) {
          if (count > 0) {
            --count;
            continue;
          }
          yield v;
        }
      }
      return fn;
    }
    exports.opSkipSync = opSkipSync2;
    var opSkip2 = (count) => (0, util_js_1.toPipeFn)(opSkipSync2(count), opSkipAsync2(count));
    exports.opSkip = opSkip2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/take.js
var require_take = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/take.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opTake = exports.opTakeSync = exports.opTakeAsync = void 0;
    var util_js_1 = require_util5();
    function opTakeAsync2(count) {
      async function* fn(iter) {
        if (count <= 0)
          return;
        for await (const v of iter) {
          yield v;
          if (--count <= 0)
            return;
        }
      }
      return fn;
    }
    exports.opTakeAsync = opTakeAsync2;
    function opTakeSync2(count) {
      function* fn(iter) {
        if (count <= 0)
          return;
        for (const v of iter) {
          yield v;
          if (--count <= 0)
            return;
        }
      }
      return fn;
    }
    exports.opTakeSync = opTakeSync2;
    var opTake2 = (count) => (0, util_js_1.toPipeFn)(opTakeSync2(count), opTakeAsync2(count));
    exports.opTake = opTake2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/tap.js
var require_tap = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/tap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opTap = exports.opTapSync = exports.opTapAsync = void 0;
    var util_js_1 = require_util5();
    function opTapAsync2(tapFn) {
      async function* fn(iter) {
        for await (const v of iter) {
          tapFn(v);
          yield v;
        }
      }
      return fn;
    }
    exports.opTapAsync = opTapAsync2;
    function opTapSync2(tapFn) {
      function* fn(iter) {
        for (const v of iter) {
          tapFn(v);
          yield v;
        }
      }
      return fn;
    }
    exports.opTapSync = opTapSync2;
    var opTap2 = (fn) => (0, util_js_1.toPipeFn)(opTapSync2(fn), opTapAsync2(fn));
    exports.opTap = opTap2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/unique.js
var require_unique = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/unique.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opUnique = exports.opUniqueSync = exports.opUniqueAsync = void 0;
    var util_js_1 = require_util5();
    function opUniqueAsync2(k) {
      function fnK(k2) {
        async function* fn2(iter) {
          const s = /* @__PURE__ */ new Set();
          for await (const v of iter) {
            const kk = k2(v);
            if (s.has(kk))
              continue;
            s.add(kk);
            yield v;
          }
        }
        return fn2;
      }
      async function* fn(iter) {
        const s = /* @__PURE__ */ new Set();
        for await (const v of iter) {
          if (s.has(v))
            continue;
          s.add(v);
          yield v;
        }
      }
      return k ? fnK(k) : fn;
    }
    exports.opUniqueAsync = opUniqueAsync2;
    function opUniqueSync2(k) {
      function fnK(key) {
        function* fn2(iter) {
          const s = /* @__PURE__ */ new Set();
          for (const v of iter) {
            const kk = key(v);
            if (s.has(kk))
              continue;
            s.add(kk);
            yield v;
          }
        }
        return fn2;
      }
      function* fn(iter) {
        const s = /* @__PURE__ */ new Set();
        for (const v of iter) {
          if (s.has(v))
            continue;
          s.add(v);
          yield v;
        }
      }
      return k ? fnK(k) : fn;
    }
    exports.opUniqueSync = opUniqueSync2;
    var opUnique2 = (getKey) => (0, util_js_1.toPipeFn)(opUniqueSync2(getKey), opUniqueAsync2(getKey));
    exports.opUnique = opUnique2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/operators/index.js
var require_operators3 = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/operators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opUniqueSync = exports.opUniqueAsync = exports.opUnique = exports.opTapSync = exports.opTapAsync = exports.opTap = exports.opTakeSync = exports.opTakeAsync = exports.opTake = exports.opSkipSync = exports.opSkipAsync = exports.opSkip = exports.opReduceSync = exports.opReduceAsync = exports.opMapSync = exports.opMapAsync = exports.opMap = exports.opLastSync = exports.opLastAsync = exports.opLast = exports.opJoinStringsSync = exports.opJoinStringsAsync = exports.opJoinStrings = exports.opFlattenSync = exports.opFlattenAsync = exports.opFlatten = exports.opFirstSync = exports.opFirstAsync = exports.opFirst = exports.opFilterSync = exports.opFilterAsync = exports.opFilter = exports.opConcatMapSync = exports.opConcatMapAsync = exports.opConcatMap = exports.opCombineSync = exports.opCombineAsync = exports.opAwaitAsync = exports.opAppendSync = exports.opAppendAsync = exports.opAppend = void 0;
    var append_js_1 = require_append();
    Object.defineProperty(exports, "opAppend", { enumerable: true, get: function() {
      return append_js_1.opAppend;
    } });
    Object.defineProperty(exports, "opAppendAsync", { enumerable: true, get: function() {
      return append_js_1.opAppendAsync;
    } });
    Object.defineProperty(exports, "opAppendSync", { enumerable: true, get: function() {
      return append_js_1.opAppendSync;
    } });
    var await_js_1 = require_await();
    Object.defineProperty(exports, "opAwaitAsync", { enumerable: true, get: function() {
      return await_js_1.opAwaitAsync;
    } });
    var combine_js_1 = require_combine();
    Object.defineProperty(exports, "opCombineAsync", { enumerable: true, get: function() {
      return combine_js_1.opCombineAsync;
    } });
    Object.defineProperty(exports, "opCombineSync", { enumerable: true, get: function() {
      return combine_js_1.opCombineSync;
    } });
    var concatMap_js_1 = require_concatMap();
    Object.defineProperty(exports, "opConcatMap", { enumerable: true, get: function() {
      return concatMap_js_1.opConcatMap;
    } });
    Object.defineProperty(exports, "opConcatMapAsync", { enumerable: true, get: function() {
      return concatMap_js_1.opConcatMapAsync;
    } });
    Object.defineProperty(exports, "opConcatMapSync", { enumerable: true, get: function() {
      return concatMap_js_1.opConcatMapSync;
    } });
    var filter_js_1 = require_filter();
    Object.defineProperty(exports, "opFilter", { enumerable: true, get: function() {
      return filter_js_1.opFilter;
    } });
    Object.defineProperty(exports, "opFilterAsync", { enumerable: true, get: function() {
      return filter_js_1.opFilterAsync;
    } });
    Object.defineProperty(exports, "opFilterSync", { enumerable: true, get: function() {
      return filter_js_1.opFilterSync;
    } });
    var first_js_1 = require_first();
    Object.defineProperty(exports, "opFirst", { enumerable: true, get: function() {
      return first_js_1.opFirst;
    } });
    Object.defineProperty(exports, "opFirstAsync", { enumerable: true, get: function() {
      return first_js_1.opFirstAsync;
    } });
    Object.defineProperty(exports, "opFirstSync", { enumerable: true, get: function() {
      return first_js_1.opFirstSync;
    } });
    var flatten_js_1 = require_flatten();
    Object.defineProperty(exports, "opFlatten", { enumerable: true, get: function() {
      return flatten_js_1.opFlatten;
    } });
    Object.defineProperty(exports, "opFlattenAsync", { enumerable: true, get: function() {
      return flatten_js_1.opFlattenAsync;
    } });
    Object.defineProperty(exports, "opFlattenSync", { enumerable: true, get: function() {
      return flatten_js_1.opFlattenSync;
    } });
    var joinStrings_js_1 = require_joinStrings();
    Object.defineProperty(exports, "opJoinStrings", { enumerable: true, get: function() {
      return joinStrings_js_1.opJoinStrings;
    } });
    Object.defineProperty(exports, "opJoinStringsAsync", { enumerable: true, get: function() {
      return joinStrings_js_1.opJoinStringsAsync;
    } });
    Object.defineProperty(exports, "opJoinStringsSync", { enumerable: true, get: function() {
      return joinStrings_js_1.opJoinStringsSync;
    } });
    var last_js_1 = require_last();
    Object.defineProperty(exports, "opLast", { enumerable: true, get: function() {
      return last_js_1.opLast;
    } });
    Object.defineProperty(exports, "opLastAsync", { enumerable: true, get: function() {
      return last_js_1.opLastAsync;
    } });
    Object.defineProperty(exports, "opLastSync", { enumerable: true, get: function() {
      return last_js_1.opLastSync;
    } });
    var map_js_1 = require_map2();
    Object.defineProperty(exports, "opMap", { enumerable: true, get: function() {
      return map_js_1.opMap;
    } });
    Object.defineProperty(exports, "opMapAsync", { enumerable: true, get: function() {
      return map_js_1.opMapAsync;
    } });
    Object.defineProperty(exports, "opMapSync", { enumerable: true, get: function() {
      return map_js_1.opMapSync;
    } });
    var reduce_js_1 = require_reduce();
    Object.defineProperty(exports, "opReduceAsync", { enumerable: true, get: function() {
      return reduce_js_1.opReduceAsync;
    } });
    Object.defineProperty(exports, "opReduceSync", { enumerable: true, get: function() {
      return reduce_js_1.opReduceSync;
    } });
    var skip_js_1 = require_skip();
    Object.defineProperty(exports, "opSkip", { enumerable: true, get: function() {
      return skip_js_1.opSkip;
    } });
    Object.defineProperty(exports, "opSkipAsync", { enumerable: true, get: function() {
      return skip_js_1.opSkipAsync;
    } });
    Object.defineProperty(exports, "opSkipSync", { enumerable: true, get: function() {
      return skip_js_1.opSkipSync;
    } });
    var take_js_1 = require_take();
    Object.defineProperty(exports, "opTake", { enumerable: true, get: function() {
      return take_js_1.opTake;
    } });
    Object.defineProperty(exports, "opTakeAsync", { enumerable: true, get: function() {
      return take_js_1.opTakeAsync;
    } });
    Object.defineProperty(exports, "opTakeSync", { enumerable: true, get: function() {
      return take_js_1.opTakeSync;
    } });
    var tap_js_1 = require_tap();
    Object.defineProperty(exports, "opTap", { enumerable: true, get: function() {
      return tap_js_1.opTap;
    } });
    Object.defineProperty(exports, "opTapAsync", { enumerable: true, get: function() {
      return tap_js_1.opTapAsync;
    } });
    Object.defineProperty(exports, "opTapSync", { enumerable: true, get: function() {
      return tap_js_1.opTapSync;
    } });
    var unique_js_1 = require_unique();
    Object.defineProperty(exports, "opUnique", { enumerable: true, get: function() {
      return unique_js_1.opUnique;
    } });
    Object.defineProperty(exports, "opUniqueAsync", { enumerable: true, get: function() {
      return unique_js_1.opUniqueAsync;
    } });
    Object.defineProperty(exports, "opUniqueSync", { enumerable: true, get: function() {
      return unique_js_1.opUniqueSync;
    } });
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/pipe.js
var require_pipe = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/pipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pipeSync = exports.pipeAsync = void 0;
    var index_js_1 = require_helpers();
    var index_js_2 = require_operators3();
    function pipeAsync2(i, ...fns) {
      const iter = (0, index_js_1.toAsyncIterable)(i);
      return (0, index_js_2.opCombineAsync)(...fns)(iter);
    }
    exports.pipeAsync = pipeAsync2;
    function pipeSync2(i, ...fns) {
      return (0, index_js_2.opCombineSync)(...fns)(i);
    }
    exports.pipeSync = pipeSync2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/reduce.js
var require_reduce2 = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduce = exports.reduceAsync = exports.reduceSync = void 0;
    var index_js_1 = require_helpers();
    var toArray_js_1 = require_toArray();
    var index_js_2 = require_operators3();
    var pipe_js_1 = require_pipe();
    function reduceSync2(iter, reduceFn, initialValue) {
      const i = initialValue === void 0 ? (0, pipe_js_1.pipeSync)(iter, (0, index_js_2.opReduceSync)(reduceFn)) : (0, pipe_js_1.pipeSync)(iter, (0, index_js_2.opReduceSync)(reduceFn, initialValue));
      return [...i][0];
    }
    exports.reduceSync = reduceSync2;
    async function reduceAsync2(iter, reduceFn, initialValue) {
      const i = initialValue === void 0 ? (0, pipe_js_1.pipeAsync)(iter, (0, index_js_2.opReduceAsync)(reduceFn)) : (0, pipe_js_1.pipeAsync)(iter, (0, index_js_2.opReduceAsync)(reduceFn, initialValue));
      const arr = await (0, toArray_js_1.toArrayAsync)(i);
      return arr[0];
    }
    exports.reduceAsync = reduceAsync2;
    function reduce2(iter, reduceFn, initialValue) {
      return (0, index_js_1.isAsyncIterable)(iter) ? reduceAsync2(iter, reduceFn, initialValue) : reduceSync2(iter, reduceFn, initialValue);
    }
    exports.reduce = reduce2;
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.helpers = exports.operators = exports.reduceSync = exports.reduceAsync = exports.reduce = exports.pipeSync = exports.pipeAsync = exports.opUnique = exports.opTap = exports.opTake = exports.opSkip = exports.opMap = exports.opLast = exports.opJoinStrings = exports.opFlatten = exports.opFirst = exports.opFilter = exports.opConcatMap = exports.opAwaitAsync = exports.opAppend = exports.toDistributableIterable = exports.toAsyncIterable = exports.toArray = exports.isAsyncIterable = exports.interleave = void 0;
    var _helpers = __importStar(require_helpers());
    var _operators = __importStar(require_operators3());
    var index_js_1 = require_helpers();
    Object.defineProperty(exports, "interleave", { enumerable: true, get: function() {
      return index_js_1.interleave;
    } });
    Object.defineProperty(exports, "isAsyncIterable", { enumerable: true, get: function() {
      return index_js_1.isAsyncIterable;
    } });
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return index_js_1.toArray;
    } });
    Object.defineProperty(exports, "toAsyncIterable", { enumerable: true, get: function() {
      return index_js_1.toAsyncIterable;
    } });
    Object.defineProperty(exports, "toDistributableIterable", { enumerable: true, get: function() {
      return index_js_1.toDistributableIterable;
    } });
    var index_js_2 = require_operators3();
    Object.defineProperty(exports, "opAppend", { enumerable: true, get: function() {
      return index_js_2.opAppend;
    } });
    Object.defineProperty(exports, "opAwaitAsync", { enumerable: true, get: function() {
      return index_js_2.opAwaitAsync;
    } });
    Object.defineProperty(exports, "opConcatMap", { enumerable: true, get: function() {
      return index_js_2.opConcatMap;
    } });
    Object.defineProperty(exports, "opFilter", { enumerable: true, get: function() {
      return index_js_2.opFilter;
    } });
    Object.defineProperty(exports, "opFirst", { enumerable: true, get: function() {
      return index_js_2.opFirst;
    } });
    Object.defineProperty(exports, "opFlatten", { enumerable: true, get: function() {
      return index_js_2.opFlatten;
    } });
    Object.defineProperty(exports, "opJoinStrings", { enumerable: true, get: function() {
      return index_js_2.opJoinStrings;
    } });
    Object.defineProperty(exports, "opLast", { enumerable: true, get: function() {
      return index_js_2.opLast;
    } });
    Object.defineProperty(exports, "opMap", { enumerable: true, get: function() {
      return index_js_2.opMap;
    } });
    Object.defineProperty(exports, "opSkip", { enumerable: true, get: function() {
      return index_js_2.opSkip;
    } });
    Object.defineProperty(exports, "opTake", { enumerable: true, get: function() {
      return index_js_2.opTake;
    } });
    Object.defineProperty(exports, "opTap", { enumerable: true, get: function() {
      return index_js_2.opTap;
    } });
    Object.defineProperty(exports, "opUnique", { enumerable: true, get: function() {
      return index_js_2.opUnique;
    } });
    var pipe_js_1 = require_pipe();
    Object.defineProperty(exports, "pipeAsync", { enumerable: true, get: function() {
      return pipe_js_1.pipeAsync;
    } });
    Object.defineProperty(exports, "pipeSync", { enumerable: true, get: function() {
      return pipe_js_1.pipeSync;
    } });
    var reduce_js_1 = require_reduce2();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_js_1.reduce;
    } });
    Object.defineProperty(exports, "reduceAsync", { enumerable: true, get: function() {
      return reduce_js_1.reduceAsync;
    } });
    Object.defineProperty(exports, "reduceSync", { enumerable: true, get: function() {
      return reduce_js_1.reduceSync;
    } });
    exports.operators = _operators;
    exports.helpers = _helpers;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/convertToTrieRefNodes.js
var require_convertToTrieRefNodes = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/convertToTrieRefNodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToTrieRefNodes = void 0;
    var gensequence_1 = require_dist2();
    var TrieNode_js_1 = require_TrieNode();
    var MinReferenceCount = 3;
    function convertToTrieRefNodes(root) {
      const eow = { f: TrieNode_js_1.FLAG_WORD, c: void 0 };
      const tallies = /* @__PURE__ */ new Map([[eow, 0]]);
      let count = 0;
      const cached = /* @__PURE__ */ new Map();
      const rollupTally = /* @__PURE__ */ new Map();
      function tally(n) {
        if (n.f && !n.c) {
          tallies.set(eow, (tallies.get(eow) || 0) + 1);
          return;
        }
        const t = tallies.get(n);
        if (t) {
          tallies.set(n, t + 1);
          return;
        }
        tallies.set(n, 1);
        for (const c of n.c?.values() || []) {
          tally(c);
        }
      }
      function rollup(n) {
        const c = rollupTally.get(n);
        if (c) {
          return c;
        }
        if (!n.c) {
          const sum2 = tallies.get(eow) || 0;
          rollupTally.set(n, sum2);
          return sum2;
        }
        const sum = [...n.c.values()].reduce((acc, v) => acc + rollup(v), tallies.get(n) || 0);
        rollupTally.set(n, sum);
        return sum;
      }
      function* walkByTallies(tallies2) {
        const nodes = [...(0, gensequence_1.genSequence)(tallies2).filter((a) => a[1] >= MinReferenceCount)].sort((a, b) => b[1] - a[1]);
        for (const [n] of nodes) {
          yield* walkByRollup(n);
        }
      }
      function* walkByRollup(n) {
        if (cached.has(n))
          return;
        if (n.f && !n.c) {
          cached.set(n, cached.get(eow));
          return;
        }
        const children = [...n.c?.values() || []].sort((a, b) => (rollupTally.get(b) || 0) - (rollupTally.get(a) || 0));
        for (const c of children) {
          yield* walkByRollup(c);
        }
        cached.set(n, count++);
        yield convert(n);
      }
      function convert(n) {
        const { f, c } = n;
        const r = c ? [...c].sort((a, b) => a[0] < b[0] ? -1 : 1).map(([s, n2]) => [s, cached.get(n2)]) : void 0;
        const rn = r ? f ? { f, r } : { r } : { f };
        return rn;
      }
      function* walk(root2) {
        cached.set(eow, count++);
        yield convert(eow);
        yield* walkByTallies(tallies);
        yield* walkByRollup(root2);
      }
      tally(root);
      rollup(root);
      return walk(root);
    }
    exports.convertToTrieRefNodes = convertToTrieRefNodes;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV1.js
var require_importExportV1 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importTrie = exports.serializeTrie = exports.DATA = void 0;
    var gensequence_1 = require_dist2();
    var convertToTrieRefNodes_js_1 = require_convertToTrieRefNodes();
    var trie_util_js_1 = require_trie_util();
    var TrieNode_js_1 = require_TrieNode();
    var EOW = "*";
    exports.DATA = EOW;
    function toReferences(node) {
      return (0, gensequence_1.genSequence)((0, convertToTrieRefNodes_js_1.convertToTrieRefNodes)(node));
    }
    var regExpEscapeChars = /([[\]\\,:{}*])/g;
    var regExTrailingComma = /,(\}|\n)/g;
    function escapeChar(char) {
      return char.replace(regExpEscapeChars, "\\$1");
    }
    function trieToExportString(node, base) {
      function* walk(node2) {
        if (node2.f) {
          yield EOW;
        }
        if (node2.r) {
          const refs = [...node2.r].sort((a, b) => a[0] < b[0] ? -1 : 1);
          for (const n of refs) {
            const [c, r] = n;
            const ref = r ? r.toString(base) : "";
            yield escapeChar(c) + ref + ",";
          }
        }
      }
      return (0, gensequence_1.genSequence)(walk(node));
    }
    function generateHeader(base, comment) {
      const header = ["#!/usr/bin/env cspell-trie reader", "TrieXv1", "base=" + base].concat(comment ? comment.split("\n").map((a) => "# " + a) : []).concat(["# Data:"]);
      return (0, gensequence_1.genSequence)(header).map((a) => a + "\n");
    }
    function serializeTrie(root, options = 16) {
      options = typeof options === "number" ? { base: options } : options;
      const { base = 16, comment = "" } = options;
      const radix = base > 36 ? 36 : base < 10 ? 10 : base;
      const rows = toReferences(root).map((node) => {
        const row = [...trieToExportString(node, radix), "\n"].join("").replace(regExTrailingComma, "$1");
        return row;
      });
      return generateHeader(radix, comment).concat(rows);
    }
    exports.serializeTrie = serializeTrie;
    function* toIterableIterator(iter) {
      yield* iter;
    }
    function importTrie(linesX) {
      let radix = 16;
      const comment = /^\s*#/;
      const iter = toIterableIterator(linesX);
      function parseHeaderRows(headerRows) {
        const header = headerRows.slice(0, 2).join("\n");
        const headerReg = /^TrieXv1\nbase=(\d+)$/;
        if (!headerReg.test(header))
          throw new Error("Unknown file format");
        radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
      }
      function readHeader(iter2) {
        const headerRows = [];
        while (true) {
          const next = iter2.next();
          if (next.done) {
            break;
          }
          const line = next.value.trim();
          if (!line || comment.test(line)) {
            continue;
          }
          if (line === exports.DATA) {
            break;
          }
          headerRows.push(line);
        }
        parseHeaderRows(headerRows);
      }
      const regNotEscapedCommas = /(^|[^\\]),/g;
      const regUnescapeCommas = /__COMMA__/g;
      const regUnescape = /[\\](.)/g;
      const flagsWord = { f: TrieNode_js_1.FLAG_WORD };
      function splitLine(line) {
        const pattern = "$1__COMMA__";
        return line.replace(regNotEscapedCommas, pattern).split(regUnescapeCommas).map((a) => a.replace(regUnescape, "$1"));
      }
      function decodeLine(line, nodes) {
        const isWord = line[0] === EOW;
        line = isWord ? line.slice(1) : line;
        const flags = isWord ? flagsWord : {};
        const children = splitLine(line).filter((a) => !!a).map((a) => [a[0], Number.parseInt(a.slice(1) || "0", radix)]).map(([k, i]) => [k, nodes[i]]);
        const cNode = children.length ? { c: new TrieNode_js_1.ChildMap(children) } : {};
        return { ...cNode, ...flags };
      }
      readHeader(iter);
      const n = (0, gensequence_1.genSequence)([exports.DATA]).concat(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
        const { lines, nodes } = acc;
        const root = decodeLine(line, nodes);
        nodes[lines] = root;
        return { lines: lines + 1, root, nodes };
      }, { lines: 0, nodes: [], root: {} });
      return (0, trie_util_js_1.trieNodeToRoot)(n.root, {});
    }
    exports.importTrie = importTrie;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV2.js
var require_importExportV2 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importTrie = exports.serializeTrie = exports.DATA = void 0;
    var gensequence_1 = require_dist2();
    var trie_util_js_1 = require_trie_util();
    var TrieNode_js_1 = require_TrieNode();
    var EOW = "*";
    exports.DATA = "__DATA__";
    function leaves(node) {
      function toRefNode(node2, k) {
        const refNode = node2;
        refNode.s = refNode.s ?? k;
        return refNode;
      }
      function* walk(node2, k, p) {
        const ref = toRefNode(node2, k);
        if (!ref.c) {
          yield { n: ref, p };
        } else {
          for (const n of ref.c) {
            yield* walk(n[1], n[0], ref);
          }
        }
      }
      return (0, gensequence_1.genSequence)(walk(node, ""));
    }
    function flattenToReferences(node) {
      function* walk() {
        let iterations = 100;
        let processed = 0;
        let index = 0;
        do {
          processed = 0;
          const signatureMap = /* @__PURE__ */ new Map();
          for (const leaf of leaves(node)) {
            const h = signature(leaf.n);
            let m = signatureMap.get(h);
            if (m === void 0) {
              yield leaf.n;
              m = index;
              signatureMap.set(h, m);
              index += 1;
            }
            if (leaf.p && leaf.p.c) {
              leaf.p.r = leaf.p.r || [];
              leaf.p.r.push(m);
              leaf.p.c.delete(leaf.n.s);
              if (!leaf.p.c.size) {
                delete leaf.p.c;
              }
            }
            processed += 1;
          }
          iterations -= 1;
        } while (processed && iterations && node.c);
        yield node;
      }
      return (0, gensequence_1.genSequence)(walk());
    }
    function signature(node) {
      const flags = node.f ? EOW : "";
      const refs = node.r ? node.r.sort((a, b) => a - b).join(",") : "";
      return node.s + flags + refs;
    }
    function toLine(node, base) {
      const flags = node.f ? EOW : "";
      const refs = node.r ? node.r.sort((a, b) => a - b).map((r) => r.toString(base)).join(",") : "";
      return node.s + flags + refs;
    }
    function generateHeader(base, comment) {
      const header = ["#!/usr/bin/env cspell-trie reader", "TrieXv2", "base=" + base].concat(comment ? comment.split("\n").map((a) => "# " + a) : []).concat(["# Data:", exports.DATA]);
      return (0, gensequence_1.genSequence)(header);
    }
    function serializeTrie(root, options = 16) {
      options = typeof options === "number" ? { base: options } : options;
      const { base = 16, comment = "" } = options;
      const radix = base > 36 ? 36 : base < 10 ? 10 : base;
      const rootRef = { ...root, s: "^" };
      const rows = flattenToReferences(rootRef).map((n) => toLine(n, base));
      return generateHeader(radix, comment).concat(rows).map((a) => a + "\n");
    }
    exports.serializeTrie = serializeTrie;
    function* toIterableIterator(iter) {
      yield* iter;
    }
    function importTrie(linesX) {
      let radix = 16;
      const comment = /^\s*#/;
      const iter = toIterableIterator(linesX);
      function parseHeaderRows(headerRows) {
        const header = headerRows.slice(0, 2).join("\n");
        const headerReg = /^TrieXv2\nbase=(\d+)$/;
        if (!headerReg.test(header))
          throw new Error("Unknown file format");
        radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
      }
      function readHeader(iter2) {
        const headerRows = [];
        while (true) {
          const next = iter2.next();
          if (next.done) {
            break;
          }
          const line = next.value.trim();
          if (!line || comment.test(line)) {
            continue;
          }
          if (line === exports.DATA) {
            break;
          }
          headerRows.push(line);
        }
        parseHeaderRows(headerRows);
      }
      function parseLine(line, base) {
        const isWord = line[1] === EOW;
        const refOffset = isWord ? 2 : 1;
        const refs = line.slice(refOffset).split(",").filter((a) => !!a).map((r) => parseInt(r, base));
        return {
          letter: line[0],
          isWord,
          refs
        };
      }
      const flagsWord = { f: TrieNode_js_1.FLAG_WORD };
      function decodeLine(line, nodes) {
        const { letter, isWord, refs } = parseLine(line, radix);
        const flags = isWord ? flagsWord : {};
        const children = refs.map((r) => nodes[r]).sort((a, b) => a.s < b.s ? -1 : 1).map((n2) => [n2.s, n2]);
        const cNode = children.length ? { c: new TrieNode_js_1.ChildMap(children) } : {};
        return { s: letter, ...cNode, ...flags };
      }
      readHeader(iter);
      const n = (0, gensequence_1.genSequence)(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
        const { nodes } = acc;
        const root = decodeLine(line, nodes);
        nodes.push(root);
        return { root, nodes };
      }, { nodes: [], root: { s: "", c: /* @__PURE__ */ new Map() } });
      return (0, trie_util_js_1.trieNodeToRoot)(n.root, {});
    }
    exports.importTrie = importTrie;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/bufferLines.js
var require_bufferLines = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/bufferLines.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferLines = exports.buffer = void 0;
    function* buffer(iter, bufferSize) {
      const buffer2 = [];
      for (const s of iter) {
        buffer2.push(s);
        if (buffer2.length >= bufferSize) {
          yield buffer2;
          buffer2.length = 0;
        }
      }
      if (buffer2.length) {
        yield buffer2;
        buffer2.length = 0;
      }
    }
    exports.buffer = buffer;
    function* bufferLines(iter, bufferSize, eol) {
      if (eol) {
        for (const s of buffer(iter, bufferSize)) {
          yield s.join("") + eol;
        }
      } else {
        for (const s of buffer(iter, bufferSize)) {
          yield s.join("");
        }
      }
    }
    exports.bufferLines = bufferLines;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV3.js
var require_importExportV3 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importTrie = exports.serializeTrie = exports.DATA = void 0;
    var gensequence_1 = require_dist2();
    var trie_util_js_1 = require_trie_util();
    var TrieNode_js_1 = require_TrieNode();
    var bufferLines_js_1 = require_bufferLines();
    var EOW = "$";
    var BACK = "<";
    var EOL = "\n";
    var LF = "\r";
    var REF = "#";
    var EOR = ";";
    var ESCAPE = "\\";
    var specialCharacters = new Set([EOW, BACK, EOL, REF, EOR, ESCAPE, LF].concat("0123456789".split("")).concat("`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|".split("")));
    var specialCharacterMap = /* @__PURE__ */ new Map([
      ["\n", "\\n"],
      ["\r", "\\r"],
      ["\\", "\\\\"]
    ]);
    var characterMap = new Map([...specialCharacterMap].map((a) => [a[1], a[0]]));
    var specialPrefix = stringToCharSet("~!");
    var WORDS_PER_LINE = 20;
    exports.DATA = "__DATA__";
    function generateHeader(base, comment) {
      const header = ["#!/usr/bin/env cspell-trie reader", "TrieXv3", "base=" + base].concat(comment ? comment.split("\n").map((a) => "# " + a) : []).concat(["# Data:", exports.DATA]);
      return (0, gensequence_1.genSequence)(header).map((a) => a + "\n");
    }
    function serializeTrie(root, options = 16) {
      options = typeof options === "number" ? { base: options, addLineBreaksToImproveDiffs: false } : options;
      const { base = 16, comment = "", addLineBreaksToImproveDiffs: addBreaks = true } = options;
      const radix = base > 36 ? 36 : base < 10 ? 10 : base;
      const cache = /* @__PURE__ */ new Map();
      const cacheShouldRef = /* @__PURE__ */ new Map();
      let count = 0;
      const backBuffer = { last: "", count: 0, words: 0, eol: false };
      const optimizeSimpleReferences = options.optimizeSimpleReferences ?? false;
      const wordChars = [];
      function ref(n) {
        return "#" + n.toString(radix) + ";";
      }
      function escape(s) {
        return specialCharacters.has(s) ? ESCAPE + (specialCharacterMap.get(s) || s) : s;
      }
      function* flush() {
        while (backBuffer.count) {
          const n = Math.min(9, backBuffer.count);
          yield n > 1 ? backBuffer.last + n : backBuffer.last;
          backBuffer.last = BACK;
          backBuffer.count -= n;
        }
        if (backBuffer.eol) {
          yield EOL;
          backBuffer.eol = false;
          backBuffer.words = 0;
        }
      }
      function* emit(s) {
        switch (s) {
          case EOW:
            yield* flush();
            backBuffer.last = EOW;
            backBuffer.count = 0;
            backBuffer.words++;
            break;
          case BACK:
            backBuffer.count++;
            break;
          case EOL:
            backBuffer.eol = true;
            break;
          default:
            if (backBuffer.words >= WORDS_PER_LINE) {
              backBuffer.eol = true;
            }
            yield* flush();
            if (s.startsWith(REF)) {
              backBuffer.words++;
            }
            yield s;
        }
      }
      function* walk(node, depth) {
        const r = cache.get(node);
        if (r !== void 0 && (!optimizeSimpleReferences || !shouldSimpleRef(node))) {
          yield* emit(ref(r));
          return;
        }
        if (node.c) {
          if (addBreaks && depth > 0 && depth <= 2) {
            yield* emit(EOL);
          }
          cache.set(node, count++);
          const c = [...node.c].sort((a, b) => a[0] < b[0] ? -1 : 1);
          for (const [s, n] of c) {
            wordChars[depth] = s;
            yield* emit(escape(s));
            yield* walk(n, depth + 1);
            yield* emit(BACK);
            if (depth === 0)
              yield* emit(EOL);
          }
        }
        if (node.f) {
          yield* emit(EOW);
        }
        if (addBreaks && (depth === 2 || depth === 3 && wordChars[0] in specialPrefix)) {
          yield* emit(EOL);
        }
      }
      function* serialize(node) {
        yield* walk(node, 0);
        yield* flush();
      }
      function _calcShouldSimpleRef(node) {
        if (node.c?.size !== 1)
          return false;
        const [n] = [...node.c.values()];
        return !!n.f && (n.c === void 0 || n.c.size === 0);
      }
      function shouldSimpleRef(node) {
        const r = cacheShouldRef.get(node);
        if (r !== void 0)
          return r;
        const rr = _calcShouldSimpleRef(node);
        cacheShouldRef.set(node, rr);
        return rr;
      }
      return generateHeader(radix, comment).concat((0, bufferLines_js_1.bufferLines)(serialize(root), 1200, ""));
    }
    exports.serializeTrie = serializeTrie;
    function* toIterableIterator(iter) {
      yield* iter;
    }
    function importTrie(linesX) {
      linesX = typeof linesX === "string" ? linesX.split(/^/m) : linesX;
      const root = (0, trie_util_js_1.trieNodeToRoot)({}, {});
      let radix = 16;
      const comment = /^\s*#/;
      const iter = toIterableIterator(linesX);
      function parseHeaderRows(headerRows) {
        const header = headerRows.slice(0, 2).join("\n");
        const headerReg = /^TrieXv3\nbase=(\d+)$/;
        if (!headerReg.test(header))
          throw new Error("Unknown file format");
        radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
      }
      function readHeader(iter2) {
        const headerRows = [];
        while (true) {
          const next = iter2.next();
          if (next.done) {
            break;
          }
          const line = next.value.trim().replace(/\r|\n/g, "");
          if (!line || comment.test(line)) {
            continue;
          }
          if (line === exports.DATA) {
            break;
          }
          headerRows.push(line);
        }
        parseHeaderRows(headerRows);
      }
      readHeader(iter);
      const n = (0, gensequence_1.genSequence)(iter).concatMap((a) => a.split("")).reduce(parseStream(radix), {
        nodes: [root],
        root,
        stack: [{ node: root, s: "" }],
        parser: void 0
      });
      return n.root;
    }
    exports.importTrie = importTrie;
    function parseStream(radix) {
      const eow = Object.freeze({ f: 1 });
      function parseReference(acc, _) {
        let ref = "";
        function parser(acc2, s) {
          if (s === EOR) {
            const { root, nodes: nodes2, stack } = acc2;
            const r = parseInt(ref, radix);
            const top = stack[stack.length - 1];
            const p = stack[stack.length - 2].node;
            p.c?.set(top.s, nodes2[r]);
            return { root, nodes: nodes2, stack, parser: void 0 };
          }
          ref = ref + s;
          return acc2;
        }
        const { nodes } = acc;
        nodes.pop();
        return { ...acc, nodes, parser };
      }
      function parseEscapeCharacter(acc, _) {
        let prev = "";
        const parser = function(acc2, s) {
          if (prev) {
            s = characterMap.get(prev + s) || s;
            return parseCharacter({ ...acc2, parser: void 0 }, s);
          }
          if (s === ESCAPE) {
            prev = s;
            return acc2;
          }
          return parseCharacter({ ...acc2, parser: void 0 }, s);
        };
        return { ...acc, parser };
      }
      function parseCharacter(acc, s) {
        const parser = void 0;
        const { root, nodes, stack } = acc;
        const top = stack[stack.length - 1];
        const node = top.node;
        node.c = node.c ?? /* @__PURE__ */ new Map();
        const n = { f: void 0, c: void 0, n: nodes.length };
        node.c.set(s, n);
        stack.push({ node: n, s });
        nodes.push(n);
        return { root, nodes, stack, parser };
      }
      function parseEOW(acc, _) {
        const parser = parseBack;
        const { root, nodes, stack } = acc;
        const top = stack[stack.length - 1];
        const node = top.node;
        node.f = TrieNode_js_1.FLAG_WORD;
        if (!node.c) {
          top.node = eow;
          const p = stack[stack.length - 2].node;
          p.c?.set(top.s, eow);
          nodes.pop();
        }
        stack.pop();
        return { root, nodes, stack, parser };
      }
      const charactersBack = new Set((BACK + "23456789").split(""));
      function parseBack(acc, s) {
        if (!charactersBack.has(s)) {
          return parserMain({ ...acc, parser: void 0 }, s);
        }
        let n = s === BACK ? 1 : parseInt(s, 10) - 1;
        const { stack } = acc;
        while (n-- > 0) {
          stack.pop();
        }
        return { ...acc, parser: parseBack };
      }
      function parseIgnore(acc, _) {
        return acc;
      }
      const parsers = /* @__PURE__ */ new Map([
        [EOW, parseEOW],
        [BACK, parseBack],
        [REF, parseReference],
        [ESCAPE, parseEscapeCharacter],
        [EOL, parseIgnore],
        [LF, parseIgnore]
      ]);
      function parserMain(acc, s) {
        const parser = acc.parser ?? parsers.get(s) ?? parseCharacter;
        return parser(acc, s);
      }
      return parserMain;
    }
    function stringToCharSet(values) {
      const set = /* @__PURE__ */ Object.create(null);
      const len = values.length;
      for (let i = 0; i < len; ++i) {
        set[values[i]] = true;
      }
      return set;
    }
  }
});

// node_modules/@cspell/cspell-pipe/dist/cjs/sync/index.js
var require_sync = __commonJS({
  "node_modules/@cspell/cspell-pipe/dist/cjs/sync/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduce = exports.pipeSync = exports.pipe = exports.opUnique = exports.opTap = exports.opTake = exports.opSkip = exports.opReduce = exports.opMap = exports.opLast = exports.opJoinStrings = exports.opFlatten = exports.opFirst = exports.opFilter = exports.opConcatMap = exports.opCombine = exports.opAppend = exports.toArray = void 0;
    var toArray_js_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_js_1.toArraySync;
    } });
    var index_js_1 = require_operators3();
    Object.defineProperty(exports, "opAppend", { enumerable: true, get: function() {
      return index_js_1.opAppendSync;
    } });
    Object.defineProperty(exports, "opCombine", { enumerable: true, get: function() {
      return index_js_1.opCombineSync;
    } });
    Object.defineProperty(exports, "opConcatMap", { enumerable: true, get: function() {
      return index_js_1.opConcatMapSync;
    } });
    Object.defineProperty(exports, "opFilter", { enumerable: true, get: function() {
      return index_js_1.opFilterSync;
    } });
    Object.defineProperty(exports, "opFirst", { enumerable: true, get: function() {
      return index_js_1.opFirstSync;
    } });
    Object.defineProperty(exports, "opFlatten", { enumerable: true, get: function() {
      return index_js_1.opFlattenSync;
    } });
    Object.defineProperty(exports, "opJoinStrings", { enumerable: true, get: function() {
      return index_js_1.opJoinStringsSync;
    } });
    Object.defineProperty(exports, "opLast", { enumerable: true, get: function() {
      return index_js_1.opLastSync;
    } });
    Object.defineProperty(exports, "opMap", { enumerable: true, get: function() {
      return index_js_1.opMapSync;
    } });
    Object.defineProperty(exports, "opReduce", { enumerable: true, get: function() {
      return index_js_1.opReduceSync;
    } });
    Object.defineProperty(exports, "opSkip", { enumerable: true, get: function() {
      return index_js_1.opSkipSync;
    } });
    Object.defineProperty(exports, "opTake", { enumerable: true, get: function() {
      return index_js_1.opTakeSync;
    } });
    Object.defineProperty(exports, "opTap", { enumerable: true, get: function() {
      return index_js_1.opTapSync;
    } });
    Object.defineProperty(exports, "opUnique", { enumerable: true, get: function() {
      return index_js_1.opUniqueSync;
    } });
    var pipe_js_1 = require_pipe();
    Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
      return pipe_js_1.pipeSync;
    } });
    Object.defineProperty(exports, "pipeSync", { enumerable: true, get: function() {
      return pipe_js_1.pipeSync;
    } });
    var reduce_js_1 = require_reduce2();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_js_1.reduceSync;
    } });
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV4.js
var require_importExportV4 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/io/importExportV4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.importTrie = exports.serializeTrie = exports.DATA = void 0;
    var sync_1 = require_sync();
    var gensequence_1 = require_dist2();
    var trie_util_js_1 = require_trie_util();
    var TrieNode_js_1 = require_TrieNode();
    var bufferLines_js_1 = require_bufferLines();
    var EOW = "$";
    var BACK = "<";
    var EOL = "\n";
    var LF = "\r";
    var REF = "#";
    var REF_REL = "@";
    var EOR = ";";
    var ESCAPE = "\\";
    var REF_INDEX_BEGIN = "[";
    var REF_INDEX_END = "]";
    var INLINE_DATA_COMMENT_LINE = "/";
    var specialCharacters = stringToCharSet([EOW, BACK, EOL, REF, REF_REL, EOR, ESCAPE, LF, REF_INDEX_BEGIN, REF_INDEX_END, INLINE_DATA_COMMENT_LINE].concat("0123456789".split("")).concat("`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|".split("")).join(""));
    var SPECIAL_CHARACTERS_MAP = [
      ["\n", "\\n"],
      ["\r", "\\r"],
      ["\\", "\\\\"]
    ];
    var specialCharacterMap = stringToCharMap(SPECIAL_CHARACTERS_MAP);
    var characterMap = stringToCharMap(SPECIAL_CHARACTERS_MAP.map((a) => [a[1], a[0]]));
    var specialPrefix = stringToCharSet("~!");
    var WORDS_PER_LINE = 20;
    exports.DATA = "__DATA__";
    function generateHeader(base, comment) {
      const comments = comment.split("\n").map((a) => "# " + a.trimEnd()).join("\n");
      return `#!/usr/bin/env cspell-trie reader
TrieXv4
base=${base}
${comments}
# Data:
${exports.DATA}
`;
    }
    function serializeTrie(root, options = 16) {
      options = typeof options === "number" ? { base: options } : options;
      const { base = 10, comment = "" } = options;
      const radix = base > 36 ? 36 : base < 10 ? 10 : base;
      const cache = /* @__PURE__ */ new Map();
      const refMap = buildReferenceMap(root, base);
      const nodeToIndexMap = new Map(refMap.refCounts.map(([node], index) => [node, index]));
      let count = 0;
      const backBuffer = { last: "", count: 0, words: 0, eol: false };
      const wordChars = [];
      function ref(n, idx) {
        const r = idx === void 0 || n < idx ? REF + n.toString(radix) : REF_REL + idx.toString(radix);
        return radix === 10 ? r : r + ";";
      }
      function escape(s) {
        return s in specialCharacters ? ESCAPE + (specialCharacterMap[s] || s) : s;
      }
      function* flush() {
        while (backBuffer.count) {
          const n = Math.min(9, backBuffer.count);
          yield n > 1 ? backBuffer.last + n : backBuffer.last;
          backBuffer.last = BACK;
          backBuffer.count -= n;
        }
        if (backBuffer.eol) {
          yield EOL;
          backBuffer.eol = false;
          backBuffer.words = 0;
        }
      }
      function* emit(s) {
        switch (s) {
          case EOW:
            yield* flush();
            backBuffer.last = EOW;
            backBuffer.count = 0;
            backBuffer.words++;
            break;
          case BACK:
            backBuffer.count++;
            break;
          case EOL:
            backBuffer.eol = true;
            break;
          default:
            if (backBuffer.words >= WORDS_PER_LINE) {
              backBuffer.eol = true;
            }
            yield* flush();
            if (s.startsWith(REF) || s.startsWith(REF_REL)) {
              backBuffer.words++;
            }
            yield s;
        }
      }
      const comment_begin = `${EOL}${INLINE_DATA_COMMENT_LINE}* `;
      const comment_end = ` *${INLINE_DATA_COMMENT_LINE}${EOL}`;
      function* walk(node, depth) {
        const nodeNumber = cache.get(node);
        const refIndex = nodeToIndexMap.get(node);
        if (nodeNumber !== void 0) {
          yield* emit(ref(nodeNumber, refIndex));
          return;
        }
        if (node.c) {
          if (depth > 0 && depth <= 2) {
            const chars = wordChars.slice(0, depth).map(escape).join("");
            yield* emit(comment_begin + chars + comment_end);
          }
          cache.set(node, count++);
          const c = [...node.c].sort((a, b) => a[0] < b[0] ? -1 : 1);
          for (const [s, n] of c) {
            wordChars[depth] = s;
            yield* emit(escape(s));
            yield* walk(n, depth + 1);
            yield* emit(BACK);
            if (depth === 0)
              yield* emit(EOL);
          }
        }
        if (node.f) {
          yield* emit(EOW);
        }
        if (depth === 2 || depth === 3 && wordChars[0] in specialPrefix) {
          yield* emit(EOL);
        }
      }
      function* serialize(node) {
        yield* walk(node, 0);
        yield* flush();
      }
      const lines = [...(0, bufferLines_js_1.bufferLines)(serialize(root), 1e3, "")];
      const resolvedReferences = refMap.refCounts.map(([node]) => cache.get(node) || 0);
      const reference = "[\n" + resolvedReferences.map((n) => n.toString(radix)).join(",").replace(/.{110,130}[,]/g, "$&\n") + "\n]\n";
      return (0, gensequence_1.genSequence)([generateHeader(radix, comment), reference]).concat(lines);
    }
    exports.serializeTrie = serializeTrie;
    function buildReferenceMap(root, base) {
      const refCount = /* @__PURE__ */ new Map();
      let nodeCount = 0;
      function walk(node) {
        const ref = refCount.get(node);
        if (ref) {
          ref.c++;
          return;
        }
        refCount.set(node, { c: 1, n: nodeCount++ });
        if (!node.c)
          return;
        for (const child of node.c.values()) {
          walk(child);
        }
      }
      walk(root);
      const refCountAndNode = [
        ...(0, sync_1.pipe)(refCount, (0, sync_1.opFilter)(([_, ref]) => ref.c >= 2))
      ].sort((a, b) => b[1].c - a[1].c || a[1].n - b[1].n);
      let adj = 0;
      const baseLogScale = 1 / Math.log(base);
      const refs = refCountAndNode.filter(([_, ref], idx) => {
        const i = idx - adj;
        const charsIdx = Math.ceil(Math.log(i) * baseLogScale);
        const charsNode = Math.ceil(Math.log(ref.n) * baseLogScale);
        const savings = ref.c * (charsNode - charsIdx) - charsIdx;
        const keep = savings > 0;
        adj += keep ? 0 : 1;
        return keep;
      }).map(([n, ref]) => [n, ref.c]);
      return { refCounts: refs };
    }
    function importTrie(linesX) {
      linesX = typeof linesX === "string" ? linesX.split(/^/m) : linesX;
      let radix = 10;
      const comment = /^\s*#/;
      const iter = tapIterable((0, sync_1.pipe)(linesX, (0, sync_1.opConcatMap)((a) => a.split(/^/m))));
      function parseHeaderRows(headerRows) {
        const header = headerRows.slice(0, 2).join("\n");
        const headerReg = /^TrieXv[34]\nbase=(\d+)$/;
        if (!headerReg.test(header))
          throw new Error("Unknown file format");
        radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
      }
      function readHeader(iter2) {
        const headerRows = [];
        for (const value of iter2) {
          const line = value.trim();
          if (!line || comment.test(line))
            continue;
          if (line === exports.DATA)
            break;
          headerRows.push(line);
        }
        parseHeaderRows(headerRows);
      }
      readHeader(iter);
      const root = parseStream(radix, iter);
      return root;
    }
    exports.importTrie = importTrie;
    var numbersSet = stringToCharSet("0123456789");
    function parseStream(radix, iter) {
      const eow = Object.freeze({ f: 1 });
      let refIndex = [];
      const root = (0, trie_util_js_1.trieNodeToRoot)({}, {});
      function parseReference(acc, s) {
        const isIndexRef = s === REF_REL;
        let ref = "";
        function parser(acc2, s2) {
          if (s2 === EOR || radix === 10 && !(s2 in numbersSet)) {
            const { root: root2, nodes: nodes2, stack } = acc2;
            const r = parseInt(ref, radix);
            const top = stack[stack.length - 1];
            const p = stack[stack.length - 2].node;
            const n = isIndexRef ? refIndex[r] : r;
            p.c?.set(top.s, nodes2[n]);
            const rr = { root: root2, nodes: nodes2, stack, parser: void 0 };
            return s2 === EOR ? rr : parserMain(rr, s2);
          }
          ref = ref + s2;
          return acc2;
        }
        const { nodes } = acc;
        nodes.pop();
        return { ...acc, nodes, parser };
      }
      function parseEscapeCharacter(acc, _) {
        let prev = "";
        const parser = function(acc2, s) {
          if (prev) {
            s = characterMap[prev + s] || s;
            return parseCharacter({ ...acc2, parser: void 0 }, s);
          }
          if (s === ESCAPE) {
            prev = s;
            return acc2;
          }
          return parseCharacter({ ...acc2, parser: void 0 }, s);
        };
        return { ...acc, parser };
      }
      function parseComment(acc, s) {
        const endOfComment = s;
        let isEscaped = false;
        function parser(acc2, s2) {
          if (isEscaped) {
            isEscaped = false;
            return acc2;
          }
          if (s2 === ESCAPE) {
            isEscaped = true;
            return acc2;
          }
          if (s2 === endOfComment) {
            return { ...acc2, parser: void 0 };
          }
          return acc2;
        }
        return { ...acc, parser };
      }
      function parseCharacter(acc, s) {
        const parser = void 0;
        const { root: root2, nodes, stack } = acc;
        const top = stack[stack.length - 1];
        const node = top.node;
        node.c = node.c ?? /* @__PURE__ */ new Map();
        const n = { f: void 0, c: void 0, n: nodes.length };
        node.c.set(s, n);
        stack.push({ node: n, s });
        nodes.push(n);
        return { root: root2, nodes, stack, parser };
      }
      function parseEOW(acc, _) {
        const parser = parseBack;
        const { root: root2, nodes, stack } = acc;
        const top = stack[stack.length - 1];
        const node = top.node;
        node.f = TrieNode_js_1.FLAG_WORD;
        if (!node.c) {
          top.node = eow;
          const p = stack[stack.length - 2].node;
          p.c?.set(top.s, eow);
          nodes.pop();
        }
        stack.pop();
        return { root: root2, nodes, stack, parser };
      }
      const charactersBack = stringToCharSet(BACK + "23456789");
      function parseBack(acc, s) {
        if (!(s in charactersBack)) {
          return parserMain({ ...acc, parser: void 0 }, s);
        }
        let n = s === BACK ? 1 : parseInt(s, 10) - 1;
        const { stack } = acc;
        while (n-- > 0) {
          stack.pop();
        }
        return { ...acc, parser: parseBack };
      }
      function parseIgnore(acc, _) {
        return acc;
      }
      const parsers = createStringLookupMap([
        [EOW, parseEOW],
        [BACK, parseBack],
        [REF, parseReference],
        [REF_REL, parseReference],
        [ESCAPE, parseEscapeCharacter],
        [EOL, parseIgnore],
        [LF, parseIgnore],
        [INLINE_DATA_COMMENT_LINE, parseComment]
      ]);
      function parserMain(acc, s) {
        const parser = acc.parser ?? parsers[s] ?? parseCharacter;
        return parser(acc, s);
      }
      const charsetSpaces = stringToCharSet(" \r\n	");
      function parseReferenceIndex(acc, s) {
        let json = "";
        function parserStart(acc2, s2) {
          if (s2 === REF_INDEX_BEGIN) {
            json = json + s2;
            return { ...acc2, parser };
          }
          if (s2 in charsetSpaces) {
            return acc2;
          }
          return parserMain({ ...acc2, parser: void 0 }, s2);
        }
        function parser(acc2, s2) {
          json = json + s2;
          if (s2 === REF_INDEX_END) {
            refIndex = json.replace(/[\s[\]]/g, "").split(",").map((n) => parseInt(n, radix));
            return { ...acc2, parser: void 0 };
          }
          return acc2;
        }
        return parserStart({ ...acc, parser: parserStart }, s);
      }
      (0, gensequence_1.genSequence)(iter).concatMap((a) => a.split("")).reduce(parserMain, {
        nodes: [root],
        root,
        stack: [{ node: root, s: "" }],
        parser: parseReferenceIndex
      });
      return root;
    }
    function stringToCharSet(values) {
      const set = /* @__PURE__ */ Object.create(null);
      const len = values.length;
      for (let i = 0; i < len; ++i) {
        set[values[i]] = true;
      }
      return set;
    }
    function stringToCharMap(values) {
      return createStringLookupMap(values);
    }
    function createStringLookupMap(values) {
      const map = /* @__PURE__ */ Object.create(null);
      const len = values.length;
      for (let i = 0; i < len; ++i) {
        map[values[i][0]] = values[i][1];
      }
      return map;
    }
    function tapIterable(iterable) {
      let lastValue;
      let iter;
      function getNext() {
        if (lastValue && lastValue.done) {
          return { ...lastValue };
        }
        iter = iter || iterable[Symbol.iterator]();
        lastValue = iter.next();
        return lastValue;
      }
      function* iterableFn() {
        let next;
        while (!(next = getNext()).done) {
          yield next.value;
        }
      }
      return {
        [Symbol.iterator]: iterableFn
      };
    }
    exports.__testing__ = {
      buildReferenceMap
    };
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/io/importExport.js
var require_importExport = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/io/importExport.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importTrie = exports.serializeTrie = void 0;
    var cspell_pipe_1 = require_cjs4();
    var gensequence_1 = require_dist2();
    var iv1 = __importStar(require_importExportV1());
    var iv2 = __importStar(require_importExportV2());
    var iv3 = __importStar(require_importExportV3());
    var iv4 = __importStar(require_importExportV4());
    var serializers = [
      iv1.serializeTrie,
      iv1.serializeTrie,
      iv2.serializeTrie,
      iv3.serializeTrie,
      iv4.serializeTrie
    ];
    var deserializers = [iv1.importTrie, iv1.importTrie, iv2.importTrie, iv3.importTrie, iv4.importTrie];
    var DEFAULT_VERSION = 3;
    function serializeTrie(root, options = 16) {
      const version3 = typeof options !== "number" && options.version ? options.version : DEFAULT_VERSION;
      const method = serializers[version3];
      if (!method) {
        throw new Error(`Unknown version: ${version3}`);
      }
      return method(root, options);
    }
    exports.serializeTrie = serializeTrie;
    function importTrie(lines) {
      function parseHeaderRows(headerRows) {
        const header = headerRows.join("\n");
        const headerReg = /^\s*TrieXv(\d+)/m;
        const match = header.match(headerReg);
        if (!match)
          throw new Error("Unknown file format");
        return parseInt(match[1], 10);
      }
      function readHeader(iter) {
        const headerRows = [];
        for (const entry of iter) {
          const line = entry.trim();
          headerRows.push(line);
          if (line === iv1.DATA || line === iv2.DATA) {
            break;
          }
        }
        return headerRows;
      }
      const input = (0, cspell_pipe_1.toDistributableIterable)(lines);
      const headerLines = readHeader(input);
      const version3 = parseHeaderRows(headerLines);
      const stream = (0, gensequence_1.genSequence)(headerLines).concat(input);
      const method = deserializers[version3];
      if (!method) {
        throw new Error(`Unsupported version: ${version3}`);
      }
      return method(stream);
    }
    exports.importTrie = importTrie;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/models/locale/knownLocales.js
var require_knownLocales = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/models/locale/knownLocales.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.codes = void 0;
    exports.codes = [
      // ['code', 'language'[', ''locale']],
      ["af", "Afrikaans"],
      ["af-NA", "Afrikaans", "Namibia"],
      ["af-ZA", "Afrikaans", "South Africa"],
      ["ak", "Akan"],
      ["ak-GH", "Akan", "Ghana"],
      ["am", "Amharic"],
      ["am-ET", "Amharic", "Ethiopia"],
      ["ar", "Arabic"],
      ["ar-1", "Arabic"],
      ["ar-AE", "Arabic", "United Arab Emirates"],
      ["ar-BH", "Arabic", "Bahrain"],
      ["ar-DJ", "Arabic", "Djibouti"],
      ["ar-DZ", "Arabic", "Algeria"],
      ["ar-EG", "Arabic", "Egypt"],
      ["ar-EH", "Arabic"],
      ["ar-ER", "Arabic", "Eritrea"],
      ["ar-IL", "Arabic", "Israel"],
      ["ar-IQ", "Arabic", "Iraq"],
      ["ar-JO", "Arabic", "Jordan"],
      ["ar-KM", "Arabic", "Comoros"],
      ["ar-KW", "Arabic", "Kuwait"],
      ["ar-LB", "Arabic", "Lebanon"],
      ["ar-LY", "Arabic", "Libya"],
      ["ar-MA", "Arabic", "Morocco"],
      ["ar-MR", "Arabic", "Mauritania"],
      ["ar-OM", "Arabic", "Oman"],
      ["ar-PS", "Arabic"],
      ["ar-QA", "Arabic", "Qatar"],
      ["ar-SA", "Arabic", "Saudi Arabia"],
      ["ar-SD", "Arabic", "Sudan"],
      ["ar-SO", "Arabic", "Somalia"],
      ["ar-SS", "Arabic"],
      ["ar-SY", "Arabic", "Syria"],
      ["ar-TD", "Arabic", "Chad"],
      ["ar-TN", "Arabic", "Tunisia"],
      ["ar-YE", "Arabic", "Yemen"],
      ["as", "Assamese"],
      ["as-IN", "Assamese", "India"],
      ["az", "Azerbaijani"],
      ["az-AZ", "Azerbaijani", "Azerbaijan"],
      ["be", "Belarusian"],
      ["be-BY", "Belarusian", "Belarus"],
      ["bg", "Bulgarian"],
      ["bg-BG", "Bulgarian", "Bulgaria"],
      ["bm", "Bambara"],
      ["bm-ML", "Bambara", "Mali"],
      ["bn", "Bengali"],
      ["bn-BD", "Bengali", "Bangladesh"],
      ["bn-IN", "Bengali", "India"],
      ["bo", "Tibetan"],
      ["bo-CN", "Tibetan", "China"],
      ["bo-IN", "Tibetan", "India"],
      ["br", "Breton"],
      ["br-FR", "Breton", "France"],
      ["bs", "Bosnian"],
      ["bs-BA", "Bosnian", "Bosnia and Herzegovina"],
      ["ca", "Catalan"],
      ["ca-AD", "Catalan", "Andorra"],
      ["ca-ES", "Catalan", "Spain"],
      ["ca-FR", "Catalan", "France"],
      ["ca-IT", "Catalan", "Italy"],
      ["ce", "Chechen"],
      ["ce-RU", "Chechen", "Russia"],
      ["cs", "Czech"],
      ["cs-CZ", "Czech", "Czech Republic"],
      ["cu", "Old Slavonic"],
      ["cu-RU", "Old Slavonic", "Russia"],
      ["cy", "Welsh"],
      ["cy-GB", "Welsh", "United Kingdom"],
      ["da", "Danish"],
      ["da-DK", "Danish", "Denmark"],
      ["da-GL", "Danish", "Greenland"],
      ["de", "German"],
      ["de-AT", "German", "Austria"],
      ["de-BE", "German", "Belgium"],
      ["de-CH", "German", "Switzerland"],
      ["de-DE", "German", "Germany"],
      ["de-IT", "German", "Italy"],
      ["de-LI", "German", "Liechtenstein"],
      ["de-LU", "German", "Luxembourg"],
      ["dz", "Dzongkha"],
      ["dz-BT", "Dzongkha", "Bhutan"],
      ["ee", "Ewe"],
      ["ee-GH", "Ewe", "Ghana"],
      ["ee-TG", "Ewe", "Togo"],
      ["el", "Greek", "Modern (1453-)"],
      ["el-CY", "Greek", "Cyprus"],
      ["el-GR", "Greek", "Greece"],
      ["en", "English"],
      ["en-AG", "English", "Antigua and Barbuda"],
      ["en-AI", "English", "Anguilla"],
      ["en-AS", "English", "American Samoa"],
      ["en-AT", "English", "Austria"],
      ["en-AU", "English", "Australia"],
      ["en-BB", "English", "Barbados"],
      ["en-BE", "English", "Belgium"],
      ["en-BI", "English", "Burundi"],
      ["en-BM", "English", "Bermuda"],
      ["en-BS", "English", "Bahamas"],
      ["en-BW", "English", "Botswana"],
      ["en-BZ", "English", "Belize"],
      ["en-CA", "English", "Canada"],
      ["en-CC", "English", "Cocos (Keeling) Islands"],
      ["en-CH", "English", "Switzerland"],
      ["en-CK", "English", "Cook Islands"],
      ["en-CM", "English", "Cameroon"],
      ["en-CX", "English", "Christmas Island"],
      ["en-CY", "English", "Cyprus"],
      ["en-DE", "English", "Germany"],
      ["en-DG", "English"],
      ["en-DK", "English", "Denmark"],
      ["en-DM", "English", "Dominica"],
      ["en-ER", "English", "Eritrea"],
      ["en-FI", "English", "Finland"],
      ["en-FJ", "English", "Fiji"],
      ["en-FK", "English", "Falkland Islands (Islas Malvinas)"],
      ["en-FM", "English", "Micronesia"],
      ["en-GB", "English", "United Kingdom"],
      ["en-GD", "English", "Grenada"],
      ["en-GG", "English", "Guernsey"],
      ["en-GH", "English", "Ghana"],
      ["en-GI", "English", "Gibraltar"],
      ["en-GM", "English", "Gambia"],
      ["en-GU", "English", "Guam"],
      ["en-GY", "English", "Guyana"],
      ["en-HK", "English", "Hong Kong"],
      ["en-IE", "English", "Ireland"],
      ["en-IL", "English", "Israel"],
      ["en-IM", "English", "Isle of Man"],
      ["en-IN", "English", "India"],
      ["en-IO", "English", "British Indian Ocean Territory"],
      ["en-JE", "English", "Jersey"],
      ["en-JM", "English", "Jamaica"],
      ["en-KE", "English", "Kenya"],
      ["en-KI", "English", "Kiribati"],
      ["en-KN", "English", "Saint Kitts and Nevis"],
      ["en-KY", "English", "Cayman Islands"],
      ["en-LC", "English", "Saint Lucia"],
      ["en-LR", "English", "Liberia"],
      ["en-LS", "English", "Lesotho"],
      ["en-MG", "English", "Madagascar"],
      ["en-MH", "English", "Marshall Islands"],
      ["en-MO", "English", "Macau"],
      ["en-MP", "English", "Northern Mariana Islands"],
      ["en-MS", "English", "Montserrat"],
      ["en-MT", "English", "Malta"],
      ["en-MU", "English", "Mauritius"],
      ["en-MW", "English", "Malawi"],
      ["en-MY", "English", "Malaysia"],
      ["en-NA", "English", "Namibia"],
      ["en-NF", "English", "Norfolk Island"],
      ["en-NG", "English", "Nigeria"],
      ["en-NL", "English", "Netherlands"],
      ["en-NR", "English", "Nauru"],
      ["en-NU", "English", "Niue"],
      ["en-NZ", "English", "New Zealand"],
      ["en-PG", "English", "Papua New Guinea"],
      ["en-PH", "English", "Philippines"],
      ["en-PK", "English", "Pakistan"],
      ["en-PN", "English", "Pitcairn Islands"],
      ["en-PR", "English", "Puerto Rico"],
      ["en-PW", "English", "Palau"],
      ["en-RW", "English", "Rwanda"],
      ["en-SB", "English", "Solomon Islands"],
      ["en-SC", "English", "Seychelles"],
      ["en-SD", "English", "Sudan"],
      ["en-SE", "English", "Sweden"],
      ["en-SG", "English", "Singapore"],
      ["en-SH", "English", "Saint Helena"],
      ["en-SI", "English", "Slovenia"],
      ["en-SL", "English", "Sierra Leone"],
      ["en-SS", "English"],
      ["en-SX", "English"],
      ["en-SZ", "English", "Swaziland"],
      ["en-TC", "English", "Turks and Caicos Islands"],
      ["en-TK", "English", "Tokelau"],
      ["en-TO", "English", "Tonga"],
      ["en-TT", "English", "Trinidad and Tobago"],
      ["en-TV", "English", "Tuvalu"],
      ["en-TZ", "English", "Tanzania"],
      ["en-UG", "English", "Uganda"],
      ["en-UM", "English", "Baker Island"],
      ["en-US", "English", "United States"],
      ["en-VC", "English", "Saint Vincent and the Grenadines"],
      ["en-VG", "English", "British Virgin Islands"],
      ["en-VI", "English", "U.S. Virgin Islands"],
      ["en-VU", "English", "Vanuatu"],
      ["en-WS", "English", "Samoa"],
      ["en-ZA", "English", "South Africa"],
      ["en-ZM", "English", "Zambia"],
      ["en-ZW", "English", "Zimbabwe"],
      ["eo", "Esperanto"],
      ["es", "Spanish"],
      ["es-AR", "Spanish", "Argentina"],
      ["es-BO", "Spanish", "Bolivia"],
      ["es-BR", "Spanish", "Brazil"],
      ["es-BZ", "Spanish", "Belize"],
      ["es-CL", "Spanish", "Chile"],
      ["es-CO", "Spanish", "Colombia"],
      ["es-CR", "Spanish", "Costa Rica"],
      ["es-CU", "Spanish", "Cuba"],
      ["es-DO", "Spanish", "Dominican Republic"],
      ["es-EA", "Spanish"],
      ["es-EC", "Spanish", "Ecuador"],
      ["es-ES", "Spanish", "Spain"],
      ["es-GQ", "Spanish", "Equatorial Guinea"],
      ["es-GT", "Spanish", "Guatemala"],
      ["es-HN", "Spanish", "Honduras"],
      ["es-IC", "Spanish"],
      ["es-MX", "Spanish", "Mexico"],
      ["es-NI", "Spanish", "Nicaragua"],
      ["es-PA", "Spanish", "Panama"],
      ["es-PE", "Spanish", "Peru"],
      ["es-PH", "Spanish", "Philippines"],
      ["es-PR", "Spanish", "Puerto Rico"],
      ["es-PY", "Spanish", "Paraguay"],
      ["es-SV", "Spanish", "El Salvador"],
      ["es-US", "Spanish", "United States"],
      ["es-UY", "Spanish", "Uruguay"],
      ["es-VE", "Spanish", "Venezuela"],
      ["et", "Estonian"],
      ["et-EE", "Estonian", "Estonia"],
      ["eu", "Basque"],
      ["eu-ES", "Basque", "Spain"],
      ["fa", "Persian"],
      ["fa-AF", "Persian", "Afghanistan"],
      ["fa-IR", "Persian", "Iran"],
      ["ff", "Fulah"],
      ["ff-CM", "Fulah", "Cameroon"],
      ["ff-GN", "Fulah", "Guinea"],
      ["ff-MR", "Fulah", "Mauritania"],
      ["ff-SN", "Fulah", "Senegal"],
      ["fi", "Finnish"],
      ["fi-FI", "Finnish", "Finland"],
      ["fo", "Faroese"],
      ["fo-DK", "Faroese", "Denmark"],
      ["fo-FO", "Faroese", "Faroe Islands"],
      ["fr", "French"],
      ["fr-BE", "French", "Belgium"],
      ["fr-BF", "French", "Burkina Faso"],
      ["fr-BI", "French", "Burundi"],
      ["fr-BJ", "French", "Benin"],
      ["fr-BL", "French"],
      ["fr-CA", "French", "Canada"],
      ["fr-CD", "French", "Congo"],
      ["fr-CF", "French", "Central African Republic"],
      ["fr-CG", "French", "Congo"],
      ["fr-CH", "French", "Switzerland"],
      ["fr-CI", "French, Cote d'Ivoire (Ivory Coast)"],
      ["fr-CM", "French", "Cameroon"],
      ["fr-DJ", "French", "Djibouti"],
      ["fr-DZ", "French", "Algeria"],
      ["fr-FR", "French", "France"],
      ["fr-GA", "French", "Gabon"],
      ["fr-GF", "French", "French Guiana"],
      ["fr-GN", "French", "Guinea"],
      ["fr-GP", "French", "Saint Barthelemy"],
      ["fr-GQ", "French", "Equatorial Guinea"],
      ["fr-HT", "French", "Haiti"],
      ["fr-KM", "French", "Comoros"],
      ["fr-LU", "French", "Luxembourg"],
      ["fr-MA", "French", "Morocco"],
      ["fr-MC", "French", "Monaco"],
      ["fr-MF", "French"],
      ["fr-MG", "French", "Madagascar"],
      ["fr-ML", "French", "Mali"],
      ["fr-MQ", "French", "Martinique"],
      ["fr-MR", "French", "Mauritania"],
      ["fr-MU", "French", "Mauritius"],
      ["fr-NC", "French", "New Caledonia"],
      ["fr-NE", "French", "Niger"],
      ["fr-PF", "French", "French Polynesia"],
      ["fr-PM", "French", "Saint Pierre and Miquelon"],
      ["fr-RE", "French", "Reunion"],
      ["fr-RW", "French", "Rwanda"],
      ["fr-SC", "French", "Seychelles"],
      ["fr-SN", "French", "Senegal"],
      ["fr-SY", "French", "Syria"],
      ["fr-TD", "French", "Chad"],
      ["fr-TG", "French", "Togo"],
      ["fr-TN", "French", "Tunisia"],
      ["fr-VU", "French", "Vanuatu"],
      ["fr-WF", "French", "Wallis and Futuna"],
      ["fr-YT", "French", "Mayotte"],
      ["fy", "Western Frisian"],
      ["fy-NL", "Western Frisian", "Netherlands"],
      ["ga", "Irish"],
      ["ga-IE", "Irish", "Ireland"],
      ["gd", "Gaelic"],
      ["gd-GB", "Gaelic", "United Kingdom"],
      ["gl", "Galician"],
      ["gl-ES", "Galician", "Spain"],
      ["gu", "Gujarati"],
      ["gu-IN", "Gujarati", "India"],
      ["gv", "Manx"],
      ["gv-IM", "Manx", "Isle of Man"],
      ["ha", "Hausa"],
      ["ha-GH", "Hausa", "Ghana"],
      ["ha-NE", "Hausa", "Niger"],
      ["ha-NG", "Hausa", "Nigeria"],
      ["he", "Hebrew"],
      ["he-IL", "Hebrew", "Israel"],
      ["hi", "Hindi"],
      ["hi-IN", "Hindi", "India"],
      ["hr", "Croatian"],
      ["hr-BA", "Croatian", "Bosnia and Herzegovina"],
      ["hr-HR", "Croatian", "Croatia"],
      ["hu", "Hungarian"],
      ["hu-HU", "Hungarian", "Hungary"],
      ["hy", "Armenian"],
      ["hy-AM", "Armenian", "Armenia"],
      ["id", "Indonesian"],
      ["id-ID", "Indonesian", "Indonesia"],
      ["ig", "Igbo"],
      ["ig-NG", "Igbo", "Nigeria"],
      ["ii", "Sichuan Yi"],
      ["ii-CN", "Sichuan Yi", "China"],
      ["is", "Icelandic"],
      ["is-IS", "Icelandic", "Iceland"],
      ["it", "Italian"],
      ["it-CH", "Italian", "Switzerland"],
      ["it-IT", "Italian", "Italy"],
      ["it-SM", "Italian", "San Marino"],
      ["it-VA", "Italian", "Vatican City"],
      ["ja", "Japanese"],
      ["ja-JP", "Japanese", "Japan"],
      ["ka", "Georgian"],
      ["ka-GE", "Georgian", "Georgia"],
      ["ki", "Kikuyu"],
      ["ki-KE", "Kikuyu", "Kenya"],
      ["kk", "Kazakh"],
      ["kk-KZ", "Kazakh", "Kazakhstan"],
      ["kl", "Kalaallisut"],
      ["kl-GL", "Kalaallisut", "Greenland"],
      ["km", "Central Khmer"],
      ["km-KH", "Central Khmer", "Cambodia"],
      ["kn", "Kannada"],
      ["kn-IN", "Kannada", "India"],
      ["ko", "Korean"],
      ["ko-KP", "Korean", "Korea"],
      ["ko-KR", "Korean", "Korea"],
      ["ks", "Kashmiri"],
      ["ks-IN", "Kashmiri", "India"],
      ["kw", "Cornish"],
      ["kw-GB", "Cornish", "United Kingdom"],
      ["ky", "Kirghiz"],
      ["ky-KG", "Kirghiz", "Kyrgyzstan"],
      ["lb", "Luxembourgish"],
      ["lb-LU", "Luxembourgish", "Luxembourg"],
      ["lg", "Ganda"],
      ["lg-UG", "Ganda", "Uganda"],
      ["ln", "Lingala"],
      ["ln-AO", "Lingala", "Angola"],
      ["ln-CD", "Lingala", "Congo"],
      ["ln-CF", "Lingala", "Central African Republic"],
      ["ln-CG", "Lingala", "Congo"],
      ["lo", "Lao"],
      ["lo-LA", "Lao", "Laos"],
      ["lt", "Lithuanian"],
      ["lt-LT", "Lithuanian", "Lithuania"],
      ["lu", "Luba-Katanga"],
      ["lu-CD", "Luba-Katanga", "Congo"],
      ["lv", "Latvian"],
      ["lv-LV", "Latvian", "Latvia"],
      ["mg", "Malagasy"],
      ["mg-MG", "Malagasy", "Madagascar"],
      ["mk", "Macedonian"],
      ["mk-MK", "Macedonian", "Macedonia"],
      ["ml", "Malayalam"],
      ["ml-IN", "Malayalam", "India"],
      ["mn", "Mongolian"],
      ["mn-MN", "Mongolian", "Mongolia"],
      ["mr", "Marathi"],
      ["mr-IN", "Marathi", "India"],
      ["ms", "Malay"],
      ["ms-BN", "Malay", "Brunei"],
      ["ms-MY", "Malay", "Malaysia"],
      ["ms-SG", "Malay", "Singapore"],
      ["mt", "Maltese"],
      ["mt-MT", "Maltese", "Malta"],
      ["my", "Burmese"],
      ["my-MM", "Burmese", "Myanmar (Burma)"],
      ["nb", "Bokm\xE5l Norwegian"],
      ["nb-NO", "Bokm\xE5l Norwegian", "Norway"],
      ["nb-SJ", "Bokm\xE5l Norwegian", "Svalbard"],
      ["nd", "Ndebele, North"],
      ["nd-ZW", "Ndebele, North", "Zimbabwe"],
      ["ne", "Nepali"],
      ["ne-IN", "Nepali", "India"],
      ["ne-NP", "Nepali", "Nepal"],
      ["nl", "Dutch"],
      ["nl-AW", "Dutch", "Aruba"],
      ["nl-BE", "Dutch", "Belgium"],
      ["nl-BQ", "Dutch"],
      ["nl-CW", "Dutch"],
      ["nl-NL", "Dutch", "Netherlands"],
      ["nl-SR", "Dutch", "Suriname"],
      ["nl-SX", "Dutch"],
      ["nn", "Norwegian Nynorsk"],
      ["nn-NO", "Norwegian Nynorsk", "Norway"],
      ["om", "Oromo"],
      ["om-ET", "Oromo", "Ethiopia"],
      ["om-KE", "Oromo", "Kenya"],
      ["or", "Oriya"],
      ["or-IN", "Oriya", "India"],
      ["os", "Ossetian"],
      ["os-GE", "Ossetian", "Georgia"],
      ["os-RU", "Ossetian", "Russia"],
      ["pa", "Panjabi"],
      ["pa-IN", "Panjabi", "India"],
      ["pa-PK", "Panjabi", "Pakistan"],
      ["pl", "Polish"],
      ["pl-PL", "Polish", "Poland"],
      ["ps", "Pushto"],
      ["ps-AF", "Pushto", "Afghanistan"],
      ["pt", "Portuguese"],
      ["pt-AO", "Portuguese", "Angola"],
      ["pt-BR", "Portuguese", "Brazil"],
      ["pt-CH", "Portuguese", "Switzerland"],
      ["pt-CV", "Portuguese", "Cape Verde"],
      ["pt-GQ", "Portuguese", "Equatorial Guinea"],
      ["pt-GW", "Portuguese", "Guinea-Bissau"],
      ["pt-LU", "Portuguese", "Luxembourg"],
      ["pt-MO", "Portuguese", "Macau"],
      ["pt-MZ", "Portuguese", "Mozambique"],
      ["pt-PT", "Portuguese", "Portugal"],
      ["pt-ST", "Portuguese", "Sao Tome and Principe"],
      ["pt-TL", "Portuguese", "Timor-Leste (East Timor)"],
      ["qu", "Quechua"],
      ["qu-BO", "Quechua", "Bolivia"],
      ["qu-EC", "Quechua", "Ecuador"],
      ["qu-PE", "Quechua", "Peru"],
      ["rm", "Romansh"],
      ["rm-CH", "Romansh", "Switzerland"],
      ["rn", "Rundi"],
      ["rn-BI", "Rundi", "Burundi"],
      ["ro", "Romanian"],
      ["ro-MD", "Romanian", "Moldova"],
      ["ro-RO", "Romanian", "Romania"],
      ["ru", "Russian"],
      ["ru-BY", "Russian", "Belarus"],
      ["ru-KG", "Russian", "Kyrgyzstan"],
      ["ru-KZ", "Russian", "Kazakhstan"],
      ["ru-MD", "Russian", "Moldova"],
      ["ru-RU", "Russian", "Russia"],
      ["ru-UA", "Russian", "Ukraine"],
      ["rw", "Kinyarwanda"],
      ["rw-RW", "Kinyarwanda", "Rwanda"],
      ["se", "Northern Sami"],
      ["se-FI", "Northern Sami", "Finland"],
      ["se-NO", "Northern Sami", "Norway"],
      ["se-SE", "Northern Sami", "Sweden"],
      ["sg", "Sango"],
      ["sg-CF", "Sango", "Central African Republic"],
      ["si", "Sinhala"],
      ["si-LK", "Sinhala", "Sri Lanka"],
      ["sk", "Slovak"],
      ["sk-SK", "Slovak", "Slovakia"],
      ["sl", "Slovenian"],
      ["sl-SI", "Slovenian", "Slovenia"],
      ["sn", "Shona"],
      ["sn-ZW", "Shona", "Zimbabwe"],
      ["so", "Somali"],
      ["so-DJ", "Somali", "Djibouti"],
      ["so-ET", "Somali", "Ethiopia"],
      ["so-KE", "Somali", "Kenya"],
      ["so-SO", "Somali", "Somalia"],
      ["sq", "Albanian"],
      ["sq-AL", "Albanian", "Albania"],
      ["sq-MK", "Albanian", "Macedonia"],
      ["sq-XK", "Albanian"],
      ["sr", "Serbian"],
      ["sr-BA", "Serbian", "Bosnia and Herzegovina"],
      ["sr-ME", "Serbian", "Montenegro"],
      ["sr-RS", "Serbian", "Serbia"],
      ["sr-XK", "Serbian"],
      ["sv", "Swedish"],
      ["sv-AX", "Swedish", "Aland"],
      ["sv-FI", "Swedish", "Finland"],
      ["sv-SE", "Swedish", "Sweden"],
      ["sw", "Swahili"],
      ["sw-CD", "Swahili", "Congo"],
      ["sw-KE", "Swahili", "Kenya"],
      ["sw-TZ", "Swahili", "Tanzania"],
      ["sw-UG", "Swahili", "Uganda"],
      ["ta", "Tamil"],
      ["ta-IN", "Tamil", "India"],
      ["ta-LK", "Tamil", "Sri Lanka"],
      ["ta-MY", "Tamil", "Malaysia"],
      ["ta-SG", "Tamil", "Singapore"],
      ["te", "Telugu"],
      ["te-IN", "Telugu", "India"],
      ["th", "Thai"],
      ["th-TH", "Thai", "Thailand"],
      ["ti", "Tigrinya"],
      ["ti-ER", "Tigrinya", "Eritrea"],
      ["ti-ET", "Tigrinya", "Ethiopia"],
      ["tk", "Turkmen"],
      ["tk-TM", "Turkmen", "Turkmenistan"],
      ["to", "Tonga (Tonga Islands)"],
      ["to-TO", "Tonga (Tonga Islands)", "Tonga"],
      ["tr", "Turkish"],
      ["tr-CY", "Turkish", "Cyprus"],
      ["tr-TR", "Turkish", "Turkey"],
      ["ug", "Uighur"],
      ["ug-CN", "Uighur", "China"],
      ["uk", "Ukrainian"],
      ["uk-UA", "Ukrainian", "Ukraine"],
      ["ur", "Urdu"],
      ["ur-IN", "Urdu", "India"],
      ["ur-PK", "Urdu", "Pakistan"],
      ["uz", "Uzbek"],
      ["uz-AF", "Uzbek", "Afghanistan"],
      ["uz-UZ", "Uzbek", "Uzbekistan"],
      ["vi", "Vietnamese"],
      ["vi-VN", "Vietnamese", "Vietnam"],
      ["vo", "Volap\xFCk"],
      ["yi", "Yiddish"],
      ["yi-1", "Yiddish"],
      ["yo", "Yoruba"],
      ["yo-BJ", "Yoruba", "Benin"],
      ["yo-NG", "Yoruba", "Nigeria"],
      ["zh", "Chinese"],
      ["zh-CN", "Chinese", "China"],
      ["zh-HK", "Chinese", "Hong Kong"],
      ["zh-MO", "Chinese", "Macau"],
      ["zh-SG", "Chinese", "Singapore"],
      ["zh-TW", "Chinese", "China"],
      ["zu", "Zulu"],
      ["zu-ZA", "Zulu", "South Africa"]
    ];
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/models/locale/locale.js
var require_locale = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/models/locale/locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseLocale = exports.lookupLocaleInfo = exports.isStandardLocale = exports.normalizeLocale = exports.Locale = void 0;
    var knownLocales_js_1 = require_knownLocales();
    var codesByLocale;
    var Locale = class {
      constructor(locale) {
        this._raw = locale;
        this._locale = normalizeLocale(locale);
      }
      get locale() {
        return this._locale;
      }
      localInfo() {
        return lookupLocaleInfo(this._locale);
      }
      isValid() {
        return isStandardLocale(this._locale);
      }
      toJSON() {
        return this.locale;
      }
      toString() {
        return this.locale;
      }
    };
    exports.Locale = Locale;
    var regExTwoLetter = /^[a-z]{2}$/i;
    var regExLocaleWithCountry = /^([a-z]{2})[_-]?([a-z]{2,3})$/i;
    var regExValidLocale = /^([a-z]{2})(?:-([A-Z]{2,3}))?$/;
    function normalizeLocale(locale) {
      locale = locale.trim();
      if (regExTwoLetter.test(locale))
        return locale.toLowerCase();
      const m = locale.match(regExLocaleWithCountry);
      if (!m)
        return locale;
      const lang = m[1].toLowerCase();
      const variant = m[2].toUpperCase();
      return `${lang}-${variant}`;
    }
    exports.normalizeLocale = normalizeLocale;
    function isStandardLocale(locale) {
      return regExValidLocale.test(locale);
    }
    exports.isStandardLocale = isStandardLocale;
    function lookupLocaleInfo(locale) {
      codesByLocale = codesByLocale || buildLocaleLookup();
      return codesByLocale.get(locale);
    }
    exports.lookupLocaleInfo = lookupLocaleInfo;
    function buildLocaleLookup() {
      const info3 = knownLocales_js_1.codes.map(([locale, language, country]) => ({ locale, language, country }));
      return new Map(info3.map((i) => [i.locale, i]));
    }
    function createLocale(locale) {
      return new Locale(locale);
    }
    function parseLocale(locales) {
      locales = typeof locales === "string" ? locales.split(",") : locales;
      return locales.map(createLocale);
    }
    exports.parseLocale = parseLocale;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/models/locale/index.js
var require_locale2 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/models/locale/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseLocale = exports.Locale = void 0;
    var locale_js_1 = require_locale();
    Object.defineProperty(exports, "Locale", { enumerable: true, get: function() {
      return locale_js_1.Locale;
    } });
    Object.defineProperty(exports, "parseLocale", { enumerable: true, get: function() {
      return locale_js_1.parseLocale;
    } });
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/util.js
var require_util6 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrayEqual = exports.replaceAllFactory = exports.regexQuote = exports.replaceAll = exports.flatten = exports.unique = exports.clean = exports.cleanCopy = exports.isDefined = void 0;
    function isDefined2(a) {
      return a !== void 0;
    }
    exports.isDefined = isDefined2;
    function cleanCopy(t) {
      const r = { ...t };
      return clean2(r);
    }
    exports.cleanCopy = cleanCopy;
    function clean2(t) {
      for (const prop in t) {
        if (t[prop] === void 0) {
          delete t[prop];
        }
      }
      return t;
    }
    exports.clean = clean2;
    function unique(a) {
      return [...new Set(a)];
    }
    exports.unique = unique;
    function* flatten(i) {
      for (const v of i) {
        yield* v;
      }
    }
    exports.flatten = flatten;
    function replaceAll(text, match, withText) {
      const fn = replaceAllFactory(match, withText);
      return fn(text);
    }
    exports.replaceAll = replaceAll;
    function regexQuote(text) {
      return text.replace(/([[\]\-+(){},|*.\\])/g, "\\$1");
    }
    exports.regexQuote = regexQuote;
    function replaceAllFactory(match, replaceWithText) {
      const r = RegExp(regexQuote(match), "g");
      return (text) => text.replace(r, replaceWithText);
    }
    exports.replaceAllFactory = replaceAllFactory;
    function isArrayEqual(a, b) {
      if (a === b)
        return true;
      let isMatch = a.length === b.length;
      const len = a.length;
      for (let i = 0; isMatch && i < len; ++i) {
        isMatch = a[i] === b[i];
      }
      return isMatch;
    }
    exports.isArrayEqual = isArrayEqual;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapCosts.js
var require_mapCosts = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapCosts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapEditCosts = exports.mapHunspellCosts = void 0;
    var util_js_1 = require_util6();
    var defaultEditCosts = {
      accentCosts: 1,
      baseCost: 100,
      capsCosts: 1,
      firstLetterPenalty: 4,
      nonAlphabetCosts: 110
    };
    var defaultHunspellCosts = {
      ...defaultEditCosts,
      ioConvertCost: 30,
      keyboardCost: 99,
      mapCost: 25,
      replaceCosts: 75,
      tryCharCost: 100
    };
    function mapHunspellCosts(costs = {}) {
      return { ...defaultHunspellCosts, ...(0, util_js_1.cleanCopy)(costs) };
    }
    exports.mapHunspellCosts = mapHunspellCosts;
    function mapEditCosts(costs = {}) {
      return { ...defaultEditCosts, ...(0, util_js_1.cleanCopy)(costs) };
    }
    exports.mapEditCosts = mapEditCosts;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/text.js
var require_text = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stripNonAccents = exports.stripAccents = exports.accentForms = exports.caseForms = exports.expandRange = exports.expandCharacterSet = void 0;
    function expandCharacterSet(line, rangeChar = "-") {
      const charSet = /* @__PURE__ */ new Set();
      let mode = 0;
      let prev = "";
      for (const char of line) {
        if (mode) {
          expandRange(prev, char).forEach((a) => charSet.add(a));
          mode = 0;
        }
        if (char === rangeChar) {
          if (prev) {
            mode = 1;
            continue;
          }
        }
        charSet.add(char);
        prev = char;
      }
      if (mode)
        charSet.add(rangeChar);
      return charSet;
    }
    exports.expandCharacterSet = expandCharacterSet;
    function expandRange(a, b) {
      const values = [];
      const end = b.codePointAt(0);
      const begin = a.codePointAt(0);
      if (!(begin && end))
        return values;
      for (let i = begin; i <= end; ++i) {
        values.push(String.fromCodePoint(i));
      }
      return values;
    }
    exports.expandRange = expandRange;
    function caseForms(letter, locale) {
      const forms = /* @__PURE__ */ new Set([letter]);
      function tryCases(s) {
        forms.add(s.toLocaleLowerCase(locale));
        forms.add(s.toLocaleUpperCase(locale));
      }
      tryCases(letter);
      [...forms].forEach(tryCases);
      return [...forms].filter((a) => !!a);
    }
    exports.caseForms = caseForms;
    function accentForms(letter) {
      const forms = /* @__PURE__ */ new Set([letter, letter.normalize("NFC"), letter.normalize("NFD")]);
      return forms;
    }
    exports.accentForms = accentForms;
    function stripAccents(characters) {
      return characters.normalize("NFD").replace(/\p{M}/gu, "");
    }
    exports.stripAccents = stripAccents;
    function stripNonAccents(characters) {
      return characters.normalize("NFD").replace(/[^\p{M}]/gu, "");
    }
    exports.stripNonAccents = stripNonAccents;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/mappers/joinLetters.js
var require_joinLetters = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/mappers/joinLetters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinLetters = void 0;
    function joinLetters(letters) {
      const v = [...letters];
      return v.map((a) => a.length > 1 || !a.length ? `(${a})` : a).join("");
    }
    exports.joinLetters = joinLetters;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapToSuggestionCostDef.js
var require_mapToSuggestionCostDef = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapToSuggestionCostDef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitMap = exports.calcCostsForAccentedLetters = exports.parseAccents = exports.calcFirstCharacterReplace = exports.calcFirstCharacterReplaceDefs = exports.parseAlphabetCaps = exports.parseAlphabet = void 0;
    var sync_1 = require_sync();
    var text_js_1 = require_text();
    var util_js_1 = require_util6();
    var joinLetters_js_1 = require_joinLetters();
    function parseAlphabet(cs, locale, editCost) {
      const { cost, penalty } = cs;
      const characters = (0, text_js_1.expandCharacterSet)(cs.characters);
      const charForms = [
        ...(0, sync_1.pipe)(characters, (0, sync_1.opMap)((c) => (0, text_js_1.caseForms)(c, locale).sort()))
      ];
      const alphabet = (0, joinLetters_js_1.joinLetters)([
        ...(0, sync_1.pipe)(charForms, (0, sync_1.opFlatten)(), (0, sync_1.opMap)((letter) => (0, text_js_1.accentForms)(letter)), (0, sync_1.opFlatten)(), (0, sync_1.opUnique)())
      ].sort());
      const sugAlpha = (0, util_js_1.clean)({
        map: alphabet,
        replace: cost,
        insDel: cost,
        swap: cost,
        penalty
      });
      return [
        sugAlpha,
        parseAlphabetCaps(cs.characters, locale, editCost),
        ...calcCostsForAccentedLetters(alphabet, locale, editCost)
      ];
    }
    exports.parseAlphabet = parseAlphabet;
    function parseAlphabetCaps(alphabet, locale, editCost) {
      const characters = (0, text_js_1.expandCharacterSet)(alphabet);
      const charForms = [
        ...(0, sync_1.pipe)(characters, (0, sync_1.opMap)((c) => (0, text_js_1.caseForms)(c, locale).sort()))
      ];
      const caps = charForms.map((a) => (0, joinLetters_js_1.joinLetters)(a)).join("|");
      const sugCaps = {
        map: caps,
        replace: editCost.capsCosts
      };
      return sugCaps;
    }
    exports.parseAlphabetCaps = parseAlphabetCaps;
    function calcFirstCharacterReplaceDefs(alphabets, editCost) {
      return alphabets.map((cs) => calcFirstCharacterReplace(cs, editCost));
    }
    exports.calcFirstCharacterReplaceDefs = calcFirstCharacterReplaceDefs;
    function calcFirstCharacterReplace(cs, editCost) {
      const mapOfFirstLetters = [
        ...(0, sync_1.pipe)((0, text_js_1.expandCharacterSet)(cs.characters), (0, sync_1.opUnique)(), (0, sync_1.opMap)((letter) => `(^${letter})`))
      ].sort().join("") + "(^)";
      const penalty = editCost.firstLetterPenalty;
      const cost = cs.cost - penalty;
      return {
        map: mapOfFirstLetters,
        replace: cost,
        penalty: penalty * 2
      };
    }
    exports.calcFirstCharacterReplace = calcFirstCharacterReplace;
    function parseAccents(cs, _editCost) {
      const { cost, penalty } = cs;
      const accents = (0, joinLetters_js_1.joinLetters)([
        ...(0, sync_1.pipe)((0, text_js_1.expandCharacterSet)(cs.characters), (0, sync_1.opMap)((char) => (0, text_js_1.stripNonAccents)(char)))
      ]);
      if (!accents)
        return void 0;
      return (0, util_js_1.clean)({
        map: accents,
        replace: cost,
        insDel: cost,
        penalty
      });
    }
    exports.parseAccents = parseAccents;
    function calcCostsForAccentedLetters(simpleMap, locale, costs) {
      const charactersWithAccents = [
        ...(0, sync_1.pipe)(splitMap(simpleMap), (0, sync_1.opMap)((char) => (0, text_js_1.caseForms)(char, locale)), (0, sync_1.opFlatten)(), (0, sync_1.opMap)((char) => [...(0, text_js_1.accentForms)(char)]), (0, sync_1.opFilter)((forms) => forms.length > 1))
      ];
      const characters = (0, sync_1.pipe)(charactersWithAccents, (0, sync_1.opMap)((forms) => /* @__PURE__ */ new Set([...forms, ...forms.map((char) => (0, text_js_1.stripAccents)(char))])), (0, sync_1.opMap)((forms) => [...forms].sort()), (0, sync_1.opFilter)((forms) => forms.length > 1), (0, sync_1.opMap)(joinLetters_js_1.joinLetters), (0, sync_1.opUnique)());
      const replaceAccentMap = [...characters].join("|");
      const cost = costs.accentCosts;
      const costToReplaceAccent = !replaceAccentMap ? [] : [{ map: replaceAccentMap, replace: cost }];
      const normalizeMap = charactersWithAccents.map((a) => a.sort()).map(joinLetters_js_1.joinLetters).join("|");
      const costToNormalizeAccent = !normalizeMap ? [] : [{ map: normalizeMap, replace: 0 }];
      return [...costToReplaceAccent, ...costToNormalizeAccent];
    }
    exports.calcCostsForAccentedLetters = calcCostsForAccentedLetters;
    function* splitMap(map) {
      let seq = "";
      let mode = 0;
      for (const char of map) {
        if (mode && char === ")") {
          yield seq;
          mode = 0;
          continue;
        }
        if (mode) {
          seq += char;
          continue;
        }
        if (char === "(") {
          mode = 1;
          seq = "";
          continue;
        }
        yield char;
      }
    }
    exports.splitMap = splitMap;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapHunspellInformation.js
var require_mapHunspellInformation = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapHunspellInformation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.hunspellInformationToSuggestionCostDef = void 0;
    var sync_1 = require_sync();
    var text_js_1 = require_text();
    var util_js_1 = require_util6();
    var joinLetters_js_1 = require_joinLetters();
    var mapCosts_js_1 = require_mapCosts();
    var mapToSuggestionCostDef_js_1 = require_mapToSuggestionCostDef();
    function hunspellInformationToSuggestionCostDef(hunInfo, locales) {
      const costs = calcCosts(hunInfo.costs, locales);
      const operations = [
        affKey,
        affKeyCaps,
        affMap,
        affMapAccents,
        affMapCaps,
        affNoTry,
        affRepConv,
        affTry,
        affTryAccents,
        affTryFirstCharacterReplace
      ];
      function parseAff(aff, costs2) {
        const regSupportedAff = /^(?:MAP|KEY|TRY|NO-TRY|ICONV|OCONV|REP)\s/;
        const rejectAff = /^(?:MAP|KEY|TRY|ICONV|OCONV|REP)\s+\d+$/;
        const lines = aff.split("\n").map((a) => a.replace(/#.*/, "")).map((a) => a.trim()).filter((a) => regSupportedAff.test(a)).filter((a) => !rejectAff.test(a));
        const defs = (0, sync_1.pipe)(lines, (0, sync_1.opMap)((line) => (0, sync_1.pipe)(operations, (0, sync_1.opMap)((fn) => fn(line, costs2)), (0, sync_1.opMap)(asArrayOf), (0, sync_1.opFlatten)())), (0, sync_1.opFlatten)(), (0, sync_1.opFilter)(util_js_1.isDefined));
        return [...defs];
      }
      return parseAff(hunInfo.aff, costs);
    }
    exports.hunspellInformationToSuggestionCostDef = hunspellInformationToSuggestionCostDef;
    function calcCosts(costs = {}, locale) {
      const useLocale = locale?.length ? locale.map((loc) => loc.locale) : void 0;
      const hunCosts = (0, mapCosts_js_1.mapHunspellCosts)(costs);
      const c = {
        ...hunCosts,
        locale: useLocale
      };
      return c;
    }
    var regExpMap = /^(?:MAP)\s+(\S+)$/;
    function affMap(line, costs) {
      const m = line.match(regExpMap);
      if (!m)
        return void 0;
      const map = m[1];
      const cost = costs.mapCost;
      return {
        map,
        replace: cost,
        swap: cost
      };
    }
    var regExpTry = /^(?:TRY)\s+(\S+)$/;
    function affTry(line, costs) {
      const m = line.match(regExpTry);
      if (!m)
        return void 0;
      const cost = costs.tryCharCost;
      const tryChars = m[1];
      const characters = tryChars;
      return (0, mapToSuggestionCostDef_js_1.parseAlphabet)({
        characters,
        cost
      }, costs.locale, costs);
    }
    function affTryFirstCharacterReplace(line, costs) {
      const m = line.match(regExpTry);
      if (!m)
        return void 0;
      const characters = m[1];
      const cost = costs.tryCharCost;
      return (0, mapToSuggestionCostDef_js_1.calcFirstCharacterReplace)({
        characters,
        cost
      }, costs);
    }
    var regExpNoTry = /^NO-TRY\s+(\S+)$/;
    function affNoTry(line, costs) {
      const m = line.match(regExpNoTry);
      if (!m)
        return void 0;
      const map = m[1];
      return {
        map,
        insDel: Math.max(costs.nonAlphabetCosts - costs.tryCharCost, 0),
        penalty: costs.nonAlphabetCosts + costs.tryCharCost
      };
    }
    var regExpRepConv = /^(?:REP|(?:I|O)CONV)\s+(\S+)\s+(\S+)$/;
    function affRepConv(line, costs) {
      const m = line.match(regExpRepConv);
      if (!m)
        return void 0;
      const cost = line.startsWith("REP") ? costs.replaceCosts : costs.ioConvertCost;
      const from = m[1];
      let into = m[2];
      into = into.replace(/^0$/, "");
      if (from.startsWith("^") && !into.startsWith("^")) {
        into = "^" + into;
      }
      if (from.endsWith("$") && !into.endsWith("$")) {
        into = into + "$";
      }
      return {
        map: (0, joinLetters_js_1.joinLetters)([from, into]),
        replace: cost
      };
    }
    var regExpKey = /^(?:KEY)\s+(\S+)$/;
    function affKey(line, costs) {
      const m = line.match(regExpKey);
      if (!m)
        return void 0;
      const kbd = m[1];
      const pairs = [...(0, mapToSuggestionCostDef_js_1.splitMap)(kbd)].map(reducer((p, v) => ({ a: p.b, b: v }), { a: "|", b: "|" })).filter((ab) => ab.a !== "|" && ab.b !== "|").map(({ a, b }) => (0, joinLetters_js_1.joinLetters)([a, b]));
      const pairsUpper = pairs.map((p) => p.toLocaleUpperCase(costs.locale));
      const map = (0, util_js_1.unique)(pairs.concat(pairsUpper)).join("|");
      const cost = costs.keyboardCost;
      return {
        map,
        replace: cost,
        swap: cost
      };
    }
    function affKeyCaps(line, costs) {
      const m = line.match(regExpKey);
      if (!m)
        return void 0;
      return parseCaps(m[1], costs);
    }
    function affMapCaps(line, costs) {
      const m = line.match(regExpMap);
      if (!m)
        return void 0;
      return parseCaps(m[1], costs);
    }
    function affTryAccents(line, costs) {
      const m = line.match(regExpTry);
      if (!m)
        return void 0;
      return (0, mapToSuggestionCostDef_js_1.calcCostsForAccentedLetters)(m[1], costs.locale, costs);
    }
    function affMapAccents(line, costs) {
      const m = line.match(regExpMap);
      if (!m)
        return void 0;
      return (0, mapToSuggestionCostDef_js_1.calcCostsForAccentedLetters)(m[1], costs.locale, costs);
    }
    function parseCaps(value, costs) {
      const locale = costs.locale;
      const letters = [...(0, mapToSuggestionCostDef_js_1.splitMap)(value)].filter((a) => a !== "|");
      const withCases = letters.map((s) => (0, text_js_1.caseForms)(s, locale)).filter((forms) => forms.length > 1).map(joinLetters_js_1.joinLetters);
      const map = (0, util_js_1.unique)(withCases).join("|");
      const cost = costs.capsCosts;
      if (!map)
        return void 0;
      return {
        map,
        replace: cost
      };
    }
    function reducer(fn, initialVal) {
      let acc = initialVal;
      return (val, i) => acc = fn(acc, val, i);
    }
    function asArrayOf(v) {
      return Array.isArray(v) ? v : [v];
    }
    exports.__testing__ = {
      affKey,
      affKeyCaps,
      affMap,
      affMapAccents,
      affMapCaps,
      affNoTry,
      affRepConv,
      affTry,
      affTryAccents,
      affTryFirstCharacterReplace,
      calcCosts,
      split: mapToSuggestionCostDef_js_1.splitMap
    };
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapDictionaryInfo.js
var require_mapDictionaryInfo = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapDictionaryInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapDictionaryInformationToAdjustment = exports.mapDictionaryInformation = void 0;
    var sync_1 = require_sync();
    var index_js_1 = require_locale2();
    var util_js_1 = require_util6();
    var mapCosts_js_1 = require_mapCosts();
    var mapHunspellInformation_js_1 = require_mapHunspellInformation();
    var mapToSuggestionCostDef_js_1 = require_mapToSuggestionCostDef();
    function mapDictionaryInformation(dictInfo) {
      const _locale = dictInfo.locale;
      const locale = _locale ? (0, index_js_1.parseLocale)(_locale).filter((loc) => loc.isValid()) : void 0;
      const locales = locale?.map((loc) => loc.locale);
      const costs = (0, mapCosts_js_1.mapEditCosts)(dictInfo.costs);
      const defsEC = dictInfo.suggestionEditCosts || [];
      const defsHI = dictInfo.hunspellInformation ? (0, mapHunspellInformation_js_1.hunspellInformationToSuggestionCostDef)(dictInfo.hunspellInformation, locale) : [];
      return [
        ...defsEC,
        ...processAlphabet(dictInfo.alphabet, locales, costs),
        ...processAccents(dictInfo.accents, costs),
        ...defsHI
      ];
    }
    exports.mapDictionaryInformation = mapDictionaryInformation;
    function processAlphabet(alphabet, locale, editCost) {
      const csAlphabet = toCharSets(alphabet, "a-zA-Z", editCost.baseCost);
      return [
        ...(0, sync_1.pipeSync)(csAlphabet, (0, sync_1.opMap)((cs) => (0, mapToSuggestionCostDef_js_1.parseAlphabet)(cs, locale, editCost)), (0, sync_1.opFlatten)()),
        ...(0, mapToSuggestionCostDef_js_1.calcFirstCharacterReplaceDefs)(csAlphabet, editCost)
      ];
    }
    function toCharSets(cs, defaultValue, cost, penalty) {
      cs = cs ?? defaultValue;
      if (!cs)
        return [];
      if (typeof cs === "string") {
        cs = [
          {
            characters: cs,
            cost
          }
        ];
      }
      if (penalty !== void 0) {
        cs.forEach((cs2) => cs2.penalty = penalty);
      }
      return cs;
    }
    function processAccents(accents, editCost) {
      const cs = toCharSets(accents, "\u0300-\u0341", editCost.accentCosts);
      return cs.map((cs2) => (0, mapToSuggestionCostDef_js_1.parseAccents)(cs2, editCost)).filter(util_js_1.isDefined);
    }
    function mapDictionaryInformationToAdjustment(dictInfo) {
      if (!dictInfo.adjustments)
        return [];
      return dictInfo.adjustments.map(mapAdjustment);
    }
    exports.mapDictionaryInformationToAdjustment = mapDictionaryInformationToAdjustment;
    function mapAdjustment(adj) {
      const { id, regexp, penalty } = adj;
      return {
        id,
        regexp: new RegExp(regexp),
        penalty
      };
    }
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapDictionaryInfoToWeightMap.js
var require_mapDictionaryInfoToWeightMap = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/mappers/mapDictionaryInfoToWeightMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.mapDictionaryInformationToWeightMap = void 0;
    var weightedMaps_js_1 = require_weightedMaps();
    var mapDictionaryInfo_js_1 = require_mapDictionaryInfo();
    var defaultDefs = [
      {
        map: "1234567890-.",
        insDel: 1,
        penalty: 200
      }
    ];
    var defaultAdjustments = [
      {
        id: "compound-case-change",
        regexp: /\p{Ll}\p{Lu}/gu,
        penalty: 1e3
      },
      {
        id: "short-compounds-1",
        regexp: /^[^]{0,2}(?=)|[^]{0,2}(?=|$)/gm,
        penalty: 100
      },
      {
        id: "short-compounds-3",
        regexp: /^[^]{3}(?=)|[^]{3}(?=|$)/gm,
        penalty: 50
      }
    ];
    function mapDictionaryInformationToWeightMap(dictInfo) {
      const defs = (0, mapDictionaryInfo_js_1.mapDictionaryInformation)(dictInfo).concat(defaultDefs);
      const adjustments = (0, mapDictionaryInfo_js_1.mapDictionaryInformationToAdjustment)(dictInfo);
      const map = (0, weightedMaps_js_1.createWeightMap)(...defs);
      (0, weightedMaps_js_1.addAdjustment)(map, ...defaultAdjustments, ...adjustments);
      return map;
    }
    exports.mapDictionaryInformationToWeightMap = mapDictionaryInformationToWeightMap;
    exports.__testing__ = {};
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/memorizeLastCall.js
var require_memorizeLastCall = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/memorizeLastCall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.memorizeLastCall = void 0;
    var SymEmpty = Symbol("memorizeLastCall");
    function memorizeLastCall(fn) {
      let lastP = void 0;
      let lastR = SymEmpty;
      function calc(p) {
        if (lastR !== SymEmpty && lastP === p)
          return lastR;
        lastP = p;
        lastR = fn(p);
        return lastR;
      }
      return calc;
    }
    exports.memorizeLastCall = memorizeLastCall;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/find.js
var require_find = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.createFindOptions = exports.isForbiddenWord = exports.isEndOfWordNode = exports.findWordExact = exports.findCompoundNode = exports.findLegacyCompound = exports.findWordNode = exports.findWord = void 0;
    var constants_js_1 = require_constants4();
    var TrieNode_js_1 = require_TrieNode();
    var memorizeLastCall_js_1 = require_memorizeLastCall();
    var mergeDefaults_js_1 = require_mergeDefaults();
    var defaultLegacyMinCompoundLength = 3;
    var _defaultFindOptions = {
      matchCase: false,
      compoundMode: "compound",
      forbidPrefix: constants_js_1.FORBID_PREFIX,
      compoundFix: constants_js_1.COMPOUND_FIX,
      caseInsensitivePrefix: constants_js_1.CASE_INSENSITIVE_PREFIX,
      legacyMinCompoundLength: defaultLegacyMinCompoundLength
    };
    var arrayCompoundModes = ["none", "compound", "legacy"];
    var knownCompoundModes = new Map(arrayCompoundModes.map((a) => [a, a]));
    function findWord(root, word, options) {
      return _findWord(root, word, (0, exports.createFindOptions)(options));
    }
    exports.findWord = findWord;
    function findWordNode(root, word, options) {
      return _findWordNode(root, word, (0, exports.createFindOptions)(options));
    }
    exports.findWordNode = findWordNode;
    function _findWord(root, word, options) {
      const { node: _, ...result } = _findWordNode(root, word, options);
      return result;
    }
    function _findWordNode(root, word, options) {
      const compoundMode = knownCompoundModes.get(options.compoundMode) || _defaultFindOptions.compoundMode;
      const compoundPrefix = options.compoundMode === "compound" ? root.compoundCharacter ?? options.compoundFix : "";
      const ignoreCasePrefix = options.matchCase ? "" : root.stripCaseAndAccentsPrefix ?? options.caseInsensitivePrefix;
      function __findCompound() {
        const f = findCompoundWord(root, word, compoundPrefix, ignoreCasePrefix);
        const result = { ...f };
        if (f.found !== false && f.compoundUsed) {
          const r = !f.caseMatched ? walk(root, options.caseInsensitivePrefix) : root;
          result.forbidden = isForbiddenWord(r, word, options.forbidPrefix);
        }
        return result;
      }
      function __findExact() {
        const n = walk(root, word);
        const isFound = isEndOfWordNode(n);
        const result = {
          found: isFound && word,
          compoundUsed: false,
          forbidden: isForbiddenWord(root, word, options.forbidPrefix),
          node: n,
          caseMatched: true
        };
        return result;
      }
      switch (compoundMode) {
        case "none":
          return options.matchCase ? __findExact() : __findCompound();
        case "compound":
          return __findCompound();
        case "legacy":
          return findLegacyCompound(root, word, options);
      }
    }
    function findLegacyCompound(root, word, options) {
      const roots = [root];
      if (!options.matchCase) {
        roots.push(walk(root, options.caseInsensitivePrefix));
      }
      return findLegacyCompoundNode(roots, word, options.legacyMinCompoundLength);
    }
    exports.findLegacyCompound = findLegacyCompound;
    function findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix) {
      const stack = [
        // { n: root, compoundPrefix: '', cr: undefined, caseMatched: true },
        { n: root, compoundPrefix: ignoreCasePrefix, cr: void 0, caseMatched: true }
      ];
      const compoundPrefix = compoundCharacter || ignoreCasePrefix;
      const possibleCompoundPrefix = ignoreCasePrefix && compoundCharacter ? ignoreCasePrefix + compoundCharacter : "";
      const w = word.normalize();
      function determineRoot(s) {
        const prefix = s.compoundPrefix;
        let r = root;
        let i2;
        for (i2 = 0; i2 < prefix.length && r; ++i2) {
          r = r.c?.get(prefix[i2]);
        }
        const caseMatched2 = s.caseMatched && prefix[0] !== ignoreCasePrefix;
        return {
          n: s.n,
          compoundPrefix: prefix === compoundPrefix ? possibleCompoundPrefix : "",
          cr: r,
          caseMatched: caseMatched2
        };
      }
      let compoundUsed = false;
      let caseMatched = true;
      let i = 0;
      let node;
      while (true) {
        const s = stack[i];
        const h = w[i++];
        const n = s.cr || s.n;
        const c = n?.c?.get(h);
        if (c && i < word.length) {
          caseMatched = s.caseMatched;
          stack[i] = { n: c, compoundPrefix, cr: void 0, caseMatched };
        } else if (!c || !c.f) {
          node = node || c;
          while (--i > 0 && (!stack[i].compoundPrefix || !stack[i].n?.c?.has(compoundCharacter))) {
          }
          if (i >= 0 && stack[i].compoundPrefix) {
            compoundUsed = i > 0;
            const r = determineRoot(stack[i]);
            stack[i] = r;
            if (!r.cr) {
              break;
            }
            if (!i && !r.caseMatched) {
              if (w !== w.toLowerCase()) {
                break;
              }
            }
          } else {
            break;
          }
        } else {
          node = c;
          caseMatched = s.caseMatched;
          break;
        }
      }
      const found = i && i === word.length && word || false;
      const result = { found, compoundUsed, node, forbidden: void 0, caseMatched };
      return result;
    }
    exports.findCompoundNode = findCompoundNode;
    function findCompoundWord(root, word, compoundCharacter, ignoreCasePrefix) {
      const { found, compoundUsed, node, caseMatched } = findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix);
      if (!node || !node.f) {
        return { found: false, compoundUsed, node, forbidden: void 0, caseMatched };
      }
      return { found, compoundUsed, node, forbidden: void 0, caseMatched };
    }
    function findWordExact(root, word) {
      return isEndOfWordNode(walk(root, word));
    }
    exports.findWordExact = findWordExact;
    function isEndOfWordNode(n) {
      return n?.f === TrieNode_js_1.FLAG_WORD;
    }
    exports.isEndOfWordNode = isEndOfWordNode;
    function walk(root, word) {
      const w = word;
      let n = root;
      let i = 0;
      while (n && i < word.length) {
        const h = w[i++];
        n = n.c?.get(h);
      }
      return n;
    }
    function findLegacyCompoundNode(roots, word, minCompoundLength) {
      const root = roots[0];
      const numRoots = roots.length;
      const stack = [
        { n: root, usedRoots: 1, subLength: 0, isCompound: false, cr: void 0, caseMatched: true }
      ];
      const w = word;
      const wLen = w.length;
      let compoundUsed = false;
      let caseMatched = true;
      let i = 0;
      let node;
      while (true) {
        const s = stack[i];
        const h = w[i++];
        const n = s.cr || s.n;
        const c = n?.c?.get(h);
        if (c && i < wLen) {
          stack[i] = {
            n: c,
            usedRoots: 0,
            subLength: s.subLength + 1,
            isCompound: s.isCompound,
            cr: void 0,
            caseMatched: s.caseMatched
          };
        } else if (!c || !c.f || c.f && s.subLength < minCompoundLength - 1) {
          while (--i > 0) {
            const s2 = stack[i];
            if (s2.usedRoots < numRoots && s2.n?.f && (s2.subLength >= minCompoundLength || !s2.subLength) && wLen - i >= minCompoundLength) {
              break;
            }
          }
          if (i > 0 || stack[i].usedRoots < numRoots) {
            compoundUsed = i > 0;
            const s2 = stack[i];
            s2.cr = roots[s2.usedRoots++];
            s2.subLength = 0;
            s2.isCompound = compoundUsed;
            s2.caseMatched = s2.caseMatched && s2.usedRoots <= 1;
          } else {
            break;
          }
        } else {
          node = c;
          caseMatched = s.caseMatched;
          break;
        }
      }
      function extractWord() {
        if (!word || i < word.length)
          return false;
        const letters = [];
        let subLen = 0;
        for (let j = 0; j < i; ++j) {
          const { subLength } = stack[j];
          if (subLength < subLen) {
            letters.push("+");
          }
          letters.push(word[j]);
          subLen = subLength;
        }
        return letters.join("");
      }
      const found = extractWord();
      const result = { found, compoundUsed, node, forbidden: void 0, caseMatched };
      return result;
    }
    function findLegacyCompoundWord(roots, word, minCompoundLength) {
      const { found, compoundUsed, caseMatched } = findLegacyCompoundNode(roots, word, minCompoundLength);
      return { found, compoundUsed, caseMatched };
    }
    function isForbiddenWord(root, word, forbiddenPrefix) {
      return findWordExact(root?.c?.get(forbiddenPrefix), word);
    }
    exports.isForbiddenWord = isForbiddenWord;
    exports.createFindOptions = (0, memorizeLastCall_js_1.memorizeLastCall)(_createFindOptions);
    function _createFindOptions(options) {
      return (0, mergeDefaults_js_1.mergeDefaults)(options, _defaultFindOptions);
    }
    exports.__testing__ = {
      findLegacyCompoundWord
    };
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/clean.js
var require_clean = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/clean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clean = void 0;
    function clean2(t) {
      const copy = { ...t };
      for (const key of Object.keys(copy)) {
        if (copy[key] === void 0) {
          delete copy[key];
        }
      }
      return copy;
    }
    exports.clean = clean2;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/isDefined.js
var require_isDefined = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/isDefined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDefined = void 0;
    function isDefined2(t) {
      return t !== void 0;
    }
    exports.isDefined = isDefined2;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/walker/hintedWalker.js
var require_hintedWalker = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/walker/hintedWalker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.hintedWalker = void 0;
    var isDefined_js_1 = require_isDefined();
    var walkerTypes_js_1 = require_walkerTypes();
    function hintedWalker(root, ignoreCase, hint, compoundingMethod, emitWordSeparator) {
      return hintedWalkerNext(root, ignoreCase, hint, compoundingMethod, emitWordSeparator);
    }
    exports.hintedWalker = hintedWalker;
    function* hintedWalkerNext(root, ignoreCase, hint, compoundingMethod, emitWordSeparator = "") {
      const _compoundingMethod = compoundingMethod ?? walkerTypes_js_1.CompoundWordsMethod.NONE;
      const compoundCharacter = root.compoundCharacter;
      const noCaseCharacter = root.stripCaseAndAccentsPrefix;
      const rawRoots = [root, ignoreCase ? root.c.get(noCaseCharacter) : void 0].filter(isDefined_js_1.isDefined);
      const specialRootsPrefix = existMap([compoundCharacter, noCaseCharacter, root.forbiddenWordPrefix]);
      function filterRoot(root2) {
        const children2 = root2.c?.entries();
        const c = children2 && [...children2].filter(([v]) => !(v in specialRootsPrefix));
        return {
          c: c && new Map(c)
        };
      }
      const roots = rawRoots.map(filterRoot);
      const compoundRoots = rawRoots.map((r) => r.c?.get(compoundCharacter)).filter(isDefined_js_1.isDefined);
      const setOfCompoundRoots = new Set(compoundRoots);
      const rootsForCompoundMethods = roots.concat(compoundRoots);
      const compoundMethodRoots = {
        [walkerTypes_js_1.CompoundWordsMethod.NONE]: [],
        [walkerTypes_js_1.CompoundWordsMethod.JOIN_WORDS]: [...rootsForCompoundMethods.map((r) => [walkerTypes_js_1.JOIN_SEPARATOR, r])],
        [walkerTypes_js_1.CompoundWordsMethod.SEPARATE_WORDS]: [...rootsForCompoundMethods.map((r) => [walkerTypes_js_1.WORD_SEPARATOR, r])]
      };
      function* children(n, hintOffset) {
        if (n.c) {
          const h = hint.slice(hintOffset, hintOffset + 3) + hint.slice(Math.max(0, hintOffset - 2), hintOffset);
          const hints = new Set(h);
          const c = n.c;
          yield* [...hints].filter((a) => c.has(a)).map((letter) => ({
            letter,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            node: c.get(letter),
            hintOffset: hintOffset + 1
          }));
          hints.add(compoundCharacter);
          yield* [...c].filter((a) => !hints.has(a[0])).map(([letter, node]) => ({
            letter,
            node,
            hintOffset: hintOffset + 1
          }));
          if (c.has(compoundCharacter) && !setOfCompoundRoots.has(n)) {
            for (const compoundRoot of compoundRoots) {
              for (const child of children(compoundRoot, hintOffset)) {
                const { letter, node, hintOffset: hintOffset2 } = child;
                yield { letter: emitWordSeparator + letter, node, hintOffset: hintOffset2 };
              }
            }
          }
        }
        if (n.f) {
          yield* [...compoundMethodRoots[_compoundingMethod]].map(([letter, node]) => ({
            letter,
            node,
            hintOffset
          }));
        }
      }
      for (const root2 of roots) {
        let depth = 0;
        const stack = [];
        const stackText = [""];
        stack[depth] = children(root2, depth);
        let ir;
        while (depth >= 0) {
          while (!(ir = stack[depth].next()).done) {
            const { letter: char, node, hintOffset } = ir.value;
            const text = stackText[depth] + char;
            const hinting = yield { text, node, depth };
            if (hinting && hinting.goDeeper) {
              depth++;
              stackText[depth] = text;
              stack[depth] = children(node, hintOffset);
            }
          }
          depth -= 1;
        }
      }
    }
    function existMap(values) {
      const m = /* @__PURE__ */ Object.create(null);
      for (const v of values) {
        m[v] = true;
      }
      return m;
    }
    exports.__testing__ = {
      hintedWalkerNext
    };
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/walker/index.js
var require_walker2 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/walker/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hintedWalker = void 0;
    var hintedWalker_js_1 = require_hintedWalker();
    Object.defineProperty(exports, "hintedWalker", { enumerable: true, get: function() {
      return hintedWalker_js_1.hintedWalker;
    } });
    __exportStar(require_walker(), exports);
    __exportStar(require_walkerTypes(), exports);
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/genSuggestionsOptions.js
var require_genSuggestionsOptions = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/genSuggestionsOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSuggestionOptions = exports.defaultSuggestionOptions = exports.defaultGenSuggestionOptions = void 0;
    var index_js_1 = require_walker2();
    exports.defaultGenSuggestionOptions = {
      compoundMethod: index_js_1.CompoundWordsMethod.NONE,
      ignoreCase: true,
      changeLimit: 5
    };
    exports.defaultSuggestionOptions = {
      ...exports.defaultGenSuggestionOptions,
      numSuggestions: 8,
      includeTies: true,
      timeout: 5e3
    };
    var keyMapOfGenSuggestionOptionsStrict = {
      changeLimit: "changeLimit",
      compoundMethod: "compoundMethod",
      ignoreCase: "ignoreCase",
      compoundSeparator: "compoundSeparator"
    };
    var keyMapOfSuggestionOptionsStrict = {
      ...keyMapOfGenSuggestionOptionsStrict,
      filter: "filter",
      includeTies: "includeTies",
      numSuggestions: "numSuggestions",
      timeout: "timeout",
      weightMap: "weightMap"
    };
    function createSuggestionOptions(...opts) {
      const options = { ...exports.defaultSuggestionOptions };
      const keys = Object.keys(keyMapOfSuggestionOptionsStrict);
      for (const opt of opts) {
        for (const key of keys) {
          assign(options, opt, key);
        }
      }
      return options;
    }
    exports.createSuggestionOptions = createSuggestionOptions;
    function assign(dest, src, k) {
      dest[k] = src[k] ?? dest[k];
    }
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/orthography.js
var require_orthography = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/orthography.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.visualLetterMaskMap = exports.visualLetterGroups = exports.compare = void 0;
    var intl = new Intl.Collator("en", { sensitivity: "base" });
    exports.compare = intl.compare;
    exports.visualLetterGroups = [
      // cspell:disable
      forms("\u01CE\xE0\xE5\xC4\xC0A\xE3\xE2\xE1\u01DF\u1EB7\u1EAF\u1EA5\u0100\u0101\u0103\u0105a\xE4\xE6\u0250\u0251\u03B1\u0430\u1FB3") + "\u1FB3",
      forms("Bb\u1E03\u0432\u044A\u044C"),
      forms("\u010B\u010C\u010Dc\u0109\xE7C\xC7\u0107\u010A\u0421\u0441\u03C2"),
      forms("\u1E0E\u1E0B\u1E0F\u1E11\u010F\u0111\u1E0DDd"),
      forms("\u0113\xEB\xC8\xCA\xCB\u1EC1\xE9\xE8\u1EBF\u1EC7\u0115eE\u0112\u0117\u0119\u011B\xEA\u0259\u025B\u0451\u0401\u0435\u0292"),
      forms("f\u1E1FF"),
      forms("\u0121\u0120\u011E\u01E7\u011D\u0123Gg\u0263"),
      forms("\u0127\u0126\u0125\u1E25Hh\u1E24\u021F\u043D"),
      forms("I\u012F\xEF\u0130\xCE\xCD\u012Bi\xCC\xEC\xED\xEE\u0131\u026A\u0268\u0457\u038A\u0399"),
      forms("jJ\u0135"),
      forms("\u0137Kk\u03BA\u043A\u045C"),
      forms("\u1E37\u0142\u013E\u013CLl\u013A\u1E36\u03AF\u03B9"),
      forms("M\u1E43\u1E41m"),
      forms("n\u0146\xD1N\u1E47\u0148\u0147\xF1\u0144\u014B\u045D\u0438\u0439"),
      forms("\xD2O\xF8\u022D\u014C\u014D\u0151\u1ECFo\xD6\xF2\u0231\u022F\xF3\xF4\xF5\xF6\u01A1\u0254\u03CC\u03B4\u043E"),
      forms("P\u1E57p\u0440\u0420\u03C1"),
      forms("Qq"),
      forms("\u0159R\u1E5Br\u0155\u0157\u0453\u0433\u044F"),
      forms("\u1E63\u0161\u0218\u1E62sS\u0160\u1E61\u015E\u015D\u015B\u0219\u0283\u03A3"),
      forms("t\u021B\u021A\u0165T\u1E6D\u1E6C\u1E6B"),
      forms("\xDC\xFC\xFB\u016A\u01B0\u016F\u016B\u0171\xFA\xDB\u016D\xD9\xF9u\u0173U"),
      forms("Vv\u03BD"),
      forms("\u0175wW\u1E83\u1E85\u1E81\u03C9\u0448"),
      forms("xX\u0445"),
      forms("\xFF\xFDY\u0177y\xDD\u1EF3\u0423\u045E\u0443"),
      forms("Z\u1E93\u017E\u017D\u017C\u017B\u017Az")
      // cspell:enable
    ];
    function forms(letters) {
      const n = letters.normalize("NFC").replace(/\p{M}/gu, "");
      const na = n.normalize("NFD").replace(/\p{M}/gu, "");
      const s = new Set(n + n.toLowerCase() + n.toUpperCase() + na + na.toLowerCase() + na.toUpperCase());
      return [...s].join("");
    }
    exports.visualLetterMaskMap = calcVisualLetterMasks(exports.visualLetterGroups);
    function calcVisualLetterMasks(groups) {
      const map = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < groups.length; ++i) {
        const m = 1 << i;
        const g = groups[i];
        for (const c of g) {
          map[c] = (map[c] || 0) | m;
        }
      }
      return map;
    }
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/timer.js
var require_timer = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/timer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polyHrTime = exports.toMilliseconds = exports.createTimer = void 0;
    var _hrTime = process?.hrtime || polyHrTime;
    function createTimer(hrTimeFn = _hrTime) {
      let start = hrTimeFn();
      return {
        start() {
          start = hrTimeFn();
        },
        elapsed() {
          return toMilliseconds(hrTimeFn(start));
        }
      };
    }
    exports.createTimer = createTimer;
    function toMilliseconds(t) {
      return (t[0] + t[1] * 1e-9) * 1e3;
    }
    exports.toMilliseconds = toMilliseconds;
    function polyHrTime(time) {
      const now = Date.now() - (time ? toMilliseconds(time) : 0);
      const inSeconds = now * 1e-3;
      const s = Math.floor(inSeconds);
      const n = (inSeconds - s) * 1e9;
      return [s, n];
    }
    exports.polyHrTime = polyHrTime;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/suggestCollector.js
var require_suggestCollector = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/suggestCollector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSuggestionResult = exports.impersonateCollector = exports.suggestionCollector = exports.defaultSuggestionCollectorOptions = exports.compSuggestionResults = void 0;
    var index_js_1 = require_distance2();
    var weightedMaps_js_1 = require_weightedMaps();
    var timer_js_1 = require_timer();
    var util_js_1 = require_util6();
    var index_js_2 = require_walker2();
    var constants_js_1 = require_constants5();
    var defaultMaxNumberSuggestions = 10;
    var BASE_COST = 100;
    var MAX_NUM_CHANGES = 5;
    var MAX_COST_SCALE = 0.5;
    var MAX_ALLOWED_COST_SCALE = 1.03 * MAX_COST_SCALE;
    var collator = new Intl.Collator();
    var regexSeparator = new RegExp(`[${(0, util_js_1.regexQuote)(index_js_2.WORD_SEPARATOR)}]`, "g");
    var wordLengthCost = [0, 50, 25, 5, 0];
    var EXTRA_WORD_COST = 5;
    var DEFAULT_COLLECTOR_TIMEOUT = 1e3;
    var symStopProcessing = Symbol("Collector Stop Processing");
    function compSuggestionResults(a, b) {
      const aPref = a.isPreferred && -1 || 0;
      const bPref = b.isPreferred && -1 || 0;
      return aPref - bPref || a.cost - b.cost || a.word.length - b.word.length || collator.compare(a.word, b.word);
    }
    exports.compSuggestionResults = compSuggestionResults;
    exports.defaultSuggestionCollectorOptions = Object.freeze({
      numSuggestions: defaultMaxNumberSuggestions,
      filter: () => true,
      changeLimit: MAX_NUM_CHANGES,
      includeTies: false,
      ignoreCase: true,
      timeout: DEFAULT_COLLECTOR_TIMEOUT,
      weightMap: void 0,
      compoundSeparator: "",
      compoundMethod: void 0
    });
    function suggestionCollector(wordToMatch, options) {
      const { filter = () => true, changeLimit = MAX_NUM_CHANGES, includeTies = false, ignoreCase = true, timeout = DEFAULT_COLLECTOR_TIMEOUT, weightMap, compoundSeparator = exports.defaultSuggestionCollectorOptions.compoundSeparator } = options;
      const numSuggestions = Math.max(options.numSuggestions, 0) || 0;
      const numSugToHold = weightMap ? numSuggestions * 2 : numSuggestions;
      const sugs = /* @__PURE__ */ new Map();
      let maxCost = BASE_COST * Math.min(wordToMatch.length * MAX_ALLOWED_COST_SCALE, changeLimit);
      const useSeparator = compoundSeparator || (weightMap ? constants_js_1.DEFAULT_COMPOUNDED_WORD_SEPARATOR : exports.defaultSuggestionCollectorOptions.compoundSeparator);
      const fnCleanWord = !useSeparator || useSeparator === compoundSeparator ? (w) => w : (0, util_js_1.replaceAllFactory)(useSeparator, "");
      if (useSeparator && weightMap) {
        (0, weightedMaps_js_1.addDefToWeightMap)(weightMap, { map: useSeparator, insDel: 50 });
      }
      const genSuggestionOptions = (0, util_js_1.clean)({
        changeLimit,
        ignoreCase,
        compoundMethod: options.compoundMethod,
        compoundSeparator: useSeparator
      });
      let timeRemaining = timeout;
      function dropMax() {
        if (sugs.size < 2 || !numSuggestions) {
          sugs.clear();
          return;
        }
        const sorted = [...sugs.values()].sort(compSuggestionResults);
        let i = numSugToHold - 1;
        maxCost = sorted[i].cost;
        for (; i < sorted.length && sorted[i].cost <= maxCost; ++i) {
        }
        for (; i < sorted.length; ++i) {
          sugs.delete(sorted[i].word);
        }
      }
      function adjustCost(sug) {
        if (sug.isPreferred)
          return sug;
        const words = sug.word.split(regexSeparator);
        const extraCost = words.map((w) => wordLengthCost[w.length] || 0).reduce((a, b) => a + b, 0) + (words.length - 1) * EXTRA_WORD_COST;
        return { word: sug.word, cost: sug.cost + extraCost };
      }
      function collectSuggestion(suggestion) {
        const { word, cost, isPreferred } = adjustCost(suggestion);
        if (cost <= maxCost && filter(suggestion.word, cost)) {
          const known = sugs.get(word);
          if (known) {
            known.cost = Math.min(known.cost, cost);
            known.isPreferred = known.isPreferred || isPreferred;
          } else {
            sugs.set(word, { word, cost, isPreferred });
            if (cost < maxCost && sugs.size > numSugToHold) {
              dropMax();
            }
          }
        }
        return maxCost;
      }
      function collect(src, timeout2, filter2) {
        let stop = false;
        timeout2 = timeout2 ?? timeRemaining;
        timeout2 = Math.min(timeout2, timeRemaining);
        if (timeout2 < 0)
          return;
        const timer = (0, timer_js_1.createTimer)();
        let ir;
        while (!(ir = src.next(stop || maxCost)).done) {
          if (timer.elapsed() > timeout2) {
            stop = symStopProcessing;
          }
          const { value } = ir;
          if (!value)
            continue;
          if (isSuggestionResult(value)) {
            if (!filter2 || filter2(value.word, value.cost)) {
              collectSuggestion(value);
            }
            continue;
          }
        }
        timeRemaining -= timer.elapsed();
      }
      function cleanCompoundResult(sr) {
        const { word, cost } = sr;
        const cWord = fnCleanWord(word);
        if (cWord !== word) {
          return {
            word: cWord,
            cost,
            compoundWord: word,
            isPreferred: void 0
          };
        }
        return { ...sr };
      }
      function suggestions() {
        if (numSuggestions < 1 || !sugs.size)
          return [];
        const NF = "NFD";
        const nWordToMatch = wordToMatch.normalize(NF);
        const rawValues = [...sugs.values()];
        const values = weightMap ? rawValues.map(({ word, cost, isPreferred }) => ({
          word,
          cost: isPreferred ? cost : (0, index_js_1.editDistanceWeighted)(nWordToMatch, word.normalize(NF), weightMap, 110),
          isPreferred
        })) : rawValues;
        const sorted = values.sort(compSuggestionResults).map(cleanCompoundResult);
        let i = Math.min(sorted.length, numSuggestions) - 1;
        const limit = includeTies ? sorted.length : Math.min(sorted.length, numSuggestions);
        const iCost = sorted[i].cost;
        const maxCost2 = Math.min(iCost, weightMap ? changeLimit * BASE_COST - 1 : iCost);
        for (i = 1; i < limit && sorted[i].cost <= maxCost2; ++i) {
        }
        sorted.length = i;
        return sorted;
      }
      const collector = {
        collect,
        add: function(suggestion) {
          collectSuggestion(suggestion);
          return this;
        },
        get suggestions() {
          return suggestions();
        },
        get maxCost() {
          return maxCost;
        },
        get word() {
          return wordToMatch;
        },
        get maxNumSuggestions() {
          return numSuggestions;
        },
        get changeLimit() {
          return changeLimit;
        },
        includesTies: includeTies,
        ignoreCase,
        symbolStopProcessing: symStopProcessing,
        genSuggestionOptions
      };
      return collector;
    }
    exports.suggestionCollector = suggestionCollector;
    function impersonateCollector(collector, word) {
      const r = Object.create(collector);
      Object.defineProperty(r, "word", { value: word, writable: false });
      return r;
    }
    exports.impersonateCollector = impersonateCollector;
    function isSuggestionResult(s) {
      const r = s;
      return r?.cost !== void 0 && r.word != void 0;
    }
    exports.isSuggestionResult = isSuggestionResult;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/suggest.js
var require_suggest = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/suggestions/suggest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.genCompoundableSuggestions = exports.genSuggestions = exports.suggest = void 0;
    var trie_util_js_1 = require_trie_util();
    var clean_js_1 = require_clean();
    var index_js_1 = require_walker2();
    var genSuggestionsOptions_js_1 = require_genSuggestionsOptions();
    var orthography_js_1 = require_orthography();
    var suggestCollector_js_1 = require_suggestCollector();
    var baseCost = 100;
    var swapCost = 75;
    var postSwapCost = swapCost - baseCost;
    var insertSpaceCost = -1;
    var mapSubCost = 1;
    var maxCostScale = 0.5;
    var discourageInsertCost = baseCost;
    var setOfSeparators = /* @__PURE__ */ new Set([index_js_1.JOIN_SEPARATOR, index_js_1.WORD_SEPARATOR]);
    function suggest(root, word, options = {}) {
      const opts = (0, genSuggestionsOptions_js_1.createSuggestionOptions)(options);
      const collectorOpts = (0, clean_js_1.clean)(opts);
      const collector = (0, suggestCollector_js_1.suggestionCollector)(word, collectorOpts);
      collector.collect(genSuggestions(root, word, { ...opts, ...collector.genSuggestionOptions }));
      return collector.suggestions;
    }
    exports.suggest = suggest;
    function* genSuggestions(root, word, options = {}) {
      const roots = Array.isArray(root) ? root : [root];
      for (const r of roots) {
        yield* genCompoundableSuggestions(r, word, options);
      }
      return void 0;
    }
    exports.genSuggestions = genSuggestions;
    function* genCompoundableSuggestions(root, word, options = {}) {
      const { compoundMethod = index_js_1.CompoundWordsMethod.NONE, changeLimit, ignoreCase } = (0, genSuggestionsOptions_js_1.createSuggestionOptions)(options);
      const history = [];
      const historyTags = /* @__PURE__ */ new Map();
      const bc = baseCost;
      const psc = postSwapCost;
      const matrix = [[]];
      const stack = [];
      const x = " " + word;
      const mx = x.length - 1;
      const specialInsCosts = Object.assign(/* @__PURE__ */ Object.create(null), {
        [index_js_1.WORD_SEPARATOR]: insertSpaceCost,
        [index_js_1.JOIN_SEPARATOR]: insertSpaceCost
      });
      const specialSubCosts = Object.assign(/* @__PURE__ */ Object.create(null), {
        "-": discourageInsertCost
      });
      let stopNow = false;
      let costLimit = bc * Math.min(word.length * maxCostScale, changeLimit);
      function updateCostLimit(maxCost) {
        switch (typeof maxCost) {
          case "number":
            costLimit = maxCost;
            break;
          case "symbol":
            stopNow = true;
            break;
        }
      }
      const a = 0;
      let b = 0;
      for (let i = 0, c = 0; i <= mx && c <= costLimit; ++i) {
        c = i * baseCost;
        matrix[0][i] = c;
        b = i;
      }
      stack[0] = { a, b };
      const hint = word;
      const iWalk = (0, index_js_1.hintedWalker)(root, ignoreCase, hint, compoundMethod, options.compoundSeparator);
      let goDeeper = true;
      for (let r = iWalk.next({ goDeeper }); !stopNow && !r.done; r = iWalk.next({ goDeeper })) {
        const { text, node, depth } = r.value;
        let { a: a2, b: b2 } = stack[depth];
        const w = text.slice(-1);
        const wG = orthography_js_1.visualLetterMaskMap[w] || 0;
        if (setOfSeparators.has(w)) {
          const mxRange = matrix[depth].slice(a2, b2 + 1);
          const mxMin = Math.min(...mxRange);
          const tag = [a2].concat(mxRange.map((c2) => c2 - mxMin)).join();
          const ht = historyTags.get(tag);
          if (ht && ht.m <= mxMin) {
            goDeeper = false;
            const { i: i2, w: w2, m } = ht;
            if (i2 >= history.length) {
              continue;
            }
            const r2 = history[i2];
            if (r2.word.slice(0, w2.length) !== w2) {
              continue;
            }
            const dc = mxMin - m;
            for (let p = i2; p < history.length; ++p) {
              const { word: word2, cost: hCost } = history[p];
              const fix = word2.slice(0, w2.length);
              if (fix !== w2) {
                break;
              }
              const cost2 = hCost + dc;
              if (cost2 <= costLimit) {
                const suffix = word2.slice(w2.length);
                const emit = text + suffix;
                updateCostLimit(yield { word: emit, cost: cost2 });
              }
            }
            continue;
          } else {
            historyTags.set(tag, { w: text, i: history.length, m: mxMin });
          }
        }
        const d = depth + 1;
        const lastSugLetter = d > 1 ? text[d - 2] : "";
        const c = bc - d + (specialSubCosts[w] || 0);
        const ci = c + (specialInsCosts[w] || 0);
        matrix[d] = matrix[d] || [];
        matrix[d][a2] = matrix[d - 1][a2] + ci + d - a2;
        let lastLetter = x[a2];
        let min = matrix[d][a2];
        let i;
        for (i = a2 + 1; i <= b2; ++i) {
          const curLetter = x[i];
          const cG = orthography_js_1.visualLetterMaskMap[curLetter] || 0;
          const subCost = w === curLetter ? 0 : wG & cG ? mapSubCost : curLetter === lastSugLetter ? w === lastLetter ? psc : c : c;
          const e = Math.min(
            matrix[d - 1][i - 1] + subCost,
            // substitute
            matrix[d - 1][i] + ci,
            // insert
            matrix[d][i - 1] + c
            // delete
          );
          min = Math.min(min, e);
          matrix[d][i] = e;
          lastLetter = curLetter;
        }
        const { b: bb } = stack[d - 1];
        while (b2 < mx) {
          b2 += 1;
          i = b2;
          const curLetter = x[i];
          const cG = orthography_js_1.visualLetterMaskMap[curLetter] || 0;
          const subCost = w === curLetter ? 0 : wG & cG ? mapSubCost : curLetter === lastSugLetter ? w === lastLetter ? psc : c : c;
          const j = Math.min(bb, i - 1);
          const e = Math.min(
            matrix[d - 1][j] + subCost,
            // substitute
            matrix[d][i - 1] + c
            // delete
          );
          min = Math.min(min, e);
          matrix[d][i] = e;
          lastLetter = curLetter;
          if (e > costLimit)
            break;
        }
        for (; b2 > a2 && matrix[d][b2] > costLimit; b2 -= 1) {
        }
        for (; a2 < b2 && matrix[d][a2] > costLimit; a2 += 1) {
        }
        b2 = Math.min(b2 + 1, mx);
        stack[d] = { a: a2, b: b2 };
        const cost = matrix[d][b2];
        if (node.f && (0, trie_util_js_1.isWordTerminationNode)(node) && cost <= costLimit) {
          const r2 = { word: text, cost };
          history.push(r2);
          updateCostLimit(yield r2);
        } else {
          updateCostLimit(yield void 0);
        }
        goDeeper = min <= costLimit;
      }
      return void 0;
    }
    exports.genCompoundableSuggestions = genCompoundableSuggestions;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/suggest.js
var require_suggest2 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/suggest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.suggest = exports.genSuggestions = exports.genCompoundableSuggestions = void 0;
    var suggest_js_1 = require_suggest();
    Object.defineProperty(exports, "genCompoundableSuggestions", { enumerable: true, get: function() {
      return suggest_js_1.genCompoundableSuggestions;
    } });
    Object.defineProperty(exports, "genSuggestions", { enumerable: true, get: function() {
      return suggest_js_1.genSuggestions;
    } });
    Object.defineProperty(exports, "suggest", { enumerable: true, get: function() {
      return suggest_js_1.suggest;
    } });
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/trie.js
var require_trie = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/trie.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Trie = exports.FORBID = exports.NORMALIZED = exports.OPTIONAL_COMPOUND = exports.COMPOUND = exports.OPTIONAL_COMPOUND_FIX = exports.FORBID_PREFIX = exports.defaultTrieOptions = exports.COMPOUND_FIX = exports.CASE_INSENSITIVE_PREFIX = void 0;
    var gensequence_1 = require_dist2();
    var constants_js_1 = require_constants4();
    var find_js_1 = require_find();
    var suggest_js_1 = require_suggest2();
    var trie_util_js_1 = require_trie_util();
    var clean_js_1 = require_clean();
    var mergeOptionalWithDefaults_js_1 = require_mergeOptionalWithDefaults();
    var util_js_1 = require_util6();
    var index_js_1 = require_walker2();
    var constants_js_2 = require_constants4();
    Object.defineProperty(exports, "CASE_INSENSITIVE_PREFIX", { enumerable: true, get: function() {
      return constants_js_2.CASE_INSENSITIVE_PREFIX;
    } });
    Object.defineProperty(exports, "COMPOUND_FIX", { enumerable: true, get: function() {
      return constants_js_2.COMPOUND_FIX;
    } });
    Object.defineProperty(exports, "defaultTrieOptions", { enumerable: true, get: function() {
      return constants_js_2.defaultTrieOptions;
    } });
    Object.defineProperty(exports, "FORBID_PREFIX", { enumerable: true, get: function() {
      return constants_js_2.FORBID_PREFIX;
    } });
    Object.defineProperty(exports, "OPTIONAL_COMPOUND_FIX", { enumerable: true, get: function() {
      return constants_js_2.OPTIONAL_COMPOUND_FIX;
    } });
    exports.COMPOUND = constants_js_1.COMPOUND_FIX;
    exports.OPTIONAL_COMPOUND = constants_js_1.OPTIONAL_COMPOUND_FIX;
    exports.NORMALIZED = constants_js_1.CASE_INSENSITIVE_PREFIX;
    exports.FORBID = constants_js_1.FORBID_PREFIX;
    var defaultLegacyMinCompoundLength = 3;
    var Trie = class _Trie {
      constructor(root, count) {
        this.root = root;
        this.count = count;
        this.lastCreateFindOptionsMatchCaseMap = /* @__PURE__ */ new Map();
        this._options = (0, mergeOptionalWithDefaults_js_1.mergeOptionalWithDefaults)(root);
        this.isLegacy = this.calcIsLegacy();
        this.hasForbidden = !!root.c.get(root.forbiddenWordPrefix);
        this._findOptionsDefaults = {
          caseInsensitivePrefix: this._options.stripCaseAndAccentsPrefix,
          compoundFix: this._options.compoundCharacter,
          forbidPrefix: this._options.forbiddenWordPrefix
        };
        this._findOptionsExact = this.createFindOptions({ compoundMode: "none" });
      }
      /**
       * Number of words in the Trie
       */
      size() {
        this.count = this.count ?? (0, trie_util_js_1.countWords)(this.root);
        return this.count;
      }
      isSizeKnown() {
        return this.count !== void 0;
      }
      get options() {
        return this._options;
      }
      /**
       * @param text - text to find in the Trie
       * @param minCompoundLength - deprecated - allows words to be glued together
       */
      find(text, minCompoundLength = false) {
        const minLength = !minCompoundLength ? void 0 : minCompoundLength === true ? defaultLegacyMinCompoundLength : minCompoundLength;
        const options = this.createFindOptions({
          compoundMode: minLength ? "legacy" : "compound",
          legacyMinCompoundLength: minLength
        });
        return (0, find_js_1.findWordNode)(this.root, text, options).node;
      }
      /**
       *
       * @param text - text to search for
       * @param minCompoundLength - minimum word compound length
       * @deprecated - this method is no longer needed since compounding can be explicitly defined by the dictionary words.
       */
      findCompound(text, minCompoundLength = defaultLegacyMinCompoundLength) {
        const options = this.createFindOptions({ legacyMinCompoundLength: minCompoundLength });
        const r = (0, find_js_1.findLegacyCompound)(this.root, text, options);
        return r.node;
      }
      findExact(text) {
        return (0, find_js_1.findWordNode)(this.root, text, this._findOptionsExact).node;
      }
      has(word, minLegacyCompoundLength) {
        if (this.hasWord(word, false))
          return true;
        if (minLegacyCompoundLength) {
          const f = this.findWord(word, { useLegacyWordCompounds: minLegacyCompoundLength });
          return !!f.found;
        }
        return false;
      }
      /**
       * Determine if a word is in the dictionary.
       * @param word - the exact word to search for - must be normalized.
       * @param caseSensitive - false means also searching a dictionary where the words were normalized to lower case and accents removed.
       * @returns true if the word was found and is not forbidden.
       */
      hasWord(word, caseSensitive) {
        const f = this.findWord(word, { caseSensitive });
        return !!f.found && !f.forbidden;
      }
      findWord(word, options) {
        if (options?.useLegacyWordCompounds) {
          const len = options.useLegacyWordCompounds !== true ? options.useLegacyWordCompounds : defaultLegacyMinCompoundLength;
          const findOptions2 = this.createFindOptions({
            legacyMinCompoundLength: len,
            matchCase: options.caseSensitive
          });
          return (0, find_js_1.findLegacyCompound)(this.root, word, findOptions2);
        }
        const findOptions = this.createFindOptionsMatchCase(options?.caseSensitive);
        return (0, find_js_1.findWord)(this.root, word, findOptions);
      }
      /**
       * Determine if a word is in the forbidden word list.
       * @param word the word to lookup.
       */
      isForbiddenWord(word) {
        return this.hasForbidden && (0, find_js_1.isForbiddenWord)(this.root, word, this.options.forbiddenWordPrefix);
      }
      /**
       * Provides an ordered sequence of words with the prefix of text.
       */
      completeWord(text) {
        const n = this.find(text);
        const compoundChar = this.options.compoundCharacter;
        const subNodes = (0, trie_util_js_1.iteratorTrieWords)(n || {}).filter((w) => w[w.length - 1] !== compoundChar).map((suffix) => text + suffix);
        return (0, gensequence_1.genSequence)(n && (0, trie_util_js_1.isWordTerminationNode)(n) ? [text] : []).concat(subNodes);
      }
      /**
       * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
       * @param text - the text to search for
       * @param maxNumSuggestions - the maximum number of suggestions to return.
       * @param compoundMethod - Use to control splitting words.
       * @param numChanges - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
       *                      the lower the value, the faster results are returned. Values less than 4 are best.
       */
      suggest(text, options) {
        return this.suggestWithCost(text, options).map((a) => a.word);
      }
      /**
       * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
       * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
       */
      suggestWithCost(text, options) {
        const sep4 = options.compoundSeparator;
        const adjWord = sep4 ? (0, util_js_1.replaceAllFactory)(sep4, "") : (a) => a;
        const optFilter = options.filter;
        const filter = optFilter ? (word, cost) => {
          const w = adjWord(word);
          return !this.isForbiddenWord(w) && optFilter(w, cost);
        } : (word) => !this.isForbiddenWord(adjWord(word));
        const opts = { ...options, filter };
        return (0, suggest_js_1.suggest)(this.root, text, opts);
      }
      /**
       * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
       * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
       * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
       */
      genSuggestions(collector, compoundMethod) {
        const filter = (word) => !this.isForbiddenWord(word);
        const options = (0, clean_js_1.clean)({ compoundMethod, ...collector.genSuggestionOptions });
        const suggestions = (0, suggest_js_1.genSuggestions)(this.root, collector.word, options);
        collector.collect(suggestions, void 0, filter);
      }
      /**
       * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
       */
      words() {
        return (0, trie_util_js_1.iteratorTrieWords)(this.root);
      }
      /**
       * Allows iteration over the entire tree.
       * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
       */
      iterate() {
        return (0, index_js_1.walker)(this.root);
      }
      insert(word) {
        (0, trie_util_js_1.insert)(word, this.root);
        return this;
      }
      calcIsLegacy() {
        const c = this.root.c;
        return !(c?.get(this._options.compoundCharacter) || c?.get(this._options.stripCaseAndAccentsPrefix) || c?.get(this._options.forbiddenWordPrefix));
      }
      static create(words, options) {
        const root = (0, trie_util_js_1.createTriFromList)(words, options);
        (0, trie_util_js_1.orderTrie)(root);
        return new _Trie(root, void 0);
      }
      createFindOptions(options = {}) {
        const findOptions = (0, find_js_1.createFindOptions)({
          ...this._findOptionsDefaults,
          ...options
        });
        return findOptions;
      }
      createFindOptionsMatchCase(matchCase) {
        const f = this.lastCreateFindOptionsMatchCaseMap.get(matchCase);
        if (f !== void 0)
          return f;
        const findOptions = this.createFindOptions({ matchCase });
        this.lastCreateFindOptionsMatchCaseMap.set(matchCase, findOptions);
        return findOptions;
      }
    };
    exports.Trie = Trie;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/secondChanceCache.js
var require_secondChanceCache = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/secondChanceCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SecondChanceCache = void 0;
    var SecondChanceCache = class {
      constructor(maxL0Size) {
        this.maxL0Size = maxL0Size;
        this.map0 = /* @__PURE__ */ new Map();
        this.map1 = /* @__PURE__ */ new Map();
      }
      has(key) {
        if (this.map0.has(key))
          return true;
        if (this.map1.has(key)) {
          this.set(key, this.get1(key));
          return true;
        }
        return false;
      }
      get(key) {
        return this.map0.get(key) ?? this.get1(key);
      }
      set(key, value) {
        if (this.map0.size >= this.maxL0Size && !this.map0.has(key)) {
          this.map1 = this.map0;
          this.map0 = /* @__PURE__ */ new Map();
        }
        this.map0.set(key, value);
        return this;
      }
      get size() {
        return this.map0.size + this.map1.size;
      }
      get size0() {
        return this.map0.size;
      }
      get size1() {
        return this.map1.size;
      }
      clear() {
        this.map0.clear();
        this.map1.clear();
        return this;
      }
      get1(key) {
        if (this.map1.has(key)) {
          const v = this.map1.get(key);
          this.map1.delete(key);
          this.set(key, v);
          return v;
        }
        return void 0;
      }
      toArray() {
        return [...this.map1, ...this.map0];
      }
    };
    exports.SecondChanceCache = SecondChanceCache;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/TrieBuilder.js
var require_TrieBuilder = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/TrieBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrieBuilder = exports.buildTrieFast = exports.buildTrie = void 0;
    var consolidate_js_1 = require_consolidate();
    var trie_js_1 = require_trie();
    var trie_util_js_1 = require_trie_util();
    var mergeOptionalWithDefaults_js_1 = require_mergeOptionalWithDefaults();
    var secondChanceCache_js_1 = require_secondChanceCache();
    function buildTrie(words, trieOptions) {
      return new TrieBuilder(words, trieOptions).build();
    }
    exports.buildTrie = buildTrie;
    function buildTrieFast(words, trieOptions) {
      const root = (0, trie_util_js_1.createTriFromList)(words, trieOptions);
      return new trie_js_1.Trie(root, void 0);
    }
    exports.buildTrieFast = buildTrieFast;
    var MAX_NUM_SIGS = 1e5;
    var MAX_TRANSFORMS = 1e6;
    var MAX_CACHE_SIZE = 1e6;
    var TrieBuilder = class {
      constructor(words, trieOptions) {
        this.count = 0;
        this.signatures = new secondChanceCache_js_1.SecondChanceCache(MAX_NUM_SIGS);
        this.cached = new secondChanceCache_js_1.SecondChanceCache(MAX_CACHE_SIZE);
        this.transforms = new secondChanceCache_js_1.SecondChanceCache(MAX_TRANSFORMS);
        this._eow = Object.freeze({ f: 1 });
        this.lastPath = [{ s: "", n: { f: void 0, c: void 0 } }];
        this.tails = /* @__PURE__ */ new Map([["", this._eow]]);
        this._canBeCached(this._eow);
        this.signatures.set(this.signature(this._eow), this._eow);
        this.cached.set(this._eow, this.count++);
        this.trieOptions = Object.freeze((0, mergeOptionalWithDefaults_js_1.mergeOptionalWithDefaults)(trieOptions));
        if (words) {
          this.insert(words);
        }
      }
      set _root(n) {
        this.lastPath[0].n = n;
      }
      get _root() {
        return (0, trie_util_js_1.trieNodeToRoot)(this.lastPath[0].n, this.trieOptions);
      }
      signature(n) {
        const isWord = n.f ? "*" : "";
        const ref = n.c ? JSON.stringify([...n.c.entries()].map(([k, n2]) => [k, this.cached.get(n2)])) : "";
        return isWord + ref;
      }
      _canBeCached(n) {
        if (!n.c)
          return true;
        for (const v of n.c) {
          if (!this.cached.has(v[1]))
            return false;
        }
        return true;
      }
      tryCacheFrozen(n) {
        if (this.cached.has(n)) {
          return n;
        }
        this.cached.set(n, this.count++);
        return n;
      }
      freeze(n) {
        if (Object.isFrozen(n))
          return n;
        if (n.c) {
          const c = [...n.c].sort((a, b) => a[0] < b[0] ? -1 : 1).map(([k, n2]) => [k, this.freeze(n2)]);
          n.c = new Map(c);
          Object.freeze(n.c);
        }
        return Object.freeze(n);
      }
      tryToCache(n) {
        if (!this._canBeCached(n)) {
          return n;
        }
        const sig = this.signature(n);
        const ref = this.signatures.get(sig);
        if (ref !== void 0) {
          return this.tryCacheFrozen(ref);
        }
        this.signatures.set(sig, this.freeze(n));
        return n;
      }
      storeTransform(src, s, result) {
        if (!Object.isFrozen(result) || !Object.isFrozen(src))
          return;
        const t = this.transforms.get(src) ?? /* @__PURE__ */ new Map();
        t.set(s, result);
        this.transforms.set(src, t);
      }
      addChild(node, head, child) {
        if (node.c?.get(head) !== child) {
          if (!node.c || Object.isFrozen(node)) {
            node = { ...node, c: new Map(node.c ?? []) };
          }
          node.c?.set(head, child);
        }
        return Object.isFrozen(child) ? this.tryToCache(node) : node;
      }
      buildTail(s) {
        const v = this.tails.get(s);
        if (v)
          return v;
        const head = s[0];
        const tail = s.slice(1);
        const t = this.tails.get(tail);
        const c = t || this.buildTail(tail);
        const n = this.addChild({ f: void 0, c: void 0 }, head, c);
        if (!t) {
          return n;
        }
        const cachedNode = this.tryCacheFrozen(Object.freeze(n));
        this.tails.set(s, cachedNode);
        return cachedNode;
      }
      _insert(node, s, d) {
        const orig = node;
        if (Object.isFrozen(node)) {
          const n = this.transforms.get(node)?.get(s);
          if (n) {
            return this.tryCacheFrozen(n);
          }
        }
        if (!s) {
          if (!node.c) {
            return this._eow;
          } else {
            node = copyIfFrozen(node);
            node.f = this._eow.f;
            return node;
          }
        }
        const head = s[0];
        const tail = s.slice(1);
        const cNode = node.c?.get(head);
        const child = cNode ? this._insert(cNode, tail, d + 1) : this.buildTail(tail);
        node = this.addChild(node, head, child);
        this.storeTransform(orig, s, node);
        this.lastPath[d] = { s: head, n: child };
        return node;
      }
      insertWord(word) {
        let d = 1;
        for (const s of word.split("")) {
          const p = this.lastPath[d];
          if (p?.s !== s)
            break;
          d++;
        }
        if (word.length < d) {
          d = word.length;
        }
        this.lastPath.length = d;
        d -= 1;
        const { n } = this.lastPath[d];
        const tail = word.slice(d);
        this.lastPath[d].n = this._insert(n, tail, d + 1);
        while (d > 0) {
          const { s, n: n2 } = this.lastPath[d];
          d -= 1;
          const parent = this.lastPath[d];
          const pn = parent.n;
          parent.n = this.addChild(pn, s, n2);
          if (pn === parent.n)
            break;
          const tail2 = word.slice(d);
          this.storeTransform(pn, tail2, parent.n);
        }
      }
      insert(words) {
        for (const w of words) {
          w && this.insertWord(w);
        }
      }
      /**
       * Resets the builder
       */
      reset() {
        this._root = (0, trie_util_js_1.createTrieRoot)(this.trieOptions);
        this.cached.clear();
        this.signatures.clear();
        this.signatures.set(this.signature(this._eow), this._eow);
        this.count = 0;
        this.cached.set(this._eow, this.count++);
      }
      build(consolidateSuffixes = false) {
        const root = this._root;
        this.reset();
        return new trie_js_1.Trie(consolidateSuffixes ? (0, consolidate_js_1.consolidate)(root) : root);
      }
    };
    exports.TrieBuilder = TrieBuilder;
    function copyIfFrozen(n) {
      if (!Object.isFrozen(n))
        return n;
      const c = n.c ? new Map(n.c) : void 0;
      return { f: n.f, c };
    }
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/utils/normalizeWord.js
var require_normalizeWord = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/utils/normalizeWord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeWordForCaseInsensitive = exports.normalizeWordToLowercase = exports.normalizeWord = void 0;
    var normalizeWord = (text) => text.normalize();
    exports.normalizeWord = normalizeWord;
    var normalizeWordToLowercase = (text) => text.toLowerCase().normalize("NFD").replace(/\p{M}/gu, "");
    exports.normalizeWordToLowercase = normalizeWordToLowercase;
    var normalizeWordForCaseInsensitive = (text) => {
      const t = text.toLowerCase();
      return [t, t.normalize("NFD").replace(/\p{M}/gu, "")];
    };
    exports.normalizeWordForCaseInsensitive = normalizeWordForCaseInsensitive;
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/SimpleDictionaryParser.js
var require_SimpleDictionaryParser = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/SimpleDictionaryParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.parseDictionary = exports.parseLinesToDictionary = exports.parseDictionaryLines = exports.createDictionaryLineParserMapper = exports.setOfCSpellDirectiveFlags = exports.cSpellToolDirective = exports.defaultParseDictionaryOptions = void 0;
    var sync_1 = require_sync();
    var constants_js_1 = require_constants4();
    var TrieBuilder_js_1 = require_TrieBuilder();
    var normalizeWord_js_1 = require_normalizeWord();
    var RegExpSplit = /[\s,;]/g;
    var _defaultOptions = {
      commentCharacter: constants_js_1.LINE_COMMENT,
      optionalCompoundCharacter: constants_js_1.OPTIONAL_COMPOUND_FIX,
      compoundCharacter: constants_js_1.COMPOUND_FIX,
      forbiddenPrefix: constants_js_1.FORBID_PREFIX,
      caseInsensitivePrefix: constants_js_1.CASE_INSENSITIVE_PREFIX,
      keepExactPrefix: constants_js_1.IDENTITY_PREFIX,
      stripCaseAndAccents: true,
      stripCaseAndAccentsKeepDuplicate: false,
      stripCaseAndAccentsOnForbidden: false,
      split: false,
      splitKeepBoth: false,
      splitSeparator: RegExpSplit
    };
    exports.defaultParseDictionaryOptions = Object.freeze(_defaultOptions);
    exports.cSpellToolDirective = "cspell-dictionary:";
    exports.setOfCSpellDirectiveFlags = ["no-split", "split", "generate-alternatives", "no-generate-alternatives"];
    function createDictionaryLineParserMapper(options) {
      const _options = options || _defaultOptions;
      const { commentCharacter = _defaultOptions.commentCharacter, optionalCompoundCharacter: optionalCompound = _defaultOptions.optionalCompoundCharacter, compoundCharacter: compound = _defaultOptions.compoundCharacter, caseInsensitivePrefix: ignoreCase = _defaultOptions.caseInsensitivePrefix, forbiddenPrefix: forbidden = _defaultOptions.forbiddenPrefix, keepExactPrefix: keepCase = _defaultOptions.keepExactPrefix, splitSeparator = _defaultOptions.splitSeparator, splitKeepBoth = _defaultOptions.splitKeepBoth, stripCaseAndAccentsKeepDuplicate = _defaultOptions.stripCaseAndAccentsKeepDuplicate, stripCaseAndAccentsOnForbidden = _defaultOptions.stripCaseAndAccentsOnForbidden } = _options;
      let { stripCaseAndAccents = _defaultOptions.stripCaseAndAccents, split = _defaultOptions.split } = _options;
      function isString2(line) {
        return typeof line === "string";
      }
      function trim(line) {
        return line.trim();
      }
      function removeComments(line) {
        const idx = line.indexOf(commentCharacter);
        if (idx < 0)
          return line;
        const idxDirective = line.indexOf(exports.cSpellToolDirective, idx);
        if (idxDirective >= 0) {
          const flags = line.slice(idxDirective).split(/[\s,;]/g).map((s) => s.trim()).filter((a) => !!a);
          for (const flag of flags) {
            switch (flag) {
              case "split":
                split = true;
                break;
              case "no-split":
                split = false;
                break;
              case "no-generate-alternatives":
                stripCaseAndAccents = false;
                break;
              case "generate-alternatives":
                stripCaseAndAccents = true;
                break;
            }
          }
        }
        return line.slice(0, idx).trim();
      }
      function filterEmptyLines(line) {
        return !!line;
      }
      function* mapOptionalPrefix(line) {
        if (line[0] === optionalCompound) {
          const t = line.slice(1);
          yield t;
          yield compound + t;
        } else {
          yield line;
        }
      }
      function* mapOptionalSuffix(line) {
        if (line.slice(-1) === optionalCompound) {
          const t = line.slice(0, -1);
          yield t;
          yield t + compound;
        } else {
          yield line;
        }
      }
      const doNotNormalizePrefix = /* @__PURE__ */ Object.create(null);
      [ignoreCase, keepCase, '"'].forEach((prefix) => doNotNormalizePrefix[prefix] = true);
      if (!stripCaseAndAccentsOnForbidden) {
        doNotNormalizePrefix[forbidden] = true;
      }
      function removeDoublePrefix(w) {
        return w.startsWith(ignoreCase + ignoreCase) ? w.slice(1) : w;
      }
      function stripKeepCasePrefixAndQuotes(word) {
        word = word.replace(/"(.*?)"/g, "$1");
        return word[0] === keepCase ? word.slice(1) : word;
      }
      function _normalize(word) {
        return (0, normalizeWord_js_1.normalizeWord)(stripKeepCasePrefixAndQuotes(word));
      }
      function* mapNormalize(word) {
        const nWord = _normalize(word);
        const forms = /* @__PURE__ */ new Set();
        forms.add(nWord);
        if (stripCaseAndAccents && !(word[0] in doNotNormalizePrefix)) {
          for (const n of (0, normalizeWord_js_1.normalizeWordForCaseInsensitive)(nWord)) {
            (stripCaseAndAccentsKeepDuplicate || n !== nWord) && forms.add(ignoreCase + n);
          }
        }
        yield* forms;
      }
      function* splitWords(lines) {
        for (const line of lines) {
          if (split) {
            const lineEscaped = line.indexOf('"') >= 0 ? line.replace(/".*?"/g, (quoted) => " " + quoted.replace(/(\s)/g, "\\$1") + " ") : line;
            const words = splitLine(lineEscaped, splitSeparator);
            yield* words.map((escaped) => escaped.replace(/\\/g, ""));
            if (!splitKeepBoth)
              continue;
          }
          yield line;
        }
      }
      function* splitLines(paragraphs) {
        for (const paragraph of paragraphs) {
          yield* paragraph.split("\n");
        }
      }
      const processLines = (0, sync_1.opCombine)((0, sync_1.opFilter)(isString2), splitLines, (0, sync_1.opMap)(removeComments), splitWords, (0, sync_1.opMap)(trim), (0, sync_1.opFilter)(filterEmptyLines), (0, sync_1.opConcatMap)(mapOptionalPrefix), (0, sync_1.opConcatMap)(mapOptionalSuffix), (0, sync_1.opConcatMap)(mapNormalize), (0, sync_1.opMap)(removeDoublePrefix));
      return processLines;
    }
    exports.createDictionaryLineParserMapper = createDictionaryLineParserMapper;
    function parseDictionaryLines(lines, options) {
      return createDictionaryLineParserMapper(options)(typeof lines === "string" ? [lines] : lines);
    }
    exports.parseDictionaryLines = parseDictionaryLines;
    function parseLinesToDictionary(lines, options) {
      const _options = mergeOptions(_defaultOptions, options);
      const dictLines = parseDictionaryLines(lines, _options);
      return (0, TrieBuilder_js_1.buildTrieFast)([...new Set(dictLines)].sort(), {
        compoundCharacter: _options.compoundCharacter,
        forbiddenWordPrefix: _options.forbiddenPrefix,
        stripCaseAndAccentsPrefix: _options.caseInsensitivePrefix
      });
    }
    exports.parseLinesToDictionary = parseLinesToDictionary;
    function parseDictionary(text, options) {
      return parseLinesToDictionary(text.split("\n"), options);
    }
    exports.parseDictionary = parseDictionary;
    function mergeOptions(base, ...partials) {
      const opt = { ...base };
      for (const p of partials) {
        if (!p)
          continue;
        Object.assign(opt, p);
      }
      return opt;
    }
    var RegExpToEncode = /\\([\s,;])/g;
    var RegExpDecode = /<<(%[\da-f]{2})>>/gi;
    function encodeLine(line) {
      return line.replace(RegExpToEncode, (_, v) => "<<" + encodeURIComponent(v) + ">>");
    }
    function decodeLine(line) {
      return line.replace(RegExpDecode, (_, v) => "\\" + decodeURIComponent(v));
    }
    function splitLine(line, regExp) {
      return encodeLine(line).split(regExp).map((line2) => decodeLine(line2));
    }
    exports.__testing__ = {
      splitLine
    };
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/suggestCollector.js
var require_suggestCollector2 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/suggestCollector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.suggestionCollector = exports.isSuggestionResult = exports.impersonateCollector = exports.defaultSuggestionCollectorOptions = exports.compSuggestionResults = void 0;
    var suggestCollector_js_1 = require_suggestCollector();
    Object.defineProperty(exports, "compSuggestionResults", { enumerable: true, get: function() {
      return suggestCollector_js_1.compSuggestionResults;
    } });
    Object.defineProperty(exports, "defaultSuggestionCollectorOptions", { enumerable: true, get: function() {
      return suggestCollector_js_1.defaultSuggestionCollectorOptions;
    } });
    Object.defineProperty(exports, "impersonateCollector", { enumerable: true, get: function() {
      return suggestCollector_js_1.impersonateCollector;
    } });
    Object.defineProperty(exports, "isSuggestionResult", { enumerable: true, get: function() {
      return suggestCollector_js_1.isSuggestionResult;
    } });
    Object.defineProperty(exports, "suggestionCollector", { enumerable: true, get: function() {
      return suggestCollector_js_1.suggestionCollector;
    } });
  }
});

// node_modules/cspell-trie-lib/dist/cjs/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hintedWalker = exports.CompoundWordsMethod = exports.expandCharacterSet = exports.normalizeWordToLowercase = exports.normalizeWordForCaseInsensitive = exports.normalizeWord = exports.mergeOptionalWithDefaults = exports.mergeDefaults = exports.isDefined = exports.FLAG_WORD = exports.ChildMap = exports.TrieBuilder = exports.buildTrieFast = exports.buildTrie = exports.walk = exports.trieNodeToRoot = exports.orderTrie = exports.iteratorTrieWords = exports.iterateTrie = exports.isWordTerminationNode = exports.isCircular = exports.insert = exports.has = exports.findNode = exports.createTriFromList = exports.createTrieRoot = exports.countWords = exports.countNodes = exports.Trie = exports.OPTIONAL_COMPOUND_FIX = exports.OPTIONAL_COMPOUND = exports.NORMALIZED = exports.FORBID_PREFIX = exports.FORBID = exports.defaultTrieOptions = exports.COMPOUND_FIX = exports.COMPOUND = exports.CASE_INSENSITIVE_PREFIX = exports.suggestionCollector = exports.impersonateCollector = exports.parseDictionaryLines = exports.parseDictionary = exports.createDictionaryLineParser = exports.mapDictionaryInformationToWeightMap = exports.serializeTrie = exports.importTrie = exports.editDistanceWeighted = exports.editDistance = exports.createWeightedMap = exports.consolidate = void 0;
    exports.WORD_SEPARATOR = exports.walker = exports.JOIN_SEPARATOR = void 0;
    var consolidate_js_1 = require_consolidate();
    Object.defineProperty(exports, "consolidate", { enumerable: true, get: function() {
      return consolidate_js_1.consolidate;
    } });
    var index_js_1 = require_distance2();
    Object.defineProperty(exports, "createWeightedMap", { enumerable: true, get: function() {
      return index_js_1.createWeightedMap;
    } });
    Object.defineProperty(exports, "editDistance", { enumerable: true, get: function() {
      return index_js_1.editDistance;
    } });
    Object.defineProperty(exports, "editDistanceWeighted", { enumerable: true, get: function() {
      return index_js_1.editDistanceWeighted;
    } });
    var importExport_js_1 = require_importExport();
    Object.defineProperty(exports, "importTrie", { enumerable: true, get: function() {
      return importExport_js_1.importTrie;
    } });
    Object.defineProperty(exports, "serializeTrie", { enumerable: true, get: function() {
      return importExport_js_1.serializeTrie;
    } });
    var mapDictionaryInfoToWeightMap_js_1 = require_mapDictionaryInfoToWeightMap();
    Object.defineProperty(exports, "mapDictionaryInformationToWeightMap", { enumerable: true, get: function() {
      return mapDictionaryInfoToWeightMap_js_1.mapDictionaryInformationToWeightMap;
    } });
    var SimpleDictionaryParser_js_1 = require_SimpleDictionaryParser();
    Object.defineProperty(exports, "createDictionaryLineParser", { enumerable: true, get: function() {
      return SimpleDictionaryParser_js_1.createDictionaryLineParserMapper;
    } });
    Object.defineProperty(exports, "parseDictionary", { enumerable: true, get: function() {
      return SimpleDictionaryParser_js_1.parseDictionary;
    } });
    Object.defineProperty(exports, "parseDictionaryLines", { enumerable: true, get: function() {
      return SimpleDictionaryParser_js_1.parseDictionaryLines;
    } });
    var suggestCollector_js_1 = require_suggestCollector2();
    Object.defineProperty(exports, "impersonateCollector", { enumerable: true, get: function() {
      return suggestCollector_js_1.impersonateCollector;
    } });
    Object.defineProperty(exports, "suggestionCollector", { enumerable: true, get: function() {
      return suggestCollector_js_1.suggestionCollector;
    } });
    var trie_js_1 = require_trie();
    Object.defineProperty(exports, "CASE_INSENSITIVE_PREFIX", { enumerable: true, get: function() {
      return trie_js_1.CASE_INSENSITIVE_PREFIX;
    } });
    Object.defineProperty(exports, "COMPOUND", { enumerable: true, get: function() {
      return trie_js_1.COMPOUND;
    } });
    Object.defineProperty(exports, "COMPOUND_FIX", { enumerable: true, get: function() {
      return trie_js_1.COMPOUND_FIX;
    } });
    Object.defineProperty(exports, "defaultTrieOptions", { enumerable: true, get: function() {
      return trie_js_1.defaultTrieOptions;
    } });
    Object.defineProperty(exports, "FORBID", { enumerable: true, get: function() {
      return trie_js_1.FORBID;
    } });
    Object.defineProperty(exports, "FORBID_PREFIX", { enumerable: true, get: function() {
      return trie_js_1.FORBID_PREFIX;
    } });
    Object.defineProperty(exports, "NORMALIZED", { enumerable: true, get: function() {
      return trie_js_1.NORMALIZED;
    } });
    Object.defineProperty(exports, "OPTIONAL_COMPOUND", { enumerable: true, get: function() {
      return trie_js_1.OPTIONAL_COMPOUND;
    } });
    Object.defineProperty(exports, "OPTIONAL_COMPOUND_FIX", { enumerable: true, get: function() {
      return trie_js_1.OPTIONAL_COMPOUND_FIX;
    } });
    Object.defineProperty(exports, "Trie", { enumerable: true, get: function() {
      return trie_js_1.Trie;
    } });
    var trie_util_js_1 = require_trie_util();
    Object.defineProperty(exports, "countNodes", { enumerable: true, get: function() {
      return trie_util_js_1.countNodes;
    } });
    Object.defineProperty(exports, "countWords", { enumerable: true, get: function() {
      return trie_util_js_1.countWords;
    } });
    Object.defineProperty(exports, "createTrieRoot", { enumerable: true, get: function() {
      return trie_util_js_1.createTrieRoot;
    } });
    Object.defineProperty(exports, "createTriFromList", { enumerable: true, get: function() {
      return trie_util_js_1.createTriFromList;
    } });
    Object.defineProperty(exports, "findNode", { enumerable: true, get: function() {
      return trie_util_js_1.findNode;
    } });
    Object.defineProperty(exports, "has", { enumerable: true, get: function() {
      return trie_util_js_1.has;
    } });
    Object.defineProperty(exports, "insert", { enumerable: true, get: function() {
      return trie_util_js_1.insert;
    } });
    Object.defineProperty(exports, "isCircular", { enumerable: true, get: function() {
      return trie_util_js_1.isCircular;
    } });
    Object.defineProperty(exports, "isWordTerminationNode", { enumerable: true, get: function() {
      return trie_util_js_1.isWordTerminationNode;
    } });
    Object.defineProperty(exports, "iterateTrie", { enumerable: true, get: function() {
      return trie_util_js_1.iterateTrie;
    } });
    Object.defineProperty(exports, "iteratorTrieWords", { enumerable: true, get: function() {
      return trie_util_js_1.iteratorTrieWords;
    } });
    Object.defineProperty(exports, "orderTrie", { enumerable: true, get: function() {
      return trie_util_js_1.orderTrie;
    } });
    Object.defineProperty(exports, "trieNodeToRoot", { enumerable: true, get: function() {
      return trie_util_js_1.trieNodeToRoot;
    } });
    Object.defineProperty(exports, "walk", { enumerable: true, get: function() {
      return trie_util_js_1.walk;
    } });
    var TrieBuilder_js_1 = require_TrieBuilder();
    Object.defineProperty(exports, "buildTrie", { enumerable: true, get: function() {
      return TrieBuilder_js_1.buildTrie;
    } });
    Object.defineProperty(exports, "buildTrieFast", { enumerable: true, get: function() {
      return TrieBuilder_js_1.buildTrieFast;
    } });
    Object.defineProperty(exports, "TrieBuilder", { enumerable: true, get: function() {
      return TrieBuilder_js_1.TrieBuilder;
    } });
    var TrieNode_js_1 = require_TrieNode();
    Object.defineProperty(exports, "ChildMap", { enumerable: true, get: function() {
      return TrieNode_js_1.ChildMap;
    } });
    Object.defineProperty(exports, "FLAG_WORD", { enumerable: true, get: function() {
      return TrieNode_js_1.FLAG_WORD;
    } });
    var isDefined_js_1 = require_isDefined();
    Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
      return isDefined_js_1.isDefined;
    } });
    var mergeDefaults_js_1 = require_mergeDefaults();
    Object.defineProperty(exports, "mergeDefaults", { enumerable: true, get: function() {
      return mergeDefaults_js_1.mergeDefaults;
    } });
    var mergeOptionalWithDefaults_js_1 = require_mergeOptionalWithDefaults();
    Object.defineProperty(exports, "mergeOptionalWithDefaults", { enumerable: true, get: function() {
      return mergeOptionalWithDefaults_js_1.mergeOptionalWithDefaults;
    } });
    var normalizeWord_js_1 = require_normalizeWord();
    Object.defineProperty(exports, "normalizeWord", { enumerable: true, get: function() {
      return normalizeWord_js_1.normalizeWord;
    } });
    Object.defineProperty(exports, "normalizeWordForCaseInsensitive", { enumerable: true, get: function() {
      return normalizeWord_js_1.normalizeWordForCaseInsensitive;
    } });
    Object.defineProperty(exports, "normalizeWordToLowercase", { enumerable: true, get: function() {
      return normalizeWord_js_1.normalizeWordToLowercase;
    } });
    var text_js_1 = require_text();
    Object.defineProperty(exports, "expandCharacterSet", { enumerable: true, get: function() {
      return text_js_1.expandCharacterSet;
    } });
    var index_js_2 = require_walker2();
    Object.defineProperty(exports, "CompoundWordsMethod", { enumerable: true, get: function() {
      return index_js_2.CompoundWordsMethod;
    } });
    Object.defineProperty(exports, "hintedWalker", { enumerable: true, get: function() {
      return index_js_2.hintedWalker;
    } });
    Object.defineProperty(exports, "JOIN_SEPARATOR", { enumerable: true, get: function() {
      return index_js_2.JOIN_SEPARATOR;
    } });
    Object.defineProperty(exports, "walker", { enumerable: true, get: function() {
      return index_js_2.walker;
    } });
    Object.defineProperty(exports, "WORD_SEPARATOR", { enumerable: true, get: function() {
      return index_js_2.WORD_SEPARATOR;
    } });
  }
});

// node_modules/cspell-trie-lib/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/cspell-trie-lib/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_lib7(), exports);
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/DictionaryReferenceCollection.js
var require_DictionaryReferenceCollection = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/DictionaryReferenceCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDictionaryReferenceCollection = void 0;
    function createDictionaryReferenceCollection(dictionaries) {
      return new _DictionaryReferenceCollection(dictionaries);
    }
    exports.createDictionaryReferenceCollection = createDictionaryReferenceCollection;
    var _DictionaryReferenceCollection = class {
      constructor(dictionaries) {
        this.dictionaries = dictionaries;
        this.collection = collect(dictionaries);
      }
      isEnabled(name) {
        const entry = this.collection[name];
        return entry === void 0 ? void 0 : !!(entry & 1);
      }
      isBlocked(name) {
        const entry = this.collection[name];
        return entry === void 0 ? void 0 : !(entry & 1);
      }
      enabled() {
        return this.dictionaryIds.filter((n) => this.isEnabled(n));
      }
      blocked() {
        return this.dictionaryIds.filter((n) => this.isBlocked(n));
      }
      get dictionaryIds() {
        return Object.keys(this.collection);
      }
    };
    function collect(dictionaries) {
      const refs = dictionaries.map(normalizeName).map(mapReference);
      const col = {};
      for (const ref of refs) {
        col[ref.name] = Math.max(ref.weight, col[ref.name] || 0);
      }
      return col;
    }
    function normalizeName(entry) {
      return entry.normalize().trim();
    }
    function mapReference(ref) {
      const name = ref.replace(/^!+/, "");
      const weight = ref.length - name.length + 1;
      return { name: name.trim(), weight };
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/DictionarySettings.js
var require_DictionarySettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/DictionarySettings.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDictionaryDefinitionInlineInternalWithSource = exports.isDictionaryFileDefinitionInternalWithSource = exports.isDictionaryDefinitionInternal = exports.isDictionaryDefinitionWithSource = exports.calcDictionaryDefsToLoad = exports.mapDictDefToInternal = exports.mapDictDefsToInternal = exports.filterDictDefsToLoad = void 0;
    var cspell_trie_lib_1 = require_cjs5();
    var path16 = __importStar(require("path"));
    var CSpellSettingsInternalDef_js_1 = require_CSpellSettingsInternalDef();
    var AutoResolve_js_1 = require_AutoResolve();
    var resolveFile_js_1 = require_resolveFile();
    var util_js_1 = require_util();
    var DictionaryReferenceCollection_js_1 = require_DictionaryReferenceCollection();
    function filterDictDefsToLoad(dictRefCol, defs) {
      const allActiveDefs = defs.filter(({ name }) => dictRefCol.isEnabled(name)).map(fixPath);
      return [...new Map(allActiveDefs.map((d) => [d.name, d])).values()];
    }
    exports.filterDictDefsToLoad = filterDictDefsToLoad;
    function fixPath(def) {
      if (def instanceof _DictionaryDefinitionInternalWithSource) {
        return def;
      }
      const newPath = fixDicPath(def.path, def.file);
      return {
        ...def,
        file: void 0,
        path: newPath
      };
    }
    function fixDicPath(defPath, defFile) {
      const parts = [defPath || "", defFile || ""].filter((p) => !!p);
      return parts.length > 1 ? path16.join(...parts) : parts[0] || "";
    }
    function mapDictDefsToInternal(defs, pathToSettingsFile) {
      return defs?.map((def) => mapDictDefToInternal(def, pathToSettingsFile));
    }
    exports.mapDictDefsToInternal = mapDictDefsToInternal;
    var internalDefs = new AutoResolve_js_1.AutoResolveWeakCache();
    function mapDictDefToInternal(def, pathToSettingsFile) {
      return internalDefs.get(def, (def2) => _mapDictDefToInternal(def2, pathToSettingsFile));
    }
    exports.mapDictDefToInternal = mapDictDefToInternal;
    function _mapDictDefToInternal(def, pathToSettingsFile) {
      if (isDictionaryDefinitionWithSource(def)) {
        return def;
      }
      if ((0, CSpellSettingsInternalDef_js_1.isDictionaryDefinitionInlineInternal)(def)) {
        return { ...def, __source: pathToSettingsFile };
      }
      return new _DictionaryDefinitionInternalWithSource(def, pathToSettingsFile);
    }
    function determineName(filename, options) {
      return options.name || path16.basename(filename);
    }
    function calcDictionaryDefsToLoad(settings) {
      const { dictionaries = [], dictionaryDefinitions = [], noSuggestDictionaries = [] } = settings;
      const colNoSug = (0, DictionaryReferenceCollection_js_1.createDictionaryReferenceCollection)(noSuggestDictionaries);
      const colDicts = (0, DictionaryReferenceCollection_js_1.createDictionaryReferenceCollection)(dictionaries.concat(colNoSug.enabled()));
      const modDefs = dictionaryDefinitions.map((def) => {
        const enabled = colNoSug.isEnabled(def.name);
        if (enabled === void 0)
          return def;
        return { ...def, noSuggest: enabled };
      });
      return filterDictDefsToLoad(colDicts, modDefs);
    }
    exports.calcDictionaryDefsToLoad = calcDictionaryDefsToLoad;
    function isDictionaryDefinitionWithSource(d) {
      return isDictionaryFileDefinitionInternalWithSource(d) || isDictionaryDefinitionInlineInternalWithSource(d);
    }
    exports.isDictionaryDefinitionWithSource = isDictionaryDefinitionWithSource;
    function isDictionaryDefinitionInternal(def) {
      return def instanceof _DictionaryDefinitionInternalWithSource;
    }
    exports.isDictionaryDefinitionInternal = isDictionaryDefinitionInternal;
    function isDictionaryFileDefinitionInternalWithSource(def) {
      return def instanceof _DictionaryDefinitionInternalWithSource;
    }
    exports.isDictionaryFileDefinitionInternalWithSource = isDictionaryFileDefinitionInternalWithSource;
    function isDictionaryDefinitionInlineInternalWithSource(def) {
      return (0, CSpellSettingsInternalDef_js_1.isDictionaryDefinitionInlineInternal)(def) && !!def.__source;
    }
    exports.isDictionaryDefinitionInlineInternalWithSource = isDictionaryDefinitionInlineInternalWithSource;
    var _DictionaryDefinitionInternalWithSource = class {
      constructor(def, __source) {
        this.__source = __source;
        const defAll = def;
        const { path: relPath = "", file = "", addWords, description, dictionaryInformation, type, repMap, noSuggest, scope, useCompounds } = defAll;
        const defaultPath = path16.dirname(__source);
        const filePath = fixDicPath(relPath, file);
        const name = determineName(filePath, def);
        const r = (0, resolveFile_js_1.resolveFile)(filePath, defaultPath);
        const ddi = {
          name,
          file: void 0,
          path: r.filename,
          addWords,
          description,
          dictionaryInformation,
          type,
          repMap,
          noSuggest,
          scope,
          useCompounds
        };
        Object.assign(this, (0, util_js_1.clean)(ddi));
        this.ddi = ddi;
        this.name = ddi.name;
        this.file = ddi.file;
        this.path = ddi.path;
        this._weightMap = this.dictionaryInformation ? (0, cspell_trie_lib_1.mapDictionaryInformationToWeightMap)(this.dictionaryInformation) : void 0;
      }
      get weightMap() {
        return this._weightMap;
      }
      toJSON() {
        return this.ddi;
      }
    };
  }
});

// node_modules/cspell-lib/dist/cjs/util/textRegex.js
var require_textRegex = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/textRegex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToRegExp = exports.regExNumericLiteral = exports.regExTrailingEndings = exports.regExDanglingQuote = exports.regExEscapeCharacters = exports.regExAccents = exports.regExMatchRegExParts = exports.regExPossibleWordBreaks = exports.regExAllLower = exports.regExAllUpper = exports.regExFirstUpper = exports.regExIgnoreCharacters = exports.regExWordsAndDigits = exports.regExWords = exports.regExSplitWords2 = exports.regExSplitWords = exports.regExUpperSOrIng = void 0;
    exports.regExUpperSOrIng = /([\p{Lu}\p{M}]+\\?[']?(?:s|ing|ies|es|ings|ed|ning))(?!\p{Ll})/gu;
    exports.regExSplitWords = /(\p{Ll}\p{M}?)(\p{Lu})/gu;
    exports.regExSplitWords2 = /(\p{Lu}\p{M}?)(\p{Lu}\p{M}?\p{Ll})/gu;
    exports.regExWords = /\p{L}\p{M}?(?:(?:\\?['])?\p{L}\p{M}?)*/gu;
    exports.regExWordsAndDigits = /[\p{L}\w'`.+-](?:(?:\\(?=[']))?[\p{L}\p{M}\w'`.+-])*/gu;
    exports.regExIgnoreCharacters = /[\p{sc=Hiragana}\p{sc=Han}\p{sc=Katakana}\u30A0-\u30FF\p{sc=Hangul}]/gu;
    exports.regExFirstUpper = /^\p{Lu}\p{M}?\p{Ll}+$/u;
    exports.regExAllUpper = /^(?:\p{Lu}\p{M}?)+$/u;
    exports.regExAllLower = /^(?:\p{Ll}\p{M}?)+$/u;
    exports.regExPossibleWordBreaks = /[-+_'`.\s]/g;
    exports.regExMatchRegExParts = /^\s*\/([\s\S]*?)\/([gimuxy]*)\s*$/;
    exports.regExAccents = /\p{M}/gu;
    exports.regExEscapeCharacters = /(?<=\\)[anrvtbf]/gi;
    exports.regExDanglingQuote = /(?<=(?:^|(?!\p{M})\P{L})(?:\p{L}\p{M}?)?)[']/gu;
    exports.regExTrailingEndings = /(?<=(?:\p{Lu}\p{M}?){2})[']?(?:s|d|ings?|ies|e[ds]?|ning|th|nth)(?!\p{Ll})/gu;
    exports.regExNumericLiteral = /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/;
    function stringToRegExp(pattern, defaultFlags = "gimu", forceFlags = "g") {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      try {
        const [, pat, flag] = [
          ...pattern.match(exports.regExMatchRegExParts) || ["", pattern.trim(), defaultFlags],
          forceFlags
        ];
        if (pat) {
          const regPattern = flag.includes("x") ? removeVerboseFromRegExp(pat) : pat;
          const flags = [...new Set(forceFlags + flag)].join("").replace(/[^gimuy]/g, "");
          const regex = new RegExp(regPattern, flags);
          return regex;
        }
      } catch (e) {
      }
      return void 0;
    }
    exports.stringToRegExp = stringToRegExp;
    var SPACES = {
      " ": true,
      "\n": true,
      "\r": true,
      "	": true
    };
    function removeVerboseFromRegExp(pattern) {
      function escape(acc) {
        const char = pattern[acc.idx];
        if (char !== "\\")
          return void 0;
        const next = pattern[++acc.idx];
        acc.idx++;
        if (next === "#") {
          acc.result += "#";
          return acc;
        }
        if (!(next in SPACES)) {
          acc.result += "\\" + next;
          return acc;
        }
        acc.result += next;
        if (next === "\r" && pattern[acc.idx] === "\n") {
          acc.result += "\n";
          acc.idx++;
        }
        return acc;
      }
      function braces(acc) {
        const char = pattern[acc.idx];
        if (char !== "[")
          return void 0;
        acc.result += char;
        acc.idx++;
        let escCount = 0;
        while (acc.idx < pattern.length) {
          const char2 = pattern[acc.idx];
          acc.result += char2;
          acc.idx++;
          if (char2 === "]" && !(escCount & 1))
            break;
          escCount = char2 === "\\" ? escCount + 1 : 0;
        }
        return acc;
      }
      function spaces(acc) {
        const char = pattern[acc.idx];
        if (!(char in SPACES))
          return void 0;
        acc.idx++;
        return acc;
      }
      function comments(acc) {
        const char = pattern[acc.idx];
        if (char !== "#")
          return void 0;
        while (acc.idx < pattern.length && pattern[acc.idx] !== "\n") {
          acc.idx++;
        }
        return acc;
      }
      function copy(acc) {
        const char = pattern[acc.idx++];
        acc.result += char;
        return acc;
      }
      const reducers = [escape, braces, spaces, comments, copy];
      const result = { idx: 0, result: "" };
      while (result.idx < pattern.length) {
        for (const r of reducers) {
          if (r(result))
            break;
        }
      }
      return result.result;
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/patterns.js
var require_patterns = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/patterns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolvePatterns = void 0;
    var textRegex_js_1 = require_textRegex();
    var util_js_1 = require_util();
    function resolvePatterns(regExpList = [], patternDefinitions = []) {
      const patternMap = new Map(patternDefinitions.map((def) => [def.name.toLowerCase(), def.pattern]));
      const resolved = /* @__PURE__ */ new Set();
      function resolvePattern(p) {
        if (resolved.has(p))
          return void 0;
        resolved.add(p);
        return patternMap.get(p.toString().toLowerCase()) || p;
      }
      function* flatten(patterns) {
        for (const pattern of patterns) {
          if (Array.isArray(pattern)) {
            yield* flatten(pattern.map(resolvePattern).filter(util_js_1.isDefined));
          } else {
            yield pattern;
          }
        }
      }
      const patternList = regExpList.map(resolvePattern).filter(util_js_1.isDefined);
      return [...flatten(patternList)].map(toRegExp).filter(util_js_1.isDefined);
    }
    exports.resolvePatterns = resolvePatterns;
    function toRegExp(pattern) {
      return pattern instanceof RegExp ? new RegExp(pattern) : (0, textRegex_js_1.stringToRegExp)(pattern, "gim", "g");
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/CSpellSettingsServer.js
var require_CSpellSettingsServer = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/CSpellSettingsServer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.extractDependencies = exports.getSources = exports.checkFilenameMatchesGlob = exports.toInternalSettings = exports.finalizeSettings = exports.calcOverrideSettings = exports.mergeInDocSettings = exports.mergeSettings = void 0;
    var assert_1 = __importDefault(require("assert"));
    var cspell_glob_1 = require_cjs();
    var path16 = __importStar(require("path"));
    var CSpellSettingsInternalDef_js_1 = require_CSpellSettingsInternalDef();
    var AutoResolve_js_1 = require_AutoResolve();
    var util = __importStar(require_util());
    var constants_js_1 = require_constants3();
    var DictionarySettings_js_1 = require_DictionarySettings();
    var patterns_js_1 = require_patterns();
    function mergeListUnique(left, right) {
      if (!Array.isArray(left))
        return Array.isArray(right) ? right : void 0;
      if (!Array.isArray(right))
        return left;
      if (!right.length)
        return left;
      if (!left.length)
        return right;
      return [.../* @__PURE__ */ new Set([...left, ...right])];
    }
    function mergeList(left, right) {
      if (!Array.isArray(left))
        return Array.isArray(right) ? right : void 0;
      if (!Array.isArray(right))
        return left;
      if (!left.length)
        return right;
      if (!right.length)
        return left;
      return left.concat(right);
    }
    var emptyWords = [];
    Object.freeze(emptyWords);
    var cachedMerges = /* @__PURE__ */ new WeakMap();
    function _mergeWordsCached(left, right) {
      const map = (0, AutoResolve_js_1.autoResolveWeak)(cachedMerges, left, () => /* @__PURE__ */ new WeakMap());
      return (0, AutoResolve_js_1.autoResolveWeak)(map, right, () => left.concat(right));
    }
    function mergeWordsCached(left, right) {
      if (!Array.isArray(left) || !left.length) {
        return Array.isArray(right) ? right.length ? right : emptyWords : void 0;
      }
      if (!Array.isArray(right) || !right.length)
        return left;
      return _mergeWordsCached(left, right);
    }
    function mergeObjects(left, right) {
      if (!left || typeof left !== "object")
        return !right || typeof right !== "object" ? void 0 : right;
      if (!right || typeof right !== "object")
        return left;
      return { ...left, ...right };
    }
    function replaceIfNotEmpty(left = [], right = []) {
      const filtered = right.filter((a) => !!a);
      if (filtered.length) {
        return filtered;
      }
      return left;
    }
    function mergeSettings3(left, ...settings) {
      const rawSettings = settings.filter(util.isDefined).reduce(merge, toInternalSettings(left));
      return util.clean(rawSettings);
    }
    exports.mergeSettings = mergeSettings3;
    function isEmpty(obj) {
      return Object.keys(obj).length === 0 && obj.constructor === Object;
    }
    var mergeCache = new AutoResolve_js_1.AutoResolveWeakCache();
    function merge(left, right) {
      const map = mergeCache.get(left, () => /* @__PURE__ */ new WeakMap());
      return (0, AutoResolve_js_1.autoResolveWeak)(map, right, () => _merge(left, right));
    }
    function _merge(left, right) {
      const _left = toInternalSettings(left);
      const _right = toInternalSettings(right);
      if (left === right) {
        return _left;
      }
      if (isEmpty(right)) {
        return _left;
      }
      if (isEmpty(left)) {
        return _right;
      }
      if (isLeftAncestorOfRight(_left, _right)) {
        return _right;
      }
      if (doesLeftHaveRightAncestor(_left, _right)) {
        return _left;
      }
      const includeRegExpList = takeRightOtherwiseLeft(_left.includeRegExpList, _right.includeRegExpList);
      const optionals = includeRegExpList?.length ? { includeRegExpList } : {};
      const version3 = max(_left.version, _right.version);
      const valuesToClear = {
        name: void 0,
        id: void 0,
        description: void 0,
        globRoot: void 0,
        import: void 0,
        __importRef: void 0
      };
      const settings = (0, CSpellSettingsInternalDef_js_1.cleanCSpellSettingsInternal)({
        ..._left,
        ..._right,
        ...optionals,
        ...valuesToClear,
        version: version3,
        words: mergeWordsCached(_left.words, _right.words),
        userWords: mergeWordsCached(_left.userWords, _right.userWords),
        flagWords: mergeWordsCached(_left.flagWords, _right.flagWords),
        ignoreWords: mergeWordsCached(_left.ignoreWords, _right.ignoreWords),
        suggestWords: mergeWordsCached(_left.suggestWords, _right.suggestWords),
        enabledLanguageIds: replaceIfNotEmpty(_left.enabledLanguageIds, _right.enabledLanguageIds),
        enableFiletypes: mergeList(_left.enableFiletypes, _right.enableFiletypes),
        ignoreRegExpList: mergeListUnique(_left.ignoreRegExpList, _right.ignoreRegExpList),
        patterns: mergeListUnique(_left.patterns, _right.patterns),
        dictionaryDefinitions: mergeListUnique(_left.dictionaryDefinitions, _right.dictionaryDefinitions),
        dictionaries: mergeListUnique(_left.dictionaries, _right.dictionaries),
        noSuggestDictionaries: mergeListUnique(_left.noSuggestDictionaries, _right.noSuggestDictionaries),
        languageSettings: mergeList(_left.languageSettings, _right.languageSettings),
        enabled: _right.enabled !== void 0 ? _right.enabled : _left.enabled,
        files: mergeListUnique(_left.files, _right.files),
        ignorePaths: versionBasedMergeList(_left.ignorePaths, _right.ignorePaths, version3),
        overrides: versionBasedMergeList(_left.overrides, _right.overrides, version3),
        features: mergeObjects(_left.features, _right.features),
        source: mergeSources(_left, _right),
        plugins: mergeList(_left.plugins, _right.plugins),
        __imports: mergeImportRefs(_left, _right)
      });
      return settings;
    }
    function versionBasedMergeList(left, right, version3) {
      if (version3 === constants_js_1.configSettingsFileVersion0_1) {
        return takeRightOtherwiseLeft(left, right);
      }
      return mergeListUnique(left, right);
    }
    function isLeftAncestorOfRight(left, right) {
      return hasAncestor(right, left, 0);
    }
    function doesLeftHaveRightAncestor(left, right) {
      return hasAncestor(left, right, 1);
    }
    function hasAncestor(s, ancestor, side) {
      const sources = s.source?.sources;
      if (!sources)
        return false;
      const i = side ? sources.length - 1 : 0;
      const src = sources[i];
      return src === ancestor || src && hasAncestor(src, ancestor, side) || false;
    }
    function mergeInDocSettings(left, right) {
      const merged = {
        ...mergeSettings3(left, right),
        includeRegExpList: mergeListUnique(left.includeRegExpList, right.includeRegExpList)
      };
      return util.clean(merged);
    }
    exports.mergeInDocSettings = mergeInDocSettings;
    function takeRightOtherwiseLeft(left, right) {
      if (right?.length) {
        return right;
      }
      return left || right;
    }
    function calcOverrideSettings2(settings, filename) {
      const _settings = toInternalSettings(settings);
      const overrides = _settings.overrides || [];
      const result = overrides.filter((override) => checkFilenameMatchesGlob(filename, override.filename)).reduce((settings2, override) => mergeSettings3(settings2, override), _settings);
      return result;
    }
    exports.calcOverrideSettings = calcOverrideSettings2;
    function finalizeSettings(settings) {
      return _finalizeSettings(toInternalSettings(settings));
    }
    exports.finalizeSettings = finalizeSettings;
    function _finalizeSettings(settings) {
      const finalized = {
        ...settings,
        finalized: true,
        ignoreRegExpList: (0, patterns_js_1.resolvePatterns)(settings.ignoreRegExpList, settings.patterns),
        includeRegExpList: (0, patterns_js_1.resolvePatterns)(settings.includeRegExpList, settings.patterns),
        parserFn: resolveParser(settings)
      };
      finalized.name = "Finalized " + (finalized.name || "");
      finalized.source = { name: settings.name || "src", sources: [settings] };
      return finalized;
    }
    var cacheInternalSettings = new AutoResolve_js_1.AutoResolveWeakCache();
    function toInternalSettings(settings) {
      if (settings === void 0)
        return void 0;
      if ((0, CSpellSettingsInternalDef_js_1.isCSpellSettingsInternal)(settings))
        return settings;
      return cacheInternalSettings.get(settings, _toInternalSettings);
    }
    exports.toInternalSettings = toInternalSettings;
    function _toInternalSettings(settings) {
      const { dictionaryDefinitions: defs, ...rest } = settings;
      const dictionaryDefinitions = (0, DictionarySettings_js_1.mapDictDefsToInternal)(defs, filenameToDirectory(settings.source?.filename) || resolveCwd());
      const setting = dictionaryDefinitions ? { ...rest, dictionaryDefinitions } : rest;
      return (0, CSpellSettingsInternalDef_js_1.cleanCSpellSettingsInternal)(setting);
    }
    function filenameToDirectory(filename) {
      return filename ? path16.dirname(filename) : void 0;
    }
    function checkFilenameMatchesGlob(filename, globs) {
      const m = new cspell_glob_1.GlobMatcher(globs);
      return m.match(filename);
    }
    exports.checkFilenameMatchesGlob = checkFilenameMatchesGlob;
    function mergeSources(left, right) {
      return {
        name: "merged",
        sources: [left, right]
      };
    }
    function max(a, b) {
      if (a === void 0 || a === null)
        return b;
      if (b === void 0 || b === null)
        return a;
      return a > b ? a : b;
    }
    function getSources(settings) {
      const visited = /* @__PURE__ */ new Set();
      const sources = [];
      function _walkSourcesTree(settings2) {
        if (!settings2 || visited.has(settings2))
          return;
        visited.add(settings2);
        if (!settings2.source?.sources?.length) {
          sources.push(settings2);
          return;
        }
        settings2.source.sources.forEach(_walkSourcesTree);
      }
      _walkSourcesTree(settings);
      return sources;
    }
    exports.getSources = getSources;
    function mergeImportRefs(left, right = {}) {
      const imports = new Map(left.__imports || []);
      if (left.__importRef) {
        imports.set(left.__importRef.filename, left.__importRef);
      }
      if (right.__importRef) {
        imports.set(right.__importRef.filename, right.__importRef);
      }
      const rightImports = right.__imports?.values() || [];
      for (const ref of rightImports) {
        imports.set(ref.filename, ref);
      }
      return imports.size ? imports : void 0;
    }
    function extractDependencies2(settings) {
      const settingsI = toInternalSettings(settings);
      const configFiles = [...mergeImportRefs(settingsI) || []].map(([filename]) => filename);
      const dictionaryFiles = (0, DictionarySettings_js_1.calcDictionaryDefsToLoad)(settingsI).map((dict) => dict.path).filter((file) => !!file);
      return {
        configFiles,
        dictionaryFiles
      };
    }
    exports.extractDependencies = extractDependencies2;
    function resolveCwd() {
      const envGlobRoot = process.env[constants_js_1.ENV_CSPELL_GLOB_ROOT];
      const cwd = envGlobRoot || process.cwd();
      return cwd;
    }
    function resolveParser(settings) {
      if (!settings.parser)
        return void 0;
      if (typeof settings.parser === "function")
        return settings.parser;
      const parserName = settings.parser;
      (0, assert_1.default)(typeof parserName === "string");
      const parsers2 = extractParsers(settings.plugins);
      const parser = parsers2.get(parserName);
      (0, assert_1.default)(parser, `Parser "${parserName}" not found.`);
      return parser;
    }
    var parserCache = new AutoResolve_js_1.AutoResolveWeakCache();
    var emptyParserMap = /* @__PURE__ */ new Map();
    function* parsers(plugins) {
      for (const plugin of plugins) {
        if (!plugin.parsers)
          continue;
        for (const parser of plugin.parsers) {
          yield [parser.name, parser];
        }
      }
    }
    function mapPlugins(plugins) {
      return new Map(parsers(plugins));
    }
    function extractParsers(plugins) {
      if (!plugins || !plugins.length)
        return emptyParserMap;
      return parserCache.get(plugins, mapPlugins);
    }
    exports.__testing__ = {
      mergeObjects
    };
  }
});

// node_modules/cspell-lib/dist/cjs/util/errors.js
var require_errors3 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.wrapCall = exports.catchPromiseError = exports.UnknownError = exports.toError = exports.isError = exports.isErrnoException = void 0;
    var util_1 = require("util");
    function getTypeOf(t) {
      return typeof t;
    }
    var allowStringOrUndefined = {
      string: true,
      undefined: true
    };
    var allowNumberOrUndefined = {
      number: true,
      undefined: true
    };
    function isErrnoException(e) {
      if (!e || typeof e !== "object")
        return false;
      if (!isError4(e))
        return false;
      const ex = e;
      return typeof ex.errno in allowNumberOrUndefined && typeof ex.code in allowStringOrUndefined && typeof ex.path in allowStringOrUndefined;
    }
    exports.isErrnoException = isErrnoException;
    function isError4(e) {
      if (e instanceof Error)
        return true;
      if (!e || typeof e !== "object")
        return false;
      const ex = e;
      return typeof ex.name == "string" && typeof ex.message == "string" && typeof ex.stack in allowStringOrUndefined;
    }
    exports.isError = isError4;
    function toError4(e, errorFactory = UnknownError) {
      if (isError4(e))
        return e;
      return new errorFactory(e);
    }
    exports.toError = toError4;
    var UnknownError = class extends Error {
      constructor(cause) {
        super((0, util_1.format)(cause));
        this.cause = cause;
      }
    };
    exports.UnknownError = UnknownError;
    function catchPromiseError(p, handler) {
      if (p === void 0)
        return void 0;
      return _catchPromiseError(p, handler);
    }
    exports.catchPromiseError = catchPromiseError;
    function wrapCall(fn, handler) {
      return (...p) => {
        try {
          return fn(...p);
        } catch (e) {
          return handler(e);
        }
      };
    }
    exports.wrapCall = wrapCall;
    async function _catchPromiseError(p, handler) {
      try {
        return await p;
      } catch (e) {
        return handler(e);
      }
    }
    exports.__testing__ = {
      getTypeOf
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs6) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs6);
      }
      if (!fs6.lutimes) {
        patchLutimes(fs6);
      }
      fs6.chown = chownFix(fs6.chown);
      fs6.fchown = chownFix(fs6.fchown);
      fs6.lchown = chownFix(fs6.lchown);
      fs6.chmod = chmodFix(fs6.chmod);
      fs6.fchmod = chmodFix(fs6.fchmod);
      fs6.lchmod = chmodFix(fs6.lchmod);
      fs6.chownSync = chownFixSync(fs6.chownSync);
      fs6.fchownSync = chownFixSync(fs6.fchownSync);
      fs6.lchownSync = chownFixSync(fs6.lchownSync);
      fs6.chmodSync = chmodFixSync(fs6.chmodSync);
      fs6.fchmodSync = chmodFixSync(fs6.fchmodSync);
      fs6.lchmodSync = chmodFixSync(fs6.lchmodSync);
      fs6.stat = statFix(fs6.stat);
      fs6.fstat = statFix(fs6.fstat);
      fs6.lstat = statFix(fs6.lstat);
      fs6.statSync = statFixSync(fs6.statSync);
      fs6.fstatSync = statFixSync(fs6.fstatSync);
      fs6.lstatSync = statFixSync(fs6.lstatSync);
      if (fs6.chmod && !fs6.lchmod) {
        fs6.lchmod = function(path16, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs6.lchmodSync = function() {
        };
      }
      if (fs6.chown && !fs6.lchown) {
        fs6.lchown = function(path16, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs6.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs6.rename = typeof fs6.rename !== "function" ? fs6.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs6.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs6.rename);
      }
      fs6.read = typeof fs6.read !== "function" ? fs6.read : function(fs$read) {
        function read2(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs6, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs6, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read2, fs$read);
        return read2;
      }(fs6.read);
      fs6.readSync = typeof fs6.readSync !== "function" ? fs6.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs6, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs6.readSync);
      function patchLchmod(fs7) {
        fs7.lchmod = function(path16, mode, callback) {
          fs7.open(
            path16,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs7.fchmod(fd, mode, function(err2) {
                fs7.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs7.lchmodSync = function(path16, mode) {
          var fd = fs7.openSync(path16, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs7.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs7.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs7.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs7) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs7.futimes) {
          fs7.lutimes = function(path16, at, mt, cb) {
            fs7.open(path16, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs7.futimes(fd, at, mt, function(er2) {
                fs7.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs7.lutimesSync = function(path16, at, mt) {
            var fd = fs7.openSync(path16, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs7.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs7.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs7.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs7.futimes) {
          fs7.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs7.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs6, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs6, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs6, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs6, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs6, target, options, callback) : orig.call(fs6, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs6, target, options) : orig.call(fs6, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream3 = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs6) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path16, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path16, options);
        Stream3.call(this);
        var self = this;
        this.path = path16;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs6.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path16, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path16, options);
        Stream3.call(this);
        this.path = path16;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs6.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs6 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs6[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs6, queue);
      fs6.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs6, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs6.close);
      fs6.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs6, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs6.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs6[gracefulQueue]);
          require("assert").equal(fs6[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs6[gracefulQueue]);
    }
    module2.exports = patch(clone(fs6));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs6.__patched) {
      module2.exports = patch(fs6);
      fs6.__patched = true;
    }
    function patch(fs7) {
      polyfills(fs7);
      fs7.gracefulify = patch;
      fs7.createReadStream = createReadStream;
      fs7.createWriteStream = createWriteStream;
      var fs$readFile = fs7.readFile;
      fs7.readFile = readFile4;
      function readFile4(path16, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path16, options, cb);
        function go$readFile(path17, options2, cb2, startTime) {
          return fs$readFile(path17, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path17, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs7.writeFile;
      fs7.writeFile = writeFile;
      function writeFile(path16, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path16, data, options, cb);
        function go$writeFile(path17, data2, options2, cb2, startTime) {
          return fs$writeFile(path17, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path17, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs7.appendFile;
      if (fs$appendFile)
        fs7.appendFile = appendFile;
      function appendFile(path16, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path16, data, options, cb);
        function go$appendFile(path17, data2, options2, cb2, startTime) {
          return fs$appendFile(path17, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path17, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs7.copyFile;
      if (fs$copyFile)
        fs7.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs7.readdir;
      fs7.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path16, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path17, options2, cb2, startTime) {
          return fs$readdir(path17, fs$readdirCallback(
            path17,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path17, options2, cb2, startTime) {
          return fs$readdir(path17, options2, fs$readdirCallback(
            path17,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path16, options, cb);
        function fs$readdirCallback(path17, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path17, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs7);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs7.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs7.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs7, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs7, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs7, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs7, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path16, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path16, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path16, options) {
        return new fs7.ReadStream(path16, options);
      }
      function createWriteStream(path16, options) {
        return new fs7.WriteStream(path16, options);
      }
      var fs$open = fs7.open;
      fs7.open = open;
      function open(path16, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path16, flags, mode, cb);
        function go$open(path17, flags2, mode2, cb2, startTime) {
          return fs$open(path17, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path17, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs7;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs6[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs6[gracefulQueue].length; ++i) {
        if (fs6[gracefulQueue][i].length > 2) {
          fs6[gracefulQueue][i][3] = now;
          fs6[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs6[gracefulQueue].length === 0)
        return;
      var elem = fs6[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs6[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/make-dir/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/make-dir/node_modules/semver/semver.js"(exports, module2) {
    exports = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports.parse = parse3;
    function parse3(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 !== "string") {
        return null;
      }
      if (version3.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version3)) {
        return null;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version3, options) {
      var v = parse3(version3, options);
      return v ? v.version : null;
    }
    exports.clean = clean2;
    function clean2(version3, options) {
      var s = parse3(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        if (version3.loose === options.loose) {
          return version3;
        } else {
          version3 = version3.version;
        }
      } else if (typeof version3 !== "string") {
        throw new TypeError("Invalid Version: " + version3);
      }
      if (version3.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version3, options);
      }
      debug("SemVer", version3, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version3.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version3);
      }
      this.raw = version3;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version3, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version3, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version22) {
      if (eq(version1, version22)) {
        return null;
      } else {
        var v12 = parse3(version1);
        var v2 = parse3(version22);
        var prefix = "";
        if (v12.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare2;
    function compare2(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare2(a, b, true);
    }
    exports.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare2(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare2(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare2(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare2(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare2(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare2(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare2(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version3) {
      debug("Comparator.test", version3, this.options.loose);
      if (this.semver === ANY || version3 === ANY) {
        return true;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version3, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version3) {
      if (!version3) {
        return false;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version3, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version3, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version3, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version3, range, options) {
      return outside(version3, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version3, range, options) {
      return outside(version3, range, ">", options);
    }
    exports.outside = outside;
    function outside(version3, range, hilo, options) {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version3, options) {
      var parsed = parse3(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version3, options) {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version3.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse3(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// node_modules/make-dir/index.js
var require_make_dir = __commonJS({
  "node_modules/make-dir/index.js"(exports, module2) {
    "use strict";
    var fs6 = require("fs");
    var path16 = require("path");
    var { promisify: promisify3 } = require("util");
    var semver = require_semver();
    var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path16.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error2 = new Error(`Path contains invalid characters: ${pth}`);
          error2.code = "EINVAL";
          throw error2;
        }
      }
    };
    var processOptions = (options) => {
      const defaults = {
        mode: 511,
        fs: fs6
      };
      return {
        ...defaults,
        ...options
      };
    };
    var permissionError = (pth) => {
      const error2 = new Error(`operation not permitted, mkdir '${pth}'`);
      error2.code = "EPERM";
      error2.errno = -4048;
      error2.path = pth;
      error2.syscall = "mkdir";
      return error2;
    };
    var makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      const mkdir = promisify3(options.fs.mkdir);
      const stat2 = promisify3(options.fs.stat);
      if (useNativeRecursiveOption && options.fs.mkdir === fs6.mkdir) {
        const pth = path16.resolve(input);
        await mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = async (pth) => {
        try {
          await mkdir(pth, options.mode);
          return pth;
        } catch (error2) {
          if (error2.code === "EPERM") {
            throw error2;
          }
          if (error2.code === "ENOENT") {
            if (path16.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error2.message.includes("null bytes")) {
              throw error2;
            }
            await make(path16.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat2(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error2;
          }
          return pth;
        }
      };
      return make(path16.resolve(input));
    };
    module2.exports = makeDir;
    module2.exports.sync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption && options.fs.mkdirSync === fs6.mkdirSync) {
        const pth = path16.resolve(input);
        fs6.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error2) {
          if (error2.code === "EPERM") {
            throw error2;
          }
          if (error2.code === "ENOENT") {
            if (path16.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error2.message.includes("null bytes")) {
              throw error2;
            }
            make(path16.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error2;
          }
        }
        return pth;
      };
      return make(path16.resolve(input));
    };
  }
});

// node_modules/xdg-basedir/index.js
var require_xdg_basedir = __commonJS({
  "node_modules/xdg-basedir/index.js"(exports) {
    "use strict";
    var os = require("os");
    var path16 = require("path");
    var homeDirectory = os.homedir();
    var { env } = process;
    exports.data = env.XDG_DATA_HOME || (homeDirectory ? path16.join(homeDirectory, ".local", "share") : void 0);
    exports.config = env.XDG_CONFIG_HOME || (homeDirectory ? path16.join(homeDirectory, ".config") : void 0);
    exports.cache = env.XDG_CACHE_HOME || (homeDirectory ? path16.join(homeDirectory, ".cache") : void 0);
    exports.runtime = env.XDG_RUNTIME_DIR || void 0;
    exports.dataDirs = (env.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":");
    if (exports.data) {
      exports.dataDirs.unshift(exports.data);
    }
    exports.configDirs = (env.XDG_CONFIG_DIRS || "/etc/xdg").split(":");
    if (exports.config) {
      exports.configDirs.unshift(exports.config);
    }
  }
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/imurmurhash/imurmurhash.js"(exports, module2) {
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module2 != "undefined") {
        module2.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports, module2) {
    var process4 = global.process;
    var processOk = function(process5) {
      return process5 && typeof process5 === "object" && typeof process5.removeListener === "function" && typeof process5.emit === "function" && typeof process5.reallyExit === "function" && typeof process5.listeners === "function" && typeof process5.kill === "function" && typeof process5.pid === "number" && typeof process5.on === "function";
    };
    if (!processOk(process4)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert7 = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process4.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process4.__signal_exit_emitter__) {
        emitter = process4.__signal_exit_emitter__;
      } else {
        emitter = process4.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert7.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process4.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process4.emit = originalProcessEmit;
        process4.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process4.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process4.kill(process4.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process4.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process4.emit = processEmit;
        process4.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process4.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process4.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process4.exitCode, null);
        emit("afterexit", process4.exitCode, null);
        originalProcessReallyExit.call(process4, process4.exitCode);
      };
      originalProcessEmit = process4.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process4.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process4.exitCode, null);
          emit("afterexit", process4.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert7;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module2) {
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module2) {
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/write-file-atomic/index.js
var require_write_file_atomic = __commonJS({
  "node_modules/write-file-atomic/index.js"(exports, module2) {
    "use strict";
    module2.exports = writeFile;
    module2.exports.sync = writeFileSync;
    module2.exports._getTmpname = getTmpname;
    module2.exports._cleanupOnExit = cleanupOnExit;
    var fs6 = require("fs");
    var MurmurHash3 = require_imurmurhash();
    var onExit = require_signal_exit();
    var path16 = require("path");
    var isTypedArray = require_is_typedarray();
    var typedArrayToBuffer = require_typedarray_to_buffer();
    var { promisify: promisify3 } = require("util");
    var activeFiles = {};
    var threadId = function getId() {
      try {
        const workerThreads = require("worker_threads");
        return workerThreads.threadId;
      } catch (e) {
        return 0;
      }
    }();
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return () => {
        try {
          fs6.unlinkSync(typeof tmpfile === "function" ? tmpfile() : tmpfile);
        } catch (_) {
        }
      };
    }
    function serializeActiveFile(absoluteName) {
      return new Promise((resolve10) => {
        if (!activeFiles[absoluteName])
          activeFiles[absoluteName] = [];
        activeFiles[absoluteName].push(resolve10);
        if (activeFiles[absoluteName].length === 1)
          resolve10();
      });
    }
    function isChownErrOk(err) {
      if (err.code === "ENOSYS") {
        return true;
      }
      const nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (err.code === "EINVAL" || err.code === "EPERM") {
          return true;
        }
      }
      return false;
    }
    async function writeFileAsync(filename, data, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      let fd;
      let tmpfile;
      const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
      const absoluteName = path16.resolve(filename);
      try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify3(fs6.realpath)(filename).catch(() => filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
          const stats = await promisify3(fs6.stat)(truename).catch(() => {
          });
          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }
            if (options.chown == null && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          }
        }
        fd = await promisify3(fs6.open)(tmpfile, "w", options.mode);
        if (options.tmpfileCreated) {
          await options.tmpfileCreated(tmpfile);
        }
        if (isTypedArray(data)) {
          data = typedArrayToBuffer(data);
        }
        if (Buffer.isBuffer(data)) {
          await promisify3(fs6.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
          await promisify3(fs6.write)(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          await promisify3(fs6.fsync)(fd);
        }
        await promisify3(fs6.close)(fd);
        fd = null;
        if (options.chown) {
          await promisify3(fs6.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        if (options.mode) {
          await promisify3(fs6.chmod)(tmpfile, options.mode).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        await promisify3(fs6.rename)(tmpfile, truename);
      } finally {
        if (fd) {
          await promisify3(fs6.close)(fd).catch(
            /* istanbul ignore next */
            () => {
            }
          );
        }
        removeOnExitHandler();
        await promisify3(fs6.unlink)(tmpfile).catch(() => {
        });
        activeFiles[absoluteName].shift();
        if (activeFiles[absoluteName].length > 0) {
          activeFiles[absoluteName][0]();
        } else
          delete activeFiles[absoluteName];
      }
    }
    function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = {};
      }
      const promise = writeFileAsync(filename, data, options);
      if (callback) {
        promise.then(callback, callback);
      }
      return promise;
    }
    function writeFileSync(filename, data, options) {
      if (typeof options === "string")
        options = { encoding: options };
      else if (!options)
        options = {};
      try {
        filename = fs6.realpathSync(filename);
      } catch (ex) {
      }
      const tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown) {
        try {
          const stats = fs6.statSync(filename);
          options = Object.assign({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
        } catch (ex) {
        }
      }
      let fd;
      const cleanup = cleanupOnExit(tmpfile);
      const removeOnExitHandler = onExit(cleanup);
      let threw = true;
      try {
        fd = fs6.openSync(tmpfile, "w", options.mode || 438);
        if (options.tmpfileCreated) {
          options.tmpfileCreated(tmpfile);
        }
        if (isTypedArray(data)) {
          data = typedArrayToBuffer(data);
        }
        if (Buffer.isBuffer(data)) {
          fs6.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs6.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          fs6.fsyncSync(fd);
        }
        fs6.closeSync(fd);
        fd = null;
        if (options.chown) {
          try {
            fs6.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        if (options.mode) {
          try {
            fs6.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        fs6.renameSync(tmpfile, filename);
        threw = false;
      } finally {
        if (fd) {
          try {
            fs6.closeSync(fd);
          } catch (ex) {
          }
        }
        removeOnExitHandler();
        if (threw) {
          cleanup();
        }
      }
    }
  }
});

// node_modules/is-obj/index.js
var require_is_obj = __commonJS({
  "node_modules/is-obj/index.js"(exports, module2) {
    "use strict";
    module2.exports = (value) => {
      const type = typeof value;
      return value !== null && (type === "object" || type === "function");
    };
  }
});

// node_modules/dot-prop/index.js
var require_dot_prop = __commonJS({
  "node_modules/dot-prop/index.js"(exports, module2) {
    "use strict";
    var isObj = require_is_obj();
    var disallowedKeys = [
      "__proto__",
      "prototype",
      "constructor"
    ];
    var isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.includes(segment));
    function getPathSegments(path16) {
      const pathArray = path16.split(".");
      const parts = [];
      for (let i = 0; i < pathArray.length; i++) {
        let p = pathArray[i];
        while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
          p = p.slice(0, -1) + ".";
          p += pathArray[++i];
        }
        parts.push(p);
      }
      if (!isValidPath(parts)) {
        return [];
      }
      return parts;
    }
    module2.exports = {
      get(object, path16, value) {
        if (!isObj(object) || typeof path16 !== "string") {
          return value === void 0 ? object : value;
        }
        const pathArray = getPathSegments(path16);
        if (pathArray.length === 0) {
          return;
        }
        for (let i = 0; i < pathArray.length; i++) {
          if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {
            return value;
          }
          object = object[pathArray[i]];
          if (object === void 0 || object === null) {
            if (i !== pathArray.length - 1) {
              return value;
            }
            break;
          }
        }
        return object;
      },
      set(object, path16, value) {
        if (!isObj(object) || typeof path16 !== "string") {
          return object;
        }
        const root = object;
        const pathArray = getPathSegments(path16);
        for (let i = 0; i < pathArray.length; i++) {
          const p = pathArray[i];
          if (!isObj(object[p])) {
            object[p] = {};
          }
          if (i === pathArray.length - 1) {
            object[p] = value;
          }
          object = object[p];
        }
        return root;
      },
      delete(object, path16) {
        if (!isObj(object) || typeof path16 !== "string") {
          return false;
        }
        const pathArray = getPathSegments(path16);
        for (let i = 0; i < pathArray.length; i++) {
          const p = pathArray[i];
          if (i === pathArray.length - 1) {
            delete object[p];
            return true;
          }
          object = object[p];
          if (!isObj(object)) {
            return false;
          }
        }
      },
      has(object, path16) {
        if (!isObj(object) || typeof path16 !== "string") {
          return false;
        }
        const pathArray = getPathSegments(path16);
        if (pathArray.length === 0) {
          return false;
        }
        for (let i = 0; i < pathArray.length; i++) {
          if (isObj(object)) {
            if (!(pathArray[i] in object)) {
              return false;
            }
            object = object[pathArray[i]];
          } else {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/crypto-random-string/index.js
var require_crypto_random_string = __commonJS({
  "node_modules/crypto-random-string/index.js"(exports, module2) {
    "use strict";
    var crypto5 = require("crypto");
    module2.exports = (length) => {
      if (!Number.isFinite(length)) {
        throw new TypeError("Expected a finite number");
      }
      return crypto5.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
    };
  }
});

// node_modules/unique-string/index.js
var require_unique_string = __commonJS({
  "node_modules/unique-string/index.js"(exports, module2) {
    "use strict";
    var cryptoRandomString = require_crypto_random_string();
    module2.exports = () => cryptoRandomString(32);
  }
});

// node_modules/configstore/index.js
var require_configstore = __commonJS({
  "node_modules/configstore/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var os = require("os");
    var fs6 = require_graceful_fs();
    var makeDir = require_make_dir();
    var xdgBasedir = require_xdg_basedir();
    var writeFileAtomic = require_write_file_atomic();
    var dotProp = require_dot_prop();
    var uniqueString = require_unique_string();
    var configDirectory = xdgBasedir.config || path16.join(os.tmpdir(), uniqueString());
    var permissionError = "You don't have access to this file.";
    var makeDirOptions = { mode: 448 };
    var writeFileOptions = { mode: 384 };
    var Configstore = class {
      constructor(id, defaults, options = {}) {
        const pathPrefix = options.globalConfigPath ? path16.join(id, "config.json") : path16.join("configstore", `${id}.json`);
        this.path = options.configPath || path16.join(configDirectory, pathPrefix);
        if (defaults) {
          this.all = {
            ...defaults,
            ...this.all
          };
        }
      }
      get all() {
        try {
          return JSON.parse(fs6.readFileSync(this.path, "utf8"));
        } catch (error2) {
          if (error2.code === "ENOENT") {
            return {};
          }
          if (error2.code === "EACCES") {
            error2.message = `${error2.message}
${permissionError}
`;
          }
          if (error2.name === "SyntaxError") {
            writeFileAtomic.sync(this.path, "", writeFileOptions);
            return {};
          }
          throw error2;
        }
      }
      set all(value) {
        try {
          makeDir.sync(path16.dirname(this.path), makeDirOptions);
          writeFileAtomic.sync(this.path, JSON.stringify(value, void 0, "	"), writeFileOptions);
        } catch (error2) {
          if (error2.code === "EACCES") {
            error2.message = `${error2.message}
${permissionError}
`;
          }
          throw error2;
        }
      }
      get size() {
        return Object.keys(this.all || {}).length;
      }
      get(key) {
        return dotProp.get(this.all, key);
      }
      set(key, value) {
        const config = this.all;
        if (arguments.length === 1) {
          for (const k of Object.keys(key)) {
            dotProp.set(config, k, key[k]);
          }
        } else {
          dotProp.set(config, key, value);
        }
        this.all = config;
      }
      has(key) {
        return dotProp.has(this.all, key);
      }
      delete(key) {
        const config = this.all;
        dotProp.delete(config, key);
        this.all = config;
      }
      clear() {
        this.all = {};
      }
    };
    module2.exports = Configstore;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/cfgStore.js
var require_cfgStore = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/cfgStore.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigStore = void 0;
    var configstore_1 = __importDefault(require_configstore());
    exports.ConfigStore = configstore_1.default;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/GlobalSettings.js
var require_GlobalSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/GlobalSettings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGlobalConfigPath = exports.writeRawGlobalSettings = exports.getRawGlobalSettings = void 0;
    var util_1 = require("util");
    var errors_js_1 = require_errors3();
    var logger_js_1 = require_logger();
    var cfgStore_js_1 = require_cfgStore();
    var packageName = "cspell";
    function getRawGlobalSettings() {
      const name = "CSpell Configstore";
      const globalConf = {
        source: {
          name,
          filename: void 0
        }
      };
      try {
        const cfgStore = new cfgStore_js_1.ConfigStore(packageName);
        const cfg = cfgStore.all;
        if (cfg && Object.keys(cfg).length) {
          Object.assign(globalConf, cfg);
          globalConf.source = {
            name,
            filename: cfgStore.path
          };
        }
      } catch (error2) {
        if (!(0, errors_js_1.isErrnoException)(error2) || !error2.code || !["ENOENT", "EACCES", "ENOTDIR", "EISDIR"].includes(error2.code)) {
          (0, logger_js_1.logError)(error2);
        }
      }
      return globalConf;
    }
    exports.getRawGlobalSettings = getRawGlobalSettings;
    function writeRawGlobalSettings(settings) {
      const toWrite = {
        import: settings.import
      };
      try {
        const cfgStore = new cfgStore_js_1.ConfigStore(packageName);
        cfgStore.set(toWrite);
        return void 0;
      } catch (error2) {
        if (error2 instanceof Error)
          return error2;
        return new Error((0, util_1.format)(error2));
      }
    }
    exports.writeRawGlobalSettings = writeRawGlobalSettings;
    function getGlobalConfigPath() {
      const cfgStore = new cfgStore_js_1.ConfigStore(packageName);
      return cfgStore.path;
    }
    exports.getGlobalConfigPath = getGlobalConfigPath;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/ImportError.js
var require_ImportError = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/ImportError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsupportedPnpFile = exports.UnsupportedSchema = exports.ImportError = void 0;
    var errors_js_1 = require_errors3();
    var ImportError = class extends Error {
      constructor(msg, cause) {
        super(msg);
        this.cause = (0, errors_js_1.isError)(cause) ? cause : void 0;
      }
    };
    exports.ImportError = ImportError;
    var UnsupportedSchema = class extends Error {
      constructor(msg) {
        super(msg);
      }
    };
    exports.UnsupportedSchema = UnsupportedSchema;
    var UnsupportedPnpFile = class extends Error {
      constructor(msg) {
        super(msg);
      }
    };
    exports.UnsupportedPnpFile = UnsupportedPnpFile;
  }
});

// node_modules/clear-module/node_modules/parent-module/index.js
var require_parent_module2 = __commonJS({
  "node_modules/clear-module/node_modules/parent-module/index.js"(exports, module2) {
    "use strict";
    var callsites = require_callsites();
    module2.exports = (filePath) => {
      const stacks = callsites();
      if (!filePath) {
        return stacks[2].getFileName();
      }
      let hasSeenValue = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilePath = stack.getFileName();
        if (typeof parentFilePath !== "string") {
          continue;
        }
        if (parentFilePath === filePath) {
          hasSeenValue = true;
          continue;
        }
        if (parentFilePath === "module.js") {
          continue;
        }
        if (hasSeenValue && parentFilePath !== filePath) {
          return parentFilePath;
        }
      }
    };
  }
});

// node_modules/clear-module/index.js
var require_clear_module = __commonJS({
  "node_modules/clear-module/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var resolveFrom = require_resolve_from2();
    var parentModule = require_parent_module2();
    var resolve10 = (moduleId) => {
      try {
        return resolveFrom(path16.dirname(parentModule(__filename)), moduleId);
      } catch (_) {
      }
    };
    var clear = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
      }
      const filePath = resolve10(moduleId);
      if (!filePath) {
        return;
      }
      if (require.cache[filePath] && require.cache[filePath].parent) {
        let i = require.cache[filePath].parent.children.length;
        while (i--) {
          if (require.cache[filePath].parent.children[i].id === filePath) {
            require.cache[filePath].parent.children.splice(i, 1);
          }
        }
      }
      if (require.cache[filePath]) {
        const children = require.cache[filePath].children.map((child) => child.id);
        delete require.cache[filePath];
        for (const id of children) {
          clear(id);
        }
      }
    };
    clear.all = () => {
      const directory = path16.dirname(parentModule(__filename));
      for (const moduleId of Object.keys(require.cache)) {
        delete require.cache[resolveFrom(directory, moduleId)];
      }
    };
    clear.match = (regex) => {
      for (const moduleId of Object.keys(require.cache)) {
        if (regex.test(moduleId)) {
          clear(moduleId);
        }
      }
    };
    clear.single = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
      }
      delete require.cache[resolve10(moduleId)];
    };
    module2.exports = clear;
  }
});

// node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS({
  "node_modules/yocto-queue/index.js"(exports, module2) {
    var Node = class {
      /// value;
      /// next;
      constructor(value) {
        this.value = value;
        this.next = void 0;
      }
    };
    var Queue = class {
      // TODO: Use private class fields when targeting Node.js 12.
      // #_head;
      // #_tail;
      // #_size;
      constructor() {
        this.clear();
      }
      enqueue(value) {
        const node = new Node(value);
        if (this._head) {
          this._tail.next = node;
          this._tail = node;
        } else {
          this._head = node;
          this._tail = node;
        }
        this._size++;
      }
      dequeue() {
        const current = this._head;
        if (!current) {
          return;
        }
        this._head = this._head.next;
        this._size--;
        return current.value;
      }
      clear() {
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
          yield current.value;
          current = current.next;
        }
      }
    };
    module2.exports = Queue;
  }
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/p-limit/index.js"(exports, module2) {
    "use strict";
    var Queue = require_yocto_queue();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
      const queue = new Queue();
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.size > 0) {
          queue.dequeue()();
        }
      };
      const run2 = async (fn, resolve10, ...args) => {
        activeCount++;
        const result = (async () => fn(...args))();
        resolve10(result);
        try {
          await result;
        } catch {
        }
        next();
      };
      const enqueue = (fn, resolve10, ...args) => {
        queue.enqueue(run2.bind(null, fn, resolve10, ...args));
        (async () => {
          await Promise.resolve();
          if (activeCount < concurrency && queue.size > 0) {
            queue.dequeue()();
          }
        })();
      };
      const generator = (fn, ...args) => new Promise((resolve10) => {
        enqueue(fn, resolve10, ...args);
      });
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.size
        },
        clearQueue: {
          value: () => {
            queue.clear();
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
  }
});

// node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "node_modules/p-locate/index.js"(exports, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options) => {
      options = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options
      };
      const limit = pLimit(options.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error2) {
        if (error2 instanceof EndError) {
          return error2.value;
        }
        throw error2;
      }
    };
    module2.exports = pLocate;
  }
});

// node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "node_modules/locate-path/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var fs6 = require("fs");
    var { promisify: promisify3 } = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify3(fs6.stat);
    var fsLStat = promisify3(fs6.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat2) => type === void 0 || stat2[typeMappings[type]]();
    module2.exports = async (paths, options) => {
      options = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat2 = await statFn(path16.resolve(options.cwd, path_));
          return matchType(options.type, stat2);
        } catch {
          return false;
        }
      }, options);
    };
    module2.exports.sync = (paths, options) => {
      options = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fs6.statSync : fs6.lstatSync;
      for (const path_ of paths) {
        try {
          const stat2 = statFn(path16.resolve(options.cwd, path_));
          if (matchType(options.type, stat2)) {
            return path_;
          }
        } catch {
        }
      }
    };
  }
});

// node_modules/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/path-exists/index.js"(exports, module2) {
    "use strict";
    var fs6 = require("fs");
    var { promisify: promisify3 } = require("util");
    var pAccess = promisify3(fs6.access);
    module2.exports = async (path16) => {
      try {
        await pAccess(path16);
        return true;
      } catch (_) {
        return false;
      }
    };
    module2.exports.sync = (path16) => {
      try {
        fs6.accessSync(path16);
        return true;
      } catch (_) {
        return false;
      }
    };
  }
});

// node_modules/find-up/index.js
var require_find_up = __commonJS({
  "node_modules/find-up/index.js"(exports, module2) {
    "use strict";
    var path16 = require("path");
    var locatePath = require_locate_path();
    var pathExists = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options = {}) => {
      let directory = path16.resolve(options.cwd || "");
      const { root } = path16.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path16.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path16.dirname(directory);
      }
    };
    module2.exports.sync = (name, options = {}) => {
      let directory = path16.resolve(options.cwd || "");
      const { root } = path16.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path16.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path16.dirname(directory);
      }
    };
    module2.exports.exists = pathExists;
    module2.exports.sync.exists = pathExists.sync;
    module2.exports.stop = stop;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/pnpLoader.js
var require_pnpLoader = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/pnpLoader.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clearPnPGlobalCache = exports.pnpLoader = exports.PnpLoader = void 0;
    var clear_module_1 = __importDefault(require_clear_module());
    var find_up_1 = __importDefault(require_find_up());
    var import_fresh_1 = __importDefault(require_import_fresh());
    var Uri_js_1 = require_Uri();
    var ImportError_js_1 = require_ImportError();
    var defaultPnpFiles = [".pnp.cjs", ".pnp.js"];
    var supportedSchemas = /* @__PURE__ */ new Set(["file"]);
    var cachedRequests = /* @__PURE__ */ new Map();
    var lock = void 0;
    var cachedPnpImportsSync = /* @__PURE__ */ new Map();
    var cachedRequestsSync = /* @__PURE__ */ new Map();
    var PnpLoader = class {
      constructor(pnpFiles = defaultPnpFiles) {
        this.pnpFiles = pnpFiles;
        this.cacheKeySuffix = ":" + pnpFiles.join();
      }
      /**
       * Request that the nearest .pnp file gets loaded
       * @param uriDirectory starting directory
       * @returns promise - rejects on error - success if loaded or not found.
       */
      async load(uriDirectory) {
        if (!supportedSchemas.has(uriDirectory.scheme))
          return void 0;
        await lock;
        const cacheKey = this.calcKey(uriDirectory);
        const cached = cachedRequests.get(cacheKey);
        if (cached)
          return cached;
        const r = findPnpAndLoad(uriDirectory, this.pnpFiles);
        cachedRequests.set(cacheKey, r);
        const result = await r;
        cachedRequestsSync.set(cacheKey, result);
        return result;
      }
      async peek(uriDirectory) {
        if (!supportedSchemas.has(uriDirectory.scheme))
          return void 0;
        await lock;
        const cacheKey = this.calcKey(uriDirectory);
        return cachedRequests.get(cacheKey) ?? Promise.resolve(void 0);
      }
      /**
       * Request that the nearest .pnp file gets loaded
       * @param uriDirectory starting directory
       * @returns promise - rejects on error - success if loaded or not found.
       */
      loadSync(uriDirectory) {
        if (!supportedSchemas.has(uriDirectory.scheme))
          return void 0;
        const cacheKey = this.calcKey(uriDirectory);
        const cached = cachedRequestsSync.get(cacheKey);
        if (cached)
          return cached;
        const r = findPnpAndLoadSync(uriDirectory, this.pnpFiles);
        cachedRequestsSync.set(cacheKey, r);
        cachedRequests.set(cacheKey, Promise.resolve(r));
        return r;
      }
      peekSync(uriDirectory) {
        if (!supportedSchemas.has(uriDirectory.scheme))
          return void 0;
        const cacheKey = this.calcKey(uriDirectory);
        return cachedRequestsSync.get(cacheKey);
      }
      /**
       * Clears the cached so .pnp files will get reloaded on request.
       */
      clearCache() {
        return clearPnPGlobalCache();
      }
      calcKey(uriDirectory) {
        return uriDirectory.toString() + this.cacheKeySuffix;
      }
    };
    exports.PnpLoader = PnpLoader;
    function pnpLoader(pnpFiles) {
      return new PnpLoader(pnpFiles);
    }
    exports.pnpLoader = pnpLoader;
    async function findPnpAndLoad(uriDirectory, pnpFiles) {
      const found = await (0, find_up_1.default)(pnpFiles, { cwd: (0, Uri_js_1.uriToFilePath)(uriDirectory) });
      return loadPnpIfNeeded(found);
    }
    function findPnpAndLoadSync(uriDirectory, pnpFiles) {
      const found = find_up_1.default.sync(pnpFiles, { cwd: (0, Uri_js_1.uriToFilePath)(uriDirectory) });
      return loadPnpIfNeeded(found);
    }
    function loadPnpIfNeeded(found) {
      if (!found)
        return void 0;
      const c = cachedPnpImportsSync.get(found);
      if (c || cachedPnpImportsSync.has(found))
        return c;
      const r = loadPnp(found);
      cachedPnpImportsSync.set(found, r);
      return r;
    }
    function loadPnp(pnpFile) {
      const pnp = (0, import_fresh_1.default)(pnpFile);
      if (pnp.setup) {
        pnp.setup();
        return (0, Uri_js_1.toUri)(pnpFile);
      }
      throw new ImportError_js_1.UnsupportedPnpFile(`Unsupported pnp file: "${pnpFile}"`);
    }
    function clearPnPGlobalCache() {
      if (lock)
        return lock;
      lock = _cleanCache().finally(() => {
        lock = void 0;
      });
      return lock;
    }
    exports.clearPnPGlobalCache = clearPnPGlobalCache;
    async function _cleanCache() {
      await Promise.all([...cachedRequests.values()].map(rejectToUndefined));
      const modules = [...cachedPnpImportsSync.values()];
      modules.forEach((r) => r && clear_module_1.default.single((0, Uri_js_1.uriToFilePath)(r)));
      cachedRequests.clear();
      cachedRequestsSync.clear();
      cachedPnpImportsSync.clear();
      return void 0;
    }
    function rejectToUndefined(p) {
      return p.catch(() => void 0);
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/defaultSettings.js
var require_defaultSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/defaultSettings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultSettings = void 0;
    var CSpellSettingsInternalDef_js_1 = require_CSpellSettingsInternalDef();
    var constants_js_1 = require_constants3();
    exports.defaultSettings = (0, CSpellSettingsInternalDef_js_1.createCSpellSettingsInternal)({
      id: "default",
      name: "default",
      version: constants_js_1.currentSettingsFileVersion
    });
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/toGlobDef.js
var require_toGlobDef = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/toGlobDef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toGlobDef = void 0;
    function toGlobDef(g, root, source) {
      if (g === void 0)
        return void 0;
      if (Array.isArray(g)) {
        return g.map((g2) => toGlobDef(g2, root, source));
      }
      if (typeof g === "string") {
        const glob2 = { glob: g };
        if (root !== void 0) {
          glob2.root = root;
        }
        return toGlobDef(glob2, root, source);
      }
      if (source) {
        return { ...g, source };
      }
      return g;
    }
    exports.toGlobDef = toGlobDef;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/normalizeRawSettings.js
var require_normalizeRawSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/normalizeRawSettings.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeCacheSettings = exports.normalizeSettingsGlobs = exports.normalizeGitignoreRoot = exports.normalizeLanguageSettings = exports.normalizeReporters = exports.normalizeOverrides = exports.normalizeDictionaryDefs = exports.normalizeRawConfig = void 0;
    var path16 = __importStar(require("path"));
    var resolveFile_js_1 = require_resolveFile();
    var util = __importStar(require_util());
    var DictionarySettings_js_1 = require_DictionarySettings();
    var toGlobDef_js_1 = require_toGlobDef();
    function normalizeRawConfig(config) {
      if (typeof config.version === "number") {
        config.version = config.version.toString();
      }
    }
    exports.normalizeRawConfig = normalizeRawConfig;
    function normalizeDictionaryDefs(settings, pathToSettingsFile) {
      const dictionaryDefinitions = (0, DictionarySettings_js_1.mapDictDefsToInternal)(settings.dictionaryDefinitions, pathToSettingsFile);
      const languageSettings = settings.languageSettings?.map((langSetting) => util.clean({
        ...langSetting,
        dictionaryDefinitions: (0, DictionarySettings_js_1.mapDictDefsToInternal)(langSetting.dictionaryDefinitions, pathToSettingsFile)
      }));
      return util.clean({
        dictionaryDefinitions,
        languageSettings
      });
    }
    exports.normalizeDictionaryDefs = normalizeDictionaryDefs;
    function normalizeOverrides(settings, pathToSettingsFile) {
      const { globRoot = path16.dirname(pathToSettingsFile) } = settings;
      const overrides = settings.overrides?.map((override) => {
        const filename = (0, toGlobDef_js_1.toGlobDef)(override.filename, globRoot, pathToSettingsFile);
        const { dictionaryDefinitions, languageSettings } = normalizeDictionaryDefs(override, pathToSettingsFile);
        return util.clean({
          ...override,
          filename,
          dictionaryDefinitions,
          languageSettings: normalizeLanguageSettings(languageSettings)
        });
      });
      return overrides ? { overrides } : {};
    }
    exports.normalizeOverrides = normalizeOverrides;
    function normalizeReporters(settings, pathToSettingsFile) {
      if (settings.reporters === void 0)
        return {};
      const folder = path16.dirname(pathToSettingsFile);
      function resolve10(s) {
        if (s === "default")
          return s;
        const r = (0, resolveFile_js_1.resolveFile)(s, folder);
        if (!r.found) {
          throw new Error(`Not found: "${s}"`);
        }
        return r.filename;
      }
      function resolveReporter(s) {
        if (typeof s === "string") {
          return resolve10(s);
        }
        if (!Array.isArray(s) || typeof s[0] !== "string")
          throw new Error("Invalid Reporter");
        const [r, ...rest] = s;
        return [resolve10(r), ...rest];
      }
      return {
        reporters: settings.reporters.map(resolveReporter)
      };
    }
    exports.normalizeReporters = normalizeReporters;
    function normalizeLanguageSettings(languageSettings) {
      if (!languageSettings)
        return void 0;
      function fixLocale(s) {
        const { local: locale, ...rest } = s;
        return util.clean({ locale, ...rest });
      }
      return languageSettings.map(fixLocale);
    }
    exports.normalizeLanguageSettings = normalizeLanguageSettings;
    function normalizeGitignoreRoot(settings, pathToSettingsFile) {
      const { gitignoreRoot } = settings;
      if (!gitignoreRoot)
        return {};
      const dir = path16.dirname(pathToSettingsFile);
      const roots = Array.isArray(gitignoreRoot) ? gitignoreRoot : [gitignoreRoot];
      return {
        gitignoreRoot: roots.map((p) => path16.resolve(dir, p))
      };
    }
    exports.normalizeGitignoreRoot = normalizeGitignoreRoot;
    function normalizeSettingsGlobs(settings, pathToSettingsFile) {
      const { globRoot } = settings;
      if (settings.ignorePaths === void 0)
        return {};
      const ignorePaths = (0, toGlobDef_js_1.toGlobDef)(settings.ignorePaths, globRoot, pathToSettingsFile);
      return {
        ignorePaths
      };
    }
    exports.normalizeSettingsGlobs = normalizeSettingsGlobs;
    function normalizeCacheSettings(settings, pathToSettingsDir) {
      const { cache } = settings;
      if (cache === void 0)
        return {};
      const { cacheLocation } = cache;
      if (cacheLocation === void 0)
        return { cache };
      return { cache: { ...cache, cacheLocation: resolveFilePath(cacheLocation, pathToSettingsDir) } };
    }
    exports.normalizeCacheSettings = normalizeCacheSettings;
    function resolveFilePath(filename, pathToSettingsFile) {
      const cwd = process.cwd();
      return path16.resolve(pathToSettingsFile, filename.replace("${cwd}", cwd));
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/PnPSettings.js
var require_PnPSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/PnPSettings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizePnPSettings = exports.defaultPnPSettings = void 0;
    var util_js_1 = require_util();
    exports.defaultPnPSettings = Object.freeze({});
    var lastPnP = exports.defaultPnPSettings;
    function normalizePnPSettings(settings) {
      if (equal(lastPnP, settings))
        return lastPnP;
      if (equal(exports.defaultPnPSettings, settings))
        return exports.defaultPnPSettings;
      const { usePnP, pnpFiles } = settings;
      return lastPnP = (0, util_js_1.clean)({ usePnP, pnpFiles });
    }
    exports.normalizePnPSettings = normalizePnPSettings;
    function equal(a, b) {
      return a === b || a.usePnP === b.usePnP && (a.pnpFiles === b.pnpFiles || a.pnpFiles?.join("|") === b.pnpFiles?.join("|"));
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/configLoader.js
var require_configLoader = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/configLoader.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.getDefaultConfigLoader = exports.createConfigLoader = exports.clearCachedSettingsFiles = exports.getCachedFileSize = exports.getGlobalSettings = exports.readRawSettings = exports.loadPnPSync = exports.loadPnP = exports.loadConfigSync = exports.loadConfig = exports.searchForConfigSync = exports.searchForConfig = exports.ConfigLoader = exports.defaultConfigFilenames = exports.defaultFileName = exports.sectionCSpell = void 0;
    var json = __importStar(require_src2());
    var cosmiconfig_1 = require_dist();
    var cspell_io_1 = require_cjs3();
    var path16 = __importStar(require("path"));
    var CSpellSettingsInternalDef_js_1 = require_CSpellSettingsInternalDef();
    var AutoResolveLRUCache_js_1 = require_AutoResolveLRUCache();
    var logger_js_1 = require_logger();
    var resolveFile_js_1 = require_resolveFile();
    var Uri_js_1 = require_Uri();
    var constants_js_1 = require_constants3();
    var CSpellSettingsServer_js_1 = require_CSpellSettingsServer();
    var GlobalSettings_js_1 = require_GlobalSettings();
    var ImportError_js_1 = require_ImportError();
    var pnpLoader_js_1 = require_pnpLoader();
    var defaultSettings_js_1 = require_defaultSettings();
    var normalizeRawSettings_js_1 = require_normalizeRawSettings();
    var PnPSettings_js_1 = require_PnPSettings();
    var supportedCSpellConfigVersions = [constants_js_1.configSettingsFileVersion0_2];
    var setOfSupportedConfigVersions = Object.freeze(new Set(supportedCSpellConfigVersions));
    exports.sectionCSpell = "cSpell";
    exports.defaultFileName = "cspell.json";
    var gcl = getDefaultConfigLoaderInternal;
    var CACHE_SIZE_SEARCH_CONFIG = 32;
    var searchPlaces = Object.freeze([
      "package.json",
      // Original locations
      ".cspell.json",
      "cspell.json",
      ".cSpell.json",
      "cSpell.json",
      // Original locations jsonc
      ".cspell.jsonc",
      "cspell.jsonc",
      // Alternate locations
      ".vscode/cspell.json",
      ".vscode/cSpell.json",
      ".vscode/.cspell.json",
      // Standard Locations
      "cspell.config.json",
      "cspell.config.jsonc",
      "cspell.config.yaml",
      "cspell.config.yml",
      "cspell.yaml",
      "cspell.yml",
      // Dynamic config is looked for last
      "cspell.config.js",
      "cspell.config.cjs",
      // .config
      ".config/.cspell.json",
      ".config/cspell.json",
      ".config/.cSpell.json",
      ".config/cSpell.json",
      ".config/.cspell.jsonc",
      ".config/cspell.jsonc",
      ".config/cspell.config.json",
      ".config/cspell.config.jsonc",
      ".config/cspell.config.yaml",
      ".config/cspell.config.yml",
      ".config/cspell.yaml",
      ".config/cspell.yml",
      ".config/cspell.config.js",
      ".config/cspell.config.cjs"
    ]);
    var cspellCosmiconfig = {
      searchPlaces: searchPlaces.concat(),
      loaders: {
        ".json": parseJson,
        ".jsonc": parseJson
      }
    };
    function parseJson(_filename, content) {
      return json.parse(content);
    }
    exports.defaultConfigFilenames = Object.freeze(searchPlaces.concat());
    var defaultConfigLoader = void 0;
    var ConfigLoader = class {
      /**
       * Use `createConfigLoader`
       * @param cspellIO - CSpellIO interface for reading files.
       */
      constructor(cspellIO) {
        this.cspellIO = cspellIO;
        this.cachedFiles = /* @__PURE__ */ new Map();
        this.cspellConfigExplorer = (0, cosmiconfig_1.cosmiconfig)("cspell", cspellCosmiconfig);
        this.cspellConfigExplorerSync = (0, cosmiconfig_1.cosmiconfigSync)("cspell", cspellCosmiconfig);
        this.searchConfigLRU = new AutoResolveLRUCache_js_1.AutoResolveLRUCache(CACHE_SIZE_SEARCH_CONFIG, (a, b) => a.searchFrom === b.searchFrom && a.pnpSettings === b.pnpSettings);
      }
      readSettings(filename, relativeToOrDefault, defaultValue) {
        const relativeTo = (typeof relativeToOrDefault === "string" ? relativeToOrDefault : "") || process.cwd();
        defaultValue = defaultValue || (typeof relativeToOrDefault !== "string" ? relativeToOrDefault : void 0);
        const ref = resolveFilename2(filename, relativeTo);
        return this.importSettings(ref, defaultValue, defaultValue || PnPSettings_js_1.defaultPnPSettings);
      }
      async readSettingsAsync(filename, relativeTo, pnpSettings) {
        const ref = resolveFilename2(filename, relativeTo || process.cwd());
        return this.importSettings(ref, void 0, pnpSettings || PnPSettings_js_1.defaultPnPSettings);
      }
      /**
       *
       * @param searchFrom the directory / file to start searching from.
       * @param pnpSettings - related to Using Yarn PNP.
       * @returns the resulting settings
       */
      searchForConfig(searchFrom, pnpSettings = PnPSettings_js_1.defaultPnPSettings) {
        pnpSettings = (0, PnPSettings_js_1.normalizePnPSettings)(pnpSettings);
        return this.searchConfigLRU.get({ searchFrom, pnpSettings }, (p) => this._searchForConfig(p));
      }
      _searchForConfig(params) {
        return gcl().normalizeSearchForConfigResultAsync(params.searchFrom || process.cwd(), this.cspellConfigExplorer.search(params.searchFrom), params.pnpSettings).then((r) => r.filepath ? r.config : void 0);
      }
      getGlobalSettings() {
        if (!this.globalSettings) {
          const globalConf = (0, GlobalSettings_js_1.getRawGlobalSettings)();
          this.globalSettings = {
            id: "global_config",
            ...this.normalizeSettings(globalConf || {}, "./global_config", {})
          };
        }
        return this.globalSettings;
      }
      clearCachedSettingsFiles() {
        this.searchConfigLRU.clear();
        this.globalSettings = void 0;
        this.cachedFiles.clear();
        this.cspellConfigExplorer.clearCaches();
        this.cspellConfigExplorerSync.clearCaches();
      }
      /**
       * Read a config file and inject the fileRef.
       * @param fileRef - filename plus context, injected into the resulting config.
       */
      readConfig(fileRef) {
        const { filename, error: error2 } = fileRef;
        if (error2) {
          fileRef.error = error2 instanceof ImportError_js_1.ImportError ? error2 : new ImportError_js_1.ImportError(`Failed to read config file: "${filename}"`, error2);
          return { __importRef: fileRef };
        }
        const s = {};
        try {
          const r = this.cspellConfigExplorerSync.load(filename);
          if (!r?.config)
            throw new Error(`not found: "${filename}"`);
          Object.assign(s, r.config);
          (0, normalizeRawSettings_js_1.normalizeRawConfig)(s);
          validateRawConfig(s, fileRef);
        } catch (err) {
          fileRef.error = err instanceof ImportError_js_1.ImportError ? err : new ImportError_js_1.ImportError(`Failed to read config file: "${filename}"`, err);
        }
        s.__importRef = fileRef;
        return s;
      }
      importSettings(fileRef, defaultValues, pnpSettings) {
        defaultValues = defaultValues ?? defaultSettings_js_1.defaultSettings;
        const { filename } = fileRef;
        const importRef = { ...fileRef };
        const cached = this.cachedFiles.get(filename);
        if (cached) {
          const cachedImportRef = cached.__importRef || importRef;
          cachedImportRef.referencedBy = mergeSourceList(cachedImportRef.referencedBy || [], importRef.referencedBy);
          cached.__importRef = cachedImportRef;
          return cached;
        }
        const id = [path16.basename(path16.dirname(filename)), path16.basename(filename)].join("/");
        const name = "";
        const finalizeSettings = (0, CSpellSettingsInternalDef_js_1.createCSpellSettingsInternal)({ id, name, __importRef: importRef });
        this.cachedFiles.set(filename, finalizeSettings);
        const settings = { ...defaultValues, id, name, ...this.readConfig(importRef) };
        Object.assign(finalizeSettings, this.normalizeSettings(settings, filename, pnpSettings));
        const finalizeSrc = { name: path16.basename(filename), ...finalizeSettings.source };
        finalizeSettings.source = { ...finalizeSrc, filename };
        this.cachedFiles.set(filename, finalizeSettings);
        return finalizeSettings;
      }
      /**
       * normalizeSettings handles correcting all relative paths, anchoring globs, and importing other config files.
       * @param rawSettings - raw configuration settings
       * @param pathToSettingsFile - path to the source file of the configuration settings.
       */
      normalizeSettings(rawSettings, pathToSettingsFile, pnpSettings) {
        const id = rawSettings.id || [path16.basename(path16.dirname(pathToSettingsFile)), path16.basename(pathToSettingsFile)].join("/");
        const name = rawSettings.name || id;
        const { usePnP = pnpSettings.usePnP, pnpFiles = pnpSettings.pnpFiles } = rawSettings;
        const pnpSettingsToUse = (0, PnPSettings_js_1.normalizePnPSettings)({ usePnP, pnpFiles });
        const pathToSettingsDir = path16.dirname(pathToSettingsFile);
        loadPnPSync(pnpSettingsToUse, (0, Uri_js_1.toUri)(pathToSettingsDir));
        const settings = {
          version: defaultSettings_js_1.defaultSettings.version,
          ...rawSettings,
          id,
          name,
          globRoot: resolveGlobRoot(rawSettings, pathToSettingsFile),
          languageSettings: (0, normalizeRawSettings_js_1.normalizeLanguageSettings)(rawSettings.languageSettings)
        };
        const pathToSettings = path16.dirname(pathToSettingsFile);
        const normalizedDictionaryDefs = (0, normalizeRawSettings_js_1.normalizeDictionaryDefs)(settings, pathToSettingsFile);
        const normalizedSettingsGlobs = (0, normalizeRawSettings_js_1.normalizeSettingsGlobs)(settings, pathToSettingsFile);
        const normalizedOverrides = (0, normalizeRawSettings_js_1.normalizeOverrides)(settings, pathToSettingsFile);
        const normalizedReporters = (0, normalizeRawSettings_js_1.normalizeReporters)(settings, pathToSettingsFile);
        const normalizedGitignoreRoot = (0, normalizeRawSettings_js_1.normalizeGitignoreRoot)(settings, pathToSettingsFile);
        const normalizedCacheSettings = (0, normalizeRawSettings_js_1.normalizeCacheSettings)(settings, pathToSettingsDir);
        const imports = typeof settings.import === "string" ? [settings.import] : settings.import || [];
        const source = settings.source || {
          name: settings.name,
          filename: pathToSettingsFile
        };
        const fileSettings = (0, CSpellSettingsInternalDef_js_1.createCSpellSettingsInternal)({
          ...settings,
          source,
          ...normalizedDictionaryDefs,
          ...normalizedSettingsGlobs,
          ...normalizedOverrides,
          ...normalizedReporters,
          ...normalizedGitignoreRoot,
          ...normalizedCacheSettings
        });
        if (!imports.length) {
          return fileSettings;
        }
        const importedSettings = imports.map((name2) => resolveFilename2(name2, pathToSettings)).map((ref) => (ref.referencedBy = [source], ref)).map((ref) => this.importSettings(ref, void 0, pnpSettingsToUse)).reduce((a, b) => (0, CSpellSettingsServer_js_1.mergeSettings)(a, b));
        const finalizeSettings = (0, CSpellSettingsServer_js_1.mergeSettings)(importedSettings, fileSettings);
        finalizeSettings.name = settings.name || finalizeSettings.name || "";
        finalizeSettings.id = settings.id || finalizeSettings.id || "";
        return finalizeSettings;
      }
    };
    exports.ConfigLoader = ConfigLoader;
    var ConfigLoaderInternal = class extends ConfigLoader {
      constructor(cspellIO) {
        super(cspellIO);
        this._readConfig = this.readConfig.bind(this);
        this._normalizeSettings = this.normalizeSettings.bind(this);
      }
      get _cachedFiles() {
        return this.cachedFiles;
      }
      get _cspellConfigExplorer() {
        return this.cspellConfigExplorer;
      }
      get _cspellConfigExplorerSync() {
        return this.cspellConfigExplorerSync;
      }
      async normalizeSearchForConfigResultAsync(searchPath, searchResult, pnpSettings) {
        let result;
        try {
          result = await searchResult || void 0;
        } catch (cause) {
          result = new ImportError_js_1.ImportError(`Failed to find config file at: "${searchPath}"`, cause);
        }
        return this.normalizeSearchForConfigResult(searchPath, result, pnpSettings);
      }
      normalizeSearchForConfigResult(searchPath, searchResult, pnpSettings) {
        const error2 = searchResult instanceof ImportError_js_1.ImportError ? searchResult : void 0;
        const result = searchResult instanceof ImportError_js_1.ImportError ? void 0 : searchResult;
        const filepath = result?.filepath;
        if (filepath) {
          const cached = cachedFiles().get(filepath);
          if (cached) {
            return {
              config: cached,
              filepath,
              error: error2
            };
          }
        }
        const { config = (0, CSpellSettingsInternalDef_js_1.createCSpellSettingsInternal)({}) } = result || {};
        const filename = result?.filepath ?? searchPath;
        const importRef = { filename, error: error2 };
        const id = [path16.basename(path16.dirname(filename)), path16.basename(filename)].join("/");
        const name = result?.filepath ? id : `Config not found: ${id}`;
        const finalizeSettings = (0, CSpellSettingsInternalDef_js_1.createCSpellSettingsInternal)({ id, name, __importRef: importRef });
        const settings = { id, ...config };
        cachedFiles().set(filename, finalizeSettings);
        Object.assign(finalizeSettings, this.normalizeSettings(settings, filename, pnpSettings));
        return {
          config: finalizeSettings,
          filepath,
          error: error2
        };
      }
    };
    function mergeSourceList(orig, append) {
      const collection = new Map(orig.map((s) => [s.name + (s.filename || ""), s]));
      for (const s of append || []) {
        const key = s.name + (s.filename || "");
        if (!collection.has(key)) {
          collection.set(key, s);
        }
      }
      return [...collection.values()];
    }
    function searchForConfig2(searchFrom, pnpSettings = PnPSettings_js_1.defaultPnPSettings) {
      return gcl().searchForConfig(searchFrom, pnpSettings);
    }
    exports.searchForConfig = searchForConfig2;
    function searchForConfigSync(searchFrom, pnpSettings = PnPSettings_js_1.defaultPnPSettings) {
      pnpSettings = (0, PnPSettings_js_1.normalizePnPSettings)(pnpSettings);
      let searchResult;
      try {
        searchResult = cspellConfigExplorerSync().search(searchFrom) || void 0;
      } catch (err) {
        searchResult = new ImportError_js_1.ImportError(`Failed to find config file from: "${searchFrom}"`, err);
      }
      return gcl().normalizeSearchForConfigResult(searchFrom || process.cwd(), searchResult, pnpSettings).config;
    }
    exports.searchForConfigSync = searchForConfigSync;
    async function loadConfig2(file, pnpSettings = PnPSettings_js_1.defaultPnPSettings) {
      return gcl().readSettingsAsync(file, void 0, pnpSettings);
    }
    exports.loadConfig = loadConfig2;
    function loadConfigSync(filename, pnpSettings = PnPSettings_js_1.defaultPnPSettings) {
      const pnp = (0, PnPSettings_js_1.normalizePnPSettings)(pnpSettings);
      return gcl().readSettings(filename, pnp);
    }
    exports.loadConfigSync = loadConfigSync;
    function loadPnP(pnpSettings, searchFrom) {
      if (!pnpSettings.usePnP) {
        return Promise.resolve(void 0);
      }
      const loader = (0, pnpLoader_js_1.pnpLoader)(pnpSettings.pnpFiles);
      return loader.load(searchFrom);
    }
    exports.loadPnP = loadPnP;
    function loadPnPSync(pnpSettings, searchFrom) {
      if (!pnpSettings.usePnP) {
        return void 0;
      }
      const loader = (0, pnpLoader_js_1.pnpLoader)(pnpSettings.pnpFiles);
      return loader.loadSync(searchFrom);
    }
    exports.loadPnPSync = loadPnPSync;
    function readRawSettings(filename, relativeTo) {
      relativeTo = relativeTo || process.cwd();
      const ref = resolveFilename2(filename, relativeTo);
      return gcl()._readConfig(ref);
    }
    exports.readRawSettings = readRawSettings;
    function resolveFilename2(filename, relativeTo) {
      const r = (0, resolveFile_js_1.resolveFile)(filename, relativeTo);
      return {
        filename: r.filename,
        error: r.found ? void 0 : new Error(`Failed to resolve file: "${filename}"`)
      };
    }
    function getGlobalSettings3() {
      return gcl().getGlobalSettings();
    }
    exports.getGlobalSettings = getGlobalSettings3;
    function getCachedFileSize() {
      return cachedFiles().size;
    }
    exports.getCachedFileSize = getCachedFileSize;
    function clearCachedSettingsFiles() {
      return gcl().clearCachedSettingsFiles();
    }
    exports.clearCachedSettingsFiles = clearCachedSettingsFiles;
    var nestedConfigDirectories = {
      ".vscode": true,
      ".config": true
    };
    function resolveGlobRoot(settings, pathToSettingsFile) {
      const settingsFileDirRaw = path16.dirname(pathToSettingsFile);
      const settingsFileDirName = path16.basename(settingsFileDirRaw);
      const isNestedConfig = settingsFileDirName in nestedConfigDirectories;
      const isVSCode = settingsFileDirName === ".vscode";
      const settingsFileDir = isNestedConfig ? path16.dirname(settingsFileDirRaw) : settingsFileDirRaw;
      const envGlobRoot = process.env[constants_js_1.ENV_CSPELL_GLOB_ROOT];
      const defaultGlobRoot = envGlobRoot ?? "${cwd}";
      const rawRoot = settings.globRoot ?? (settings.version === constants_js_1.configSettingsFileVersion0_1 || envGlobRoot && !settings.version || isVSCode && !settings.version ? defaultGlobRoot : settingsFileDir);
      const globRoot = rawRoot.startsWith("${cwd}") ? rawRoot : path16.resolve(settingsFileDir, rawRoot);
      return globRoot;
    }
    function validationMessage(msg, fileRef) {
      return msg + `
  File: "${fileRef.filename}"`;
    }
    function validateRawConfigVersion(config, fileRef) {
      const { version: version3 } = config;
      if (version3 === void 0)
        return;
      if (typeof version3 !== "string") {
        (0, logger_js_1.logError)(validationMessage(`Unsupported config file version: "${version3}", string expected`, fileRef));
        return;
      }
      if (setOfSupportedConfigVersions.has(version3))
        return;
      if (!/^\d+(\.\d+)*$/.test(version3)) {
        (0, logger_js_1.logError)(validationMessage(`Unsupported config file version: "${version3}"`, fileRef));
        return;
      }
      const msg = version3 > constants_js_1.currentSettingsFileVersion ? `Newer config file version found: "${version3}". Supported version is "${constants_js_1.currentSettingsFileVersion}"` : `Legacy config file version found: "${version3}", upgrade to "${constants_js_1.currentSettingsFileVersion}"`;
      (0, logger_js_1.logWarning)(validationMessage(msg, fileRef));
    }
    function validateRawConfigExports(config, fileRef) {
      if (config.default) {
        throw new ImportError_js_1.ImportError(validationMessage("Module `export default` is not supported.\n  Use `module.exports =` instead.", fileRef));
      }
    }
    function validateRawConfig(config, fileRef) {
      const validations = [validateRawConfigExports, validateRawConfigVersion];
      validations.forEach((fn) => fn(config, fileRef));
    }
    function createConfigLoaderInternal(cspellIO) {
      return new ConfigLoaderInternal(cspellIO ?? (0, cspell_io_1.getDefaultCSpellIO)());
    }
    function createConfigLoader(cspellIO) {
      return createConfigLoaderInternal(cspellIO);
    }
    exports.createConfigLoader = createConfigLoader;
    function getDefaultConfigLoaderInternal() {
      if (defaultConfigLoader)
        return defaultConfigLoader;
      return defaultConfigLoader = createConfigLoaderInternal();
    }
    function getDefaultConfigLoader() {
      return getDefaultConfigLoaderInternal();
    }
    exports.getDefaultConfigLoader = getDefaultConfigLoader;
    function cachedFiles() {
      return gcl()._cachedFiles;
    }
    function cspellConfigExplorerSync() {
      return gcl()._cspellConfigExplorerSync;
    }
    exports.__testing__ = {
      getDefaultConfigLoaderInternal,
      normalizeCacheSettings: normalizeRawSettings_js_1.normalizeCacheSettings,
      validateRawConfigExports,
      validateRawConfigVersion
    };
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/extractImportErrors.js
var require_extractImportErrors = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/extractImportErrors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractImportErrors = void 0;
    function extractImportErrors2(settings) {
      const imports = mergeImportRefs(settings);
      return !imports ? [] : [...imports.values()].filter(isImportFileRefWithError);
    }
    exports.extractImportErrors = extractImportErrors2;
    function mergeImportRefs(left, right = {}) {
      const imports = new Map(left.__imports || []);
      if (left.__importRef) {
        imports.set(left.__importRef.filename, left.__importRef);
      }
      if (right.__importRef) {
        imports.set(right.__importRef.filename, right.__importRef);
      }
      const rightImports = right.__imports?.values() || [];
      for (const ref of rightImports) {
        imports.set(ref.filename, ref);
      }
      return imports.size ? imports : void 0;
    }
    function isImportFileRefWithError(ref) {
      return !!ref.error;
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/readSettings.js
var require_readSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/readSettings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readSettings = void 0;
    var configLoader_js_1 = require_configLoader();
    function readSettings(filename, relativeToOrDefault, defaultValue) {
      const loader = (0, configLoader_js_1.getDefaultConfigLoader)();
      if (typeof relativeToOrDefault !== "string" || defaultValue === void 0)
        return loader.readSettings(filename, relativeToOrDefault);
      return loader.readSettings(filename, relativeToOrDefault, defaultValue);
    }
    exports.readSettings = readSettings;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/readSettingsFiles.js
var require_readSettingsFiles = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/readSettingsFiles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readSettingsFiles = void 0;
    var CSpellSettingsServer_js_1 = require_CSpellSettingsServer();
    var defaultSettings_js_1 = require_defaultSettings();
    var readSettings_js_1 = require_readSettings();
    function readSettingsFiles(filenames) {
      return filenames.map((filename) => (0, readSettings_js_1.readSettings)(filename)).reduce((a, b) => (0, CSpellSettingsServer_js_1.mergeSettings)(a, b), defaultSettings_js_1.defaultSettings);
    }
    exports.readSettingsFiles = readSettingsFiles;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/index.js
var require_configLoader2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/Controller/configLoader/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readSettingsFiles = exports.readSettings = exports.extractImportErrors = exports.sectionCSpell = exports.searchForConfigSync = exports.searchForConfig = exports.readRawSettings = exports.loadPnPSync = exports.loadPnP = exports.loadConfigSync = exports.loadConfig = exports.getGlobalSettings = exports.getCachedFileSize = exports.defaultFileName = exports.defaultConfigFilenames = exports.createConfigLoader = exports.ConfigLoader = exports.clearCachedSettingsFiles = exports.__testing__ = void 0;
    var configLoader_js_1 = require_configLoader();
    Object.defineProperty(exports, "__testing__", { enumerable: true, get: function() {
      return configLoader_js_1.__testing__;
    } });
    Object.defineProperty(exports, "clearCachedSettingsFiles", { enumerable: true, get: function() {
      return configLoader_js_1.clearCachedSettingsFiles;
    } });
    Object.defineProperty(exports, "ConfigLoader", { enumerable: true, get: function() {
      return configLoader_js_1.ConfigLoader;
    } });
    Object.defineProperty(exports, "createConfigLoader", { enumerable: true, get: function() {
      return configLoader_js_1.createConfigLoader;
    } });
    Object.defineProperty(exports, "defaultConfigFilenames", { enumerable: true, get: function() {
      return configLoader_js_1.defaultConfigFilenames;
    } });
    Object.defineProperty(exports, "defaultFileName", { enumerable: true, get: function() {
      return configLoader_js_1.defaultFileName;
    } });
    Object.defineProperty(exports, "getCachedFileSize", { enumerable: true, get: function() {
      return configLoader_js_1.getCachedFileSize;
    } });
    Object.defineProperty(exports, "getGlobalSettings", { enumerable: true, get: function() {
      return configLoader_js_1.getGlobalSettings;
    } });
    Object.defineProperty(exports, "loadConfig", { enumerable: true, get: function() {
      return configLoader_js_1.loadConfig;
    } });
    Object.defineProperty(exports, "loadConfigSync", { enumerable: true, get: function() {
      return configLoader_js_1.loadConfigSync;
    } });
    Object.defineProperty(exports, "loadPnP", { enumerable: true, get: function() {
      return configLoader_js_1.loadPnP;
    } });
    Object.defineProperty(exports, "loadPnPSync", { enumerable: true, get: function() {
      return configLoader_js_1.loadPnPSync;
    } });
    Object.defineProperty(exports, "readRawSettings", { enumerable: true, get: function() {
      return configLoader_js_1.readRawSettings;
    } });
    Object.defineProperty(exports, "searchForConfig", { enumerable: true, get: function() {
      return configLoader_js_1.searchForConfig;
    } });
    Object.defineProperty(exports, "searchForConfigSync", { enumerable: true, get: function() {
      return configLoader_js_1.searchForConfigSync;
    } });
    Object.defineProperty(exports, "sectionCSpell", { enumerable: true, get: function() {
      return configLoader_js_1.sectionCSpell;
    } });
    var extractImportErrors_js_1 = require_extractImportErrors();
    Object.defineProperty(exports, "extractImportErrors", { enumerable: true, get: function() {
      return extractImportErrors_js_1.extractImportErrors;
    } });
    var readSettings_js_1 = require_readSettings();
    Object.defineProperty(exports, "readSettings", { enumerable: true, get: function() {
      return readSettings_js_1.readSettings;
    } });
    var readSettingsFiles_js_1 = require_readSettingsFiles();
    Object.defineProperty(exports, "readSettingsFiles", { enumerable: true, get: function() {
      return readSettingsFiles_js_1.readSettingsFiles;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/link.js
var require_link = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/link.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.removePathsFromGlobalImports = exports.addPathsToGlobalImports = exports.listGlobalImports = void 0;
    var fs6 = __importStar(require("fs"));
    var Path3 = __importStar(require("path"));
    var util_js_1 = require_util();
    var index_js_1 = require_configLoader2();
    var GlobalSettings_js_1 = require_GlobalSettings();
    function listGlobalImports() {
      const globalSettings = (0, GlobalSettings_js_1.getRawGlobalSettings)();
      const list = resolveImports(globalSettings).map(({ filename, settings, error: error2 }) => ({
        filename,
        error: error2,
        id: settings.id,
        name: settings.name,
        dictionaryDefinitions: settings.dictionaryDefinitions,
        languageSettings: settings.languageSettings,
        package: findPackageForCSpellConfig(Path3.dirname(filename))
      }));
      return {
        list,
        globalSettings
      };
    }
    exports.listGlobalImports = listGlobalImports;
    function isString2(s) {
      return s !== void 0;
    }
    function addPathsToGlobalImports(paths) {
      const resolvedSettings = paths.map(resolveSettings);
      const hasError = resolvedSettings.filter((r) => !!r.error).length > 0;
      if (hasError) {
        return {
          success: false,
          resolvedSettings,
          error: "Unable to resolve files."
        };
      }
      const rawGlobalSettings = (0, GlobalSettings_js_1.getRawGlobalSettings)();
      const resolvedImports = resolveImports(rawGlobalSettings);
      const imports = new Set(resolvedImports.map((r) => r.resolvedToFilename || r.filename));
      resolvedSettings.map((s) => s.resolvedToFilename).filter(isString2).reduce((imports2, s) => imports2.add(s), imports);
      const globalSettings = {
        import: [...imports]
      };
      const error2 = (0, GlobalSettings_js_1.writeRawGlobalSettings)(globalSettings);
      return {
        success: !error2,
        error: error2?.message,
        resolvedSettings
      };
    }
    exports.addPathsToGlobalImports = addPathsToGlobalImports;
    function removePathsFromGlobalImports(paths) {
      const listResult = listGlobalImports();
      const toRemove = /* @__PURE__ */ new Set();
      function matchPackage(pathToRemove) {
        return ({ package: pkg, id }) => pathToRemove === pkg?.name || pathToRemove === id;
      }
      function compareFilenames(fullPath, partialPath) {
        if (fullPath === partialPath)
          return true;
        if (!fullPath.endsWith(partialPath))
          return false;
        const c = fullPath[fullPath.length - partialPath.length - 1];
        return c === Path3.sep || c === Path3.posix.sep;
      }
      function matchFilename(pathToRemove) {
        return Path3.dirname(pathToRemove) != "." ? ({ filename }) => compareFilenames(filename, pathToRemove) : () => false;
      }
      paths.map((a) => a.trim()).filter((a) => !!a).forEach((pathToRemove) => {
        const excludePackage = matchPackage(pathToRemove);
        const excludeFilename = matchFilename(pathToRemove);
        const shouldExclude = (r) => excludePackage(r) || excludeFilename(r);
        for (const r of listResult.list) {
          if (shouldExclude(r)) {
            toRemove.add(r.filename);
          }
        }
      });
      const toImport = normalizeImports(listResult.globalSettings.import).filter((p) => !toRemove.has(p));
      const updatedSettings = {
        import: toImport
      };
      const error2 = toRemove.size > 0 ? (0, GlobalSettings_js_1.writeRawGlobalSettings)(updatedSettings) : void 0;
      return {
        success: true,
        removed: [...toRemove],
        error: error2?.toString()
      };
    }
    exports.removePathsFromGlobalImports = removePathsFromGlobalImports;
    function resolveSettings(filename) {
      const settings = (0, index_js_1.readRawSettings)(filename);
      const ref = settings.__importRef;
      const resolvedToFilename = ref?.filename;
      const error2 = ref?.error?.message || !resolvedToFilename && "File not Found" || void 0;
      return (0, util_js_1.clean)({
        filename,
        resolvedToFilename,
        error: error2,
        settings
      });
    }
    function normalizeImports(imports) {
      return typeof imports === "string" ? [imports] : imports || [];
    }
    function resolveImports(s) {
      const imported = normalizeImports(s.import);
      return imported.map(resolveSettings);
    }
    function findPackageForCSpellConfig(pathToConfig) {
      try {
        const filename = Path3.join(pathToConfig, "package.json");
        const pkg = JSON.parse(fs6.readFileSync(filename, "utf8"));
        return {
          filename,
          name: pkg["name"]
        };
      } catch (e) {
        return void 0;
      }
    }
    exports.__testing__ = {
      findPackageForCSpellConfig
    };
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/index.link.js
var require_index_link = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/index.link.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removePathsFromGlobalImports = exports.listGlobalImports = exports.addPathsToGlobalImports = void 0;
    var link_js_1 = require_link();
    Object.defineProperty(exports, "addPathsToGlobalImports", { enumerable: true, get: function() {
      return link_js_1.addPathsToGlobalImports;
    } });
    Object.defineProperty(exports, "listGlobalImports", { enumerable: true, get: function() {
      return link_js_1.listGlobalImports;
    } });
    Object.defineProperty(exports, "removePathsFromGlobalImports", { enumerable: true, get: function() {
      return link_js_1.removePathsFromGlobalImports;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/util/search.js
var require_search = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.binarySearch = void 0;
    function binarySearch(arr, item, leftOffset, rightOffset) {
      let left = Math.max(leftOffset ?? 0, 0);
      let right = Math.min(rightOffset ?? arr.length, arr.length);
      while (left < right) {
        const pos = left + right >> 1;
        if (arr[pos] < item) {
          left = pos + 1;
        } else {
          right = pos;
        }
      }
      return left;
    }
    exports.binarySearch = binarySearch;
  }
});

// node_modules/cspell-lib/dist/cjs/util/text.js
var require_text2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.removeAccents = exports.calculateTextDocumentOffsets = exports.extractText = exports.textOffset = exports.matchCase = exports.camelToSnake = exports.snakeToCamel = exports.lcFirst = exports.ucFirst = exports.isFirstCharacterLower = exports.isFirstCharacterUpper = exports.isLowerCase = exports.isUpperCase = exports.extractWordsFromCodeTextOffset = exports.extractWordsFromCode = exports.extractPossibleWordsFromTextOffset = exports.cleanTextOffset = exports.cleanText = exports.extractWordsFromTextOffset = exports.extractWordsFromText = exports.extractLinesOfText = exports.matchToTextOffset = exports.matchStringToTextOffset = exports.match = exports.splitCamelCaseWord = exports.splitCamelCaseWordWithOffset = exports.stringToRegExp = void 0;
    var sync_1 = require_sync();
    var gensequence_1 = require_dist2();
    var search_js_1 = require_search();
    var textRegex_js_1 = require_textRegex();
    var Uri_js_1 = require_Uri();
    var util_js_1 = require_util();
    var textRegex_js_2 = require_textRegex();
    Object.defineProperty(exports, "stringToRegExp", { enumerable: true, get: function() {
      return textRegex_js_2.stringToRegExp;
    } });
    function splitCamelCaseWordWithOffset(wo) {
      return splitCamelCaseWord(wo.text).map((0, util_js_1.scanMap)((last, text) => ({ text, offset: last.offset + last.text.length }), {
        text: "",
        offset: wo.offset
      }));
    }
    exports.splitCamelCaseWordWithOffset = splitCamelCaseWordWithOffset;
    function splitCamelCaseWord(word) {
      const wPrime = word.replace(textRegex_js_1.regExUpperSOrIng, (s) => s[0] + s.slice(1).toLowerCase());
      const separator = "_<^*_*^>_";
      const pass1 = wPrime.replace(textRegex_js_1.regExSplitWords, "$1" + separator + "$2");
      const pass2 = pass1.replace(textRegex_js_1.regExSplitWords2, "$1" + separator + "$2");
      return pass2.split(separator);
    }
    exports.splitCamelCaseWord = splitCamelCaseWord;
    function match(reg, text) {
      return (0, gensequence_1.sequenceFromRegExpMatch)(reg, text);
    }
    exports.match = match;
    function matchStringToTextOffset(reg, text) {
      return matchToTextOffset(reg, { text, offset: 0 });
    }
    exports.matchStringToTextOffset = matchStringToTextOffset;
    function matchToTextOffset(reg, text) {
      const textOffset2 = text;
      const fnOffsetMap = offsetMap(textOffset2.offset);
      textOffset2.text.matchAll(reg);
      return (0, sync_1.pipe)(match(reg, textOffset2.text), (0, sync_1.opMap)((m) => fnOffsetMap({ text: m[0], offset: m.index || 0 })));
    }
    exports.matchToTextOffset = matchToTextOffset;
    function* extractLinesOfText(text) {
      let i = 0;
      for (let j = text.indexOf("\n", i); j >= 0; j = text.indexOf("\n", i)) {
        const end = j + 1;
        yield { text: text.slice(i, end), offset: i };
        i = end;
      }
      yield { text: text.slice(i, text.length), offset: i };
    }
    exports.extractLinesOfText = extractLinesOfText;
    function extractWordsFromText(text) {
      return extractWordsFromTextOffset(textOffset(text));
    }
    exports.extractWordsFromText = extractWordsFromText;
    function extractWordsFromTextOffset(text) {
      const reg = new RegExp(textRegex_js_1.regExWords);
      return matchToTextOffset(reg, cleanTextOffset(text));
    }
    exports.extractWordsFromTextOffset = extractWordsFromTextOffset;
    function cleanText(text) {
      text = text.replace(textRegex_js_1.regExIgnoreCharacters, (match2) => " ".repeat(match2.length));
      return text;
    }
    exports.cleanText = cleanText;
    function cleanTextOffset(text) {
      return {
        text: cleanText(text.text),
        offset: text.offset
      };
    }
    exports.cleanTextOffset = cleanTextOffset;
    function extractPossibleWordsFromTextOffset(text) {
      const reg = new RegExp(textRegex_js_1.regExWordsAndDigits);
      return matchToTextOffset(reg, text);
    }
    exports.extractPossibleWordsFromTextOffset = extractPossibleWordsFromTextOffset;
    function extractWordsFromCode(text) {
      return extractWordsFromCodeTextOffset(textOffset(text));
    }
    exports.extractWordsFromCode = extractWordsFromCode;
    function extractWordsFromCodeTextOffset(textOffset2) {
      return (0, sync_1.pipe)(extractWordsFromTextOffset(textOffset2), (0, sync_1.opConcatMap)(splitCamelCaseWordWithOffset));
    }
    exports.extractWordsFromCodeTextOffset = extractWordsFromCodeTextOffset;
    function isUpperCase(word) {
      return !!word.match(textRegex_js_1.regExAllUpper);
    }
    exports.isUpperCase = isUpperCase;
    function isLowerCase(word) {
      return !!word.match(textRegex_js_1.regExAllLower);
    }
    exports.isLowerCase = isLowerCase;
    function isFirstCharacterUpper(word) {
      return isUpperCase(word.slice(0, 1));
    }
    exports.isFirstCharacterUpper = isFirstCharacterUpper;
    function isFirstCharacterLower(word) {
      return isLowerCase(word.slice(0, 1));
    }
    exports.isFirstCharacterLower = isFirstCharacterLower;
    function ucFirst(word) {
      return word.slice(0, 1).toUpperCase() + word.slice(1);
    }
    exports.ucFirst = ucFirst;
    function lcFirst(word) {
      return word.slice(0, 1).toLowerCase() + word.slice(1);
    }
    exports.lcFirst = lcFirst;
    function snakeToCamel(word) {
      return word.split("_").map(ucFirst).join("");
    }
    exports.snakeToCamel = snakeToCamel;
    function camelToSnake(word) {
      return splitCamelCaseWord(word).join("_").toLowerCase();
    }
    exports.camelToSnake = camelToSnake;
    function matchCase(example, word) {
      if (example.match(textRegex_js_1.regExFirstUpper)) {
        return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();
      }
      if (example.match(textRegex_js_1.regExAllLower)) {
        return word.toLowerCase();
      }
      if (example.match(textRegex_js_1.regExAllUpper)) {
        return word.toUpperCase();
      }
      if (isFirstCharacterUpper(example)) {
        return ucFirst(word);
      }
      if (isFirstCharacterLower(example)) {
        return lcFirst(word);
      }
      return word;
    }
    exports.matchCase = matchCase;
    function textOffset(text, offset = 0) {
      return { text, offset };
    }
    exports.textOffset = textOffset;
    function extractText(textOffset2, startPos, endPos) {
      const { text, offset: orig } = textOffset2;
      const a = Math.max(startPos - orig, 0);
      const b = Math.max(endPos - orig, 0);
      return text.slice(a, b);
    }
    exports.extractText = extractText;
    function offsetMap(offset) {
      return (xo) => ({ ...xo, offset: xo.offset + offset });
    }
    function calculateTextDocumentOffsets(uri, doc, wordOffsets) {
      const lines = [
        -1,
        ...(0, sync_1.pipe)(match(/\n/g, doc), (0, sync_1.opMap)((a) => a.index)),
        doc.length
      ];
      let lastRow = -1;
      let lastOffset = doc.length + 1;
      let lastLineRow = -1;
      let lastLine;
      function findRowCol(offset) {
        const row = (0, search_js_1.binarySearch)(lines, offset, offset >= lastOffset ? lastRow : void 0);
        const col = offset - lines[Math.max(0, row - 1)];
        lastOffset = offset;
        lastRow = row;
        return [row, col];
      }
      function extractLine(row) {
        const offset = lines[row - 1] + 1;
        const text = doc.slice(offset, lines[row] + 1);
        return { text, offset };
      }
      function calcLine(row) {
        const last = lastLineRow === row ? lastLine : void 0;
        lastLineRow = row;
        const r = last ?? extractLine(row);
        lastLine = r;
        return r;
      }
      const _uri = (0, Uri_js_1.toUri)(uri).toString();
      return wordOffsets.map((wo) => {
        const [row, col] = findRowCol(wo.offset);
        return { ...wo, row, col, doc, uri: _uri, line: calcLine(row) };
      });
    }
    exports.calculateTextDocumentOffsets = calculateTextDocumentOffsets;
    function removeAccents(text) {
      return text.normalize("NFD").replace(textRegex_js_1.regExAccents, "");
    }
    exports.removeAccents = removeAccents;
    exports.__testing__ = {
      regExWords: textRegex_js_1.regExWords,
      regExWordsAndDigits: textRegex_js_1.regExWordsAndDigits
    };
  }
});

// node_modules/cspell-lib/dist/cjs/LanguageIds.js
var require_LanguageIds = __commonJS({
  "node_modules/cspell-lib/dist/cjs/LanguageIds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLanguagesForBasename = exports.getLanguagesForExt = exports.buildLanguageExtensionMapSet = exports.isGenerated = exports.isGeneratedFile = exports.isGeneratedExt = exports.isBinary = exports.isBinaryFile = exports.isBinaryExt = exports.languageIds = exports.generatedFiles = exports.binaryLanguages = exports.languageExtensionDefinitions = void 0;
    var AutoResolve_js_1 = require_AutoResolve();
    exports.languageExtensionDefinitions = [
      { id: "ada", extensions: [".adb", ".ads"] },
      { id: "apiblueprint", extensions: [".apib", ".apiblueprint"] },
      { id: "asciidoc", extensions: [".adoc", ".asc", ".asciidoc"] },
      { id: "bat", extensions: [".bat", ".cmd"] },
      { id: "clojure", extensions: [".clj", ".cljs", ".cljx", ".clojure", ".edn"] },
      { id: "coffeescript", extensions: [".coffee", ".cson"] },
      { id: "c", extensions: [".c"] },
      // cspell:ignore cmake
      { id: "cmake", extensions: [".cmake"], filenames: ["CMakeLists.txt"] },
      {
        id: "cpp",
        extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx", ".h", ".mm", ".ino", ".inl"]
      },
      { id: "csharp", extensions: [".cs"] },
      { id: "css", extensions: [".css"] },
      { id: "dhall", extensions: [".dhall"] },
      { id: "diff", extensions: [".diff", ".patch", ".rej"] },
      { id: "dockerfile", extensions: [".dockerfile"], filenames: ["Dockerfile"] },
      { id: "elixir", extensions: [".ex", ".exs"] },
      { id: "fsharp", extensions: [".fs", ".fsi", ".fsx", ".fsscript"] },
      { id: "go", extensions: [".go"] },
      { id: "groovy", extensions: [".groovy", ".gvy", ".gradle"] },
      { id: "handlebars", extensions: [".handlebars", ".hbs"] },
      { id: "haskell", extensions: [".hs", ".lhs"] },
      {
        id: "html",
        extensions: [".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm", ".volt", ".vue"]
      },
      { id: "ini", extensions: [".ini", ".conf"] },
      { id: "properties", extensions: [".properties", ".gitconfig", ".cfg", ".conf"] },
      { id: "jade", extensions: [".jade", ".pug"] },
      { id: "java", extensions: [".java", ".jav"] },
      { id: "javascriptreact", extensions: [".jsx"] },
      { id: "javascript", extensions: [".js", ".mjs", ".es6", ".cjs"] },
      {
        id: "json",
        extensions: [".json", ".jsonc", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc", ".webmanifest"]
      },
      { id: "jsonc", extensions: [".jsonc"] },
      { id: "jsonc", extensions: [".code-workspace"], filenames: [".code-workspace"] },
      { id: "jungle", extensions: [".jungle"] },
      { id: "less", extensions: [".less"] },
      { id: "literate haskell", extensions: [".lhs"] },
      { id: "lua", extensions: [".lua"] },
      { id: "makefile", extensions: [".mk"] },
      { id: "markdown", extensions: [".md", ".mdown", ".markdown", ".markdn"] },
      { id: "mdx", extensions: [".mdx"] },
      { id: "monkeyc", extensions: [".mc", ".mb"] },
      { id: "objective-c", extensions: [".m"] },
      { id: "perl", extensions: [".pl", ".pm", ".pod", ".t", ".PL", ".psgi"] },
      { id: "perl6", extensions: [".p6", ".pl6", ".pm6", ".nqp"] },
      { id: "php", extensions: [".php", ".php4", ".php5", ".phtml", ".ctp"] },
      { id: "plaintext", extensions: [".txt"] },
      { id: "powershell", extensions: [".ps1", ".psm1", ".psd1", ".pssc", ".psrc"] },
      { id: "purescript", extensions: [".purs"] },
      { id: "python", extensions: [".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi"] },
      { id: "r", extensions: [".r", ".R", ".rhistory", ".rprofile", ".rt"] },
      { id: "razor", extensions: [".cshtml"] },
      { id: "ruby", extensions: [".rb", ".rbx", ".rjs", ".gemspec", ".rake", ".ru"] },
      { id: "ruby", extensions: [], filenames: ["Gemfile"] },
      { id: "rust", extensions: [".rs"] },
      { id: "scala", extensions: [".scala", ".sc", ".sbt"] },
      { id: "scss", extensions: [".scss"] },
      { id: "shaderlab", extensions: [".shader", ".cginc"] },
      {
        id: "shellscript",
        extensions: [
          ".sh",
          ".bash",
          ".bashrc",
          ".bash_aliases",
          ".bash_profile",
          ".bash_login",
          ".ebuild",
          ".install",
          ".profile",
          ".bash_logout",
          ".zsh",
          ".zshrc",
          ".zprofile",
          ".zlogin",
          ".zlogout",
          ".zshenv",
          ".zsh-theme"
        ]
      },
      { id: "sql", extensions: [".sql", ".dsql"] },
      { id: "svelte", extensions: [".svelte"] },
      { id: "swift", extensions: [".swift"] },
      { id: "toml", extensions: [".toml"] },
      { id: "typescript", extensions: [".ts", ".cts", ".mts"] },
      { id: "typescriptreact", extensions: [".tsx"] },
      { id: "vb", extensions: [".vb", ".brs", ".vbs", ".bas"] },
      { id: "vue", extensions: [".vue"] },
      {
        id: "xml",
        extensions: [
          ".ascx",
          ".atom",
          ".axml",
          ".bpmn",
          ".config",
          ".cpt",
          ".csl",
          ".csproj.user",
          ".csproj",
          ".dita",
          ".ditamap",
          ".dtd",
          ".dtml",
          ".ent",
          ".fsproj",
          ".fxml",
          ".iml",
          ".isml",
          ".jmx",
          ".launch",
          ".menu",
          ".mod",
          ".mxml",
          ".nuspec",
          ".opml",
          ".owl",
          ".proj",
          ".pt",
          ".pubxml.user",
          ".pubxml",
          ".rdf",
          ".rng",
          ".rss",
          ".shproj",
          ".storyboard",
          ".svg",
          ".targets",
          ".tld",
          ".tmx",
          ".vbproj.user",
          ".vbproj",
          ".vcxproj.filters",
          ".vcxproj",
          ".wsdl",
          ".wxi",
          ".wxl",
          ".wxs",
          ".xaml",
          ".xbl",
          ".xib",
          ".xlf",
          ".xliff",
          ".xml",
          ".xoml",
          ".xpdl",
          ".xsd",
          ".xul"
        ]
      },
      { id: "wheel", extensions: [".whl"], format: "Binary" },
      { id: "xsl", extensions: [".xsl", ".xslt"] },
      { id: "yaml", extensions: [".eyaml", ".eyml", ".yaml", ".yml"] },
      { id: "latex", extensions: [".tex"] },
      { id: "map", extensions: [".map"] },
      { id: "pdf", extensions: [".pdf"] },
      { id: "rsa", extensions: [".pub"], filenames: ["id_rsa", "id_rsa.pub"] },
      { id: "pem", extensions: [".private-key.pem", ".pem"] },
      { id: "pem-private-key", extensions: [".private-key.pem"] },
      //
      // Special file types used to prevent spell checking.
      //
      {
        id: "image",
        extensions: [
          ".bmp",
          ".exr",
          ".gif",
          ".ico",
          ".jpeg",
          ".jpg",
          ".pbm",
          ".pgm",
          ".png",
          ".ppm",
          ".ras",
          ".sgi",
          ".tiff",
          ".webp",
          ".xbm"
        ],
        format: "Binary",
        description: "Some image extensions"
      },
      // cspell:ignore woff
      {
        id: "binary",
        extensions: [".gz", ".exe", ".dll", ".lib", ".obj", ".o", ".eot", ".cur", ".zip"],
        format: "Binary"
      },
      {
        id: "fonts",
        extensions: [".ttf", ".woff", ".woff2"],
        format: "Binary"
      },
      {
        id: "video",
        extensions: [".mov", ".mpg"],
        format: "Binary"
      },
      {
        id: "lock",
        extensions: [".lock"],
        filenames: ["package-lock.json"]
      },
      {
        id: "cache_files",
        extensions: [],
        // cspell:ignore eslintcache
        filenames: [".cspellcache", ".DS_Store", ".eslintcache"]
      },
      { id: "dll", extensions: [".dll"], format: "Binary" },
      { id: "exe", extensions: [".exe"], format: "Binary" },
      { id: "object-file", extensions: [".o", ".obj"], format: "Binary" },
      { id: "jar", extensions: [".jar"], format: "Binary" },
      { id: "spv", extensions: [".spv"], format: "Binary", description: "SPSS Output Document" },
      { id: "mdb", extensions: [".mdb"], format: "Binary", description: "Microsoft Access DB" },
      { id: "webm", extensions: [".webm"], format: "Binary", description: "WebM is an audiovisual media file format." },
      { id: "trie", extensions: [".trie"], format: "Binary", description: "CSpell dictionary file." }
    ];
    var binaryFormatIds = exports.languageExtensionDefinitions.filter((d) => d.format === "Binary").map((d) => d.id);
    exports.binaryLanguages = new Set(["binary", "image", "video", "fonts"].concat(binaryFormatIds));
    exports.generatedFiles = /* @__PURE__ */ new Set([...exports.binaryLanguages, "map", "lock", "pdf", "cache_files", "rsa", "pem", "trie"]);
    exports.languageIds = exports.languageExtensionDefinitions.map(({ id }) => id);
    var mapExtensionToSetOfLanguageIds = buildLanguageExtensionMapSet(exports.languageExtensionDefinitions);
    var mapExtensionToLanguageIds = buildExtensionToLanguageIdMap(mapExtensionToSetOfLanguageIds);
    function isBinaryExt(ext) {
      return isBinary(getLanguagesForExt(ext));
    }
    exports.isBinaryExt = isBinaryExt;
    function isBinaryFile3(basename3) {
      return isBinary(getLanguagesForBasename(basename3));
    }
    exports.isBinaryFile = isBinaryFile3;
    function isBinary(languageId) {
      return doesSetContainAnyOf(exports.binaryLanguages, languageId);
    }
    exports.isBinary = isBinary;
    function isGeneratedExt(ext) {
      return isGenerated(getLanguagesForExt(ext));
    }
    exports.isGeneratedExt = isGeneratedExt;
    function isGeneratedFile(basename3) {
      return isGenerated(getLanguagesForBasename(basename3));
    }
    exports.isGeneratedFile = isGeneratedFile;
    function isGenerated(languageId) {
      return doesSetContainAnyOf(exports.generatedFiles, languageId);
    }
    exports.isGenerated = isGenerated;
    function doesSetContainAnyOf(setOfIds, languageId) {
      if (typeof languageId === "string") {
        return setOfIds.has(languageId);
      }
      for (const id of languageId) {
        if (setOfIds.has(id)) {
          return true;
        }
      }
      return false;
    }
    function buildLanguageExtensionMapSet(defs) {
      return defs.reduce((map, def) => {
        function addId(value) {
          (0, AutoResolve_js_1.autoResolve)(map, value, () => /* @__PURE__ */ new Set()).add(def.id);
        }
        def.extensions.forEach(addId);
        def.filenames?.forEach(addId);
        return map;
      }, /* @__PURE__ */ new Map());
    }
    exports.buildLanguageExtensionMapSet = buildLanguageExtensionMapSet;
    function buildExtensionToLanguageIdMap(map) {
      return new Map([...map].map(([k, s]) => [k, [...s]]));
    }
    function _getLanguagesForExt(ext) {
      return mapExtensionToLanguageIds.get(ext) || mapExtensionToLanguageIds.get("." + ext);
    }
    function getLanguagesForExt(ext) {
      return _getLanguagesForExt(ext) || _getLanguagesForExt(ext.toLowerCase()) || [];
    }
    exports.getLanguagesForExt = getLanguagesForExt;
    function _getLanguagesForBasename(basename3) {
      const found = mapExtensionToLanguageIds.get(basename3);
      if (found)
        return found;
      for (let pos = basename3.indexOf("."); pos >= 0; pos = basename3.indexOf(".", pos + 1)) {
        const ids = mapExtensionToLanguageIds.get(basename3.slice(pos));
        if (ids)
          return ids;
      }
      return void 0;
    }
    function getLanguagesForBasename(basename3) {
      return _getLanguagesForBasename(basename3) || _getLanguagesForBasename(basename3.toLowerCase()) || [];
    }
    exports.getLanguagesForBasename = getLanguagesForBasename;
  }
});

// node_modules/cspell-lib/dist/cjs/Document/normalizeLanguageIds.js
var require_normalizeLanguageIds = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Document/normalizeLanguageIds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeLanguageIds = void 0;
    function normalizeLanguageIds(languageId) {
      return (Array.isArray(languageId) ? languageId.join(",") : languageId).split(",").map((s) => s.trim());
    }
    exports.normalizeLanguageIds = normalizeLanguageIds;
  }
});

// node_modules/cspell-lib/dist/cjs/Document/isBinaryDoc.js
var require_isBinaryDoc = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Document/isBinaryDoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBinaryFile = exports.isBinaryDoc = void 0;
    var LanguageIds_js_1 = require_LanguageIds();
    var Uri_js_1 = require_Uri();
    var normalizeLanguageIds_js_1 = require_normalizeLanguageIds();
    function isBinaryDoc(document) {
      return isBinaryFile3((0, Uri_js_1.toUri)(document.uri), document.languageId);
    }
    exports.isBinaryDoc = isBinaryDoc;
    function isBinaryFile3(filename, languageId) {
      const filenameUri = (0, Uri_js_1.toUri)(filename);
      if (languageId) {
        const ids = (0, normalizeLanguageIds_js_1.normalizeLanguageIds)(languageId);
        if (ids.length)
          return (0, LanguageIds_js_1.isGenerated)(ids);
      }
      const file = (0, Uri_js_1.basename)(filenameUri);
      return (0, LanguageIds_js_1.isGeneratedFile)(file);
    }
    exports.isBinaryFile = isBinaryFile3;
  }
});

// node_modules/vscode-languageserver-textdocument/lib/umd/main.js
var require_main = __commonJS({
  "node_modules/vscode-languageserver-textdocument/lib/umd/main.js"(exports, module2) {
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocument = void 0;
      var FullTextDocument = (
        /** @class */
        function() {
          function FullTextDocument2(uri, languageId, version3, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version3;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(changes, version3) {
            for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
              var change = changes_1[_i];
              if (FullTextDocument2.isIncremental(change)) {
                var range = getWellformedRange(change.range);
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                  for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                    lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                  }
                } else {
                  if (addedLineOffsets.length < 1e4) {
                    lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));
                  } else {
                    this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                  }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                  for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                    lineOffsets[i] = lineOffsets[i] + diff;
                  }
                }
              } else if (FullTextDocument2.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = void 0;
              } else {
                throw new Error("Unknown change event received");
              }
            }
            this._version = version3;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              this._lineOffsets = computeLineOffsets(this._content, true);
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return { line: 0, character: offset };
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return { line, character: offset - lineOffsets[line] };
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.isIncremental = function(event) {
            var candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
          };
          FullTextDocument2.isFull = function(event) {
            var candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
          };
          return FullTextDocument2;
        }()
      );
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version3, content) {
          return new FullTextDocument(uri, languageId, version3, content);
        }
        TextDocument2.create = create;
        function update(document, changes, version3) {
          if (document instanceof FullTextDocument) {
            document.update(changes, version3);
            return document;
          } else {
            throw new Error("TextDocument.update: document must be created by TextDocument.create");
          }
        }
        TextDocument2.update = update;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = 0;
          var spans = [];
          for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
            var e = sortedEdits_1[_i];
            var startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
              throw new Error("Overlapping edit");
            } else if (startOffset > lastModifiedOffset) {
              spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
              spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
          }
          spans.push(text.substr(lastModifiedOffset));
          return spans.join("");
        }
        TextDocument2.applyEdits = applyEdits;
      })(TextDocument = exports2.TextDocument || (exports2.TextDocument = {}));
      function mergeSort(data, compare2) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare2);
        mergeSort(right, compare2);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare2(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
      function computeLineOffsets(text, isAtLineStart, textOffset) {
        if (textOffset === void 0) {
          textOffset = 0;
        }
        var result = isAtLineStart ? [textOffset] : [];
        for (var i = 0; i < text.length; i++) {
          var ch = text.charCodeAt(i);
          if (ch === 13 || ch === 10) {
            if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
              i++;
            }
            result.push(textOffset + i + 1);
          }
        }
        return result;
      }
      function getWellformedRange(range) {
        var start = range.start;
        var end = range.end;
        if (start.line > end.line || start.line === end.line && start.character > end.character) {
          return { start: end, end: start };
        }
        return range;
      }
      function getWellformedEdit(textEdit) {
        var range = getWellformedRange(textEdit.range);
        if (range !== textEdit.range) {
          return { newText: textEdit.newText, range };
        }
        return textEdit;
      }
    });
  }
});

// node_modules/cspell-lib/dist/cjs/Models/TextDocument.js
var require_TextDocument = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Models/TextDocument.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTextDocument = exports.loadTextDocument = exports.updateTextDocument = exports.createTextDocument = void 0;
    var assert_1 = __importDefault(require("assert"));
    var fs_1 = require("fs");
    var vscode_languageserver_textdocument_1 = require_main();
    var LanguageIds_js_1 = require_LanguageIds();
    var Uri = __importStar(require_Uri());
    var TextDocumentImpl = class {
      constructor(uri, text, languageId, locale, version3) {
        this.uri = uri;
        this.languageId = languageId;
        this.locale = locale;
        const primaryLanguageId = typeof languageId === "string" ? languageId : languageId[0] || "plaintext";
        this.vsTextDoc = vscode_languageserver_textdocument_1.TextDocument.create(uri.toString(), primaryLanguageId, version3, text);
      }
      get version() {
        return this.vsTextDoc.version;
      }
      get text() {
        return this.vsTextDoc.getText();
      }
      positionAt(offset) {
        return this.vsTextDoc.positionAt(offset);
      }
      offsetAt(position) {
        return this.vsTextDoc.offsetAt(position);
      }
      lineAt(offset) {
        const position = this.vsTextDoc.positionAt(offset);
        return this.getLine(position.line);
      }
      getLine(lineNum) {
        const position = { line: lineNum, character: 0 };
        const end = { line: lineNum + 1, character: 0 };
        const range = {
          start: position,
          end
        };
        const lineOffset = this.vsTextDoc.offsetAt(position);
        const text = this.vsTextDoc.getText(range);
        return {
          text,
          offset: lineOffset,
          position
        };
      }
      /**
       * Iterate over the lines of a document one-by-one.
       * Changing the document between iterations can change the result
       */
      *getLines() {
        const range = {
          start: { line: 0, character: 0 },
          end: { line: 1, character: 0 }
        };
        while (this.vsTextDoc.offsetAt(range.end) > this.vsTextDoc.offsetAt(range.start)) {
          const offset = this.vsTextDoc.offsetAt(range.start);
          yield {
            text: this.vsTextDoc.getText(range),
            offset,
            position: range.start
          };
          ++range.start.line;
          ++range.end.line;
        }
      }
      /**
       * Apply edits to the text.
       * Note: the edits are applied one after the other.
       * @param edits - changes to the text
       * @param version - optional version to use.
       * @returns this
       */
      update(edits, version3) {
        version3 = version3 ?? this.version + 1;
        for (const edit of edits) {
          const vsEdit = edit.range ? {
            range: { start: this.positionAt(edit.range[0]), end: this.positionAt(edit.range[1]) },
            text: edit.text
          } : edit;
          vscode_languageserver_textdocument_1.TextDocument.update(this.vsTextDoc, [vsEdit], version3);
        }
        return this;
      }
    };
    function createTextDocument({ uri, content, languageId, locale, version: version3 }) {
      version3 = version3 ?? 1;
      uri = Uri.toUri(uri);
      languageId = languageId ?? (0, LanguageIds_js_1.getLanguagesForBasename)(Uri.basename(uri));
      languageId = languageId.length === 0 ? "text" : languageId;
      return new TextDocumentImpl(uri, content, languageId, locale, version3);
    }
    exports.createTextDocument = createTextDocument;
    function updateTextDocument(doc, edits, version3) {
      (0, assert_1.default)(isTextDocumentImpl(doc), "Unknown TextDocument type");
      return doc.update(edits, version3);
    }
    exports.updateTextDocument = updateTextDocument;
    function isTextDocumentImpl(doc) {
      return doc instanceof TextDocumentImpl;
    }
    async function loadTextDocument(filename, languageId) {
      const uri = Uri.toUri(filename);
      const content = await fs_1.promises.readFile(Uri.uriToFilePath(uri), "utf8");
      return createTextDocument({ uri, languageId, content });
    }
    exports.loadTextDocument = loadTextDocument;
    exports.isTextDocument = isTextDocumentImpl;
  }
});

// node_modules/cspell-lib/dist/cjs/Document/resolveDocument.js
var require_resolveDocument = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Document/resolveDocument.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveDocument = exports.resolveDocumentToTextDocument = exports.documentToTextDocument = exports.fileToTextDocument = exports.fileToDocument = void 0;
    var promises_1 = require("fs/promises");
    var TextDocument_js_1 = require_TextDocument();
    var Uri = __importStar(require_Uri());
    var util_js_1 = require_util();
    var defaultEncoding = "utf8";
    function fileToDocument2(file, text, languageId, locale) {
      return (0, util_js_1.clean)({
        uri: Uri.toUri(file).toString(),
        text,
        languageId,
        locale
      });
    }
    exports.fileToDocument = fileToDocument2;
    async function fileToTextDocument(file) {
      return documentToTextDocument(await resolveDocument(fileToDocument2(file)));
    }
    exports.fileToTextDocument = fileToTextDocument;
    function documentToTextDocument(document) {
      const { uri, text: content, languageId, locale } = document;
      return (0, TextDocument_js_1.createTextDocument)({ uri, content, languageId, locale });
    }
    exports.documentToTextDocument = documentToTextDocument;
    async function resolveDocumentToTextDocument(doc) {
      return documentToTextDocument(await resolveDocument(doc));
    }
    exports.resolveDocumentToTextDocument = resolveDocumentToTextDocument;
    async function readDocument(filename, encoding = defaultEncoding) {
      const text = await (0, promises_1.readFile)(filename, encoding);
      const uri = Uri.toUri(filename).toString();
      return {
        uri,
        text
      };
    }
    function resolveDocument(document, encoding) {
      if (isDocumentWithText(document))
        return Promise.resolve(document);
      const uri = Uri.toUri(document.uri);
      if (uri.scheme !== "file") {
        throw new Error(`Unsupported schema: "${uri.scheme}", open "${uri.toString()}"`);
      }
      return readDocument(Uri.uriToFilePath(uri), encoding);
    }
    exports.resolveDocument = resolveDocument;
    function isDocumentWithText(doc) {
      return doc.text !== void 0;
    }
  }
});

// node_modules/cspell-lib/dist/cjs/Document/index.js
var require_Document = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Document/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fileToTextDocument = exports.fileToDocument = exports.isBinaryFile = void 0;
    var isBinaryDoc_js_1 = require_isBinaryDoc();
    Object.defineProperty(exports, "isBinaryFile", { enumerable: true, get: function() {
      return isBinaryDoc_js_1.isBinaryFile;
    } });
    var resolveDocument_js_1 = require_resolveDocument();
    Object.defineProperty(exports, "fileToDocument", { enumerable: true, get: function() {
      return resolveDocument_js_1.fileToDocument;
    } });
    Object.defineProperty(exports, "fileToTextDocument", { enumerable: true, get: function() {
      return resolveDocument_js_1.fileToTextDocument;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/FeatureFlags/FeatureFlags.js
var require_FeatureFlags = __commonJS({
  "node_modules/cspell-lib/dist/cjs/FeatureFlags/FeatureFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSystemFeatureFlags = exports.UnknownFeatureFlagError = exports.FeatureFlags = void 0;
    var systemFeatureFlags;
    var FeatureFlags = class {
      constructor(flags = []) {
        this.flagValues = /* @__PURE__ */ new Map();
        this.flags = new Map(flags.map((f) => [f.name, f]));
      }
      register(flagOrName, description) {
        if (typeof flagOrName === "string") {
          return this.register({ name: flagOrName, description: description || "" });
        }
        this.flags.set(flagOrName.name, flagOrName);
        return this;
      }
      getFlag(flag) {
        return this.flagValues.get(flag);
      }
      getFlagBool(flag) {
        return toBool(this.getFlag(flag));
      }
      setFlag(flag, value = true) {
        if (!this.flags.has(flag)) {
          throw new UnknownFeatureFlagError(flag);
        }
        this.flagValues.set(flag, value);
        return this;
      }
      getFlagInfo(flag) {
        return this.flags.get(flag);
      }
      getFlags() {
        return [...this.flags.values()];
      }
      getFlagValues() {
        return new Map(this.flagValues);
      }
      reset() {
        this.flagValues.clear();
        return this;
      }
    };
    exports.FeatureFlags = FeatureFlags;
    var UnknownFeatureFlagError = class extends Error {
      constructor(flag) {
        super(`Unknown feature flag: ${flag}`);
        this.flag = flag;
      }
    };
    exports.UnknownFeatureFlagError = UnknownFeatureFlagError;
    function getSystemFeatureFlags2() {
      return systemFeatureFlags || (systemFeatureFlags = new FeatureFlags());
    }
    exports.getSystemFeatureFlags = getSystemFeatureFlags2;
    var boolValues = {
      0: false,
      1: true,
      f: false,
      false: false,
      n: false,
      no: false,
      t: true,
      true: true,
      y: true,
      yes: true
    };
    function toBool(value) {
      if (typeof value !== "string")
        return value;
      return boolValues[value.toLowerCase()];
    }
  }
});

// node_modules/cspell-lib/dist/cjs/FeatureFlags/index.js
var require_FeatureFlags2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/FeatureFlags/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownFeatureFlagError = exports.getSystemFeatureFlags = exports.FeatureFlags = void 0;
    var FeatureFlags_js_1 = require_FeatureFlags();
    Object.defineProperty(exports, "FeatureFlags", { enumerable: true, get: function() {
      return FeatureFlags_js_1.FeatureFlags;
    } });
    Object.defineProperty(exports, "getSystemFeatureFlags", { enumerable: true, get: function() {
      return FeatureFlags_js_1.getSystemFeatureFlags;
    } });
    Object.defineProperty(exports, "UnknownFeatureFlagError", { enumerable: true, get: function() {
      return FeatureFlags_js_1.UnknownFeatureFlagError;
    } });
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/grammarTypesHelpers.js
var require_grammarTypesHelpers = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/grammarTypesHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isGrammar = exports.isPatternPatterns = exports.isPatternBeginEnd = exports.isPatternMatch = exports.isPatternInclude = void 0;
    function isPatternInclude(p) {
      return !!p.include;
    }
    exports.isPatternInclude = isPatternInclude;
    var TypeofMatch = {
      object: true,
      string: true
    };
    var TypeofBegin = TypeofMatch;
    var TypeofEnd = { ...TypeofBegin, undefined: true };
    function isPatternMatch(pattern) {
      const p = pattern;
      return !!p.match && typeof p.match in TypeofMatch;
    }
    exports.isPatternMatch = isPatternMatch;
    function isPatternBeginEnd(pattern) {
      const p = pattern;
      return p.begin !== void 0 && typeof p.begin in TypeofBegin && typeof p.end in TypeofEnd;
    }
    exports.isPatternBeginEnd = isPatternBeginEnd;
    function isPatternPatterns(p) {
      return Array.isArray(p.patterns);
    }
    exports.isPatternPatterns = isPatternPatterns;
    function isGrammar(g) {
      return g.scopeName !== void 0;
    }
    exports.isGrammar = isGrammar;
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/matchResult.js
var require_matchResult = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/matchResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSimpleMatchResult = exports.createMatchResult = exports.segmentMatch = void 0;
    function segmentMatch(mr) {
      const { matches, index, groups, input } = mr;
      const segments = [];
      let p = index;
      for (let groupNum = 0; groupNum < matches.length; ++groupNum) {
        const m = matches[groupNum];
        if (!m)
          continue;
        const idx0 = input.indexOf(m, p);
        const idx = idx0 >= p ? idx0 : input.lastIndexOf(m, p);
        if (idx < 0)
          continue;
        segments.push({ match: m, index: idx, groupNum, groupName: void 0 });
        p = idx;
      }
      const textToSeg = new Map(segments.map((s) => [s.match, s]));
      for (const [name, value] of Object.entries(groups)) {
        const s = value && textToSeg.get(value);
        if (!s)
          continue;
        s.groupName = s.groupName ? Array.isArray(s.groupName) ? s.groupName.concat([name]) : [s.groupName, name] : name;
      }
      return segments;
    }
    exports.segmentMatch = segmentMatch;
    function createMatchResult(r, lineNumber) {
      const groups = /* @__PURE__ */ Object.create(null);
      r.groups && Object.assign(groups, r.groups);
      const matches = r;
      const match = r[0];
      return { index: r.index, input: r.input, match, matches, groups, lineNumber };
    }
    exports.createMatchResult = createMatchResult;
    function createSimpleMatchResult(match, input, index, lineNumber) {
      const groups = /* @__PURE__ */ Object.create(null);
      return { index, input, match, matches: [match], groups, lineNumber };
    }
    exports.createSimpleMatchResult = createSimpleMatchResult;
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/scope.js
var require_scope = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/scope.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopePool = exports.Scope = void 0;
    var assert_1 = __importDefault(require("assert"));
    var Scope = class _Scope {
      constructor(value, parent) {
        this.value = value;
        this.parent = parent;
      }
      /**
       * Convert the scope hierarchy to a string
       * @param ltr - return ancestry from left-to-right
       * @returns the scope hierarchy as a string separated by a space.
       */
      toString(ltr = false) {
        if (!this.parent)
          return this.value;
        return ltr ? this.parent.toString(ltr) + " " + this.value : this.value + " " + this.parent.toString(ltr);
      }
      static isScope(value) {
        return value instanceof _Scope;
      }
    };
    exports.Scope = Scope;
    var ScopePool = class {
      constructor() {
        this.pool = /* @__PURE__ */ new Map();
      }
      /**
       * Get a Scope that matches the scope. This method is idempotent.
       * @param scopeValue - a single scope value: i.e. `source.ts`
       * @param parent - optional parent Scope
       */
      getScope(scopeValue, parent) {
        const foundPoolMap = this.pool.get(scopeValue);
        const poolMap = foundPoolMap || /* @__PURE__ */ new Map();
        if (poolMap !== foundPoolMap) {
          this.pool.set(scopeValue, poolMap);
        }
        const foundScope = poolMap.get(parent);
        if (foundScope)
          return foundScope.v;
        const scope = new Scope(scopeValue, parent);
        poolMap.set(parent, { v: scope });
        return scope;
      }
      parseScope(scopes, ltr = false) {
        if (Scope.isScope(scopes))
          return scopes;
        if (isScopeLike(scopes)) {
          const parent = scopes.parent ? this.parseScope(scopes.parent) : void 0;
          return this.getScope(scopes.value, parent);
        }
        return this.parseScopeString(scopes, ltr);
      }
      parseScopeString(scopes, ltr) {
        scopes = Array.isArray(scopes) ? scopes : scopes.split(" ");
        const parentToChild = ltr ? scopes : scopes.reverse();
        let parent = void 0;
        for (const value of parentToChild) {
          parent = this.getScope(value, parent);
        }
        (0, assert_1.default)(parent, "Empty scope is not allowed.");
        return parent;
      }
    };
    exports.ScopePool = ScopePool;
    function isScopeLike(value) {
      return typeof value === "object" && !Array.isArray(value) && value.value !== void 0;
    }
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/grammarNormalizer.js
var require_grammarNormalizer = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/grammarNormalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractScope = exports.nPattern = exports.normalizeGrammar = void 0;
    var grammarTypesHelpers_js_1 = require_grammarTypesHelpers();
    var matchResult_js_1 = require_matchResult();
    var scope_js_1 = require_scope();
    function normalizeGrammar(grammar) {
      return new ImplNGrammar(grammar);
    }
    exports.normalizeGrammar = normalizeGrammar;
    var SpecialRepositoryReferences = {
      $self: true,
      $base: true
    };
    function nPattern(p) {
      if ((0, grammarTypesHelpers_js_1.isPatternMatch)(p))
        return normalizePatternMatch(p);
      if ((0, grammarTypesHelpers_js_1.isPatternBeginEnd)(p))
        return normalizePatternBeginEnd(p);
      if ((0, grammarTypesHelpers_js_1.isPatternInclude)(p))
        return normalizePatternInclude(p);
      if ((0, grammarTypesHelpers_js_1.isPatternPatterns)(p))
        return normalizePatternsPatterns(p);
      return normalizePatternName(p);
    }
    exports.nPattern = nPattern;
    function normalizePatternMatch(p) {
      const regExec = makeTestMatchFn(p.match);
      const self = {
        ...p,
        captures: normalizeCapture(p.captures),
        findMatch
      };
      function findMatch(line, parentRule) {
        const match = regExec(line);
        if (!match)
          return void 0;
        const rule = factoryRule(parentRule, self);
        return { rule, match, line };
      }
      return self;
    }
    function normalizePatternBeginEnd(p) {
      const patterns = normalizePatterns(p.patterns);
      const self = {
        ...p,
        captures: normalizeCapture(p.captures),
        beginCaptures: normalizeCapture(p.beginCaptures),
        endCaptures: normalizeCapture(p.endCaptures),
        patterns,
        findMatch
      };
      function findMatch(line, parentRule) {
        const match = testBegin(line);
        if (!match)
          return void 0;
        const rule = factoryRule(parentRule, self, findNext, end);
        return { rule, match, line };
      }
      const testBegin = makeTestMatchFn(p.begin);
      const testEnd = p.end !== void 0 ? makeTestMatchFn(p.end) : () => void 0;
      function findNext(line) {
        return patterns && findInPatterns(patterns, line, this);
      }
      function end(line) {
        return testEnd(line);
      }
      return self;
    }
    function normalizePatternName(p) {
      const patterns = void 0;
      const self = {
        ...p,
        patterns,
        findMatch
      };
      function findMatch(line, parentRule) {
        const rule = factoryRule(parentRule, self);
        const input = line.text.slice(line.offset);
        const match = (0, matchResult_js_1.createSimpleMatchResult)(input, input, line.offset, line.lineNumber);
        return { rule, match, line };
      }
      return self;
    }
    function normalizePatternInclude(p) {
      const { include } = p;
      return include.startsWith("#") || include in SpecialRepositoryReferences ? normalizePatternIncludeRef(p) : normalizePatternIncludeExt(p);
    }
    function normalizePatternIncludeRef(p) {
      const { include, ...rest } = p;
      const reference = include.startsWith("#") ? include.slice(1) : include;
      const self = {
        ...rest,
        reference,
        findMatch
      };
      function findMatch(line, parentRule) {
        const pat = parentRule.repository[reference];
        if (pat === void 0)
          throw new Error(`Unknown Include Reference ${include}`);
        return pat.findMatch(line, parentRule);
      }
      return self;
    }
    function normalizePatternIncludeExt(p) {
      function findMatch(_line) {
        return void 0;
      }
      const self = {
        ...p,
        findMatch
      };
      return self;
    }
    function normalizePatternsPatterns(p) {
      return new ImplNPatternPatterns(p);
    }
    function findInPatterns(patterns, line, rule) {
      let r = void 0;
      for (const pat of patterns) {
        if (pat.disabled)
          continue;
        const er = pat.findMatch(line, rule);
        if (er?.match !== void 0 && !er.rule.pattern.disabled) {
          r = r && r.match && r.match.index <= er.match.index && r || er;
        }
      }
      return r;
    }
    function normalizePatterns(patterns) {
      if (!patterns)
        return void 0;
      return patterns.map((p) => typeof p === "string" ? { include: p } : p).map(nPattern);
    }
    var emptyRepository = Object.freeze(/* @__PURE__ */ Object.create(null));
    function normalizePatternRepository(rep) {
      if (!rep)
        return emptyRepository;
      return normalizeRepository(rep);
    }
    function normalizeRepository(rep) {
      const repository = /* @__PURE__ */ Object.create(null);
      for (const [key, pat] of Object.entries(rep)) {
        repository[key] = nPattern(pat);
      }
      return repository;
    }
    var ruleCounter = 0;
    function factoryRuleBase(parent, pattern, repository, grammar, findNext, end) {
      const depth = parent ? parent.depth + 1 : 0;
      return {
        id: ruleCounter++,
        grammar,
        pattern,
        parent,
        repository,
        depth,
        findNext,
        end
      };
    }
    function factoryRule(parent, pattern, findNext, end) {
      return factoryRuleBase(parent, pattern, parent.repository, parent.grammar, findNext, end);
    }
    function normalizeCapture(cap) {
      if (cap === void 0)
        return void 0;
      if (typeof cap === "string")
        return { [0]: cap };
      const capture = /* @__PURE__ */ Object.create(null);
      for (const [key, pat] of Object.entries(cap)) {
        capture[key] = typeof pat === "string" ? pat : normalizePatternName(pat).name;
      }
      return capture;
    }
    function makeTestMatchFn(reg) {
      if (typeof reg === "string")
        return matchString(reg);
      return matchRegExp(reg);
    }
    function matchString(s) {
      return (line) => {
        const input = line.text;
        const index = input.indexOf(s, line.offset);
        if (index < 0)
          return void 0;
        return (0, matchResult_js_1.createSimpleMatchResult)(s, input, index, line.lineNumber);
      };
    }
    function matchRegExp(r) {
      return (line) => {
        const rg = RegExp(r, "gm");
        rg.lastIndex = line.offset;
        const m = rg.exec(line.text);
        return (m && (0, matchResult_js_1.createMatchResult)(m, line.lineNumber)) ?? void 0;
      };
    }
    function extractScope(er, isContent = true) {
      const scope = [];
      for (let rule = er; rule; rule = rule.parent) {
        const pattern = rule.pattern;
        const { name, contentName } = pattern;
        if (contentName && isContent) {
          scope.push(contentName);
        }
        if (name !== void 0) {
          scope.push(name);
        }
        isContent = true;
      }
      return er.grammar.scopePool.parseScope(scope);
    }
    exports.extractScope = extractScope;
    var ImplNGrammar = class {
      constructor(grammar) {
        this.scopeName = grammar.scopeName;
        this.name = grammar.scopeName;
        this.comment = grammar.comment;
        this.disabled = grammar.disabled;
        this.grammarName = grammar.name;
        const self = nPattern({
          patterns: [{ patterns: grammar.patterns }]
        });
        const repository = normalizePatternRepository(grammar.repository);
        this.patterns = self.patterns;
        this.repository = repository;
        this.self = self;
        this.scopePool = new scope_js_1.ScopePool();
      }
      begin(parentRule) {
        const patterns = this.patterns;
        function grammarToRule(grammar, baseGrammar, parent) {
          const repository = /* @__PURE__ */ Object.create(null);
          Object.assign(repository, grammar.repository);
          repository["$self"] = grammar.self;
          repository["$base"] = repository["$base"] || baseGrammar.self;
          function findNext(line) {
            return findInPatterns(patterns, line, this);
          }
          function end(_line) {
            return void 0;
          }
          return factoryRuleBase(parent, grammar, repository, grammar, findNext, end);
        }
        return grammarToRule(this, parentRule?.grammar ?? this, parentRule);
      }
    };
    var ImplNPatternPatterns = class {
      constructor(p) {
        const { name, comment, disabled, ...rest } = p;
        this.patterns = normalizePatterns(rest.patterns);
        this.name = name;
        this.comment = comment;
        this.disabled = disabled;
      }
      findMatch(line, parentRule) {
        const patterns = this.patterns;
        const rule = factoryRule(parentRule, this, findNext);
        function findNext(line2) {
          return findInPatterns(patterns, line2, this);
        }
        return rule.findNext?.(line);
      }
    };
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/grammar.js
var require_grammar = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/grammar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileGrammar = void 0;
    var grammarNormalizer_js_1 = require_grammarNormalizer();
    function compileGrammar(grammar) {
      return (0, grammarNormalizer_js_1.normalizeGrammar)(grammar);
    }
    exports.compileGrammar = compileGrammar;
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/util.js
var require_util7 = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDefined = void 0;
    function isDefined2(t) {
      return t !== void 0 && t !== null;
    }
    exports.isDefined = isDefined2;
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/processors/procMatchingRule.js
var require_procMatchingRule = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/processors/procMatchingRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyCaptures = exports.applyCaptureToEnd = exports.applyCaptureToBeginOrMatch = void 0;
    var grammarNormalizer_js_1 = require_grammarNormalizer();
    var matchResult_js_1 = require_matchResult();
    var util_js_1 = require_util7();
    function applyCaptureToBeginOrMatch(matchRuleResult) {
      const { match, rule } = matchRuleResult;
      const bePattern = rule.pattern;
      const captures = bePattern.beginCaptures ?? bePattern.captures;
      return applyCaptures(rule, match, captures);
    }
    exports.applyCaptureToBeginOrMatch = applyCaptureToBeginOrMatch;
    function applyCaptureToEnd(rule, match) {
      const { pattern } = rule;
      const bePattern = pattern;
      const captures = bePattern.endCaptures ?? bePattern.captures;
      return applyCaptures(rule, match, captures);
    }
    exports.applyCaptureToEnd = applyCaptureToEnd;
    function applyCaptures(rule, match, captures) {
      const scope = (0, grammarNormalizer_js_1.extractScope)(rule, false);
      const pool = rule.grammar.scopePool;
      const text = match.match;
      const input = match.input;
      const range = [match.index, match.index + text.length, match.lineNumber];
      if (!text && !captures)
        return [];
      if (!captures) {
        const tokenized = {
          scope,
          text,
          range
        };
        return [tokenized];
      }
      const captureScopes = new Map(Object.entries(captures));
      const cap0 = captureScopes.get("0");
      if (captureScopes.size === 1 && cap0) {
        const tokenized = {
          scope: rule.grammar.scopePool.getScope(cap0, scope),
          text,
          range
        };
        return [tokenized];
      }
      const min = match.index;
      const max = match.index + text.length;
      function trimSegment(seg) {
        const { index, match: match2 } = seg;
        const right = match2.length;
        if (index >= min && right <= max)
          return seg;
        if (index >= max || right < min)
          return void 0;
        const a = Math.max(index, min) - index;
        const b = Math.min(right, max) - index;
        const text2 = match2.slice(a, b);
        return {
          ...seg,
          index: index + a,
          match: text2
        };
      }
      const segments = (0, matchResult_js_1.segmentMatch)(match).map(trimSegment).filter(util_js_1.isDefined);
      function processSegments(segments2) {
        const base = segments2[0];
        const root = {
          a: base.index,
          b: base.index + base.match.length,
          s: { seg: base }
        };
        let m;
        for (let i = 1; i < segments2.length; ++i) {
          const seg = segments2[i];
          const index = seg.index;
          const end = index + seg.match.length;
          m = m && m.a <= index ? m : root;
          while (m && m.b <= index) {
            m = m.n;
          }
          while (m && m.a < end) {
            if (m.a < index) {
              const n = { ...m, a: index };
              m.n = n;
              m.b = index;
              m = n;
            }
            if (m.b > end) {
              const n = { ...m, a: end };
              m.b = end;
              m.n = n;
            }
            m.s = { seg, next: m.s };
            m = m.n;
          }
        }
        return root;
      }
      function segChainToScope(chain) {
        function* _chain(chain2) {
          while (chain2) {
            const seg = chain2.seg;
            if (seg.groupName) {
              if (Array.isArray(seg.groupName)) {
                yield* seg.groupName;
              } else {
                yield seg.groupName;
              }
            }
            yield seg.groupNum.toString();
            chain2 = chain2.next;
          }
        }
        const scopeValues = [..._chain(chain)].map((cap) => captureScopes.get(cap)).filter(util_js_1.isDefined).reverse();
        return scopeValues.reduce((s, v) => pool.getScope(v, s), scope);
      }
      const merged = processSegments(segments);
      function* emit(m) {
        while (m) {
          const t = {
            text: input.slice(m.a, m.b),
            range: [m.a, m.b, match.lineNumber],
            scope: segChainToScope(m.s)
          };
          yield t;
          m = m.n;
        }
      }
      const parsedText = [...emit(merged)];
      return parsedText;
    }
    exports.applyCaptures = applyCaptures;
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/tokenizeLine.js
var require_tokenizeLine = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/tokenizeLine.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenizeTextIterable = exports.tokenizeText = exports.tokenizeLine = void 0;
    var assert_1 = __importDefault(require("assert"));
    var grammarNormalizer_js_1 = require_grammarNormalizer();
    var procMatchingRule_js_1 = require_procMatchingRule();
    function tokenizeLine(line, rule) {
      const text = line.text;
      const lineLen = line.text.length;
      const parsedText = [];
      let ctx = buildContext({ ...line, offset: 0, anchor: -1 }, rule);
      while (ctx.line.offset <= lineLen) {
        let endMatch = ctx.rule.end?.(ctx.line);
        while (endMatch?.index === ctx.line.offset) {
          parsedText.push(...(0, procMatchingRule_js_1.applyCaptureToEnd)(ctx.rule, endMatch));
          ctx = findParentWithEnd(ctx);
          ctx.line.offset = endMatch.index + endMatch.match.length;
          endMatch = ctx.rule.end?.(ctx.line);
        }
        if (ctx.line.offset >= lineLen)
          break;
        const { line: line2, rule: rule2 } = ctx;
        const offset = line2.offset;
        const match = rule2.findNext?.(line2);
        const limit = endMatch?.index ?? lineLen;
        const emitTil = match ? Math.min(match.match.index, limit) : limit;
        if (offset < emitTil) {
          const scope = (0, grammarNormalizer_js_1.extractScope)(rule2);
          const start = offset;
          const end = emitTil;
          parsedText.push({
            scope,
            text: text.slice(start, end),
            range: [start, end, line2.lineNumber]
          });
          ctx.line.offset = emitTil;
        }
        if (!match || endMatch && endMatch.index <= match.match.index) {
          continue;
        }
        parsedText.push(...(0, procMatchingRule_js_1.applyCaptureToBeginOrMatch)(match));
        line2.anchor = match.match.index + match.match.match.length;
        line2.offset = line2.anchor;
        ctx = findNearestWithEnd(buildContext(line2, match.rule));
      }
      return toParseLineResult(line, ctx.rule, parsedText);
    }
    exports.tokenizeLine = tokenizeLine;
    function tokenizeText(text, grammar) {
      return [...tokenizeTextIterable(text, grammar)];
    }
    exports.tokenizeText = tokenizeText;
    function* tokenizeTextIterable(text, grammar) {
      const lines = text.split(/(?<=\r\n|\n|\r(?!\n))/);
      const rule = grammar.begin();
      let documentOffset = 0;
      let tr = tokenizeLine({ text: lines[0], lineNumber: 0, documentOffset }, rule);
      documentOffset += lines[0].length;
      yield toParsedLine(tr);
      for (let i = 1; i < lines.length; ++i) {
        const line = { text: lines[i], lineNumber: i, documentOffset };
        documentOffset += line.text.length;
        tr = tr.parse(line);
        yield toParsedLine(tr);
      }
    }
    exports.tokenizeTextIterable = tokenizeTextIterable;
    function toParsedLine(pr) {
      const { tokens: parsedText, line, offset } = pr;
      return { tokens: parsedText, line, offset };
    }
    function toParseLineResult(line, rule, parsedText) {
      return {
        tokens: parsedText,
        line,
        offset: line.documentOffset,
        parse: (line2) => tokenizeLine(line2, rule)
      };
    }
    function buildContext(line, rule) {
      const rules = calcRuleStack(rule);
      const numRules = rules.length;
      const rootNum = numRules - 1;
      const rootRule = rules[rootNum];
      const rootContext = {
        line,
        rule: rootRule
      };
      let ctx = rootContext;
      for (let i = rootNum - 1; i >= 0; --i) {
        const rule2 = rules[i];
        const line2 = ctx.line;
        ctx = {
          line: line2,
          rule: rule2,
          parent: ctx
        };
      }
      return ctx;
    }
    function calcRuleStack(rule) {
      const rules = [];
      let r = rule;
      while (r) {
        rules.push(r);
        r = r.parent;
      }
      return rules;
    }
    function must(t, msg = "Must be defined") {
      (0, assert_1.default)(t !== void 0 && t !== null, msg);
      return t;
    }
    function findParentWithEnd(ctx) {
      return findNearestWithEnd(must(ctx.parent));
    }
    function findNearestWithEnd(ctx) {
      while (!ctx.rule.end) {
        ctx = must(ctx.parent);
      }
      return ctx;
    }
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/index.js
var require_parser = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenizeText = exports.tokenizeLine = exports.compileGrammar = void 0;
    var grammar_js_1 = require_grammar();
    Object.defineProperty(exports, "compileGrammar", { enumerable: true, get: function() {
      return grammar_js_1.compileGrammar;
    } });
    var tokenizeLine_js_1 = require_tokenizeLine();
    Object.defineProperty(exports, "tokenizeLine", { enumerable: true, get: function() {
      return tokenizeLine_js_1.tokenizeLine;
    } });
    Object.defineProperty(exports, "tokenizeText", { enumerable: true, get: function() {
      return tokenizeLine_js_1.tokenizeText;
    } });
  }
});

// node_modules/cspell-grammar/dist/cjs/grammars/typescript.js
var require_typescript = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/grammars/typescript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.grammar = void 0;
    var repository = {
      statements: {
        name: "code.ts",
        patterns: [
          "#keyword",
          "#regexp",
          "#string",
          "#comment",
          "#braces",
          "#punctuation",
          "#space",
          { name: "identifier", match: /[^\s;,!|&:^%{}[\]()*/+=<>]+/ }
        ]
      },
      keyword: {
        patterns: ["#keywordBase", "#standardTypes", "#standardLib"]
      },
      keywordBase: {
        name: "keyword.typescript.ts",
        match: /\b(?:any|as|async|await|bigint|boolean|break|case|catch|const|continue|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|in|instanceof|interface|import|let|map|module|new|new|null|number|of|package|private|public|require|return|set|static|string|super|switch|this|throw|true|try|type|typeof|unknown|undefined|var|void|while|yield)\b/
      },
      standardTypes: {
        name: "keyword.type.ts",
        match: /\b(?:Promise|Record|Omit|Extract|Exclude|BigInt|Array)\b/
      },
      standardLib: {
        name: "keyword.lib.ts",
        match: /\b(?:console|process|window)\b/
      },
      string: {
        patterns: ["#string_q_single", "#string_q_double", "#string_template"]
      },
      string_q_single: {
        name: "string.quoted.single.ts",
        begin: "'",
        end: /'|((?:[^\\\n])$)/,
        captures: "punctuation.string.ts",
        patterns: [{ include: "#string_character_escape" }]
      },
      string_q_double: {
        name: "string.quoted.double.ts",
        begin: '"',
        end: /"|((?:[^\\\n])$)/,
        captures: "punctuation.string.ts",
        patterns: [{ include: "#string_character_escape" }]
      },
      string_template: {
        name: "string.template.ts",
        begin: "`",
        end: "`",
        captures: "punctuation.string.ts",
        patterns: [
          {
            name: "meta.template.expression.ts",
            contentName: "meta.embedded.line.ts",
            begin: "${",
            end: "}",
            patterns: ["#statements"],
            captures: "punctuation.definition.template.expression.ts"
          },
          { include: "#string_character_escape" }
        ]
      },
      string_character_escape: {
        name: "constant.character.escape.ts",
        match: /\\(x[0-9A-Fa-f]{2}|[0-3][0-7]{0,2}|[4-7][0-7]?|u[0-9A-Fa-f]{4}|.|\r?\n?$)/
      },
      braces: {
        patterns: [
          {
            begin: "(",
            end: ")",
            captures: "punctuation.meta.brace.ts",
            patterns: ["#statements"],
            name: "meta.brace.ts",
            contentName: "code.ts"
          },
          {
            begin: "{",
            end: "}",
            captures: "punctuation.meta.brace.ts",
            patterns: ["#statements"],
            name: "meta.brace.ts",
            contentName: "code.ts"
          },
          {
            begin: "[",
            end: "]",
            captures: "punctuation.meta.brace.ts",
            patterns: ["#statements"],
            name: "meta.brace.ts",
            contentName: "code.ts"
          }
        ]
      },
      punctuation: {
        name: "punctuation.ts",
        match: /[-;:,!|&^%*/+=<>\n\r]/
      },
      space: {
        name: "punctuation.space.ts",
        match: /\s+/
      },
      comment: {
        patterns: [
          {
            name: "comment.line.ts",
            comment: "line comment",
            begin: "//",
            end: /(?=$)/,
            captures: "punctuation.definition.comment.ts"
          },
          {
            name: "comment.block.documentation.ts",
            comment: "DocBlock",
            begin: /\/\*\*(?!\/)/,
            captures: "punctuation.definition.comment.ts",
            end: "*/"
          },
          {
            name: "comment.block.ts",
            begin: "/*",
            end: "*/",
            captures: "punctuation.definition.comment.ts"
          }
        ]
      },
      regexp: {
        name: "regexp.ts",
        begin: /\/(?![/*])/,
        end: /\/([a-z]*)/i,
        beginCaptures: "punctuation.begin.regexp.ts",
        endCaptures: "punctuation.end.regexp.ts",
        patterns: ["#regexp_escape", "#regexp_brace"]
      },
      regexp_escape: {
        name: "escape.regexp.ts",
        match: /\\./
      },
      regexp_brace: {
        name: "brace.regexp.ts",
        begin: "[",
        end: "]",
        contentName: "character-class.regexp.ts",
        patterns: ["#regexp_escape"]
      }
    };
    exports.grammar = {
      name: "TypeScript",
      scopeName: "source.ts",
      patterns: [
        {
          name: "comment.line.shebang.ts",
          match: /^#!.*(?=$)/
        },
        {
          include: "#statements"
        }
      ],
      repository
    };
  }
});

// node_modules/cspell-grammar/dist/cjs/mappers/appendMappedText.js
var require_appendMappedText = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/mappers/appendMappedText.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.appendMappedText = void 0;
    var assert_1 = __importDefault(require("assert"));
    function appendMappedText(a, b) {
      if (!a.map && !b.map) {
        return { text: a.text + b.text };
      }
      const aLen = a.text.length;
      const bLen = b.text.length;
      const aMap = [0, 0].concat(a.map || [0, 0, aLen, aLen]);
      const bMap = [0, 0].concat(b.map || [0, 0, bLen, bLen]);
      (0, assert_1.default)(aMap[aMap.length - 1] === aLen);
      (0, assert_1.default)(bMap[bMap.length - 1] === bLen);
      (0, assert_1.default)((aMap.length & 1) === 0);
      (0, assert_1.default)((bMap.length & 1) === 0);
      return {
        text: a.text + b.text,
        map: joinMaps(aMap, bMap)
      };
    }
    exports.appendMappedText = appendMappedText;
    function joinMaps(aMap, bMap) {
      const n = aMap.length - 1;
      const offsets = [aMap[n - 1], aMap[n]];
      const ab = aMap.concat(bMap.map((v, i) => v + offsets[i & 1]));
      const r = [0, 0];
      let last0 = 0, last1 = 0;
      for (let i = 0; i < ab.length; i += 2) {
        const v0 = ab[i];
        const v12 = ab[i + 1];
        if (v0 === last0 && v12 === last1) {
          continue;
        }
        r.push(v0, v12);
        last0 = v0;
        last1 = v12;
      }
      return r;
    }
  }
});

// node_modules/cspell-grammar/dist/cjs/mappers/typescript.js
var require_typescript2 = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/mappers/typescript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapRawString = void 0;
    var hexChars = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    var escapeChars = {
      t: "	",
      n: "\n",
      r: "\r",
      b: "\b",
      "\\": "\\",
      '"': '"',
      "'": "'",
      "\n": ""
    };
    function mapRawString(text) {
      const end = text.length;
      let t = "";
      const map = [];
      const isHex = /^[0-9a-fA-F]+$/;
      let i, j;
      for (i = 0, j = 0; i < end; ++i) {
        let parsed;
        const ti = text[i];
        if (ti === "\\") {
          map.push(i, j);
          const tc = text[++i];
          const ec = escapeChars[tc];
          if (ec) {
            t += ec;
            j += ec.length;
            map.push(i, j);
            continue;
          }
          switch (tc) {
            case "u":
              {
                let char;
                let end2;
                if (text[i + 1] !== "{") {
                  const digits = text.slice(i + 1, i + 5);
                  parsed = isHex.test(digits) ? parseInt(digits, 16) : NaN;
                  char = isNaN(parsed) ? "" : String.fromCharCode(parsed);
                  end2 = i + 4;
                } else {
                  for (end2 = i + 2; text[end2] in hexChars; ++end2) {
                  }
                  if (text[end2] !== "}") {
                    char = "";
                  } else {
                    const digits = text.slice(i + 2, end2);
                    parsed = isHex.test(digits) ? parseInt(digits, 16) : NaN;
                    char = isNaN(parsed) ? "" : String.fromCodePoint(parsed);
                  }
                }
                if (!char) {
                  t += tc;
                  j += 1;
                } else {
                  t += char;
                  j += char.length;
                  i = end2;
                }
              }
              break;
            case "x":
              {
                const digits = text.slice(i + 1, i + 3);
                parsed = isHex.test(digits) ? parseInt(digits, 16) : NaN;
                if (isNaN(parsed)) {
                  t += tc;
                  j += 1;
                } else {
                  t += String.fromCharCode(parsed);
                  i += 2;
                  ++j;
                }
              }
              break;
            case "0":
              t += "0";
              j += 1;
              break;
            case "\r":
              i += text[i + 1] === "\n" ? 1 : 0;
              break;
            case "\n":
              break;
            case void 0:
              break;
            default:
              t += tc;
              ++j;
              break;
          }
          map.push(i + 1, j);
          continue;
        }
        t += ti;
        ++j;
      }
      if (map.length) {
        const ii = map[map.length - 2];
        const jj = map[map.length - 1];
        if (ii !== i || jj !== j) {
          map.push(i, j);
        }
      }
      return {
        text: t,
        map
      };
    }
    exports.mapRawString = mapRawString;
  }
});

// node_modules/cspell-grammar/dist/cjs/parser/parser.js
var require_parser2 = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parser/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createParser = exports.parseDocument = void 0;
    var sync_1 = require_sync();
    var tokenizeLine_js_1 = require_tokenizeLine();
    function parseDocument(grammar, _filename, content, emitter = (line) => console.log(line)) {
      const r = (0, tokenizeLine_js_1.tokenizeText)(content, grammar);
      const tokens = (0, sync_1.pipe)(r, (0, sync_1.opMap)((tl) => tl.tokens.map((t) => ({ t, l: tl.line }))), (0, sync_1.opFlatten)(), (0, sync_1.opFilter)((t) => !t.t.scope.value.startsWith("punctuation")));
      for (const { t: token, l: line } of tokens) {
        emitter(`${(token.range[2] ?? line.lineNumber) + 1}:${token.range[0] + 1}	 ${JSON.stringify(token.text)}	 ${token.scope.toString()}`);
      }
    }
    exports.parseDocument = parseDocument;
    function mapTokenizedLine(tl) {
      return tl.tokens.map((t) => ({
        text: t.text,
        range: [tl.offset + t.range[0], tl.offset + t.range[1]],
        scope: t.scope
      }));
    }
    function mapTokenizedLines(itl) {
      return (0, sync_1.pipe)(itl, (0, sync_1.opMap)(mapTokenizedLine), (0, sync_1.opFlatten)());
    }
    function createParser(grammar, name, transform = mapTokenizedLines) {
      function parse3(content, filename) {
        const parsedTexts = (0, sync_1.pipe)((0, tokenizeLine_js_1.tokenizeTextIterable)(content, grammar), transform);
        return { content, filename, parsedTexts };
      }
      return { name, parse: parse3 };
    }
    exports.createParser = createParser;
  }
});

// node_modules/cspell-grammar/dist/cjs/parsers/typescript/TypeScriptParser.js
var require_TypeScriptParser = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parsers/typescript/TypeScriptParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parser = void 0;
    var sync_1 = require_sync();
    var typescript_js_1 = require_typescript();
    var appendMappedText_js_1 = require_appendMappedText();
    var typescript_js_2 = require_typescript2();
    var grammar_js_1 = require_grammar();
    var parser_js_1 = require_parser2();
    var scope_js_1 = require_scope();
    var tsGrammar = (0, grammar_js_1.compileGrammar)(typescript_js_1.grammar);
    var pool = new scope_js_1.ScopePool();
    var useScope = /* @__PURE__ */ new WeakMap();
    function* transform(texts) {
      for (const parsed of texts) {
        if (doesScopeMatch(parsed.scope, "constant.character.escape.ts")) {
          const mapped = (0, typescript_js_2.mapRawString)(parsed.text);
          const scope = parsed.scope ? pool.parseScope(parsed.scope) : void 0;
          yield {
            text: mapped.text,
            scope: scope?.parent,
            map: mapped.map,
            range: parsed.range
          };
          continue;
        }
        yield parsed;
      }
    }
    function* mergeStringResults(results) {
      let last;
      for (const next of results) {
        if (!doesScopeMatch(next.scope, "string.")) {
          if (last) {
            yield last;
            last = void 0;
          }
          yield next;
          continue;
        }
        if (!last) {
          last = next;
          continue;
        }
        if (next.scope !== last.scope || last.range[1] !== next.range[0]) {
          yield last;
          last = next;
          continue;
        }
        last = mergeParsedText(last, next);
      }
      if (last)
        yield last;
    }
    function mergeParsedText(a, b) {
      const abT = (0, appendMappedText_js_1.appendMappedText)(a, b);
      const ab = {
        text: abT.text,
        scope: a.scope,
        range: [a.range[0], b.range[1]],
        map: abT.map,
        delegate: a.delegate
      };
      return ab;
    }
    function filterScope(scope) {
      const cached = useScope.get(scope);
      if (cached !== void 0)
        return cached;
      const value = scope.value;
      const use = !value.startsWith("punctuation") && !value.startsWith("keyword.");
      useScope.set(scope, use);
      return use;
    }
    function mapTokenizedLine(tl) {
      return tl.tokens.filter((t) => filterScope(t.scope)).map((t) => ({
        text: t.text,
        range: [tl.offset + t.range[0], tl.offset + t.range[1]],
        scope: t.scope
      }));
    }
    function mapTokenizedLines(itl) {
      return (0, sync_1.pipe)(itl, (0, sync_1.opMap)(mapTokenizedLine), (0, sync_1.opFlatten)(), transform, mergeStringResults);
    }
    exports.parser = (0, parser_js_1.createParser)(tsGrammar, "typescript", mapTokenizedLines);
    function doesScopeMatch(s, match) {
      if (!s)
        return false;
      return typeof s === "string" ? s.startsWith(match) : s.value.startsWith(match);
    }
  }
});

// node_modules/cspell-grammar/dist/cjs/parsers/typescript/index.js
var require_typescript3 = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parsers/typescript/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parser = void 0;
    var TypeScriptParser_js_1 = require_TypeScriptParser();
    Object.defineProperty(exports, "parser", { enumerable: true, get: function() {
      return TypeScriptParser_js_1.parser;
    } });
  }
});

// node_modules/cspell-grammar/dist/cjs/parsers/index.js
var require_parsers = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/parsers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsers = void 0;
    var index_js_1 = require_typescript3();
    exports.parsers = [index_js_1.parser];
  }
});

// node_modules/cspell-grammar/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/cspell-grammar/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsers = exports.tokenizeText = exports.tokenizeLine = exports.compileGrammar = void 0;
    var index_js_1 = require_parser();
    Object.defineProperty(exports, "compileGrammar", { enumerable: true, get: function() {
      return index_js_1.compileGrammar;
    } });
    Object.defineProperty(exports, "tokenizeLine", { enumerable: true, get: function() {
      return index_js_1.tokenizeLine;
    } });
    Object.defineProperty(exports, "tokenizeText", { enumerable: true, get: function() {
      return index_js_1.tokenizeText;
    } });
    var index_js_2 = require_parsers();
    Object.defineProperty(exports, "parsers", { enumerable: true, get: function() {
      return index_js_2.parsers;
    } });
  }
});

// node_modules/cspell-lib/dist/lib-cjs/pkg-info.cjs
var require_pkg_info = __commonJS({
  "node_modules/cspell-lib/dist/lib-cjs/pkg-info.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.srcDirectory = void 0;
    exports.srcDirectory = __dirname;
  }
});

// node_modules/cspell-lib/dist/lib-cjs/index.cjs
var require_lib_cjs = __commonJS({
  "node_modules/cspell-lib/dist/lib-cjs/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.srcDirectory = void 0;
    var pkg_info_cjs_1 = require_pkg_info();
    Object.defineProperty(exports, "srcDirectory", { enumerable: true, get: function() {
      return pkg_info_cjs_1.srcDirectory;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/Models/PatternRegExp.js
var require_PatternRegExp = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Models/PatternRegExp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatternRegExp = void 0;
    var PatternRegExp = class extends RegExp {
      constructor(pattern) {
        super(pattern);
      }
      toJSON() {
        return this.toString();
      }
    };
    exports.PatternRegExp = PatternRegExp;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/LanguageSettings.js
var require_LanguageSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/LanguageSettings.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calcSettingsForLanguageId = exports.calcUserSettingsForLanguage = exports.calcSettingsForLanguage = exports.isValidLocaleIntlFormat = exports.isLocaleInSet = exports.normalizeLocaleIntl = exports.normalizeLocale = exports.normalizeLanguageId = exports.getDefaultLanguageSettings = void 0;
    var AutoResolve_js_1 = require_AutoResolve();
    var util_js_1 = require_util();
    var SpellSettings = __importStar(require_CSpellSettingsServer());
    var defaultLocale = "en";
    var defaultLanguageSettings = [];
    function getDefaultLanguageSettings() {
      return defaultLanguageSettings;
    }
    exports.getDefaultLanguageSettings = getDefaultLanguageSettings;
    function localesToList(locales) {
      return stringToList(locales.replace(/\s+/g, ","));
    }
    function stringToList(sList) {
      return sList.replace(/[|;]/g, ",").split(",").map((s) => s.trim()).filter((s) => !!s);
    }
    function memorizer(resolver) {
      const cache = (0, AutoResolve_js_1.createAutoResolveCache)();
      return (k) => cache.get(k, resolver);
    }
    var _normalizeLanguageId = memorizer(__normalizeLanguageId);
    function __normalizeLanguageId(langId) {
      const langIds = stringToList(langId);
      return new Set(langIds.map((a) => a.toLowerCase()));
    }
    function normalizeLanguageId(langId) {
      return _normalizeLanguageId(typeof langId === "string" ? langId : langId.join(","));
    }
    exports.normalizeLanguageId = normalizeLanguageId;
    var _normalizeLocale = memorizer(__normalizeLocale);
    function __normalizeLocale(locale) {
      const locales = localesToList(locale);
      return new Set(locales.map((locale2) => locale2.toLowerCase().replace(/[^a-z]/g, "")));
    }
    function normalizeLocale(locale) {
      locale = typeof locale === "string" ? locale : locale.join(",");
      return _normalizeLocale(locale);
    }
    exports.normalizeLocale = normalizeLocale;
    function normalizeLocaleIntl(locale) {
      const values = [...normalizeLocale(locale)].map((locale2) => locale2.replace(/^([a-z]{2})-?([a-z]{2})$/, (_, lang, locale3) => locale3 ? `${lang}-${locale3.toUpperCase()}` : lang));
      return new Set(values);
    }
    exports.normalizeLocaleIntl = normalizeLocaleIntl;
    function isLocaleInSet(locale, setOfLocals) {
      const locales = normalizeLocale(locale);
      return (0, util_js_1.doSetsIntersect)(locales, setOfLocals);
    }
    exports.isLocaleInSet = isLocaleInSet;
    var regExpValidIntlLocaleStrict = /^[a-z]{2}(-[A-Z]{2})?$/;
    var regExpValidIntlLocale = new RegExp(regExpValidIntlLocaleStrict, "i");
    function isValidLocaleIntlFormat(locale, strict = false) {
      if (typeof locale === "string")
        return strict ? regExpValidIntlLocaleStrict.test(locale) : regExpValidIntlLocale.test(locale);
      for (const item of locale) {
        if (!isValidLocaleIntlFormat(item, strict))
          return false;
      }
      return locale.length > 0;
    }
    exports.isValidLocaleIntlFormat = isValidLocaleIntlFormat;
    var cacheCalcSettingsForLanguage = /* @__PURE__ */ new WeakMap();
    function calcSettingsForLanguage(languageSettings, languageId, locale) {
      const mapLang = (0, AutoResolve_js_1.autoResolveWeak)(cacheCalcSettingsForLanguage, languageSettings, () => /* @__PURE__ */ new Map());
      const mapLocale = (0, AutoResolve_js_1.autoResolve)(mapLang, languageId, () => /* @__PURE__ */ new Map());
      return (0, AutoResolve_js_1.autoResolve)(mapLocale, locale, () => _calcSettingsForLanguage(languageSettings, languageId, locale));
    }
    exports.calcSettingsForLanguage = calcSettingsForLanguage;
    function _calcSettingsForLanguage(languageSettings, languageId, locale) {
      languageId = languageId.toLowerCase();
      const allowedLocals = normalizeLocale(locale);
      const ls = languageSettings.filter((s) => doesLanguageSettingMatchLanguageId(s, languageId)).filter((s) => !s.locale || s.locale === "*" || isLocaleInSet(s.locale, allowedLocals)).map((langSetting) => {
        const { languageId: _languageId, locale: _locale, ...s } = langSetting;
        return s;
      }).reduce((langSetting, setting) => SpellSettings.mergeSettings(langSetting, setting), {});
      ls.languageId = languageId;
      ls.locale = locale;
      return ls;
    }
    var cacheDoesLanguageSettingMatchLanguageId = /* @__PURE__ */ new WeakMap();
    function doesLanguageSettingMatchLanguageId(s, languageId) {
      const r = cacheDoesLanguageSettingMatchLanguageId.get(s) ?? /* @__PURE__ */ new Map();
      const f = r.get(languageId);
      if (f !== void 0) {
        return f;
      }
      const v = _doesLanguageSettingMatchLanguageId(s, languageId);
      r.set(languageId, v);
      cacheDoesLanguageSettingMatchLanguageId.set(s, r);
      return v;
    }
    function _doesLanguageSettingMatchLanguageId(s, languageId) {
      const languageSettingsLanguageIds = s.languageId;
      if (!languageSettingsLanguageIds || languageSettingsLanguageIds === "*")
        return true;
      const ids = normalizeLanguageId(languageSettingsLanguageIds);
      if (ids.has(languageId))
        return true;
      if (ids.has("!" + languageId))
        return false;
      const numExcludes = [...ids].filter((id) => id.startsWith("!")).length;
      return numExcludes === ids.size;
    }
    function calcUserSettingsForLanguage(settings, languageId) {
      const { languageSettings = [], language: locale = defaultLocale, allowCompoundWords, enabled } = settings;
      const langSettings = {
        allowCompoundWords,
        enabled,
        ...calcSettingsForLanguage(languageSettings, languageId, locale)
      };
      return SpellSettings.mergeSettings(settings, langSettings);
    }
    exports.calcUserSettingsForLanguage = calcUserSettingsForLanguage;
    function calcSettingsForLanguageId(baseSettings, languageId) {
      const langIds = ["*", ...normalizeLanguageId(languageId)];
      const langSettings = langIds.reduce((settings, languageId2) => {
        return calcUserSettingsForLanguage(settings, languageId2);
      }, baseSettings);
      return langSettings;
    }
    exports.calcSettingsForLanguageId = calcSettingsForLanguageId;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/RegExpPatterns.js
var require_RegExpPatterns = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/RegExpPatterns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regExHashStrings = exports.regExSha = exports.regExRepeatedChar = exports.regExEmail = exports.rexExPythonStyleComments = exports.regExCStyleComments = exports.regExString = exports.regExPhpHereDoc = exports.regExBase64MultiLine = exports.regExBase64SingleLine = exports.regExBase64 = exports.regExEscapeCharacters = exports.regExSshRSA = exports.regExCert = exports.regExPublicKey = exports.regExIgnoreSpellingDirectives = exports.regExSpellingGuardLine = exports.regExSpellingGuardNext = exports.regExSpellingGuardBlock = exports.regExUnicodeRef = exports.regExUUID = exports.regExCSSHexValue = exports.regExCStyleHexValue = exports.regExCommitHashLink = exports.regExCommitHash = exports.regExMatchCommonHexFormats = exports.regExHRef = exports.regExMatchUrls = void 0;
    exports.regExMatchUrls = /(?:https?|ftp):\/\/[^\s"]+/gi;
    exports.regExHRef = /\bhref\s*=\s*".*?"/gi;
    exports.regExMatchCommonHexFormats = /(?:#[0-9a-f]{3,8})|(?:0x[0-9a-f]+)|(?:\\u[0-9a-f]{4})|(?:\\x\{[0-9a-f]{4}\})/gi;
    exports.regExCommitHash = /\b(?![a-f]+\b)(?:0x)?[0-9a-f]{7,}\b/gi;
    exports.regExCommitHashLink = /\[[0-9a-f]{7,}\]/gi;
    exports.regExCStyleHexValue = /\b0x[0-9a-f]+\b/gi;
    exports.regExCSSHexValue = /#[0-9a-f]{3,8}\b/gi;
    exports.regExUUID = /\b[0-9a-fx]{8}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{12}\b/gi;
    exports.regExUnicodeRef = /\bU\+[0-9a-f]{4,5}(?:-[0-9a-f]{4,5})?/gi;
    exports.regExSpellingGuardBlock = /(\bc?spell(?:-?checker)?::?)\s*disable(?!-line|-next)\b(?!-)[\s\S]*?((?:\1\s*enable\b)|$)/gi;
    exports.regExSpellingGuardNext = /\bc?spell(?:-?checker)?::?\s*disable-next\b.*\s\s?.*/gi;
    exports.regExSpellingGuardLine = /^.*\bc?spell(?:-?checker)?::?\s*disable-line\b.*/gim;
    exports.regExIgnoreSpellingDirectives = /\bc?spell(?:-?checker)?::?\s*ignoreRegExp.*/gim;
    exports.regExPublicKey = /-{5}BEGIN\s+((?:RSA\s+)?PUBLIC\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
    exports.regExCert = /-{5}BEGIN\s+(CERTIFICATE|(?:RSA\s+)?(?:PRIVATE|PUBLIC)\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
    exports.regExSshRSA = /ssh-rsa\s+[a-z0-9/+]{28,}={0,3}(?![a-z0-9/+=])/gi;
    exports.regExEscapeCharacters = /\\(?:[anrvtbf]|[xu][a-f0-9]+)/gi;
    exports.regExBase64 = /(?<![A-Za-z0-9/+])(?:[A-Za-z0-9/+]{40,})(?:\s^\s*[A-Za-z0-9/+]{40,})*(?:\s^\s*[A-Za-z0-9/+]+=*)?(?![A-Za-z0-9/+=])/gm;
    exports.regExBase64SingleLine = /(?<![A-Za-z0-9/+])(?=[^/]|[/][A-Za-z0-9/+]+?[=+])(?![A-Za-z/]+(?![A-Za-z0-9/+=]))(?=[A-Za-z0-9/+=]*?(?:[A-Z]{2}|[0-9]{2}))(?:[A-Za-z0-9/+]{4}){10,}(?:[A-Za-z0-9/+]{3}={1}|[A-Za-z0-9/+]{2}={2}|[A-Za-z0-9/+]{1}={3})?(?![A-Za-z0-9/+=])(?=$|[:.,"'\\)])/gm;
    exports.regExBase64MultiLine = /(?<![A-Za-z0-9/+])["']?(?:[A-Za-z0-9/+]{40,})["']?(?:\s^\s*["']?[A-Za-z0-9/+]{40,}["']?)+(?:\s^\s*["']?[A-Za-z0-9/+]+={0,3}["']?)?(?![A-Za-z0-9/+=])/gm;
    exports.regExPhpHereDoc = /<<<['"]?(\w+)['"]?[\s\S]+?^\1;/gm;
    exports.regExString = /(?:(['"]).*?(?<![^\\]\\(\\\\)*)\1)|(?:`[\s\S]*?(?<![^\\]\\(\\\\)*)`)/g;
    exports.regExCStyleComments = /(?<!\w:)(?:\/\/.*)|(?:\/\*[\s\S]*?\*\/)/g;
    exports.rexExPythonStyleComments = /#.*|(?:('''|""")[^\1]+?\1)/gm;
    exports.regExEmail = /<?\b[\w.\-+]{1,128}@\w{1,63}(\.\w{1,63}){1,4}\b>?/gi;
    exports.regExRepeatedChar = /^(\w)\1{3,}$/i;
    exports.regExSha = /\bsha\d+-[a-z0-9+/]{25,}={0,3}/gi;
    exports.regExHashStrings = /(?:\b(?:sha\d+|md5|base64|crypt|bcrypt|scrypt|security-token|assertion)[-,:$=]|#code[/])[-\w/+%.]{25,}={0,3}(?:(['"])\s*\+?\s*\1?[-\w/+%.]+={0,3})*(?![-\w/+=%.])/gi;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/DefaultSettings.js
var require_DefaultSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/DefaultSettings.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultBundledSettings = exports.getDefaultSettings = exports._defaultSettings = exports._defaultSettingsBasis = void 0;
    var cspell_grammar_1 = require_cjs6();
    var index_cjs_1 = require_lib_cjs();
    var CSpellSettingsInternalDef_js_1 = require_CSpellSettingsInternalDef();
    var PatternRegExp_js_1 = require_PatternRegExp();
    var resolveFile_js_1 = require_resolveFile();
    var index_js_1 = require_configLoader2();
    var CSpellSettingsServer_js_1 = require_CSpellSettingsServer();
    var LanguageSettings = __importStar(require_LanguageSettings());
    var RegPat = __importStar(require_RegExpPatterns());
    var defaultConfigFileModuleRef = "@cspell/cspell-bundled-dicts/cspell-default.json";
    var defaultConfigFile = resolveConfigModule(defaultConfigFileModuleRef);
    var regExpSpellCheckerDisable = [
      new PatternRegExp_js_1.PatternRegExp(RegPat.regExSpellingGuardBlock),
      new PatternRegExp_js_1.PatternRegExp(RegPat.regExSpellingGuardLine),
      new PatternRegExp_js_1.PatternRegExp(RegPat.regExSpellingGuardNext)
    ];
    var predefinedPatterns = [
      // Exclude patterns
      { name: "CommitHash", pattern: RegPat.regExCommitHash },
      { name: "CommitHashLink", pattern: RegPat.regExCommitHashLink },
      { name: "CStyleHexValue", pattern: RegPat.regExCStyleHexValue },
      { name: "CSSHexValue", pattern: RegPat.regExCSSHexValue },
      { name: "Urls", pattern: RegPat.regExMatchUrls },
      { name: "HexValues", pattern: RegPat.regExMatchCommonHexFormats },
      { name: "SpellCheckerDisable", pattern: regExpSpellCheckerDisable },
      { name: "PublicKey", pattern: RegPat.regExPublicKey },
      { name: "RsaCert", pattern: RegPat.regExCert },
      { name: "SshRsa", pattern: RegPat.regExSshRSA },
      { name: "EscapeCharacters", pattern: RegPat.regExEscapeCharacters },
      { name: "Base64", pattern: RegPat.regExBase64 },
      { name: "Base64SingleLine", pattern: RegPat.regExBase64SingleLine },
      { name: "Base64MultiLine", pattern: RegPat.regExBase64MultiLine },
      { name: "Email", pattern: RegPat.regExEmail },
      { name: "SHA", pattern: RegPat.regExSha },
      { name: "HashStrings", pattern: RegPat.regExHashStrings },
      { name: "UnicodeRef", pattern: RegPat.regExUnicodeRef },
      { name: "UUID", pattern: RegPat.regExUUID },
      { name: "href", pattern: RegPat.regExHRef },
      { name: "SpellCheckerDisableBlock", pattern: RegPat.regExSpellingGuardBlock },
      { name: "SpellCheckerDisableLine", pattern: RegPat.regExSpellingGuardLine },
      { name: "SpellCheckerDisableNext", pattern: RegPat.regExSpellingGuardNext },
      { name: "SpellCheckerIgnoreInDocSetting", pattern: RegPat.regExIgnoreSpellingDirectives },
      // Include Patterns
      { name: "PhpHereDoc", pattern: RegPat.regExPhpHereDoc },
      { name: "string", pattern: RegPat.regExString },
      { name: "CStyleComment", pattern: RegPat.regExCStyleComments },
      { name: "Everything", pattern: ".*" }
    ];
    var defaultRegExpPatterns = [...predefinedPatterns].map(normalizePattern2);
    var definedDefaultRegExpExcludeList = [
      "SpellCheckerDisable",
      "SpellCheckerIgnoreInDocSetting",
      "Urls",
      "Email",
      "RsaCert",
      "SshRsa",
      "Base64MultiLine",
      "Base64SingleLine",
      "CommitHash",
      "CommitHashLink",
      "CStyleHexValue",
      "CSSHexValue",
      "SHA",
      "HashStrings",
      "UnicodeRef",
      "UUID"
    ];
    var defaultRegExpExcludeList = definedDefaultRegExpExcludeList;
    exports._defaultSettingsBasis = Object.freeze((0, CSpellSettingsInternalDef_js_1.createCSpellSettingsInternal)({
      id: "static_defaults",
      language: "en",
      name: "Static Defaults",
      enabled: true,
      enabledLanguageIds: [],
      maxNumberOfProblems: 100,
      numSuggestions: 10,
      suggestionsTimeout: 500,
      suggestionNumChanges: 3,
      words: [],
      userWords: [],
      ignorePaths: [],
      allowCompoundWords: false,
      patterns: defaultRegExpPatterns,
      ignoreRegExpList: [],
      languageSettings: [],
      source: { name: "defaultSettings" },
      reporters: [],
      plugins: [{ parsers: cspell_grammar_1.parsers }]
    }));
    exports._defaultSettings = Object.freeze((0, CSpellSettingsInternalDef_js_1.createCSpellSettingsInternal)({
      ...exports._defaultSettingsBasis,
      enabledLanguageIds: [
        "ada",
        "csharp",
        "go",
        "javascript",
        "javascriptreact",
        "json",
        "markdown",
        "mdx",
        "php",
        "plaintext",
        "python",
        "text",
        "typescript",
        "typescriptreact",
        "haskell",
        "html",
        "css",
        "less",
        "scss",
        "latex",
        "ruby",
        "rust",
        "shellscript",
        "toml"
      ],
      ignoreRegExpList: defaultRegExpExcludeList,
      languageSettings: LanguageSettings.getDefaultLanguageSettings()
    }));
    var getSettings = function() {
      let settings = void 0;
      return function(useDefaultDictionaries) {
        if (!useDefaultDictionaries) {
          return exports._defaultSettingsBasis;
        }
        if (!settings) {
          const jsonSettings = (0, index_js_1.readSettings)(defaultConfigFile);
          settings = (0, CSpellSettingsServer_js_1.mergeSettings)(exports._defaultSettings, jsonSettings);
          if (jsonSettings.name !== void 0) {
            settings.name = jsonSettings.name;
          } else {
            delete settings.name;
          }
        }
        return settings;
      };
    }();
    function resolveConfigModule(configModuleName) {
      return (0, resolveFile_js_1.resolveFile)(configModuleName, index_cjs_1.srcDirectory).filename;
    }
    function normalizePattern2(pat) {
      const { name, pattern, description } = pat;
      if (!(pattern instanceof RegExp))
        return pat;
      return {
        name,
        pattern: new PatternRegExp_js_1.PatternRegExp(pattern),
        description
      };
    }
    function getDefaultSettings3(useDefaultDictionaries = true) {
      return getSettings(useDefaultDictionaries);
    }
    exports.getDefaultSettings = getDefaultSettings3;
    function getDefaultBundledSettings() {
      return getDefaultSettings3();
    }
    exports.getDefaultBundledSettings = getDefaultBundledSettings;
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/index.js
var require_Settings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultSettings = exports.getDefaultBundledSettings = exports.mergeSettings = exports.mergeInDocSettings = exports.getSources = exports.finalizeSettings = exports.extractDependencies = exports.checkFilenameMatchesGlob = exports.calcOverrideSettings = exports.ImportError = exports.sectionCSpell = exports.searchForConfig = exports.readSettingsFiles = exports.readSettings = exports.readRawSettings = exports.loadPnPSync = exports.loadPnP = exports.loadConfig = exports.getGlobalSettings = exports.getCachedFileSize = exports.extractImportErrors = exports.defaultFileName = exports.defaultConfigFilenames = exports.clearCachedSettingsFiles = exports.ENV_CSPELL_GLOB_ROOT = exports.currentSettingsFileVersion = void 0;
    var constants_js_1 = require_constants3();
    Object.defineProperty(exports, "currentSettingsFileVersion", { enumerable: true, get: function() {
      return constants_js_1.currentSettingsFileVersion;
    } });
    Object.defineProperty(exports, "ENV_CSPELL_GLOB_ROOT", { enumerable: true, get: function() {
      return constants_js_1.ENV_CSPELL_GLOB_ROOT;
    } });
    var index_js_1 = require_configLoader2();
    Object.defineProperty(exports, "clearCachedSettingsFiles", { enumerable: true, get: function() {
      return index_js_1.clearCachedSettingsFiles;
    } });
    Object.defineProperty(exports, "defaultConfigFilenames", { enumerable: true, get: function() {
      return index_js_1.defaultConfigFilenames;
    } });
    Object.defineProperty(exports, "defaultFileName", { enumerable: true, get: function() {
      return index_js_1.defaultFileName;
    } });
    Object.defineProperty(exports, "extractImportErrors", { enumerable: true, get: function() {
      return index_js_1.extractImportErrors;
    } });
    Object.defineProperty(exports, "getCachedFileSize", { enumerable: true, get: function() {
      return index_js_1.getCachedFileSize;
    } });
    Object.defineProperty(exports, "getGlobalSettings", { enumerable: true, get: function() {
      return index_js_1.getGlobalSettings;
    } });
    Object.defineProperty(exports, "loadConfig", { enumerable: true, get: function() {
      return index_js_1.loadConfig;
    } });
    Object.defineProperty(exports, "loadPnP", { enumerable: true, get: function() {
      return index_js_1.loadPnP;
    } });
    Object.defineProperty(exports, "loadPnPSync", { enumerable: true, get: function() {
      return index_js_1.loadPnPSync;
    } });
    Object.defineProperty(exports, "readRawSettings", { enumerable: true, get: function() {
      return index_js_1.readRawSettings;
    } });
    Object.defineProperty(exports, "readSettings", { enumerable: true, get: function() {
      return index_js_1.readSettings;
    } });
    Object.defineProperty(exports, "readSettingsFiles", { enumerable: true, get: function() {
      return index_js_1.readSettingsFiles;
    } });
    Object.defineProperty(exports, "searchForConfig", { enumerable: true, get: function() {
      return index_js_1.searchForConfig;
    } });
    Object.defineProperty(exports, "sectionCSpell", { enumerable: true, get: function() {
      return index_js_1.sectionCSpell;
    } });
    var ImportError_js_1 = require_ImportError();
    Object.defineProperty(exports, "ImportError", { enumerable: true, get: function() {
      return ImportError_js_1.ImportError;
    } });
    var CSpellSettingsServer_js_1 = require_CSpellSettingsServer();
    Object.defineProperty(exports, "calcOverrideSettings", { enumerable: true, get: function() {
      return CSpellSettingsServer_js_1.calcOverrideSettings;
    } });
    Object.defineProperty(exports, "checkFilenameMatchesGlob", { enumerable: true, get: function() {
      return CSpellSettingsServer_js_1.checkFilenameMatchesGlob;
    } });
    Object.defineProperty(exports, "extractDependencies", { enumerable: true, get: function() {
      return CSpellSettingsServer_js_1.extractDependencies;
    } });
    Object.defineProperty(exports, "finalizeSettings", { enumerable: true, get: function() {
      return CSpellSettingsServer_js_1.finalizeSettings;
    } });
    Object.defineProperty(exports, "getSources", { enumerable: true, get: function() {
      return CSpellSettingsServer_js_1.getSources;
    } });
    Object.defineProperty(exports, "mergeInDocSettings", { enumerable: true, get: function() {
      return CSpellSettingsServer_js_1.mergeInDocSettings;
    } });
    Object.defineProperty(exports, "mergeSettings", { enumerable: true, get: function() {
      return CSpellSettingsServer_js_1.mergeSettings;
    } });
    var DefaultSettings_js_1 = require_DefaultSettings();
    Object.defineProperty(exports, "getDefaultBundledSettings", { enumerable: true, get: function() {
      return DefaultSettings_js_1.getDefaultBundledSettings;
    } });
    Object.defineProperty(exports, "getDefaultSettings", { enumerable: true, get: function() {
      return DefaultSettings_js_1.getDefaultSettings;
    } });
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/AutoCache.js
var require_AutoCache = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/AutoCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractStats = exports.autoCache = exports.createCache01 = void 0;
    var CACHE_SIZE = 100;
    var Cache01 = class {
      constructor(maxSize) {
        this.maxSize = maxSize;
        this.count = 0;
        this.cache0 = /* @__PURE__ */ Object.create(null);
        this.cache1 = /* @__PURE__ */ Object.create(null);
        this.hits = 0;
        this.misses = 0;
        this.swaps = 0;
      }
      get(key) {
        const cache0 = this.cache0;
        const cache1 = this.cache1;
        if (key in cache0) {
          ++this.hits;
          return cache0[key];
        }
        if (key in cache1) {
          ++this.hits;
          ++this.count;
          const r = cache1[key];
          cache0[key] = r;
          return r;
        }
        ++this.misses;
        return void 0;
      }
      set(key, value) {
        if (this.count >= this.maxSize) {
          this.cache1 = this.cache0;
          this.cache0 = /* @__PURE__ */ Object.create(null);
          this.swaps++;
          this.count = 0;
        }
        ++this.count;
        this.cache0[key] = value;
        return this;
      }
    };
    function createCache01(size) {
      return new Cache01(size);
    }
    exports.createCache01 = createCache01;
    function autoCache(fn, size = CACHE_SIZE) {
      const cache = createCache01(size);
      const ac = get;
      ac.hits = 0;
      ac.misses = 0;
      ac.swaps = 0;
      function get(k) {
        const f = cache.get(k);
        if (f !== void 0) {
          ++ac.hits;
          return f;
        }
        const r = fn(k);
        cache.set(k, r);
        ac.swaps = cache.swaps;
        ++ac.misses;
        return r;
      }
      return ac;
    }
    exports.autoCache = autoCache;
    function extractStats(ac) {
      const { hits, misses, swaps } = ac;
      return { hits, misses, swaps };
    }
    exports.extractStats = extractStats;
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/text.js
var require_text3 = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeUnboundAccents = exports.removeAccents = exports.matchCase = exports.lcFirst = exports.ucFirst = exports.isFirstCharacterLower = exports.isFirstCharacterUpper = exports.isLowerCase = exports.isUpperCase = void 0;
    var regExFirstUpper = /^\p{Lu}\p{M}?\p{Ll}+$/u;
    var regExAllUpper = /^(?:\p{Lu}\p{M}?)+$/u;
    var regExAllLower = /^(?:\p{Ll}\p{M}?)+$/u;
    var regExAccents = /\p{M}/gu;
    function isUpperCase(word) {
      return !!word.match(regExAllUpper);
    }
    exports.isUpperCase = isUpperCase;
    function isLowerCase(word) {
      return !!word.match(regExAllLower);
    }
    exports.isLowerCase = isLowerCase;
    function isFirstCharacterUpper(word) {
      return isUpperCase(word.slice(0, 1));
    }
    exports.isFirstCharacterUpper = isFirstCharacterUpper;
    function isFirstCharacterLower(word) {
      return isLowerCase(word.slice(0, 1));
    }
    exports.isFirstCharacterLower = isFirstCharacterLower;
    function ucFirst(word) {
      return word.slice(0, 1).toUpperCase() + word.slice(1);
    }
    exports.ucFirst = ucFirst;
    function lcFirst(word) {
      return word.slice(0, 1).toLowerCase() + word.slice(1);
    }
    exports.lcFirst = lcFirst;
    function matchCase(example, word) {
      if (example.match(regExFirstUpper)) {
        return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();
      }
      if (example.match(regExAllLower)) {
        return word.toLowerCase();
      }
      if (example.match(regExAllUpper)) {
        return word.toUpperCase();
      }
      if (isFirstCharacterUpper(example)) {
        return ucFirst(word);
      }
      if (isFirstCharacterLower(example)) {
        return lcFirst(word);
      }
      return word;
    }
    exports.matchCase = matchCase;
    function removeAccents(text) {
      return text.normalize("NFD").replace(regExAccents, "");
    }
    exports.removeAccents = removeAccents;
    function removeUnboundAccents(text) {
      return text.replace(regExAccents, "");
    }
    exports.removeUnboundAccents = removeUnboundAccents;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionaryMethods.js
var require_SpellingDictionaryMethods = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionaryMethods.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testMethods__ = exports.createWeightMapFromDictionaryInformation = exports.suggestArgsToSuggestOptions = exports.canonicalSearchOptions = exports.hasOptionToSearchOption = exports.wordSuggestForms = exports.wordSuggestFormsArray = exports.wordSearchForms = exports.defaultNumSuggestions = exports.suggestionCollector = exports.impersonateCollector = void 0;
    var cspell_trie_lib_1 = require_cjs5();
    var text_js_1 = require_text3();
    var cspell_trie_lib_2 = require_cjs5();
    Object.defineProperty(exports, "impersonateCollector", { enumerable: true, get: function() {
      return cspell_trie_lib_2.impersonateCollector;
    } });
    Object.defineProperty(exports, "suggestionCollector", { enumerable: true, get: function() {
      return cspell_trie_lib_2.suggestionCollector;
    } });
    exports.defaultNumSuggestions = 10;
    function wordSearchFormsArray(word, isDictionaryCaseSensitive, ignoreCase) {
      return [...wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase)];
    }
    function wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase) {
      const forms = /* @__PURE__ */ new Set();
      word = word.normalize("NFC");
      const wordLc = word.toLowerCase();
      if (ignoreCase) {
        if (isDictionaryCaseSensitive) {
          forms.add(wordLc);
        } else {
          forms.add(wordLc);
          forms.add((0, text_js_1.removeUnboundAccents)(wordLc));
        }
      } else {
        if (isDictionaryCaseSensitive) {
          forms.add(word);
          forms.add(wordLc);
          if ((0, text_js_1.isUpperCase)(word)) {
            forms.add((0, text_js_1.ucFirst)(wordLc));
          }
        } else {
          forms.add(wordLc);
          forms.add((0, text_js_1.removeUnboundAccents)(wordLc));
        }
      }
      return forms;
    }
    exports.wordSearchForms = wordSearchForms;
    function wordSuggestFormsArray(word) {
      return [...wordSuggestForms(word)];
    }
    exports.wordSuggestFormsArray = wordSuggestFormsArray;
    function wordSuggestForms(word) {
      word = word.normalize("NFC");
      const forms = /* @__PURE__ */ new Set([word]);
      const wordLc = word.toLowerCase();
      forms.add(wordLc);
      return forms;
    }
    exports.wordSuggestForms = wordSuggestForms;
    var DEFAULT_HAS_OPTIONS = Object.freeze({});
    function hasOptionToSearchOption(opt) {
      return canonicalSearchOptions(!opt ? DEFAULT_HAS_OPTIONS : opt);
    }
    exports.hasOptionToSearchOption = hasOptionToSearchOption;
    var canonicalSearchOptionsMap = /* @__PURE__ */ new Map();
    var knownCanonicalOptions = /* @__PURE__ */ new WeakMap();
    function canonicalSearchOptions(opt) {
      const known = knownCanonicalOptions.get(opt);
      if (known)
        return known;
      const { ignoreCase, useCompounds } = opt;
      const foundLevel1Map = canonicalSearchOptionsMap.get(ignoreCase);
      const useLevel1Map = foundLevel1Map || /* @__PURE__ */ new Map();
      if (!foundLevel1Map) {
        canonicalSearchOptionsMap.set(ignoreCase, useLevel1Map);
      }
      const foundCanOpts = useLevel1Map.get(useCompounds);
      const canOpts = foundCanOpts || Object.freeze({ ignoreCase, useCompounds });
      if (!foundCanOpts) {
        useLevel1Map.set(useCompounds, canOpts);
      }
      knownCanonicalOptions.set(opt, canOpts);
      return canOpts;
    }
    exports.canonicalSearchOptions = canonicalSearchOptions;
    function suggestArgsToSuggestOptions(args) {
      const [_word, options, compoundMethod, numChanges, ignoreCase] = args;
      const suggestOptions = typeof options === "object" ? options : {
        numSuggestions: options,
        compoundMethod,
        numChanges,
        ignoreCase
      };
      return suggestOptions;
    }
    exports.suggestArgsToSuggestOptions = suggestArgsToSuggestOptions;
    function createWeightMapFromDictionaryInformation(di) {
      return di ? (0, cspell_trie_lib_1.mapDictionaryInformationToWeightMap)(di) : void 0;
    }
    exports.createWeightMapFromDictionaryInformation = createWeightMapFromDictionaryInformation;
    exports.__testMethods__ = {
      wordSearchForms,
      wordSearchFormsArray
    };
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/CachingDictionary.js
var require_CachingDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/CachingDictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCachingDictionary = void 0;
    var AutoCache_js_1 = require_AutoCache();
    var SpellingDictionaryMethods_js_1 = require_SpellingDictionaryMethods();
    var dictionaryCounter = 0;
    var DefaultAutoCacheSize = 1e3;
    var CachedDict = class {
      constructor(dict, options) {
        this.dict = dict;
        this.options = options;
        this.id = ++dictionaryCounter;
        this.has = (0, AutoCache_js_1.autoCache)((word) => this.dict.has(word, this.options), DefaultAutoCacheSize);
        this.isNoSuggestWord = (0, AutoCache_js_1.autoCache)((word) => this.dict.isNoSuggestWord(word, this.options), DefaultAutoCacheSize);
        this.isForbidden = (0, AutoCache_js_1.autoCache)((word) => this.dict.isForbidden(word), DefaultAutoCacheSize);
        this.getPreferredSuggestions = (0, AutoCache_js_1.autoCache)((word) => this.dict.getPreferredSuggestions?.(word), DefaultAutoCacheSize);
        this.name = dict.name;
      }
      stats() {
        return {
          name: this.name,
          id: this.id,
          has: (0, AutoCache_js_1.extractStats)(this.has),
          isNoSuggestWord: (0, AutoCache_js_1.extractStats)(this.isNoSuggestWord),
          isForbidden: (0, AutoCache_js_1.extractStats)(this.isForbidden),
          getPreferredSuggestions: (0, AutoCache_js_1.extractStats)(this.getPreferredSuggestions)
        };
      }
    };
    var knownDicts = /* @__PURE__ */ new Map();
    function createCachingDictionary(dict, options) {
      options = (0, SpellingDictionaryMethods_js_1.canonicalSearchOptions)(options);
      let knownOptions = knownDicts.get(options);
      if (!knownOptions) {
        knownOptions = /* @__PURE__ */ new WeakMap();
        knownDicts.set(options, knownOptions);
      }
      const known = knownOptions.get(dict);
      if (known)
        return known;
      const cached = new CachedDict(dict, options);
      knownOptions.set(dict, cached);
      return cached;
    }
    exports.createCachingDictionary = createCachingDictionary;
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/AutoResolve.js
var require_AutoResolve2 = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/AutoResolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAutoResolveWeakCache = exports.AutoResolveWeakCache = exports.autoResolveWeak = exports.createAutoResolveCache = exports.AutoResolveCache = exports.autoResolve = void 0;
    function autoResolve(map, key, resolve10) {
      const found = map.get(key);
      if (found !== void 0 || map.has(key))
        return found;
      const value = resolve10(key);
      map.set(key, value);
      return value;
    }
    exports.autoResolve = autoResolve;
    var AutoResolveCache = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      get(k, resolve10) {
        return resolve10 ? autoResolve(this.map, k, resolve10) : this.map.get(k);
      }
      has(k) {
        return this.map.has(k);
      }
      set(k, v) {
        this.map.set(k, v);
        return this;
      }
    };
    exports.AutoResolveCache = AutoResolveCache;
    function createAutoResolveCache() {
      return new AutoResolveCache();
    }
    exports.createAutoResolveCache = createAutoResolveCache;
    function autoResolveWeak(map, key, resolve10) {
      const found = map.get(key);
      if (found !== void 0 || map.has(key))
        return found;
      const value = resolve10(key);
      map.set(key, value);
      return value;
    }
    exports.autoResolveWeak = autoResolveWeak;
    var AutoResolveWeakCache = class {
      constructor() {
        this.map = /* @__PURE__ */ new WeakMap();
      }
      get(k, resolve10) {
        return resolve10 ? autoResolveWeak(this.map, k, resolve10) : this.map.get(k);
      }
      has(k) {
        return this.map.has(k);
      }
      set(k, v) {
        this.map.set(k, v);
        return this;
      }
    };
    exports.AutoResolveWeakCache = AutoResolveWeakCache;
    function createAutoResolveWeakCache() {
      return new AutoResolveWeakCache();
    }
    exports.createAutoResolveWeakCache = createAutoResolveWeakCache;
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/util.js
var require_util8 = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDefined = void 0;
    function isDefined2(v) {
      return v !== void 0;
    }
    exports.isDefined = isDefined2;
  }
});

// node_modules/fast-equals/dist/fast-equals.cjs.js
var require_fast_equals_cjs = __commonJS({
  "node_modules/fast-equals/dist/fast-equals.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createDefaultIsNestedEqual(comparator) {
      return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {
        return comparator(a, b, meta);
      };
    }
    function createIsCircular(areItemsEqual) {
      return function isCircular(a, b, isEqual, cache) {
        if (!a || !b || typeof a !== "object" || typeof b !== "object") {
          return areItemsEqual(a, b, isEqual, cache);
        }
        var cachedA = cache.get(a);
        var cachedB = cache.get(b);
        if (cachedA && cachedB) {
          return cachedA === b && cachedB === a;
        }
        cache.set(a, b);
        cache.set(b, a);
        var result = areItemsEqual(a, b, isEqual, cache);
        cache.delete(a);
        cache.delete(b);
        return result;
      };
    }
    function merge(a, b) {
      var merged = {};
      for (var key in a) {
        merged[key] = a[key];
      }
      for (var key in b) {
        merged[key] = b[key];
      }
      return merged;
    }
    function isPlainObject(value) {
      return value.constructor === Object || value.constructor == null;
    }
    function isPromiseLike(value) {
      return typeof value.then === "function";
    }
    function sameValueZeroEqual(a, b) {
      return a === b || a !== a && b !== b;
    }
    var ARGUMENTS_TAG = "[object Arguments]";
    var BOOLEAN_TAG = "[object Boolean]";
    var DATE_TAG = "[object Date]";
    var REG_EXP_TAG = "[object RegExp]";
    var MAP_TAG = "[object Map]";
    var NUMBER_TAG = "[object Number]";
    var OBJECT_TAG = "[object Object]";
    var SET_TAG = "[object Set]";
    var STRING_TAG = "[object String]";
    var toString = Object.prototype.toString;
    function createComparator(_a) {
      var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areMapsEqual2 = _a.areMapsEqual, areObjectsEqual2 = _a.areObjectsEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;
      var isEqual = createIsNestedEqual(comparator);
      function comparator(a, b, meta) {
        if (a === b) {
          return true;
        }
        if (!a || !b || typeof a !== "object" || typeof b !== "object") {
          return a !== a && b !== b;
        }
        if (isPlainObject(a) && isPlainObject(b)) {
          return areObjectsEqual2(a, b, isEqual, meta);
        }
        var aArray = Array.isArray(a);
        var bArray = Array.isArray(b);
        if (aArray || bArray) {
          return aArray === bArray && areArraysEqual2(a, b, isEqual, meta);
        }
        var aTag = toString.call(a);
        if (aTag !== toString.call(b)) {
          return false;
        }
        if (aTag === DATE_TAG) {
          return areDatesEqual2(a, b, isEqual, meta);
        }
        if (aTag === REG_EXP_TAG) {
          return areRegExpsEqual2(a, b, isEqual, meta);
        }
        if (aTag === MAP_TAG) {
          return areMapsEqual2(a, b, isEqual, meta);
        }
        if (aTag === SET_TAG) {
          return areSetsEqual2(a, b, isEqual, meta);
        }
        if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {
          return isPromiseLike(a) || isPromiseLike(b) ? false : areObjectsEqual2(a, b, isEqual, meta);
        }
        if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {
          return sameValueZeroEqual(a.valueOf(), b.valueOf());
        }
        return false;
      }
      return comparator;
    }
    function areArraysEqual(a, b, isEqual, meta) {
      var index = a.length;
      if (b.length !== index) {
        return false;
      }
      while (index-- > 0) {
        if (!isEqual(a[index], b[index], index, index, a, b, meta)) {
          return false;
        }
      }
      return true;
    }
    var areArraysEqualCircular = createIsCircular(areArraysEqual);
    function areDatesEqual(a, b) {
      return sameValueZeroEqual(a.valueOf(), b.valueOf());
    }
    function areMapsEqual(a, b, isEqual, meta) {
      var isValueEqual = a.size === b.size;
      if (!isValueEqual) {
        return false;
      }
      if (!a.size) {
        return true;
      }
      var matchedIndices = {};
      var indexA = 0;
      a.forEach(function(aValue, aKey) {
        if (!isValueEqual) {
          return;
        }
        var hasMatch = false;
        var matchIndexB = 0;
        b.forEach(function(bValue, bKey) {
          if (!hasMatch && !matchedIndices[matchIndexB] && (hasMatch = isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) && isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
            matchedIndices[matchIndexB] = true;
          }
          matchIndexB++;
        });
        indexA++;
        isValueEqual = hasMatch;
      });
      return isValueEqual;
    }
    var areMapsEqualCircular = createIsCircular(areMapsEqual);
    var OWNER = "_owner";
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function areObjectsEqual(a, b, isEqual, meta) {
      var keysA = Object.keys(a);
      var index = keysA.length;
      if (Object.keys(b).length !== index) {
        return false;
      }
      var key;
      while (index-- > 0) {
        key = keysA[index];
        if (key === OWNER) {
          var reactElementA = !!a.$$typeof;
          var reactElementB = !!b.$$typeof;
          if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
            return false;
          }
        }
        if (!hasOwnProperty2.call(b, key) || !isEqual(a[key], b[key], key, key, a, b, meta)) {
          return false;
        }
      }
      return true;
    }
    var areObjectsEqualCircular = createIsCircular(areObjectsEqual);
    function areRegExpsEqual(a, b) {
      return a.source === b.source && a.flags === b.flags;
    }
    function areSetsEqual(a, b, isEqual, meta) {
      var isValueEqual = a.size === b.size;
      if (!isValueEqual) {
        return false;
      }
      if (!a.size) {
        return true;
      }
      var matchedIndices = {};
      a.forEach(function(aValue, aKey) {
        if (!isValueEqual) {
          return;
        }
        var hasMatch = false;
        var matchIndex = 0;
        b.forEach(function(bValue, bKey) {
          if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
            matchedIndices[matchIndex] = true;
          }
          matchIndex++;
        });
        isValueEqual = hasMatch;
      });
      return isValueEqual;
    }
    var areSetsEqualCircular = createIsCircular(areSetsEqual);
    var DEFAULT_CONFIG = Object.freeze({
      areArraysEqual,
      areDatesEqual,
      areMapsEqual,
      areObjectsEqual,
      areRegExpsEqual,
      areSetsEqual,
      createIsNestedEqual: createDefaultIsNestedEqual
    });
    var DEFAULT_CIRCULAR_CONFIG = Object.freeze({
      areArraysEqual: areArraysEqualCircular,
      areDatesEqual,
      areMapsEqual: areMapsEqualCircular,
      areObjectsEqual: areObjectsEqualCircular,
      areRegExpsEqual,
      areSetsEqual: areSetsEqualCircular,
      createIsNestedEqual: createDefaultIsNestedEqual
    });
    var isDeepEqual = createComparator(DEFAULT_CONFIG);
    function deepEqual(a, b) {
      return isDeepEqual(a, b, void 0);
    }
    var isShallowEqual = createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function() {
      return sameValueZeroEqual;
    } }));
    function shallowEqual(a, b) {
      return isShallowEqual(a, b, void 0);
    }
    var isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);
    function circularDeepEqual(a, b) {
      return isCircularDeepEqual(a, b, /* @__PURE__ */ new WeakMap());
    }
    var isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {
      createIsNestedEqual: function() {
        return sameValueZeroEqual;
      }
    }));
    function circularShallowEqual(a, b) {
      return isCircularShallowEqual(a, b, /* @__PURE__ */ new WeakMap());
    }
    function createCustomEqual(getComparatorOptions) {
      return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));
    }
    function createCustomCircularEqual(getComparatorOptions) {
      var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));
      return function(a, b, meta) {
        if (meta === void 0) {
          meta = /* @__PURE__ */ new WeakMap();
        }
        return comparator(a, b, meta);
      };
    }
    exports.circularDeepEqual = circularDeepEqual;
    exports.circularShallowEqual = circularShallowEqual;
    exports.createCustomCircularEqual = createCustomCircularEqual;
    exports.createCustomEqual = createCustomEqual;
    exports.deepEqual = deepEqual;
    exports.sameValueZeroEqual = sameValueZeroEqual;
    exports.shallowEqual = shallowEqual;
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/simpleCache.js
var require_simpleCache = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/simpleCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoCache = exports.SimpleCache = exports.AutoWeakCache = exports.SimpleWeakCache = void 0;
    var SimpleWeakCache = class {
      constructor(size) {
        this.size = size;
        this.L0 = /* @__PURE__ */ new WeakMap();
        this.L1 = /* @__PURE__ */ new WeakMap();
        this.L2 = /* @__PURE__ */ new WeakMap();
        this.sizeL0 = 0;
      }
      has(key) {
        for (const c of this.caches()) {
          if (c.has(key))
            return true;
        }
        return false;
      }
      get(key) {
        for (const c of this.caches()) {
          const entry = c.get(key);
          if (entry) {
            if (c !== this.L0) {
              this._set(key, entry);
            }
            return entry.v;
          }
        }
        return void 0;
      }
      set(key, value) {
        this._set(key, { v: value });
      }
      _set(key, entry) {
        if (this.L0.has(key)) {
          this.L0.set(key, entry);
          return this;
        }
        if (this.sizeL0 >= this.size) {
          this.rotate();
        }
        this.sizeL0 += 1;
        this.L0.set(key, entry);
      }
      caches() {
        return [this.L0, this.L1, this.L2];
      }
      rotate() {
        this.L2 = this.L1;
        this.L1 = this.L0;
        this.L0 = /* @__PURE__ */ new WeakMap();
        this.sizeL0 = 0;
      }
    };
    exports.SimpleWeakCache = SimpleWeakCache;
    var AutoWeakCache = class extends SimpleWeakCache {
      constructor(factory, size) {
        super(size);
        this.factory = factory;
      }
      get(key) {
        const v = super.get(key);
        if (v !== void 0)
          return v;
        const val = this.factory(key);
        this.set(key, val);
        return val;
      }
    };
    exports.AutoWeakCache = AutoWeakCache;
    var SimpleCache = class {
      constructor(size) {
        this.size = size;
        this.L0 = /* @__PURE__ */ new Map();
        this.L1 = /* @__PURE__ */ new Map();
        this.L2 = /* @__PURE__ */ new Map();
      }
      has(key) {
        for (const c of this.caches()) {
          if (c.has(key))
            return true;
        }
        return false;
      }
      get(key) {
        for (const c of this.caches()) {
          const entry = c.get(key);
          if (entry) {
            if (c !== this.L0) {
              this._set(key, entry);
            }
            return entry.v;
          }
        }
        return void 0;
      }
      set(key, value) {
        this._set(key, { v: value });
      }
      _set(key, entry) {
        if (this.L0.has(key)) {
          this.L0.set(key, entry);
          return this;
        }
        if (this.L0.size >= this.size) {
          this.rotate();
        }
        this.L0.set(key, entry);
      }
      caches() {
        return [this.L0, this.L1, this.L2];
      }
      rotate() {
        this.L2 = this.L1;
        this.L1 = this.L0;
        this.L0 = /* @__PURE__ */ new Map();
      }
    };
    exports.SimpleCache = SimpleCache;
    var AutoCache = class extends SimpleCache {
      constructor(factory, size) {
        super(size);
        this.factory = factory;
      }
      get(key) {
        const v = super.get(key);
        if (v !== void 0)
          return v;
        const val = this.factory(key);
        this.set(key, val);
        return val;
      }
    };
    exports.AutoCache = AutoCache;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionary.js
var require_SpellingDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptions = exports.CompoundWordsMethod = void 0;
    var cspell_trie_lib_1 = require_cjs5();
    Object.defineProperty(exports, "CompoundWordsMethod", { enumerable: true, get: function() {
      return cspell_trie_lib_1.CompoundWordsMethod;
    } });
    exports.defaultOptions = Object.freeze({
      weightMap: void 0
    });
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/clean.js
var require_clean2 = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/clean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clean = void 0;
    function clean2(src) {
      const r = src;
      for (const key of Object.keys(r)) {
        if (r[key] === void 0) {
          delete r[key];
        }
      }
      return r;
    }
    exports.clean = clean2;
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/regexHelper.js
var require_regexHelper = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/regexHelper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeRegEx = void 0;
    function escapeRegEx(s) {
      return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    exports.escapeRegEx = escapeRegEx;
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/repMap.js
var require_repMap = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/repMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.createRepMapper = exports.createMapper = void 0;
    var cspell_trie_lib_1 = require_cjs5();
    var regexHelper_js_1 = require_regexHelper();
    var util_js_1 = require_util8();
    function createMapper(repMap, ignoreCharset) {
      if (!repMap && !ignoreCharset)
        return (a) => a;
      repMap = repMap || [];
      const charsetMap = charsetToRepMapRegEx(ignoreCharset);
      if (charsetMap) {
        repMap = repMap.concat(charsetMap);
      }
      const filteredMap = repMap.filter(([match, _]) => !!match);
      if (!filteredMap.length) {
        return (a) => a;
      }
      const regEx = createMapperRegExp(repMap);
      const values = repMap.filter(([match, _]) => !!match).map(([_, into]) => into);
      function resolve10(m, ...matches) {
        const index = matches.findIndex((a) => !!a);
        return 0 <= index && index < values.length ? values[index] : m;
      }
      return function(s) {
        return s.replace(regEx, resolve10);
      };
    }
    exports.createMapper = createMapper;
    function charsetToRepMapRegEx(charset, replaceWith = "") {
      if (!charset)
        return void 0;
      return charset.split("|").map((chars) => `[${chars.replace(/[\][\\]/g, "\\$&")}]`).map((map) => [map, replaceWith]);
    }
    function charsetToRepMap(charset, replaceWith = "") {
      if (!charset)
        return void 0;
      return charset.split("|").flatMap((chars) => [...(0, cspell_trie_lib_1.expandCharacterSet)(chars)]).map((char) => [char, replaceWith]);
    }
    function expandReplaceMap(repMap) {
      return repMap.flatMap(([from, replaceWith]) => from.split("|").map((w) => [w, replaceWith]));
    }
    function createMapperRegExp(repMap) {
      const filteredMap = repMap.filter(([match, _]) => !!match);
      if (!filteredMap.length) {
        return /$^/;
      }
      const regExStr = filteredMap.map(([from, _]) => from).map((s) => {
        try {
          const r = s.match(/\(/) ? s.replace(/\((?=.*\))/g, "(?:").replace(/\(\?:\?/g, "(?") : s;
          new RegExp(r);
          s = r;
        } catch (err) {
          return (0, regexHelper_js_1.escapeRegEx)(s);
        }
        return s;
      }).map((s) => `(${s})`).join("|");
      const regEx = new RegExp(regExStr, "g");
      return regEx;
    }
    function createRepMapper(repMap, ignoreCharset) {
      if (!repMap && !ignoreCharset)
        return (word) => [word];
      const trie = createTrie(repMap, ignoreCharset);
      return (word) => {
        const edits = calcAllEdits(trie, word);
        return applyEdits(word, edits);
      };
    }
    exports.createRepMapper = createRepMapper;
    function applyEdits(word, edits) {
      if (!edits.length)
        return [word];
      const letterEdits = [];
      for (let i = 0; i < word.length; ++i) {
        letterEdits[i] = { edits: [{ b: i, e: i + 1, r: word[i] }], suffixes: [] };
      }
      letterEdits[word.length] = { edits: [], suffixes: [""] };
      for (const edit of edits) {
        const le = letterEdits[edit.b];
        le.edits.push(edit);
      }
      for (let i = word.length - 1; i >= 0; --i) {
        const le = letterEdits[i];
        const sfx = le.suffixes;
        for (const edit of le.edits) {
          const pfx = edit.r;
          const nSfx = letterEdits[edit.e].suffixes;
          for (const s of nSfx) {
            sfx.push(pfx + s);
          }
        }
      }
      const results = new Set(letterEdits[0].suffixes);
      return [...results];
    }
    function calcAllEdits(root, word) {
      const edits = [];
      function walk(node, b, e) {
        if (node.rep) {
          node.rep.forEach((r) => edits.push({ b, e, r }));
        }
        if (e === word.length || !node.children)
          return;
        const n = node.children[word[e]];
        if (!n)
          return;
        walk(n, b, e + 1);
      }
      for (let i = 0; i < word.length; ++i) {
        walk(root, i, i);
      }
      return edits;
    }
    function createTrie(repMap, ignoreCharset) {
      const combined = [repMap, charsetToRepMap(ignoreCharset)].filter(util_js_1.isDefined).flatMap((a) => a);
      const expanded = expandReplaceMap(combined);
      const trieRoot = /* @__PURE__ */ Object.create(null);
      expanded.forEach(([match, replaceWith]) => addToTrie(trieRoot, match, replaceWith));
      return trieRoot;
    }
    function addToTrie(node, match, replaceWith) {
      while (match) {
        const children = node.children || (node.children = /* @__PURE__ */ Object.create(null));
        const k = match[0];
        const childNode = children[k] || (children[k] = /* @__PURE__ */ Object.create(null));
        node = childNode;
        match = match.slice(1);
      }
      const s = new Set(node.rep || []);
      s.add(replaceWith);
      node.rep = [...s];
    }
    exports.__testing__ = {
      charsetToRepMap: charsetToRepMapRegEx,
      createMapperRegExp,
      createTrie,
      calcAllEdits,
      applyEdits
    };
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/defaults.js
var require_defaults = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isForbiddenIgnoreCaseAndAccents = exports.ignoreCase = void 0;
    exports.ignoreCase = true;
    exports.isForbiddenIgnoreCaseAndAccents = false;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionaryFromTrie.js
var require_SpellingDictionaryFromTrie = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionaryFromTrie.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.createSpellingDictionaryFromTrieFile = exports.SpellingDictionaryFromTrie = void 0;
    var sync_1 = require_sync();
    var cspell_trie_lib_1 = require_cjs5();
    var AutoCache_js_1 = require_AutoCache();
    var clean_js_1 = require_clean2();
    var repMap_js_1 = require_repMap();
    var Defaults = __importStar(require_defaults());
    var SpellingDictionaryMethods_js_1 = require_SpellingDictionaryMethods();
    var findWordOptionsCaseSensitive = Object.freeze({ caseSensitive: true });
    var findWordOptionsNotCaseSensitive = Object.freeze({ caseSensitive: false });
    var SpellingDictionaryFromTrie = class {
      constructor(trie, name, options, source = "from trie", size) {
        this.trie = trie;
        this.name = name;
        this.options = options;
        this.source = source;
        this._size = 0;
        this.knownWords = /* @__PURE__ */ new Set();
        this.unknownWords = /* @__PURE__ */ new Set();
        this.type = "SpellingDictionaryFromTrie";
        this._find = findCache((word, useCompounds, ignoreCase) => this.findAnyForm(word, useCompounds, ignoreCase));
        this._isForbidden = (0, AutoCache_js_1.autoCache)((word) => {
          return this.trie.isForbiddenWord(word);
        });
        this.mapWord = (0, repMap_js_1.createMapper)(options.repMap, options.dictionaryInformation?.ignore);
        this.remapWord = (0, repMap_js_1.createRepMapper)(options.repMap, options.dictionaryInformation?.ignore);
        this.isDictionaryCaseSensitive = options.caseSensitive ?? !trie.isLegacy;
        this.containsNoSuggestWords = options.noSuggest || false;
        this._size = size || 0;
        this.weightMap = options.weightMap || (0, SpellingDictionaryMethods_js_1.createWeightMapFromDictionaryInformation)(options.dictionaryInformation);
      }
      get size() {
        if (!this._size) {
          const i = this.trie.iterate();
          let deeper = true;
          let size = 0;
          for (let r = i.next(); !r.done; r = i.next(deeper)) {
            size += 1;
            deeper = r.value.text.length < 5;
          }
          this._size = size;
        }
        return this._size;
      }
      has(word, hasOptions) {
        const { useCompounds, ignoreCase } = this.resolveOptions(hasOptions);
        const r = this._find(word, useCompounds, ignoreCase);
        return !!r && !r.forbidden && !!r.found;
      }
      find(word, hasOptions) {
        const { useCompounds, ignoreCase } = this.resolveOptions(hasOptions);
        const r = this._find(word, useCompounds, ignoreCase);
        const { forbidden = this.isForbidden(word) } = r || {};
        if (!r && !forbidden)
          return void 0;
        const { found = forbidden ? word : false } = r || {};
        const noSuggest = found !== false && this.containsNoSuggestWords;
        return { found, forbidden, noSuggest };
      }
      resolveOptions(hasOptions) {
        const { useCompounds = this.options.useCompounds, ignoreCase = Defaults.ignoreCase } = (0, SpellingDictionaryMethods_js_1.hasOptionToSearchOption)(hasOptions);
        return { useCompounds, ignoreCase };
      }
      findAnyForm(word, useCompounds, ignoreCase) {
        const outerForms = outerWordForms(word, this.remapWord ? this.remapWord : (word2) => [this.mapWord(word2)]);
        for (const form of outerForms) {
          const r = this._findAnyForm(form, useCompounds, ignoreCase);
          if (r)
            return r;
        }
        return void 0;
      }
      _findAnyForm(mWord, useCompounds, ignoreCase) {
        const opts = ignoreCase ? findWordOptionsNotCaseSensitive : findWordOptionsCaseSensitive;
        const findResult = this.trie.findWord(mWord, opts);
        if (findResult.found !== false) {
          return findResult;
        }
        const forms = (0, SpellingDictionaryMethods_js_1.wordSearchForms)(mWord, this.isDictionaryCaseSensitive, ignoreCase);
        for (const w of forms) {
          const findResult2 = this.trie.findWord(w, opts);
          if (findResult2.found !== false) {
            return findResult2;
          }
        }
        if (useCompounds) {
          const optsUseCompounds = { ...opts, useLegacyWordCompounds: useCompounds };
          for (const w of forms) {
            const findResult2 = this.trie.findWord(w, optsUseCompounds);
            if (findResult2.found !== false) {
              return findResult2;
            }
          }
        }
        return void 0;
      }
      isNoSuggestWord(word, options) {
        return this.containsNoSuggestWords ? this.has(word, options) : false;
      }
      isForbidden(word, _ignoreCaseAndAccents) {
        return this._isForbidden(word);
      }
      suggest(...args) {
        const [word] = args;
        const suggestOptions = (0, SpellingDictionaryMethods_js_1.suggestArgsToSuggestOptions)(args);
        return this._suggest(word, suggestOptions);
      }
      _suggest(word, suggestOptions) {
        const { numSuggestions = SpellingDictionaryMethods_js_1.defaultNumSuggestions, numChanges, includeTies, ignoreCase, timeout } = suggestOptions;
        function filter(_word) {
          return true;
        }
        const collector = (0, cspell_trie_lib_1.suggestionCollector)(word, (0, clean_js_1.clean)({
          numSuggestions,
          filter,
          changeLimit: numChanges,
          includeTies,
          ignoreCase,
          timeout,
          weightMap: this.weightMap
        }));
        this.genSuggestions(collector, suggestOptions);
        return collector.suggestions.map((r) => ({ ...r, word: r.word }));
      }
      genSuggestions(collector, suggestOptions) {
        if (this.options.noSuggest)
          return;
        const _compoundMethod = suggestOptions.compoundMethod ?? (this.options.useCompounds ? cspell_trie_lib_1.CompoundWordsMethod.JOIN_WORDS : cspell_trie_lib_1.CompoundWordsMethod.NONE);
        (0, SpellingDictionaryMethods_js_1.wordSuggestFormsArray)(collector.word).forEach((w) => this.trie.genSuggestions((0, SpellingDictionaryMethods_js_1.impersonateCollector)(collector, w), _compoundMethod));
      }
      getErrors() {
        return [];
      }
    };
    exports.SpellingDictionaryFromTrie = SpellingDictionaryFromTrie;
    SpellingDictionaryFromTrie.cachedWordsLimit = 5e4;
    function createSpellingDictionaryFromTrieFile(data, name, source, options) {
      data = typeof data === "string" ? data.split("\n") : data;
      const trieNode = (0, cspell_trie_lib_1.importTrie)(data);
      const trie = new cspell_trie_lib_1.Trie(trieNode);
      return new SpellingDictionaryFromTrie(trie, name, options, source);
    }
    exports.createSpellingDictionaryFromTrieFile = createSpellingDictionaryFromTrieFile;
    function findCache(fn, size = 2e3) {
      const cache = (0, AutoCache_js_1.createCache01)(size);
      function find(word, useCompounds, ignoreCase) {
        const r = cache.get(word);
        if (r !== void 0) {
          if (r.useCompounds === useCompounds && r.ignoreCase === ignoreCase) {
            return r.findResult;
          }
        }
        const findResult = fn(word, useCompounds, ignoreCase);
        cache.set(word, { useCompounds, ignoreCase, findResult });
        return findResult;
      }
      return find;
    }
    function outerWordForms(word, mapWord) {
      const forms = (0, sync_1.pipe)([word], (0, sync_1.opConcatMap)((word2) => [word2, word2.normalize("NFC"), word2.normalize("NFD")]), (0, sync_1.opConcatMap)((word2) => [word2, ...mapWord(word2)]));
      return new Set(forms);
    }
    exports.__testing__ = { outerWordForms };
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/createSpellingDictionary.js
var require_createSpellingDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/createSpellingDictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFailedToLoadDictionary = exports.createSpellingDictionary = void 0;
    var cspell_trie_lib_1 = require_cjs5();
    var fast_equals_1 = require_fast_equals_cjs();
    var simpleCache_js_1 = require_simpleCache();
    var SpellingDictionary_js_1 = require_SpellingDictionary();
    var SpellingDictionaryFromTrie_js_1 = require_SpellingDictionaryFromTrie();
    var SpellingDictionaryMethods_js_1 = require_SpellingDictionaryMethods();
    var cachedDictionaries = new simpleCache_js_1.AutoWeakCache(_createSpellingDictionary, 64);
    var maxSetSize = 3;
    var cachedParamsByWordList = new simpleCache_js_1.SimpleCache(64);
    function createSpellingDictionary(wordList, name, source, options) {
      const params = [wordList, name, source, options];
      if (!Array.isArray(wordList)) {
        return _createSpellingDictionary(params);
      }
      const cached = cachedParamsByWordList.get(name) || /* @__PURE__ */ new Set();
      for (const cachedParams of cached) {
        if ((0, fast_equals_1.deepEqual)(params, cachedParams)) {
          return cachedDictionaries.get(cachedParams);
        }
      }
      if (cached.size > maxSetSize)
        cached.clear();
      cached.add(params);
      cachedParamsByWordList.set(name, cached);
      return cachedDictionaries.get(params);
    }
    exports.createSpellingDictionary = createSpellingDictionary;
    function _createSpellingDictionary(params) {
      const [wordList, name, source, options] = params;
      const parseOptions = { stripCaseAndAccents: options?.supportNonStrictSearches ?? true };
      const words = (0, cspell_trie_lib_1.parseDictionaryLines)(wordList, parseOptions);
      const trie = (0, cspell_trie_lib_1.buildTrieFast)(words);
      const opts = { ...options || SpellingDictionary_js_1.defaultOptions };
      if (opts.weightMap === void 0 && opts.dictionaryInformation) {
        opts.weightMap = (0, SpellingDictionaryMethods_js_1.createWeightMapFromDictionaryInformation)(opts.dictionaryInformation);
      }
      return new SpellingDictionaryFromTrie_js_1.SpellingDictionaryFromTrie(trie, name, opts, source);
    }
    function createFailedToLoadDictionary(name, source, error2, options) {
      options = options || {};
      return {
        name,
        source,
        type: "error",
        containsNoSuggestWords: false,
        has: () => false,
        find: () => void 0,
        isNoSuggestWord: () => false,
        isForbidden: () => false,
        suggest: () => [],
        mapWord: (a) => a,
        genSuggestions: () => {
          return;
        },
        size: 0,
        options,
        isDictionaryCaseSensitive: false,
        getErrors: () => [error2]
      };
    }
    exports.createFailedToLoadDictionary = createFailedToLoadDictionary;
  }
});

// node_modules/cspell-dictionary/dist/cjs/util/textMappers.js
var require_textMappers = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/util/textMappers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapperRemoveCaseAndAccents = exports.mapperNormalizeNFC = void 0;
    var text_js_1 = require_text3();
    function* mapperNormalizeNFC(words) {
      for (const word of words) {
        yield word.normalize("NFC");
      }
    }
    exports.mapperNormalizeNFC = mapperNormalizeNFC;
    function* mapperRemoveCaseAndAccents(words) {
      for (const word of words) {
        const lc = word.toLowerCase();
        yield lc;
        const woAccents = (0, text_js_1.removeAccents)(lc);
        if (lc !== woAccents)
          yield woAccents;
      }
    }
    exports.mapperRemoveCaseAndAccents = mapperRemoveCaseAndAccents;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/Typos/util.js
var require_util9 = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/Typos/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractIgnoreValues = exports.extractAllSuggestions = exports.createTyposDef = exports.appendToDef = exports.mergeDef = exports.mergeDefEntry = void 0;
    var sync_1 = require_sync();
    function normalizeTyposDefValue(value) {
      if (!value)
        return false;
      if (typeof value === "string")
        return value;
      const unique = [...new Set(value)];
      return unique.length > 1 ? unique : unique.length === 1 ? unique[0] : false;
    }
    function mergeDefEntry(targetDef, key, value) {
      const curValue = targetDef[key];
      if (!curValue) {
        targetDef[key] = normalizeTyposDefValue(value);
        return targetDef;
      }
      if (!value)
        return targetDef;
      const newValue = Array.isArray(curValue) ? curValue : [curValue];
      if (Array.isArray(value)) {
        newValue.push(...value);
      } else {
        newValue.push(value);
      }
      targetDef[key] = normalizeTyposDefValue(newValue);
      return targetDef;
    }
    exports.mergeDefEntry = mergeDefEntry;
    function mergeDef(targetDef, fromDef) {
      for (const key of Object.keys(fromDef)) {
        mergeDefEntry(targetDef, key, fromDef[key]);
      }
      return targetDef;
    }
    exports.mergeDef = mergeDef;
    function appendToDef(def, entry) {
      if (!entry)
        return def;
      if (typeof entry === "string") {
        if (!def[entry]) {
          def[entry] = false;
        }
        return def;
      }
      if (Array.isArray(entry)) {
        const [key, ...sugs] = entry.map((s2) => s2.trim());
        if (!key)
          return def;
        const s = sugs.map((s2) => s2.trim()).filter((s2) => !!s2);
        return mergeDefEntry(def, key, s);
      }
      return mergeDef(def, entry);
    }
    exports.appendToDef = appendToDef;
    function createTyposDef(entries) {
      const def = /* @__PURE__ */ Object.create(null);
      if (!entries)
        return def;
      for (const [key, value] of entries) {
        def[key] = isDefined2(value) ? value : false;
      }
      return def;
    }
    exports.createTyposDef = createTyposDef;
    function extractAllSuggestions(typosDef) {
      const allSugs = (0, sync_1.pipe)(Object.values(typosDef), (0, sync_1.opFilter)(hasSuggestions), (0, sync_1.opConcatMap)((v) => Array.isArray(v) ? v : [v]));
      return new Set(allSugs);
    }
    exports.extractAllSuggestions = extractAllSuggestions;
    function extractIgnoreValues(typosDef, ignorePrefix) {
      const pfxLen = ignorePrefix.length;
      return new Set(Object.keys(typosDef).filter((k) => k.startsWith(ignorePrefix)).map((k) => k.slice(pfxLen)));
    }
    exports.extractIgnoreValues = extractIgnoreValues;
    function isDefined2(v) {
      return v !== void 0 && v !== null;
    }
    function isString2(v) {
      return typeof v === "string";
    }
    function isArray(v) {
      return Array.isArray(v);
    }
    function hasSuggestions(v) {
      return isString2(v) || isArray(v);
    }
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/Typos/typosParser.js
var require_typosParser = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/Typos/typosParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTyposFile = exports.parseTyposLine = exports.processEntriesToTyposDef = exports.sanitizeIntoTypoDef = exports.createTyposDefFromEntries = void 0;
    var assert_1 = __importDefault(require("assert"));
    var util_js_1 = require_util9();
    function assertString(v) {
      (0, assert_1.default)(typeof v === "string", "A string was expected.");
      return true;
    }
    var suggestionsSeparator = /[,]/;
    var typoSuggestionsSeparator = /:|->/;
    var typoEntrySeparator = /[\n;]/;
    var inlineComment = /#.*/gm;
    function createTyposDefFromEntries(entries) {
      const def = /* @__PURE__ */ Object.create(null);
      for (const entry of entries) {
        (0, util_js_1.appendToDef)(def, entry);
      }
      return def;
    }
    exports.createTyposDefFromEntries = createTyposDefFromEntries;
    function normalize(s) {
      return s.normalize();
    }
    function trimAndFilter(lines) {
      return lines.map((s) => s.trim()).filter((s) => !!s).map(normalize);
    }
    function cleanSugs(rawSugs) {
      const sugs = trimAndFilter(rawSugs);
      return sugs.length === 1 ? sugs[0] : sugs.length ? sugs : false;
    }
    function splitSuggestionsValue(value) {
      return cleanSugs(value.split(suggestionsSeparator));
    }
    function sanitizeIntoTypoDef(dirtyDef) {
      if (!dirtyDef || typeof dirtyDef !== "object")
        return void 0;
      const def = (0, util_js_1.createTyposDef)();
      for (const [rawKey, value] of Object.entries(dirtyDef)) {
        const key = normalize(rawKey.trim());
        if (!key)
          continue;
        if (typeof value === "string") {
          def[key] = splitSuggestionsValue(value);
          continue;
        }
        if (Array.isArray(value)) {
          const sugs = cleanSugs(value.filter(assertString));
          def[key] = sugs;
          continue;
        }
        (0, assert_1.default)(value === false, "Unexpected suggestion type.");
        def[key] = false;
      }
      return def;
    }
    exports.sanitizeIntoTypoDef = sanitizeIntoTypoDef;
    function processEntriesToTyposDef(entries) {
      const def = isIterable2(entries) ? reduceToTyposDef(entries) : entries;
      const result = sanitizeIntoTypoDef(def);
      (0, assert_1.default)(result);
      return result;
    }
    exports.processEntriesToTyposDef = processEntriesToTyposDef;
    function reduceToTyposDef(entries) {
      const def = (0, util_js_1.createTyposDef)();
      for (const entry of entries) {
        (0, util_js_1.appendToDef)(def, parseTyposLine(entry));
      }
      return def;
    }
    function parseTyposLine(line) {
      if (!line)
        return void 0;
      if (typeof line === "string") {
        const def = (0, util_js_1.createTyposDef)();
        for (const subEntry of splitIntoLines(line)) {
          const [left, right] = splitEntry(subEntry);
          const typo = left.trim();
          if (!right)
            return typo;
          const sugs = splitSuggestionsValue(right);
          def[typo] = sugs;
        }
        return def;
      }
      if (Array.isArray(line)) {
        const [key, ...sugs] = line.filter(assertString).map((s) => s.trim());
        if (!key)
          return void 0;
        return [key, ...sugs];
      }
      return sanitizeIntoTypoDef(line);
    }
    exports.parseTyposLine = parseTyposLine;
    function splitIntoLines(content) {
      return trimAndFilter(normalize(content).split(typoEntrySeparator));
    }
    function splitEntry(line) {
      return line.split(typoSuggestionsSeparator, 2);
    }
    function parseTyposFile(content) {
      const lines = splitIntoLines(content.replace(inlineComment, ""));
      return reduceToTyposDef(lines);
    }
    exports.parseTyposFile = parseTyposFile;
    function isIterable2(v) {
      return Symbol.iterator in v;
    }
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/Typos/index.js
var require_Typos = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/Typos/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractAllSuggestions = exports.createTyposDef = exports.processEntriesToTyposDef = exports.parseTyposLine = exports.parseTyposFile = void 0;
    var typosParser_js_1 = require_typosParser();
    Object.defineProperty(exports, "parseTyposFile", { enumerable: true, get: function() {
      return typosParser_js_1.parseTyposFile;
    } });
    Object.defineProperty(exports, "parseTyposLine", { enumerable: true, get: function() {
      return typosParser_js_1.parseTyposLine;
    } });
    Object.defineProperty(exports, "processEntriesToTyposDef", { enumerable: true, get: function() {
      return typosParser_js_1.processEntriesToTyposDef;
    } });
    var util_js_1 = require_util9();
    Object.defineProperty(exports, "createTyposDef", { enumerable: true, get: function() {
      return util_js_1.createTyposDef;
    } });
    Object.defineProperty(exports, "extractAllSuggestions", { enumerable: true, get: function() {
      return util_js_1.extractAllSuggestions;
    } });
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/TyposDictionary.js
var require_TyposDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/TyposDictionary.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTyposDictionary = void 0;
    var sync_1 = require_sync();
    var AutoResolve_js_1 = require_AutoResolve2();
    var textMappers_js_1 = require_textMappers();
    var defaults = __importStar(require_defaults());
    var index_js_1 = require_Typos();
    var util_js_1 = require_util9();
    var TyposDictionaryImpl = class {
      constructor(name, source, typosDef, ignoreList) {
        this.name = name;
        this.source = source;
        this.typosDef = typosDef;
        this.options = {};
        this.type = "typos";
        this.isDictionaryCaseSensitive = true;
        this.size = Object.keys(typosDef).length;
        this.explicitIgnoreWords = (0, util_js_1.extractIgnoreValues)(typosDef, "!");
        this.suggestions = (0, util_js_1.extractAllSuggestions)(typosDef);
        this.ignoreWords = new Set((0, sync_1.pipe)(this.explicitIgnoreWords, (0, sync_1.opAppend)(ignoreList || [])));
        this.suggestionsLower = new Set((0, sync_1.pipe)(this.suggestions, textMappers_js_1.mapperRemoveCaseAndAccents));
        this.containsNoSuggestWords = this.ignoreWords.size > 0;
      }
      /**
       * A Forbidden word list does not "have" valid words.
       * Therefore it always returns false.
       * @param _word - the word
       * @param _options - options
       * @returns always false
       */
      has(_word, _options) {
        return false;
      }
      /** A more detailed search for a word, might take longer than `has` */
      find(word, options) {
        const result = this._findForms(word, options?.ignoreCase ?? defaults.ignoreCase);
        if (result === false)
          return void 0;
        const { found, ignore } = result;
        return { found, forbidden: !ignore, noSuggest: ignore };
      }
      _findForms(word, ignoreCaseAndAccents) {
        const lcWord = word.toLowerCase();
        if (this.ignoreWords.has(word)) {
          return { found: word, ignore: true };
        }
        if (this.suggestions.has(word)) {
          return false;
        }
        if (ignoreCaseAndAccents) {
          if (this.suggestionsLower.has(lcWord)) {
            return false;
          }
          if (this.ignoreWords.has(lcWord)) {
            return { found: lcWord, ignore: true };
          }
        }
        if (word in this.typosDef)
          return { found: word, ignore: false };
        if (lcWord in this.typosDef)
          return { found: lcWord, ignore: false };
        return false;
      }
      isForbidden(word, ignoreCaseAndAccents = defaults.isForbiddenIgnoreCaseAndAccents) {
        const found = this._findForms(word, ignoreCaseAndAccents);
        return found !== false && !found.ignore;
      }
      isNoSuggestWord(word, options) {
        const result = this.find(word, options);
        return result?.noSuggest ?? false;
      }
      /**
       * Determine if the word can appear in a list of suggestions.
       * @param word - word
       * @param ignoreCaseAndAccents - ignore case.
       * @returns true if a word is suggested, otherwise false.
       */
      isSuggestedWord(word, ignoreCaseAndAccents = defaults.isForbiddenIgnoreCaseAndAccents) {
        if (this.suggestions.has(word))
          return true;
        const lcWord = word.toLowerCase();
        return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
      }
      suggest(word) {
        return this.getPreferredSuggestions(word);
      }
      _suggest(word) {
        if (this.ignoreWords.has(word))
          return [];
        if (!(word in this.typosDef))
          return void 0;
        const sug = this.typosDef[word];
        const isPreferred = true;
        if (!sug)
          return [];
        if (typeof sug === "string") {
          return [
            {
              word: sug,
              cost: 1,
              isPreferred
            }
          ];
        }
        return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
      }
      genSuggestions(collector) {
        const sugs = this.suggest(collector.word);
        sugs.forEach((result) => collector.add(result));
      }
      getPreferredSuggestions(word) {
        return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
      }
      mapWord(word) {
        return word;
      }
      getErrors() {
        return [];
      }
    };
    var createCache2 = (0, AutoResolve_js_1.createAutoResolveWeakCache)();
    function createTyposDictionary(entries, name, source) {
      return createCache2.get(entries, () => {
        const def = (0, index_js_1.processEntriesToTyposDef)(entries);
        return new TyposDictionaryImpl(name, source, def);
      });
    }
    exports.createTyposDictionary = createTyposDictionary;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/FlagWordsDictionary.js
var require_FlagWordsDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/FlagWordsDictionary.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFlagWordsDictionary = void 0;
    var sync_1 = require_sync();
    var cspell_trie_lib_1 = require_cjs5();
    var AutoResolve_js_1 = require_AutoResolve2();
    var Defaults = __importStar(require_defaults());
    var SpellingDictionary_js_1 = require_SpellingDictionary();
    var SpellingDictionaryFromTrie_js_1 = require_SpellingDictionaryFromTrie();
    var SpellingDictionaryMethods_js_1 = require_SpellingDictionaryMethods();
    var TyposDictionary_js_1 = require_TyposDictionary();
    var FlagWordsDictionaryTrie = class extends SpellingDictionaryFromTrie_js_1.SpellingDictionaryFromTrie {
      constructor(trie, name, source) {
        super(trie, name, SpellingDictionary_js_1.defaultOptions, source);
        this.name = name;
        this.source = source;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.isDictionaryCaseSensitive = true;
      }
      /**
       * A Forbidden word list does not "have" valid words.
       * Therefore it always returns false.
       * @param _word - the word
       * @param _options - options
       * @returns always false
       */
      has(_word, _options) {
        return false;
      }
      find(word, hasOptions) {
        const f = super.find(word, hasOptions);
        if (!f || !f.forbidden)
          return void 0;
        return f;
      }
      suggest() {
        return [];
      }
      genSuggestions() {
        return;
      }
    };
    var FlagWordsDictionary = class {
      constructor(name, source, dictTypos, dictTrie) {
        this.name = name;
        this.source = source;
        this.dictTypos = dictTypos;
        this.dictTrie = dictTrie;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.type = "flag-words";
        this.isDictionaryCaseSensitive = true;
      }
      /**
       * A Forbidden word list does not "have" valid words.
       * Therefore it always returns false.
       * @param word - the word
       * @param options - options
       * @returns always false
       */
      has(word, options) {
        return this.dictTypos.has(word, options) || this.dictTrie?.has(word, options) || false;
      }
      /** A more detailed search for a word, might take longer than `has` */
      find(word, options) {
        const findTypos = this.dictTypos.find(word, options);
        if (findTypos)
          return findTypos;
        const ignoreCase = options?.ignoreCase ?? Defaults.ignoreCase;
        if (this.dictTypos.isSuggestedWord(word, ignoreCase))
          return void 0;
        return this.dictTrie?.find(word, options);
      }
      isForbidden(word, ignoreCaseAndAccents = Defaults.isForbiddenIgnoreCaseAndAccents) {
        const findResult = this.find(word, { ignoreCase: ignoreCaseAndAccents });
        return findResult?.forbidden || false;
      }
      isNoSuggestWord(word, options) {
        return this.dictTrie?.isNoSuggestWord(word, options) || this.dictTypos.isNoSuggestWord(word, options);
      }
      suggest(...args) {
        const [word] = args;
        const suggestOptions = (0, SpellingDictionaryMethods_js_1.suggestArgsToSuggestOptions)(args);
        return this.dictTypos.suggest(word, suggestOptions);
      }
      getPreferredSuggestions(word) {
        return this.dictTypos.getPreferredSuggestions(word);
      }
      genSuggestions() {
        return;
      }
      mapWord(word) {
        return word;
      }
      get size() {
        return this.dictTypos.size + (this.dictTrie?.size || 0);
      }
      getErrors() {
        return [];
      }
    };
    var createCache2 = (0, AutoResolve_js_1.createAutoResolveWeakCache)();
    function createFlagWordsDictionary(wordList, name, source) {
      return createCache2.get(wordList, () => {
        const testSpecialCharacters = /[~*+]/;
        const { t: specialWords, f: typoWords } = bisect((0, cspell_trie_lib_1.parseDictionaryLines)(wordList, { stripCaseAndAccents: false }), (line) => testSpecialCharacters.test(line));
        const trieDict = specialWords.size ? buildTrieDict(specialWords, name, source) : void 0;
        const typosDict = (0, TyposDictionary_js_1.createTyposDictionary)(typoWords, name, source);
        if (!trieDict)
          return typosDict;
        return new FlagWordsDictionary(name, source, typosDict, trieDict);
      });
    }
    exports.createFlagWordsDictionary = createFlagWordsDictionary;
    var regExpCleanIgnore = /^(!!)+/;
    function buildTrieDict(words, name, source) {
      const trie = (0, cspell_trie_lib_1.buildTrieFast)((0, sync_1.pipe)(words, (0, sync_1.opMap)((w) => "!" + w), (0, sync_1.opMap)((w) => w.replace(regExpCleanIgnore, ""))));
      return new FlagWordsDictionaryTrie(trie, name, source);
    }
    function bisect(values, predicate) {
      const t = /* @__PURE__ */ new Set();
      const f = /* @__PURE__ */ new Set();
      for (const v of values) {
        if (predicate(v)) {
          t.add(v);
        } else {
          f.add(v);
        }
      }
      return { t, f };
    }
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/IgnoreWordsDictionary.js
var require_IgnoreWordsDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/IgnoreWordsDictionary.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIgnoreWordsDictionary = void 0;
    var sync_1 = require_sync();
    var cspell_trie_lib_1 = require_cjs5();
    var AutoResolve_js_1 = require_AutoResolve2();
    var createSpellingDictionary_js_1 = require_createSpellingDictionary();
    var Defaults = __importStar(require_defaults());
    var NormalizeForm = "NFC";
    var IgnoreWordsDictionary = class {
      constructor(name, source, words) {
        this.name = name;
        this.source = source;
        this.containsNoSuggestWords = true;
        this.options = {};
        this.type = "ignore";
        this.isDictionaryCaseSensitive = true;
        this.dict = new Set(words);
        this.dictNonStrict = new Set((0, sync_1.pipe)(this.dict, (0, sync_1.opFilter)((w) => w.startsWith("~")), (0, sync_1.opMap)((w) => w.slice(1))));
      }
      /**
       * A Forbidden word list does not "have" valid words.
       * Therefore it always returns false.
       * @param _word - the word
       * @param _options - options
       * @returns always false
       */
      has(word, options) {
        const nWord = word.normalize(NormalizeForm);
        if (this.dict.has(nWord))
          return true;
        const lcWord = nWord.toLowerCase();
        if (this.dict.has(lcWord))
          return true;
        const ignoreCase = options?.ignoreCase ?? Defaults.ignoreCase;
        return ignoreCase && (this.dictNonStrict.has(nWord) || this.dictNonStrict.has(lcWord));
      }
      /** A more detailed search for a word, might take longer than `has` */
      find(word, options) {
        const nWord = word.normalize(NormalizeForm);
        if (this.dict.has(nWord))
          return { found: nWord, forbidden: false, noSuggest: true };
        const lcWord = nWord.toLowerCase();
        if (this.dict.has(lcWord))
          return { found: lcWord, forbidden: false, noSuggest: true };
        const ignoreCase = options?.ignoreCase ?? Defaults.ignoreCase;
        if (!ignoreCase)
          return void 0;
        if (this.dictNonStrict.has(nWord))
          return { found: nWord, forbidden: false, noSuggest: true };
        return this.dictNonStrict.has(lcWord) && { found: lcWord, forbidden: false, noSuggest: true } || void 0;
      }
      isForbidden(_word, _ignoreCase) {
        return false;
      }
      isNoSuggestWord(word, options) {
        return this.has(word, options);
      }
      suggest() {
        return [];
      }
      genSuggestions() {
        return;
      }
      mapWord(word) {
        return word;
      }
      get size() {
        return this.dict.size;
      }
      getErrors() {
        return [];
      }
    };
    var createCache2 = (0, AutoResolve_js_1.createAutoResolveWeakCache)();
    function createIgnoreWordsDictionary(wordList, name, source) {
      return createCache2.get(wordList, () => {
        const testSpecialCharacters = /[*+]/;
        const words = [...(0, cspell_trie_lib_1.parseDictionaryLines)(wordList, { stripCaseAndAccents: true })].map((w) => w.normalize(NormalizeForm));
        const hasSpecial = words.findIndex((word) => testSpecialCharacters.test(word)) >= 0;
        if (hasSpecial) {
          return (0, createSpellingDictionary_js_1.createSpellingDictionary)(words, name, source, {
            caseSensitive: true,
            noSuggest: true,
            weightMap: void 0,
            supportNonStrictSearches: true
          });
        }
        return new IgnoreWordsDictionary(name, source, words);
      });
    }
    exports.createIgnoreWordsDictionary = createIgnoreWordsDictionary;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionaryCollection.js
var require_SpellingDictionaryCollection = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SpellingDictionaryCollection.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.isSpellingDictionaryCollection = exports.createCollection = void 0;
    var cspell_trie_lib_1 = require_cjs5();
    var gensequence_1 = require_dist2();
    var util_js_1 = require_util8();
    var Defaults = __importStar(require_defaults());
    var SpellingDictionary_js_1 = require_SpellingDictionary();
    var SpellingDictionaryMethods_js_1 = require_SpellingDictionaryMethods();
    function identityString(w) {
      return w;
    }
    var SpellingDictionaryCollectionImpl = class {
      constructor(dictionaries, name, source) {
        this.dictionaries = dictionaries;
        this.name = name;
        this.options = { weightMap: void 0 };
        this.mapWord = identityString;
        this.type = "SpellingDictionaryCollection";
        this._isNoSuggestWord = (word, options) => {
          if (!this.containsNoSuggestWords)
            return false;
          return !!isNoSuggestWordInAnyDictionary(this.dictionaries, word, options || {});
        };
        this.dictionaries = this.dictionaries.sort((a, b) => b.size - a.size);
        this.source = source || dictionaries.map((d) => d.name).join(", ");
        this.isDictionaryCaseSensitive = this.dictionaries.reduce((a, b) => a || b.isDictionaryCaseSensitive, false);
        this.containsNoSuggestWords = this.dictionaries.reduce((a, b) => a || b.containsNoSuggestWords, false);
      }
      has(word, hasOptions) {
        const options = (0, SpellingDictionaryMethods_js_1.hasOptionToSearchOption)(hasOptions);
        return !!isWordInAnyDictionary(this.dictionaries, word, options) && !this.isForbidden(word);
      }
      find(word, hasOptions) {
        const options = (0, SpellingDictionaryMethods_js_1.hasOptionToSearchOption)(hasOptions);
        return findInAnyDictionary(this.dictionaries, word, options);
      }
      isNoSuggestWord(word, options) {
        return this._isNoSuggestWord(word, options);
      }
      isForbidden(word, ignoreCaseAndAccents) {
        const ignoreCase = ignoreCaseAndAccents ?? Defaults.isForbiddenIgnoreCaseAndAccents;
        return !!this._isForbiddenInDict(word, ignoreCase) && !this.isNoSuggestWord(word, { ignoreCase });
      }
      suggest(...args) {
        const [word] = args;
        const suggestOptions = (0, SpellingDictionaryMethods_js_1.suggestArgsToSuggestOptions)(args);
        return this._suggest(word, suggestOptions);
      }
      _suggest(word, suggestOptions) {
        const { numSuggestions = SpellingDictionaryMethods_js_1.defaultNumSuggestions, numChanges, ignoreCase, includeTies, timeout } = suggestOptions;
        const prefixNoCase = cspell_trie_lib_1.CASE_INSENSITIVE_PREFIX;
        const filter = (word2, _cost) => {
          return (ignoreCase || word2[0] !== prefixNoCase) && !this.isForbidden(word2) && !this.isNoSuggestWord(word2, suggestOptions);
        };
        const collectorOptions = {
          numSuggestions,
          filter,
          changeLimit: numChanges,
          includeTies,
          ignoreCase,
          timeout
        };
        const collector = (0, SpellingDictionaryMethods_js_1.suggestionCollector)(word, collectorOptions);
        this.genSuggestions(collector, suggestOptions);
        return collector.suggestions;
      }
      get size() {
        return this.dictionaries.reduce((a, b) => a + b.size, 0);
      }
      getPreferredSuggestions(word) {
        const sugs = this.dictionaries.flatMap((dict) => dict.getPreferredSuggestions?.(word)).filter(util_js_1.isDefined);
        if (sugs.length <= 1)
          return sugs;
        const unique = /* @__PURE__ */ new Set();
        return sugs.filter((sug) => {
          if (unique.has(sug.word))
            return false;
          unique.add(sug.word);
          return true;
        });
      }
      genSuggestions(collector, suggestOptions) {
        const _suggestOptions = { ...suggestOptions };
        const { compoundMethod = SpellingDictionary_js_1.CompoundWordsMethod.SEPARATE_WORDS } = suggestOptions;
        _suggestOptions.compoundMethod = this.options.useCompounds ? SpellingDictionary_js_1.CompoundWordsMethod.JOIN_WORDS : compoundMethod;
        this.dictionaries.forEach((dict) => dict.genSuggestions(collector, _suggestOptions));
      }
      getErrors() {
        return this.dictionaries.reduce((errors, dict) => errors.concat(dict.getErrors?.() || []), []);
      }
      _isForbiddenInDict(word, ignoreCase) {
        return isWordForbiddenInAnyDictionary(this.dictionaries, word, ignoreCase);
      }
    };
    function createCollection(dictionaries, name, source) {
      return new SpellingDictionaryCollectionImpl(dictionaries, name, source);
    }
    exports.createCollection = createCollection;
    function isWordInAnyDictionary(dicts, word, options) {
      return (0, gensequence_1.genSequence)(dicts).first((dict) => dict.has(word, options));
    }
    function findInAnyDictionary(dicts, word, options) {
      const found = dicts.map((dict) => dict.find(word, options)).filter(util_js_1.isDefined);
      if (!found.length)
        return void 0;
      return found.reduce((a, b) => ({
        found: a.forbidden ? a.found : b.forbidden ? b.found : a.found || b.found,
        forbidden: a.forbidden || b.forbidden,
        noSuggest: a.noSuggest || b.noSuggest
      }));
    }
    function isNoSuggestWordInAnyDictionary(dicts, word, options) {
      return (0, gensequence_1.genSequence)(dicts).first((dict) => dict.isNoSuggestWord(word, options));
    }
    function isWordForbiddenInAnyDictionary(dicts, word, ignoreCase) {
      return (0, gensequence_1.genSequence)(dicts).first((dict) => dict.isForbidden(word, ignoreCase));
    }
    function isSpellingDictionaryCollection(dict) {
      return dict instanceof SpellingDictionaryCollectionImpl;
    }
    exports.isSpellingDictionaryCollection = isSpellingDictionaryCollection;
    exports.__testing__ = {
      isWordInAnyDictionary,
      isWordForbiddenInAnyDictionary
    };
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SuggestDictionary.js
var require_SuggestDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/SuggestDictionary.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSuggestDictionary = void 0;
    var sync_1 = require_sync();
    var AutoResolve_js_1 = require_AutoResolve2();
    var textMappers_js_1 = require_textMappers();
    var defaults = __importStar(require_defaults());
    var index_js_1 = require_Typos();
    var util_js_1 = require_util9();
    var SuggestDictionaryImpl = class {
      constructor(name, source, typosDef) {
        this.name = name;
        this.source = source;
        this.typosDef = typosDef;
        this.containsNoSuggestWords = false;
        this.options = {};
        this.type = "suggest";
        this.isDictionaryCaseSensitive = true;
        this.size = Object.keys(typosDef).length;
        this.suggestions = (0, util_js_1.extractAllSuggestions)(typosDef);
        this.suggestionsLower = new Set((0, sync_1.pipe)(this.suggestions, textMappers_js_1.mapperRemoveCaseAndAccents));
      }
      /**
       * A Forbidden word list does not "have" valid words.
       * Therefore it always returns false.
       * @param _word - the word
       * @param _options - options
       * @returns always false
       */
      has(_word, _options) {
        return false;
      }
      /** A more detailed search for a word, might take longer than `has` */
      find(_word, _options) {
        return void 0;
      }
      isForbidden(_word, _ignoreCaseAndAccents) {
        return false;
      }
      isNoSuggestWord(_word, _options) {
        return false;
      }
      /**
       * Determine if the word can appear in a list of suggestions.
       * @param word - word
       * @param ignoreCaseAndAccents - ignore case.
       * @returns true if a word is suggested, otherwise false.
       */
      isSuggestedWord(word, ignoreCaseAndAccents = defaults.isForbiddenIgnoreCaseAndAccents) {
        if (this.suggestions.has(word))
          return true;
        const lcWord = word.toLowerCase();
        return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
      }
      suggest(word) {
        return this.getPreferredSuggestions(word);
      }
      _suggest(word) {
        if (!(word in this.typosDef))
          return void 0;
        const sug = this.typosDef[word];
        const isPreferred = true;
        if (!sug)
          return [];
        if (typeof sug === "string") {
          return [
            {
              word: sug,
              cost: 1,
              isPreferred
            }
          ];
        }
        return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
      }
      getPreferredSuggestions(word) {
        return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
      }
      genSuggestions(collector) {
        const sugs = this.suggest(collector.word);
        sugs.forEach((result) => collector.add(result));
      }
      mapWord(word) {
        return word;
      }
      getErrors() {
        return [];
      }
    };
    var createCache2 = (0, AutoResolve_js_1.createAutoResolveWeakCache)();
    function createSuggestDictionary(entries, name, source) {
      return createCache2.get(entries, () => {
        const def = (0, index_js_1.processEntriesToTyposDef)(entries);
        return new SuggestDictionaryImpl(name, source, def);
      });
    }
    exports.createSuggestDictionary = createSuggestDictionary;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/createInlineSpellingDictionary.js
var require_createInlineSpellingDictionary = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/createInlineSpellingDictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInlineSpellingDictionary = void 0;
    var AutoResolve_js_1 = require_AutoResolve2();
    var util_js_1 = require_util8();
    var createSpellingDictionary_js_1 = require_createSpellingDictionary();
    var FlagWordsDictionary_js_1 = require_FlagWordsDictionary();
    var IgnoreWordsDictionary_js_1 = require_IgnoreWordsDictionary();
    var SpellingDictionaryCollection_js_1 = require_SpellingDictionaryCollection();
    var SuggestDictionary_js_1 = require_SuggestDictionary();
    var cache = (0, AutoResolve_js_1.createAutoResolveWeakCache)();
    function createInlineSpellingDictionary(inlineDict, source) {
      return cache.get(inlineDict, () => {
        const { words, flagWords, ignoreWords, suggestWords, name } = inlineDict;
        const dictSources = [
          words && (0, createSpellingDictionary_js_1.createSpellingDictionary)(words, name + "-words", source, inlineDict),
          flagWords && (0, FlagWordsDictionary_js_1.createFlagWordsDictionary)(flagWords, name + "-flag-words", source),
          ignoreWords && (0, IgnoreWordsDictionary_js_1.createIgnoreWordsDictionary)(ignoreWords, name + "-ignore-words", source),
          suggestWords && (0, SuggestDictionary_js_1.createSuggestDictionary)(suggestWords, name + "-suggest", source)
        ].filter(util_js_1.isDefined);
        return (0, SpellingDictionaryCollection_js_1.createCollection)(dictSources, name, source);
      });
    }
    exports.createInlineSpellingDictionary = createInlineSpellingDictionary;
  }
});

// node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/index.js
var require_SpellingDictionary2 = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/SpellingDictionary/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTyposDictionary = exports.createSuggestDictionary = exports.createSpellingDictionaryFromTrieFile = exports.createCollection = exports.createIgnoreWordsDictionary = exports.createForbiddenWordsDictionary = exports.createFlagWordsDictionary = exports.createSpellingDictionary = exports.createFailedToLoadDictionary = exports.createInlineSpellingDictionary = exports.createCachingDictionary = void 0;
    var CachingDictionary_js_1 = require_CachingDictionary();
    Object.defineProperty(exports, "createCachingDictionary", { enumerable: true, get: function() {
      return CachingDictionary_js_1.createCachingDictionary;
    } });
    var createInlineSpellingDictionary_js_1 = require_createInlineSpellingDictionary();
    Object.defineProperty(exports, "createInlineSpellingDictionary", { enumerable: true, get: function() {
      return createInlineSpellingDictionary_js_1.createInlineSpellingDictionary;
    } });
    var createSpellingDictionary_js_1 = require_createSpellingDictionary();
    Object.defineProperty(exports, "createFailedToLoadDictionary", { enumerable: true, get: function() {
      return createSpellingDictionary_js_1.createFailedToLoadDictionary;
    } });
    Object.defineProperty(exports, "createSpellingDictionary", { enumerable: true, get: function() {
      return createSpellingDictionary_js_1.createSpellingDictionary;
    } });
    var FlagWordsDictionary_js_1 = require_FlagWordsDictionary();
    Object.defineProperty(exports, "createFlagWordsDictionary", { enumerable: true, get: function() {
      return FlagWordsDictionary_js_1.createFlagWordsDictionary;
    } });
    Object.defineProperty(exports, "createForbiddenWordsDictionary", { enumerable: true, get: function() {
      return FlagWordsDictionary_js_1.createFlagWordsDictionary;
    } });
    var IgnoreWordsDictionary_js_1 = require_IgnoreWordsDictionary();
    Object.defineProperty(exports, "createIgnoreWordsDictionary", { enumerable: true, get: function() {
      return IgnoreWordsDictionary_js_1.createIgnoreWordsDictionary;
    } });
    var SpellingDictionaryCollection_js_1 = require_SpellingDictionaryCollection();
    Object.defineProperty(exports, "createCollection", { enumerable: true, get: function() {
      return SpellingDictionaryCollection_js_1.createCollection;
    } });
    var SpellingDictionaryFromTrie_js_1 = require_SpellingDictionaryFromTrie();
    Object.defineProperty(exports, "createSpellingDictionaryFromTrieFile", { enumerable: true, get: function() {
      return SpellingDictionaryFromTrie_js_1.createSpellingDictionaryFromTrieFile;
    } });
    var SuggestDictionary_js_1 = require_SuggestDictionary();
    Object.defineProperty(exports, "createSuggestDictionary", { enumerable: true, get: function() {
      return SuggestDictionary_js_1.createSuggestDictionary;
    } });
    var TyposDictionary_js_1 = require_TyposDictionary();
    Object.defineProperty(exports, "createTyposDictionary", { enumerable: true, get: function() {
      return TyposDictionary_js_1.createTyposDictionary;
    } });
  }
});

// node_modules/cspell-dictionary/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/cspell-dictionary/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSuggestDictionary = exports.createSpellingDictionaryFromTrieFile = exports.createSpellingDictionary = exports.createInlineSpellingDictionary = exports.createIgnoreWordsDictionary = exports.createForbiddenWordsDictionary = exports.createFlagWordsDictionary = exports.createFailedToLoadDictionary = exports.createCollection = exports.createCachingDictionary = void 0;
    var index_js_1 = require_SpellingDictionary2();
    Object.defineProperty(exports, "createCachingDictionary", { enumerable: true, get: function() {
      return index_js_1.createCachingDictionary;
    } });
    Object.defineProperty(exports, "createCollection", { enumerable: true, get: function() {
      return index_js_1.createCollection;
    } });
    Object.defineProperty(exports, "createFailedToLoadDictionary", { enumerable: true, get: function() {
      return index_js_1.createFailedToLoadDictionary;
    } });
    Object.defineProperty(exports, "createFlagWordsDictionary", { enumerable: true, get: function() {
      return index_js_1.createFlagWordsDictionary;
    } });
    Object.defineProperty(exports, "createForbiddenWordsDictionary", { enumerable: true, get: function() {
      return index_js_1.createForbiddenWordsDictionary;
    } });
    Object.defineProperty(exports, "createIgnoreWordsDictionary", { enumerable: true, get: function() {
      return index_js_1.createIgnoreWordsDictionary;
    } });
    Object.defineProperty(exports, "createInlineSpellingDictionary", { enumerable: true, get: function() {
      return index_js_1.createInlineSpellingDictionary;
    } });
    Object.defineProperty(exports, "createSpellingDictionary", { enumerable: true, get: function() {
      return index_js_1.createSpellingDictionary;
    } });
    Object.defineProperty(exports, "createSpellingDictionaryFromTrieFile", { enumerable: true, get: function() {
      return index_js_1.createSpellingDictionaryFromTrieFile;
    } });
    Object.defineProperty(exports, "createSuggestDictionary", { enumerable: true, get: function() {
      return index_js_1.createSuggestDictionary;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/static.js
var require_static = __commonJS({
  "node_modules/cspell-lib/dist/cjs/static.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCSpellIO = void 0;
    var cspell_io_1 = require_cjs3();
    var cspellIO = new cspell_io_1.CSpellIONode();
    function getCSpellIO() {
      return cspellIO;
    }
    exports.getCSpellIO = getCSpellIO;
  }
});

// node_modules/@cspell/strong-weak-map/dist/cjs/StrongWeakMap.js
var require_StrongWeakMap = __commonJS({
  "node_modules/@cspell/strong-weak-map/dist/cjs/StrongWeakMap.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StrongWeakMap = void 0;
    var StrongWeakMap = class {
      constructor(init) {
        this[_a] = "StrongWeakMap";
        this.map = new Map(init?.map(([k, v]) => [k, new WeakRef(v)]));
      }
      clear() {
        this.map.clear();
      }
      /**
       * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.
       */
      delete(key) {
        return this.map.delete(key);
      }
      /**
       * Executes a provided function once per each key/value pair in the Map, in insertion order.
       */
      forEach(callbackfn, thisArg) {
        if (thisArg) {
          callbackfn = callbackfn.bind(thisArg);
        }
        for (const [key, value] of this) {
          callbackfn(value, key, this);
        }
      }
      /**
       * Returns a specified element from the Map object. You will get a reference to the value object and any change made to that
       * object will effectively modify it inside the Map.
       * @returns Returns the element associated with the specified key.
       *   If no element is associated with the specified key, undefined is returned.
       */
      get(key) {
        const ref = this.map.get(key);
        if (!ref)
          return void 0;
        const value = ref.deref();
        if (!value) {
          this.map.delete(key);
          return void 0;
        }
        return value;
      }
      /**
       * Returns a specified element from the Map. If the element isn't found, the resolver function is called and the result is stored in the map and returned.
       */
      autoGet(key, resolver) {
        const found = this.get(key);
        if (found)
          return found;
        const created = resolver(key);
        this.set(key, created);
        return created;
      }
      /**
       * Note: has will cause the value object to live longer.
       * See: [WeakRef - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef#notes_on_weakrefs)
       * @returns boolean indicating whether an element with the specified key exists or not.
       */
      has(key) {
        const value = this.get(key);
        return !!value;
      }
      /**
       * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.
       */
      set(key, value) {
        this.map.set(key, new WeakRef(value));
        return this;
      }
      /**
       * @returns the number of elements in the Map. Note: it is possible that some of the values have been dereferenced
       */
      get size() {
        return this.map.size;
      }
      /** Returns an iterable of entries in the map. */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Returns an iterable of key, value pairs for every entry in the map.
       */
      *entries() {
        for (const key of this.map.keys()) {
          const value = this.get(key);
          if (!value)
            continue;
          yield [key, value];
        }
      }
      /**
       * Returns an iterable of keys in the map
       *
       * Note: It is possible that the value associated with the key was released.
       */
      keys() {
        return this.map.keys();
      }
      /**
       * Returns an iterable of values in the map
       */
      *values() {
        for (const [_, value] of this) {
          yield value;
        }
      }
      /**
       * Removes any keys that reference released objects.
       */
      cleanKeys() {
        [...this];
        return this;
      }
    };
    exports.StrongWeakMap = StrongWeakMap;
    _a = Symbol.toStringTag;
  }
});

// node_modules/@cspell/strong-weak-map/dist/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@cspell/strong-weak-map/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StrongWeakMap = void 0;
    var StrongWeakMap_js_1 = require_StrongWeakMap();
    Object.defineProperty(exports, "StrongWeakMap", { enumerable: true, get: function() {
      return StrongWeakMap_js_1.StrongWeakMap;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/SpellingDictionary/SpellingDictionaryError.js
var require_SpellingDictionaryError = __commonJS({
  "node_modules/cspell-lib/dist/cjs/SpellingDictionary/SpellingDictionaryError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSpellingDictionaryLoadError = exports.SpellingDictionaryLoadError = void 0;
    var SpellingDictionaryLoadError = class extends Error {
      constructor(uri, options, cause, message) {
        super(message);
        this.uri = uri;
        this.options = options;
        this.cause = cause;
        this.name = options.name;
      }
    };
    exports.SpellingDictionaryLoadError = SpellingDictionaryLoadError;
    function isSpellingDictionaryLoadError2(e) {
      return e instanceof SpellingDictionaryLoadError;
    }
    exports.isSpellingDictionaryLoadError = isSpellingDictionaryLoadError2;
  }
});

// node_modules/cspell-lib/dist/cjs/SpellingDictionary/DictionaryController/DictionaryLoader.js
var require_DictionaryLoader = __commonJS({
  "node_modules/cspell-lib/dist/cjs/SpellingDictionary/DictionaryController/DictionaryLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DictionaryLoader = void 0;
    var sync_1 = require_sync();
    var strong_weak_map_1 = require_cjs8();
    var cspell_dictionary_1 = require_cjs7();
    var CSpellSettingsInternalDef_js_1 = require_CSpellSettingsInternalDef();
    var AutoResolve_js_1 = require_AutoResolve();
    var errors_js_1 = require_errors3();
    var SpellingDictionaryError_js_1 = require_SpellingDictionaryError();
    var MAX_AGE = 1e4;
    var loaders = {
      S: loadSimpleWordList,
      C: legacyWordList,
      W: wordsPerLineWordList,
      T: loadTrie,
      default: loadSimpleWordList
    };
    var loadersSync = {
      S: loadSimpleWordListSync,
      C: legacyWordListSync,
      W: wordsPerLineWordListSync,
      T: loadTrieSync,
      default: loadSimpleWordListSync
    };
    var LoadingState;
    (function(LoadingState2) {
      LoadingState2[LoadingState2["Loaded"] = 0] = "Loaded";
      LoadingState2[LoadingState2["Loading"] = 1] = "Loading";
    })(LoadingState || (LoadingState = {}));
    var DictionaryLoader = class {
      constructor(cspellIO) {
        this.cspellIO = cspellIO;
        this.dictionaryCache = new strong_weak_map_1.StrongWeakMap();
        this.inlineDictionaryCache = new AutoResolve_js_1.AutoResolveWeakCache();
        this.dictionaryCacheByDef = new strong_weak_map_1.StrongWeakMap();
        this.reader = toReader(cspellIO);
        this.readerSync = toReaderSync(cspellIO);
      }
      loadDictionary(def) {
        if ((0, CSpellSettingsInternalDef_js_1.isDictionaryDefinitionInlineInternal)(def)) {
          return Promise.resolve(this.loadInlineDict(def));
        }
        const { key, entry } = this.getCacheEntry(def);
        if (entry) {
          return entry.pending.then(([dictionary]) => dictionary);
        }
        const loadedEntry = this.loadEntry(def.path, def);
        this.setCacheEntry(key, loadedEntry, def);
        return loadedEntry.pending.then(([dictionary]) => dictionary);
      }
      loadDictionarySync(def) {
        if ((0, CSpellSettingsInternalDef_js_1.isDictionaryDefinitionInlineInternal)(def)) {
          return this.loadInlineDict(def);
        }
        const { key, entry } = this.getCacheEntry(def);
        if (entry?.dictionary && entry.loadingState === LoadingState.Loaded) {
          return entry.dictionary;
        }
        const loadedEntry = this.loadEntrySync(def.path, def);
        this.setCacheEntry(key, loadedEntry, def);
        return loadedEntry.dictionary;
      }
      /**
       * Check to see if any of the cached dictionaries have changed. If one has changed, reload it.
       * @param maxAge - Only check the dictionary if it has been at least `maxAge` ms since the last check.
       * @param now - optional timestamp representing now. (Mostly used in testing)
       */
      async refreshCacheEntries(maxAge = MAX_AGE, now = Date.now()) {
        await Promise.all([...this.dictionaryCache.values()].map((entry) => this.refreshEntry(entry, maxAge, now)));
      }
      getCacheEntry(def) {
        const defEntry = this.dictionaryCacheByDef.get(def);
        if (defEntry) {
          return defEntry;
        }
        const key = calcKey(def);
        const entry = this.dictionaryCache.get(key);
        if (entry) {
          entry.options = def;
        }
        return { key, entry };
      }
      setCacheEntry(key, entry, def) {
        this.dictionaryCache.set(key, entry);
        this.dictionaryCacheByDef.set(def, { key, entry });
      }
      async refreshEntry(entry, maxAge, now) {
        if (now - entry.ts >= maxAge) {
          const sig = now + Math.random();
          entry.sig = sig;
          entry.ts = now;
          const pStat = this.getStat(entry.uri);
          const [newStat] = await Promise.all([pStat, entry.pending]);
          const hasChanged = !this.isEqual(newStat, entry.stat);
          const sigMatches = entry.sig === sig;
          if (sigMatches && hasChanged) {
            entry.loadingState = LoadingState.Loading;
            const key = calcKey(entry.options);
            const newEntry = this.loadEntry(entry.uri, entry.options);
            this.dictionaryCache.set(key, newEntry);
            this.dictionaryCacheByDef.set(entry.options, { key, entry: newEntry });
          }
        }
      }
      loadEntry(uri, options, now = Date.now()) {
        options = this.normalizeOptions(uri, options);
        const pDictionary = load(this.reader, uri, options).catch((e) => (0, cspell_dictionary_1.createFailedToLoadDictionary)(options.name, uri, new SpellingDictionaryError_js_1.SpellingDictionaryLoadError(uri, options, e, "failed to load"), options));
        const pStat = this.getStat(uri);
        const pending = Promise.all([pDictionary, pStat]);
        const sig = now + Math.random();
        const entry = {
          uri,
          options,
          ts: now,
          stat: void 0,
          dictionary: void 0,
          pending,
          loadingState: LoadingState.Loading,
          sig
        };
        pending.then(([dictionary, stat2]) => {
          entry.stat = stat2;
          entry.dictionary = dictionary;
          entry.loadingState = LoadingState.Loaded;
          return;
        });
        return entry;
      }
      loadEntrySync(uri, options, now = Date.now()) {
        options = this.normalizeOptions(uri, options);
        const stat2 = this.getStatSync(uri);
        const sig = now + Math.random();
        try {
          const dictionary = loadSync(this.readerSync, uri, options);
          const pending = Promise.resolve([dictionary, stat2]);
          return {
            uri,
            options,
            ts: now,
            stat: stat2,
            dictionary,
            pending,
            loadingState: LoadingState.Loaded,
            sig
          };
        } catch (e) {
          const error2 = (0, errors_js_1.toError)(e);
          const dictionary = (0, cspell_dictionary_1.createFailedToLoadDictionary)(options.name, uri, new SpellingDictionaryError_js_1.SpellingDictionaryLoadError(uri, options, error2, "failed to load"), options);
          const pending = Promise.resolve([dictionary, stat2]);
          return {
            uri,
            options,
            ts: now,
            stat: stat2,
            dictionary,
            pending,
            loadingState: LoadingState.Loaded,
            sig
          };
        }
      }
      getStat(uri) {
        return this.cspellIO.getStat(uri).catch(errors_js_1.toError);
      }
      getStatSync(uri) {
        try {
          return this.cspellIO.getStatSync(uri);
        } catch (e) {
          return (0, errors_js_1.toError)(e);
        }
      }
      isEqual(a, b) {
        if (!b)
          return false;
        if (isError4(a)) {
          return isError4(b) && a.message === b.message && a.name === b.name;
        }
        return !isError4(b) && !this.cspellIO.compareStats(a, b);
      }
      normalizeOptions(uri, options) {
        if (options.name)
          return options;
        return { ...options, name: this.cspellIO.uriBasename(uri) };
      }
      loadInlineDict(def) {
        return this.inlineDictionaryCache.get(def, (def2) => (0, cspell_dictionary_1.createInlineSpellingDictionary)(def2, def2.__source || "memory"));
      }
    };
    exports.DictionaryLoader = DictionaryLoader;
    function toReader(cspellIO) {
      return async function(filename) {
        const res = await cspellIO.readFile(filename);
        return res.content.split(/\n|\r\n|\r/);
      };
    }
    function toReaderSync(cspellIO) {
      return function(filename) {
        const res = cspellIO.readFileSync(filename);
        return res.content.split(/\n|\r\n|\r/);
      };
    }
    var importantOptionKeys = ["name", "noSuggest", "useCompounds", "type"];
    function calcKey(def) {
      const path16 = def.path;
      const loaderType = determineType(path16, def);
      const optValues = importantOptionKeys.map((k) => def[k]?.toString() || "");
      const parts = [path16, loaderType].concat(optValues);
      return parts.join("|");
    }
    function isError4(e) {
      const err = e;
      return !!err.message;
    }
    function determineType(uri, opts) {
      const t = opts.type && opts.type in loaders && opts.type || "S";
      const defLoaderType = t;
      const defType = uri.endsWith(".trie.gz") ? "T" : defLoaderType;
      const regTrieTest = /\.trie\b/i;
      return regTrieTest.test(uri) ? "T" : defType;
    }
    function load(reader2, uri, options) {
      const type = determineType(uri, options);
      const loader = loaders[type] || loaders.default;
      return loader(reader2, uri, options);
    }
    function loadSync(reader2, uri, options) {
      const type = determineType(uri, options);
      const loader = loadersSync[type] || loaders.default;
      return loader(reader2, uri, options);
    }
    async function legacyWordList(readLines, filename, options) {
      const lines = await readLines(filename);
      return _legacyWordListSync(lines, filename, options);
    }
    function legacyWordListSync(readLinesSync, filename, options) {
      const lines = readLinesSync(filename);
      return _legacyWordListSync(lines, filename, options);
    }
    function _legacyWordListSync(lines, filename, options) {
      const words = (0, sync_1.pipe)(
        lines,
        // Remove comments
        (0, sync_1.opMap)((line) => line.replace(/#.*/g, "")),
        // Split on everything else
        (0, sync_1.opConcatMap)((line) => line.split(/[^\w\p{L}\p{M}']+/gu)),
        (0, sync_1.opFilter)((word) => !!word)
      );
      return (0, cspell_dictionary_1.createSpellingDictionary)(words, options.name, filename, options);
    }
    async function wordsPerLineWordList(readLines, filename, options) {
      const lines = await readLines(filename);
      return _wordsPerLineWordList(lines, filename, options);
    }
    function wordsPerLineWordListSync(readLinesSync, filename, options) {
      const lines = readLinesSync(filename);
      return _wordsPerLineWordList(lines, filename, options);
    }
    function _wordsPerLineWordList(lines, filename, options) {
      const words = (0, sync_1.pipe)(
        lines,
        // Remove comments
        (0, sync_1.opMap)((line) => line.replace(/#.*/g, "")),
        // Split on everything else
        (0, sync_1.opConcatMap)((line) => line.split(/\s+/gu)),
        (0, sync_1.opFilter)((word) => !!word)
      );
      return (0, cspell_dictionary_1.createSpellingDictionary)(words, options.name, filename, options);
    }
    async function loadSimpleWordList(reader2, filename, options) {
      const lines = await reader2(filename);
      return (0, cspell_dictionary_1.createSpellingDictionary)(lines, options.name, filename, options);
    }
    function loadSimpleWordListSync(readLinesSync, filename, options) {
      const lines = readLinesSync(filename);
      return (0, cspell_dictionary_1.createSpellingDictionary)(lines, options.name, filename, options);
    }
    async function loadTrie(readLines, filename, options) {
      const lines = await readLines(filename);
      return (0, cspell_dictionary_1.createSpellingDictionaryFromTrieFile)(lines, options.name, filename, options);
    }
    function loadTrieSync(readLinesSync, filename, options) {
      const lines = readLinesSync(filename);
      return (0, cspell_dictionary_1.createSpellingDictionaryFromTrieFile)(lines, options.name, filename, options);
    }
  }
});

// node_modules/cspell-lib/dist/cjs/SpellingDictionary/DictionaryController/index.js
var require_DictionaryController = __commonJS({
  "node_modules/cspell-lib/dist/cjs/SpellingDictionary/DictionaryController/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DictionaryLoader = void 0;
    var DictionaryLoader_js_1 = require_DictionaryLoader();
    Object.defineProperty(exports, "DictionaryLoader", { enumerable: true, get: function() {
      return DictionaryLoader_js_1.DictionaryLoader;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/SpellingDictionary/DictionaryLoader.js
var require_DictionaryLoader2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/SpellingDictionary/DictionaryLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.refreshCacheEntries = exports.loadDictionarySync = exports.loadDictionary = exports.getDictionaryLoader = void 0;
    var static_js_1 = require_static();
    var index_js_1 = require_DictionaryController();
    var loader;
    function getDictionaryLoader(cspellIO) {
      if (loader)
        return loader;
      return loader = new index_js_1.DictionaryLoader(cspellIO || (0, static_js_1.getCSpellIO)());
    }
    exports.getDictionaryLoader = getDictionaryLoader;
    function loadDictionary(def) {
      return getDictionaryLoader().loadDictionary(def);
    }
    exports.loadDictionary = loadDictionary;
    function loadDictionarySync(def) {
      return getDictionaryLoader().loadDictionarySync(def);
    }
    exports.loadDictionarySync = loadDictionarySync;
    async function refreshCacheEntries(maxAge, now) {
      return getDictionaryLoader().refreshCacheEntries(maxAge, now);
    }
    exports.refreshCacheEntries = refreshCacheEntries;
  }
});

// node_modules/cspell-lib/dist/cjs/SpellingDictionary/Dictionaries.js
var require_Dictionaries = __commonJS({
  "node_modules/cspell-lib/dist/cjs/SpellingDictionary/Dictionaries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDictionaryInternalSync = exports.getDictionaryInternal = exports.refreshDictionaryCache = exports.loadDictionaryDefsSync = exports.loadDictionaryDefs = void 0;
    var cspell_dictionary_1 = require_cjs7();
    var DictionarySettings_js_1 = require_DictionarySettings();
    var util_js_1 = require_util();
    var DictionaryLoader_js_1 = require_DictionaryLoader2();
    function loadDictionaryDefs(defsToLoad) {
      return defsToLoad.map(DictionaryLoader_js_1.loadDictionary);
    }
    exports.loadDictionaryDefs = loadDictionaryDefs;
    function loadDictionaryDefsSync(defsToLoad) {
      return defsToLoad.map(DictionaryLoader_js_1.loadDictionarySync);
    }
    exports.loadDictionaryDefsSync = loadDictionaryDefsSync;
    function refreshDictionaryCache(maxAge) {
      return (0, DictionaryLoader_js_1.refreshCacheEntries)(maxAge);
    }
    exports.refreshDictionaryCache = refreshDictionaryCache;
    var emptyWords = Object.freeze([]);
    async function getDictionaryInternal(settings) {
      const spellDictionaries = await Promise.all(loadDictionaryDefs((0, DictionarySettings_js_1.calcDictionaryDefsToLoad)(settings)));
      return _getDictionaryInternal(settings, spellDictionaries);
    }
    exports.getDictionaryInternal = getDictionaryInternal;
    function getDictionaryInternalSync(settings) {
      const spellDictionaries = loadDictionaryDefsSync((0, DictionarySettings_js_1.calcDictionaryDefsToLoad)(settings));
      return _getDictionaryInternal(settings, spellDictionaries);
    }
    exports.getDictionaryInternalSync = getDictionaryInternalSync;
    function _getDictionaryInternal(settings, spellDictionaries) {
      const { words = emptyWords, userWords = emptyWords, flagWords = emptyWords, ignoreWords = emptyWords, suggestWords = emptyWords } = settings;
      const settingsWordsDictionary = (0, cspell_dictionary_1.createSpellingDictionary)(words, "[words]", "From Settings `words`", {
        caseSensitive: true,
        weightMap: void 0
      });
      const settingsUserWordsDictionary = userWords.length ? (0, cspell_dictionary_1.createSpellingDictionary)(userWords, "[userWords]", "From Settings `userWords`", {
        caseSensitive: true,
        weightMap: void 0
      }) : void 0;
      const ignoreWordsDictionary = (0, cspell_dictionary_1.createIgnoreWordsDictionary)(ignoreWords, "[ignoreWords]", "From Settings `ignoreWords`");
      const flagWordsDictionary = (0, cspell_dictionary_1.createForbiddenWordsDictionary)(flagWords, "[flagWords]", "From Settings `flagWords`");
      const suggestWordsDictionary = (0, cspell_dictionary_1.createSuggestDictionary)(suggestWords, "[suggestWords]", "From Settings `suggestWords`");
      const dictionaries = [
        ...spellDictionaries,
        settingsWordsDictionary,
        settingsUserWordsDictionary,
        ignoreWordsDictionary,
        flagWordsDictionary,
        suggestWordsDictionary
      ].filter(util_js_1.isDefined);
      return (0, cspell_dictionary_1.createCollection)(dictionaries, "dictionary collection");
    }
  }
});

// node_modules/cspell-lib/dist/cjs/SpellingDictionary/SpellingDictionary.js
var require_SpellingDictionary3 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/SpellingDictionary/SpellingDictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompoundWordsMethod = exports.createSpellingDictionary = exports.createInlineSpellingDictionary = exports.createCollection = void 0;
    var cspell_dictionary_1 = require_cjs7();
    Object.defineProperty(exports, "createCollection", { enumerable: true, get: function() {
      return cspell_dictionary_1.createCollection;
    } });
    Object.defineProperty(exports, "createInlineSpellingDictionary", { enumerable: true, get: function() {
      return cspell_dictionary_1.createInlineSpellingDictionary;
    } });
    Object.defineProperty(exports, "createSpellingDictionary", { enumerable: true, get: function() {
      return cspell_dictionary_1.createSpellingDictionary;
    } });
    var cspell_trie_lib_1 = require_cjs5();
    Object.defineProperty(exports, "CompoundWordsMethod", { enumerable: true, get: function() {
      return cspell_trie_lib_1.CompoundWordsMethod;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/SpellingDictionary/index.js
var require_SpellingDictionary4 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/SpellingDictionary/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Dictionaries(), exports);
    __exportStar(require_SpellingDictionary3(), exports);
    __exportStar(require_SpellingDictionaryError(), exports);
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/InDocSettings.js
var require_InDocSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/InDocSettings.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal = exports.getIgnoreRegExpFromDocument = exports.getIgnoreWordsFromDocument = exports.extractInDocDictionary = exports.regExSpellingGuardLine = exports.regExSpellingGuardNext = exports.regExSpellingGuardBlock = exports.validateInDocumentSettings = exports.getInDocumentSettings = void 0;
    var sync_1 = require_sync();
    var gensequence_1 = require_dist2();
    var index_js_1 = require_SpellingDictionary4();
    var Text2 = __importStar(require_text2());
    var util_js_1 = require_util();
    var CSpellSettingsServer_js_1 = require_CSpellSettingsServer();
    var regExMatchRegEx = /\/.*\/[gimuy]*/;
    var regExCSpellInDocDirective = /\b(?:spell-?checker|c?spell)::?(.*)/gi;
    var regExCSpellDirectiveKey = /(?<=\b(?:spell-?checker|c?spell)::?)(?!:)(.*)/i;
    var regExInFileSettings = [regExCSpellInDocDirective, /\b(LocalWords:?.*)/g];
    var officialDirectives = [
      "enable",
      "disable",
      "disable-line",
      "disable-next",
      "disable-next-line",
      "word",
      "words",
      "ignore",
      "ignoreWord",
      "ignoreWords",
      "ignore-word",
      "ignore-words",
      "includeRegExp",
      "ignoreRegExp",
      "local",
      "locale",
      "language",
      "dictionaries",
      "dictionary",
      "forbid",
      "forbidWord",
      "forbid-word",
      "flag",
      "flagWord",
      "flag-word",
      "enableCompoundWords",
      "enableAllowCompoundWords",
      "disableCompoundWords",
      "disableAllowCompoundWords",
      "enableCaseSensitive",
      "disableCaseSensitive"
    ];
    var noSuggestDirectives = /* @__PURE__ */ new Set(["local"]);
    var preferredDirectives = [
      "enable",
      "disable",
      "disable-line",
      "disable-next-line",
      "words",
      "ignore",
      "forbid",
      "locale",
      "dictionary",
      "dictionaries",
      "enableCaseSensitive",
      "disableCaseSensitive"
    ];
    var allDirectives = new Set(preferredDirectives.concat(officialDirectives));
    var allDirectiveSuggestions = [
      ...(0, sync_1.pipeSync)(allDirectives, (0, sync_1.opMap)((word) => ({ word })))
    ];
    var dictInDocSettings = (0, index_js_1.createSpellingDictionary)(allDirectives, "Directives", "Directive List", {
      supportNonStrictSearches: false
    });
    var EmptyWords = [];
    Object.freeze(EmptyWords);
    var staticInDocumentDictionaryName = `[in-document-dict]`;
    function getInDocumentSettings(text) {
      const collectedSettings = getPossibleInDocSettings(text).concatMap((a) => parseSettingMatch(a)).reduce((s, setting) => {
        return (0, CSpellSettingsServer_js_1.mergeInDocSettings)(s, setting);
      }, { id: "in-doc-settings" });
      const { words, flagWords, ignoreWords, suggestWords, dictionaries = [], dictionaryDefinitions = [], ...rest } = collectedSettings;
      const dict = (words || flagWords || ignoreWords || suggestWords) && (0, util_js_1.clean)({
        name: staticInDocumentDictionaryName,
        words,
        flagWords,
        ignoreWords,
        suggestWords
      });
      const dictSettings = dict ? {
        dictionaries: dictionaries.concat(staticInDocumentDictionaryName),
        dictionaryDefinitions: dictionaryDefinitions.concat(dict)
      } : (0, util_js_1.clean)({
        dictionaries: dictionaries.length ? dictionaries : void 0,
        dictionaryDefinitions: dictionaryDefinitions.length ? dictionaryDefinitions : void 0
      });
      const settings = {
        ...rest,
        ...dictSettings
      };
      return settings;
    }
    exports.getInDocumentSettings = getInDocumentSettings;
    function validateInDocumentSettings(docText, _settings) {
      return (0, sync_1.pipeSync)(getPossibleInDocSettings(docText), (0, sync_1.opMap)(parseSettingMatchValidation), (0, sync_1.opFilter)(util_js_1.isDefined));
    }
    exports.validateInDocumentSettings = validateInDocumentSettings;
    var settingParsers = [
      [/^(?:enable|disable)(?:allow)?CompoundWords\b(?!-)/i, parseCompoundWords],
      [/^(?:enable|disable)CaseSensitive\b(?!-)/i, parseCaseSensitive],
      [/^enable\b(?!-)/i, parseEnable],
      [/^disable(-line|-next(-line)?)?\b(?!-)/i, parseDisable],
      [/^words?\b(?!-)/i, parseWords],
      [/^ignore(?:-?words?)?\b(?!-)/i, parseIgnoreWords],
      [/^(?:flag|forbid)(?:-?words?)?\b(?!-)/i, parseFlagWords],
      [/^ignore_?Reg_?Exp\s+.+$/i, parseIgnoreRegExp],
      [/^include_?Reg_?Exp\s+.+$/i, parseIncludeRegExp],
      [/^locale?\b(?!-)/i, parseLocale],
      [/^language\s\b(?!-)/i, parseLocale],
      [/^dictionar(?:y|ies)\b(?!-)/i, parseDictionaries],
      [/^LocalWords:/, (w) => parseWords(w.replace(/^LocalWords:?/gi, " "))]
    ];
    exports.regExSpellingGuardBlock = /(\bc?spell(?:-?checker)?::?)\s*disable(?!-line|-next)\b[\s\S]*?((?:\1\s*enable\b)|$)/gi;
    exports.regExSpellingGuardNext = /\bc?spell(?:-?checker)?::?\s*disable-next\b.*\s\s?.*/gi;
    exports.regExSpellingGuardLine = /^.*\bc?spell(?:-?checker)?::?\s*disable-line\b.*/gim;
    var emptySettings = Object.freeze({});
    var issueMessages = {
      unknownDirective: "Unknown CSpell directive"
    };
    function parseSettingMatchValidation(matchArray) {
      const [fullMatch = ""] = matchArray;
      const directiveMatch = fullMatch.match(regExCSpellDirectiveKey);
      if (!directiveMatch)
        return void 0;
      const match = directiveMatch[1];
      const possibleSetting = match.trim();
      if (!possibleSetting)
        return void 0;
      const start = (matchArray.index || 0) + (directiveMatch.index || 0) + (match.length - match.trimStart().length);
      const text = possibleSetting.replace(/^([-\w]+)?.*/, "$1");
      const end = start + text.length;
      if (!text)
        return void 0;
      const matchingParsers = settingParsers.filter(([regex]) => regex.test(possibleSetting));
      if (matchingParsers.length > 0)
        return void 0;
      const dictSugs = dictInDocSettings.suggest(text, { ignoreCase: false }).map(({ word, isPreferred }) => isPreferred ? { word, isPreferred } : { word }).filter((a) => !noSuggestDirectives.has(a.word));
      const sugs = (0, sync_1.pipeSync)(dictSugs, (0, sync_1.opAppend)(allDirectiveSuggestions), filterUniqueSuggestions);
      const suggestionsEx = [...sugs].slice(0, 8);
      const suggestions = suggestionsEx.map((s) => s.word);
      const issue = {
        range: [start, end],
        text,
        message: issueMessages.unknownDirective,
        suggestions,
        suggestionsEx
      };
      return issue;
    }
    function* filterUniqueSuggestions(sugs) {
      const map = /* @__PURE__ */ new Map();
      for (const sug of sugs) {
        const existing = map.get(sug.word);
        if (existing) {
          if (sug.isPreferred) {
            existing.isPreferred = true;
          }
        }
        yield sug;
      }
    }
    function parseSettingMatch(matchArray) {
      const [, match = ""] = matchArray;
      const possibleSetting = match.trim();
      return settingParsers.filter(([regex]) => regex.test(possibleSetting)).map(([, fn]) => fn).map((fn) => fn(possibleSetting));
    }
    function parseCompoundWords(match) {
      const allowCompoundWords = /enable/i.test(match);
      return { allowCompoundWords };
    }
    function parseCaseSensitive(match) {
      const caseSensitive = /enable/i.test(match);
      return { caseSensitive };
    }
    function parseWords(match) {
      const words = match.split(/[,\s;]+/g).slice(1).filter((a) => !!a);
      return { words };
    }
    function parseLocale(match) {
      const parts = match.trim().split(/[\s,]+/);
      const language = parts.slice(1).join(",");
      return language ? { language } : emptySettings;
    }
    function parseIgnoreWords(match) {
      const wordsSetting = parseWords(match);
      const ignoreWords = wordsSetting.words;
      return ignoreWords && ignoreWords.length ? { ignoreWords } : emptySettings;
    }
    function parseFlagWords(match) {
      const wordsSetting = parseWords(match);
      const flagWords = wordsSetting.words;
      return flagWords && flagWords.length ? { flagWords } : emptySettings;
    }
    function parseRegEx(match) {
      const patterns = [match.replace(/^[^\s]+\s+/, "")].map((a) => {
        const m = a.match(regExMatchRegEx);
        if (m && m[0]) {
          return m[0];
        }
        return a.replace(/((?:[^\s]|\\ )+).*/, "$1");
      });
      return patterns;
    }
    function parseIgnoreRegExp(match) {
      const ignoreRegExpList = parseRegEx(match);
      return { ignoreRegExpList };
    }
    function parseIncludeRegExp(match) {
      const includeRegExpList = parseRegEx(match);
      return { includeRegExpList };
    }
    function parseDictionaries(match) {
      const dictionaries = match.split(/[,\s]+/g).slice(1);
      return { dictionaries };
    }
    function getPossibleInDocSettings(text) {
      return (0, gensequence_1.genSequence)(regExInFileSettings).concatMap((regexp) => Text2.match(regexp, text));
    }
    function getWordsFromDocument(text) {
      const dict = extractInDocDictionary(getInDocumentSettings(text));
      return dict?.words || EmptyWords;
    }
    function parseEnable(_match) {
      return {};
    }
    function parseDisable(_match) {
      return {};
    }
    function extractInDocDictionary(settings) {
      const inDocDicts = settings.dictionaryDefinitions?.filter((def) => def.name === staticInDocumentDictionaryName);
      const dict = inDocDicts?.[0];
      return dict;
    }
    exports.extractInDocDictionary = extractInDocDictionary;
    function getIgnoreWordsFromDocument(text) {
      const dict = extractInDocDictionary(getInDocumentSettings(text));
      return dict?.ignoreWords || EmptyWords;
    }
    exports.getIgnoreWordsFromDocument = getIgnoreWordsFromDocument;
    function getIgnoreRegExpFromDocument(text) {
      const { ignoreRegExpList = [] } = getInDocumentSettings(text);
      return ignoreRegExpList;
    }
    exports.getIgnoreRegExpFromDocument = getIgnoreRegExpFromDocument;
    exports.internal = {
      getPossibleInDocSettings,
      getWordsFromDocument,
      parseWords,
      parseCompoundWords,
      parseIgnoreRegExp,
      parseIgnoreWords,
      staticInDocumentDictionaryName
    };
  }
});

// node_modules/cspell-lib/dist/cjs/Settings/TextDocumentSettings.js
var require_TextDocumentSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/Settings/TextDocumentSettings.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractSettingsFromText = exports.combineTextAndLanguageSettings = void 0;
    var CSpellSettingsServer = __importStar(require_CSpellSettingsServer());
    var InDocSettings_js_1 = require_InDocSettings();
    var LanguageSettings_js_1 = require_LanguageSettings();
    function combineTextAndLanguageSettings(settings, text, languageId) {
      if (!text) {
        return CSpellSettingsServer.toInternalSettings((0, LanguageSettings_js_1.calcSettingsForLanguageId)(settings, languageId));
      }
      const docSettings = extractSettingsFromText(text);
      const settingsForText = CSpellSettingsServer.mergeSettings(settings, docSettings);
      const langSettings = (0, LanguageSettings_js_1.calcSettingsForLanguageId)(settingsForText, languageId);
      return CSpellSettingsServer.mergeSettings(langSettings, docSettings);
    }
    exports.combineTextAndLanguageSettings = combineTextAndLanguageSettings;
    function extractSettingsFromText(text) {
      return (0, InDocSettings_js_1.getInDocumentSettings)(text);
    }
    exports.extractSettingsFromText = extractSettingsFromText;
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/determineTextDocumentSettings.js
var require_determineTextDocumentSettings = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/determineTextDocumentSettings.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.determineTextDocumentSettings = void 0;
    var path16 = __importStar(require("path"));
    var LanguageIds_js_1 = require_LanguageIds();
    var index_js_1 = require_Settings();
    var TextDocumentSettings_js_1 = require_TextDocumentSettings();
    var Uri_js_1 = require_Uri();
    function determineTextDocumentSettings(doc, settings) {
      const filename = (0, Uri_js_1.uriToFilePath)(doc.uri);
      const settingsWithDefaults = (0, index_js_1.mergeSettings)((0, index_js_1.getDefaultSettings)(settings.loadDefaultConfiguration ?? true), (0, index_js_1.getGlobalSettings)(), settings);
      const fileSettings = (0, index_js_1.calcOverrideSettings)(settingsWithDefaults, filename);
      const languageIds = fileSettings?.languageId?.length ? fileSettings.languageId : doc.languageId ? doc.languageId : getLanguageForFilename(filename);
      if (doc.locale) {
        fileSettings.language = doc.locale;
      }
      return (0, TextDocumentSettings_js_1.combineTextAndLanguageSettings)(fileSettings, doc.text, languageIds);
    }
    exports.determineTextDocumentSettings = determineTextDocumentSettings;
    function getLanguageForFilename(filename) {
      const basename3 = path16.basename(filename);
      return (0, LanguageIds_js_1.getLanguagesForBasename)(basename3);
    }
  }
});

// node_modules/@cspell/cspell-types/dist/cjs/configFields.js
var require_configFields = __commonJS({
  "node_modules/@cspell/cspell-types/dist/cjs/configFields.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigFields = void 0;
    exports.ConfigFields = {
      allowCompoundWords: "allowCompoundWords",
      cache: "cache",
      caseSensitive: "caseSensitive",
      description: "description",
      dictionaries: "dictionaries",
      dictionaryDefinitions: "dictionaryDefinitions",
      enabled: "enabled",
      enabledLanguageIds: "enabledLanguageIds",
      enableFiletypes: "enableFiletypes",
      enableGlobDot: "enableGlobDot",
      failFast: "failFast",
      features: "features",
      files: "files",
      flagWords: "flagWords",
      gitignoreRoot: "gitignoreRoot",
      globRoot: "globRoot",
      ignorePaths: "ignorePaths",
      ignoreRegExpList: "ignoreRegExpList",
      ignoreWords: "ignoreWords",
      import: "import",
      includeRegExpList: "includeRegExpList",
      language: "language",
      languageId: "languageId",
      languageSettings: "languageSettings",
      loadDefaultConfiguration: "loadDefaultConfiguration",
      maxDuplicateProblems: "maxDuplicateProblems",
      maxNumberOfProblems: "maxNumberOfProblems",
      minWordLength: "minWordLength",
      name: "name",
      noConfigSearch: "noConfigSearch",
      noSuggestDictionaries: "noSuggestDictionaries",
      numSuggestions: "numSuggestions",
      overrides: "overrides",
      patterns: "patterns",
      pnpFiles: "pnpFiles",
      readonly: "readonly",
      reporters: "reporters",
      showStatus: "showStatus",
      spellCheckDelayMs: "spellCheckDelayMs",
      suggestionNumChanges: "suggestionNumChanges",
      suggestionsTimeout: "suggestionsTimeout",
      suggestWords: "suggestWords",
      useGitignore: "useGitignore",
      usePnP: "usePnP",
      userWords: "userWords",
      validateDirectives: "validateDirectives",
      words: "words",
      // Experimental
      parser: "parser"
    };
  }
});

// node_modules/@cspell/cspell-types/dist/cjs/CSpellReporter.js
var require_CSpellReporter = __commonJS({
  "node_modules/@cspell/cspell-types/dist/cjs/CSpellReporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageTypes = exports.IssueType = void 0;
    var IssueType2;
    (function(IssueType3) {
      IssueType3[IssueType3["spelling"] = 0] = "spelling";
      IssueType3[IssueType3["directive"] = 1] = "directive";
    })(IssueType2 = exports.IssueType || (exports.IssueType = {}));
    exports.MessageTypes = {
      Debug: "Debug",
      Info: "Info",
      Warning: "Warning"
    };
  }
});

// node_modules/@cspell/cspell-types/dist/cjs/index.js
var require_cjs9 = __commonJS({
  "node_modules/@cspell/cspell-types/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageTypes = exports.IssueType = exports.ConfigFields = void 0;
    var configFields_js_1 = require_configFields();
    Object.defineProperty(exports, "ConfigFields", { enumerable: true, get: function() {
      return configFields_js_1.ConfigFields;
    } });
    var CSpellReporter_js_1 = require_CSpellReporter();
    Object.defineProperty(exports, "IssueType", { enumerable: true, get: function() {
      return CSpellReporter_js_1.IssueType;
    } });
    Object.defineProperty(exports, "MessageTypes", { enumerable: true, get: function() {
      return CSpellReporter_js_1.MessageTypes;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/util/memorizeLastCall.js
var require_memorizeLastCall2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/memorizeLastCall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.memorizeLastCall = void 0;
    var util_js_1 = require_util();
    function memorizeLastCall(fn) {
      let last;
      return (...p) => {
        if (last && (0, util_js_1.isArrayEqual)(last.args, p)) {
          return last.value;
        }
        const args = p;
        const value = fn(...args);
        last = { args, value };
        return value;
      };
    }
    exports.memorizeLastCall = memorizeLastCall;
  }
});

// node_modules/cspell-lib/dist/cjs/suggestions.js
var require_suggestions = __commonJS({
  "node_modules/cspell-lib/dist/cjs/suggestions.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SuggestionError = exports.calcSuggestionAdjustedToToMatchCase = exports.suggestionsForWord = exports.suggestionsForWords = void 0;
    var assert_1 = __importDefault(require("assert"));
    var index_js_1 = require_Settings();
    var LanguageSettings_js_1 = require_LanguageSettings();
    var index_js_2 = require_SpellingDictionary4();
    var AutoResolve_js_1 = require_AutoResolve();
    var memorizeLastCall_js_1 = require_memorizeLastCall2();
    var util = __importStar(require_util());
    var emptySuggestionOptions = Object.freeze({});
    var emptyCSpellSettings = Object.freeze({});
    async function* suggestionsForWords2(words, options, settings) {
      for await (const word of words) {
        yield await suggestionsForWord(word, options, settings);
      }
    }
    exports.suggestionsForWords = suggestionsForWords2;
    var memorizeSuggestions = (0, memorizeLastCall_js_1.memorizeLastCall)(cacheSuggestionsForWord);
    function cacheSuggestionsForWord(options, settings) {
      const cache = (0, AutoResolve_js_1.createAutoResolveCache)();
      return (word) => cache.get(word, (word2) => _suggestionsForWord(word2, options, settings));
    }
    function suggestionsForWord(word, options = emptySuggestionOptions, settings = emptyCSpellSettings) {
      return memorizeSuggestions(options, settings)(word);
    }
    exports.suggestionsForWord = suggestionsForWord;
    async function _suggestionsForWord(word, options, settings) {
      const { languageId, locale: language, includeDefaultConfig = true, dictionaries } = options;
      async function determineDictionaries(config2) {
        const withLocale = (0, index_js_1.mergeSettings)(config2, util.clean({
          language: language || config2.language
          // dictionaries: dictionaries?.length ? dictionaries : config.dictionaries,
        }));
        const withLanguageId = (0, LanguageSettings_js_1.calcSettingsForLanguageId)(withLocale, languageId ?? withLocale.languageId ?? "plaintext");
        const settings2 = (0, index_js_1.finalizeSettings)(withLanguageId);
        settings2.dictionaries = dictionaries?.length ? dictionaries : settings2.dictionaries || [];
        validateDictionaries(settings2, dictionaries);
        const dictionaryCollection2 = await (0, index_js_2.getDictionaryInternal)(settings2);
        settings2.dictionaries = settings2.dictionaryDefinitions?.map((def) => def.name) || [];
        const allDictionaryCollection2 = await (0, index_js_2.getDictionaryInternal)(settings2);
        return {
          dictionaryCollection: dictionaryCollection2,
          allDictionaryCollection: allDictionaryCollection2
        };
      }
      await (0, index_js_2.refreshDictionaryCache)();
      const config = includeDefaultConfig ? (0, index_js_1.mergeSettings)((0, index_js_1.getDefaultSettings)(settings.loadDefaultConfiguration ?? true), (0, index_js_1.getGlobalSettings)(), settings) : settings;
      const { dictionaryCollection, allDictionaryCollection } = await determineDictionaries(config);
      return _suggestionsForWordSync(word, options, settings, dictionaryCollection, allDictionaryCollection);
    }
    function _suggestionsForWordSync(word, options, settings, dictionaryCollection, allDictionaryCollection) {
      const extendsDictionaryCollection = allDictionaryCollection || dictionaryCollection;
      const { locale: language, strict = true, numChanges = 4, numSuggestions = 8, includeTies = true, includeDefaultConfig = true } = options;
      const ignoreCase = !strict;
      const config = includeDefaultConfig ? (0, index_js_1.mergeSettings)((0, index_js_1.getDefaultSettings)(settings.loadDefaultConfiguration ?? true), (0, index_js_1.getGlobalSettings)(), settings) : settings;
      const opts = { ignoreCase, numChanges, numSuggestions, includeTies };
      const suggestionsByDictionary = dictionaryCollection.dictionaries.flatMap((dict) => dict.suggest(word, opts).map((r) => ({ ...r, dictName: dict.name })));
      const locale = adjustLocale(language || config.language || void 0);
      const collator = Intl.Collator(locale);
      const combined = limitResults(combine(suggestionsByDictionary.sort((a, b) => a.cost - b.cost || collator.compare(a.word, b.word))), numSuggestions, includeTies);
      const sugsAdjusted = calcSuggestionAdjustedToToMatchCase(word, combined, locale, ignoreCase, extendsDictionaryCollection);
      const allSugs = sugsAdjusted.map((sug) => {
        const found = extendsDictionaryCollection.find(sug.word);
        return {
          ...sug,
          forbidden: found?.forbidden || false,
          noSuggest: found?.noSuggest || false
        };
      });
      return {
        word,
        suggestions: limitResults(allSugs, numSuggestions, includeTies)
      };
    }
    function combine(suggestions) {
      const words = /* @__PURE__ */ new Map();
      for (const sug of suggestions) {
        const { word, cost, dictName, ...rest } = sug;
        const f = words.get(word) || { word, cost, ...rest, dictionaries: [] };
        f.cost = Math.min(f.cost, cost);
        f.dictionaries.push(dictName);
        f.dictionaries.sort();
        words.set(word, f);
      }
      return [...words.values()];
    }
    function adjustLocale(locale) {
      if (!locale)
        return void 0;
      const locales = [...(0, LanguageSettings_js_1.normalizeLocaleIntl)(locale)].filter((locale2) => (0, LanguageSettings_js_1.isValidLocaleIntlFormat)(locale2));
      if (!locales.length)
        return void 0;
      if (locales.length === 1)
        return locales[0];
      return locales;
    }
    function calcSuggestionAdjustedToToMatchCase(originalWord, sugs, locale, ignoreCase, dict) {
      locale = adjustLocale(locale);
      const knownSugs = new Set(sugs.map((sug) => sug.word));
      const matchStyle = { ...analyzeCase(originalWord), locale, ignoreCase };
      return sugs.map((sug) => {
        const alt = matchCase(sug.word, !!sug.isPreferred, matchStyle);
        if (alt === sug.word || knownSugs.has(alt))
          return sug;
        const found = dict.find(alt);
        if (!found || !found.forbidden || !found.noSuggest) {
          knownSugs.add(alt);
          return { ...sug, wordAdjustedToMatchCase: alt };
        }
        return sug;
      });
    }
    exports.calcSuggestionAdjustedToToMatchCase = calcSuggestionAdjustedToToMatchCase;
    function limitResults(suggestions, numSuggestions, includeTies) {
      let cost = suggestions[0]?.cost;
      let i = 0;
      for (; i < suggestions.length; ++i) {
        if (i >= numSuggestions && (!includeTies || suggestions[i].cost > cost)) {
          break;
        }
        cost = suggestions[i].cost;
      }
      return suggestions.slice(0, i);
    }
    function validateDictionaries(settings, dictionaries) {
      if (!dictionaries?.length)
        return;
      const knownDicts = new Set(settings.dictionaryDefinitions?.map((def) => def.name) || []);
      for (const dict of dictionaries) {
        if (!knownDicts.has(dict)) {
          throw new SuggestionError2(`Unknown dictionary: "${dict}"`, "E_dictionary_unknown");
        }
      }
    }
    function matchCase(word, isPreferred, style) {
      const locale = style.locale;
      if (style.isMixedCaps) {
        return word;
      }
      if (hasCaps(word)) {
        if (style.isAllCaps)
          return word.toLocaleUpperCase(locale);
        if (!style.ignoreCase || style.hasCaps || isPreferred)
          return word;
        if (isTitleCase(word) || isAllCaps(word))
          return word.toLocaleLowerCase(locale);
        return word;
      }
      if (!style.hasCaps)
        return word;
      if (style.isAllCaps)
        return word.toLocaleUpperCase(locale);
      (0, assert_1.default)(style.isTitleCase);
      return word.replace(/^\p{L}/u, (firstLetter) => firstLetter.toLocaleUpperCase(locale));
    }
    var regExpHasCaps = /\p{Lu}/u;
    var regExpIsAllCaps = /^[\P{L}\p{Lu}]+$/u;
    var regExpIsTitleCase = /^\p{Lu}[\P{L}\p{Ll}]+$/u;
    function analyzeCase(word) {
      const hasCaps2 = regExpHasCaps.test(word);
      const isAllCaps2 = hasCaps2 && regExpIsAllCaps.test(word);
      const isTitleCase2 = hasCaps2 && !isAllCaps2 && regExpIsTitleCase.test(word);
      const isMixedCaps = hasCaps2 && !isAllCaps2 && !isTitleCase2;
      return { hasCaps: hasCaps2, isAllCaps: isAllCaps2, isMixedCaps, isTitleCase: isTitleCase2 };
    }
    function hasCaps(word) {
      return regExpHasCaps.test(word);
    }
    function isTitleCase(word) {
      return regExpIsTitleCase.test(word);
    }
    function isAllCaps(word) {
      return regExpIsAllCaps.test(word);
    }
    var SuggestionError2 = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
      }
    };
    exports.SuggestionError = SuggestionError2;
  }
});

// node_modules/cspell-lib/dist/cjs/util/simpleCache.js
var require_simpleCache2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/simpleCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoCache = exports.SimpleCache = exports.AutoWeakCache = exports.SimpleWeakCache = void 0;
    var SimpleWeakCache = class {
      constructor(size) {
        this.size = size;
        this.L0 = /* @__PURE__ */ new WeakMap();
        this.L1 = /* @__PURE__ */ new WeakMap();
        this.L2 = /* @__PURE__ */ new WeakMap();
        this.sizeL0 = 0;
      }
      has(key) {
        for (const c of this.caches()) {
          if (c.has(key))
            return true;
        }
        return false;
      }
      get(key) {
        for (const c of this.caches()) {
          const entry = c.get(key);
          if (entry) {
            if (c !== this.L0) {
              this._set(key, entry);
            }
            return entry.v;
          }
        }
        return void 0;
      }
      set(key, value) {
        this._set(key, { v: value });
      }
      _set(key, entry) {
        if (this.L0.has(key)) {
          this.L0.set(key, entry);
          return this;
        }
        if (this.sizeL0 >= this.size) {
          this.rotate();
        }
        this.sizeL0 += 1;
        this.L0.set(key, entry);
      }
      caches() {
        return [this.L0, this.L1, this.L2];
      }
      rotate() {
        this.L2 = this.L1;
        this.L1 = this.L0;
        this.L0 = /* @__PURE__ */ new WeakMap();
        this.sizeL0 = 0;
      }
    };
    exports.SimpleWeakCache = SimpleWeakCache;
    var AutoWeakCache = class extends SimpleWeakCache {
      constructor(factory, size) {
        super(size);
        this.factory = factory;
      }
      get(key) {
        const v = super.get(key);
        if (v !== void 0)
          return v;
        const val = this.factory(key);
        this.set(key, val);
        return val;
      }
    };
    exports.AutoWeakCache = AutoWeakCache;
    var SimpleCache = class {
      constructor(size) {
        this.size = size;
        this.L0 = /* @__PURE__ */ new Map();
        this.L1 = /* @__PURE__ */ new Map();
        this.L2 = /* @__PURE__ */ new Map();
      }
      has(key) {
        for (const c of this.caches()) {
          if (c.has(key))
            return true;
        }
        return false;
      }
      get(key) {
        for (const c of this.caches()) {
          const entry = c.get(key);
          if (entry) {
            if (c !== this.L0) {
              this._set(key, entry);
            }
            return entry.v;
          }
        }
        return void 0;
      }
      set(key, value) {
        this._set(key, { v: value });
      }
      _set(key, entry) {
        if (this.L0.has(key)) {
          this.L0.set(key, entry);
          return this;
        }
        if (this.L0.size >= this.size) {
          this.rotate();
        }
        this.L0.set(key, entry);
      }
      caches() {
        return [this.L0, this.L1, this.L2];
      }
      rotate() {
        this.L2 = this.L1;
        this.L1 = this.L0;
        this.L0 = /* @__PURE__ */ new Map();
      }
    };
    exports.SimpleCache = SimpleCache;
    var AutoCache = class extends SimpleCache {
      constructor(factory, size) {
        super(size);
        this.factory = factory;
      }
      get(key) {
        const v = super.get(key);
        if (v !== void 0)
          return v;
        const val = this.factory(key);
        this.set(key, val);
        return val;
      }
    };
    exports.AutoCache = AutoCache;
  }
});

// node_modules/cspell-lib/dist/cjs/util/timer.js
var require_timer2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/timer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLapRecorder = exports.polyHrTime = exports.toMilliseconds = exports.createTimer = void 0;
    var _hrTime = process?.hrtime || polyHrTime;
    function createTimer(hrTimeFn = _hrTime) {
      let start = hrTimeFn();
      let lastLap = 0;
      function elapsed() {
        return toMilliseconds(hrTimeFn(start));
      }
      return {
        start() {
          start = hrTimeFn();
          lastLap = 0;
        },
        elapsed,
        lap() {
          const now = elapsed();
          const diff = now - lastLap;
          lastLap = now;
          return diff;
        }
      };
    }
    exports.createTimer = createTimer;
    function toMilliseconds(t) {
      return (t[0] + t[1] * 1e-9) * 1e3;
    }
    exports.toMilliseconds = toMilliseconds;
    function polyHrTime(time) {
      const now = Date.now() - (time ? toMilliseconds(time) : 0);
      const inSeconds = now * 1e-3;
      const s = Math.floor(inSeconds);
      const n = (inSeconds - s) * 1e9;
      return [s, n];
    }
    exports.polyHrTime = polyHrTime;
    function createLapRecorder() {
      const timer = createTimer();
      const times = [];
      let lapTime = 0;
      function lap(name) {
        const now = timer.elapsed();
        const diff = now - lapTime;
        times.push([name, diff, now]);
        lapTime = diff;
      }
      function report() {
        return times.map(([name, time]) => `${name}: ${time.toFixed(2)}`);
      }
      return {
        times,
        lap,
        report
      };
    }
    exports.createLapRecorder = createLapRecorder;
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/defaultConstants.js
var require_defaultConstants = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/defaultConstants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minWordSplitLen = exports.defaultMinWordLength = exports.defaultMaxDuplicateProblems = exports.defaultMaxNumberOfProblems = void 0;
    exports.defaultMaxNumberOfProblems = 200;
    exports.defaultMaxDuplicateProblems = 5;
    exports.defaultMinWordLength = 4;
    exports.minWordSplitLen = 3;
  }
});

// node_modules/cspell-lib/dist/cjs/util/PairingHeap.js
var require_PairingHeap2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/PairingHeap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.heapMethods = exports.PairingHeap = void 0;
    var PairingHeap = class {
      constructor(compare2) {
        this.compare = compare2;
        this._size = 0;
      }
      add(v) {
        this._heap = insert(this.compare, this._heap, v);
        ++this._size;
        return this;
      }
      dequeue() {
        const n = this.next();
        if (n.done)
          return void 0;
        return n.value;
      }
      concat(i) {
        for (const v of i) {
          this.add(v);
        }
        return this;
      }
      next() {
        if (!this._heap) {
          return { value: void 0, done: true };
        }
        const value = this._heap.v;
        --this._size;
        this._heap = removeHead(this.compare, this._heap);
        return { value };
      }
      peek() {
        return this._heap?.v;
      }
      [Symbol.iterator]() {
        return this;
      }
      get length() {
        return this._size;
      }
    };
    exports.PairingHeap = PairingHeap;
    function removeHead(compare2, heap) {
      if (!heap || !heap.c)
        return void 0;
      return mergeSiblings(compare2, heap.c);
    }
    function insert(compare2, heap, v) {
      const n = {
        v,
        s: void 0,
        c: void 0
      };
      if (!heap || compare2(v, heap.v) <= 0) {
        n.c = heap;
        return n;
      }
      n.s = heap.c;
      heap.c = n;
      return heap;
    }
    function merge(compare2, a, b) {
      if (compare2(a.v, b.v) <= 0) {
        a.s = void 0;
        b.s = a.c;
        a.c = b;
        return a;
      }
      b.s = void 0;
      a.s = b.c;
      b.c = a;
      return b;
    }
    function mergeSiblings(compare2, n) {
      if (!n.s)
        return n;
      const s = n.s;
      const ss = s.s;
      const m = merge(compare2, n, s);
      return ss ? merge(compare2, m, mergeSiblings(compare2, ss)) : m;
    }
    exports.heapMethods = {
      insert,
      merge,
      mergeSiblings
    };
  }
});

// node_modules/cspell-lib/dist/cjs/util/regexHelper.js
var require_regexHelper2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/regexHelper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeRegEx = void 0;
    function escapeRegEx(s) {
      return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    exports.escapeRegEx = escapeRegEx;
  }
});

// node_modules/cspell-lib/dist/cjs/util/wordSplitter.js
var require_wordSplitter = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/wordSplitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.split = void 0;
    var PairingHeap_js_1 = require_PairingHeap2();
    var regexHelper_js_1 = require_regexHelper2();
    var textRegex_js_1 = require_textRegex();
    var ignoreBreak = Object.freeze([]);
    function split(line, offset, isValidWord, options = {}) {
      const relWordToSplit = findNextWordText({ text: line.text, offset: offset - line.offset });
      const lineOffset = line.offset;
      const requested = /* @__PURE__ */ new Map();
      const regExpIgnoreSegment = /^[-.+\d_eE'`\\\s]+$/;
      if (!relWordToSplit.text) {
        const text = rebaseTextOffset(relWordToSplit);
        return {
          line,
          offset,
          text,
          words: [],
          endOffset: text.offset + text.text.length
        };
      }
      const lineSegment = {
        line,
        relStart: relWordToSplit.offset,
        relEnd: relWordToSplit.offset + relWordToSplit.text.length
      };
      const possibleBreaks = generateWordBreaks(lineSegment, options);
      if (!possibleBreaks.length) {
        const text = rebaseTextOffset(relWordToSplit);
        return {
          line,
          offset,
          text,
          words: [{ ...text, isFound: isValidWord(text) }],
          endOffset: text.offset + text.text.length
        };
      }
      function rebaseTextOffset(relText) {
        return {
          ...relText,
          offset: relText.offset + lineOffset
        };
      }
      function has(word) {
        if (regExpIgnoreSegment.test(word.text)) {
          return true;
        }
        const i = word.offset;
        const j = word.text.length;
        let v = i + (j << 20);
        if (i < 1 << 20 && j < 1 << 11) {
          const b = requested.get(v);
          if (b !== void 0)
            return b;
        } else {
          v = -1;
        }
        const r = isValidWord(rebaseTextOffset(word));
        if (v >= 0) {
          requested.set(v, r);
        }
        return r;
      }
      possibleBreaks.push({
        offset: lineSegment.relEnd,
        breaks: [ignoreBreak]
      });
      const result = {
        line,
        offset,
        text: rebaseTextOffset(relWordToSplit),
        words: splitIntoWords(lineSegment, possibleBreaks, has).map(rebaseTextOffset),
        endOffset: lineOffset + lineSegment.relEnd
      };
      return result;
    }
    exports.split = split;
    function findNextWordText({ text, offset }) {
      const reg = new RegExp(textRegex_js_1.regExWordsAndDigits);
      reg.lastIndex = offset;
      const m = reg.exec(text);
      if (!m) {
        return {
          text: "",
          offset: offset + text.length
        };
      }
      if (textRegex_js_1.regExNumericLiteral.test(m[0])) {
        return findNextWordText({ text, offset: offset + m[0].length });
      }
      return {
        text: m[0],
        offset: m.index
      };
    }
    function generateWordBreaks(line, options) {
      const camelBreaks = genWordBreakCamel(line);
      const symbolBreaks = genSymbolBreaks(line);
      const optionalBreaks = genOptionalWordBreaks(line, options.optionalWordBreakCharacters);
      return mergeSortedBreaks(...camelBreaks, ...symbolBreaks, ...optionalBreaks);
    }
    function offsetRegEx(reg, offset) {
      const r = new RegExp(reg);
      r.lastIndex = offset;
      return r;
    }
    function genWordBreakCamel(line) {
      const breaksCamel1 = [];
      const text = line.line.text.slice(0, line.relEnd);
      for (const m of text.matchAll(offsetRegEx(textRegex_js_1.regExSplitWords, line.relStart))) {
        if (m.index === void 0)
          break;
        const i = m.index + 1;
        breaksCamel1.push({
          offset: m.index,
          breaks: [[i, i], ignoreBreak]
        });
      }
      const breaksCamel2 = [];
      for (const m of text.matchAll(offsetRegEx(textRegex_js_1.regExSplitWords2, line.relStart))) {
        if (m.index === void 0)
          break;
        const i = m.index + m[1].length;
        const j = i + 1;
        breaksCamel2.push({
          offset: m.index,
          breaks: [[i, i], [j, j], ignoreBreak]
        });
      }
      return [breaksCamel1, breaksCamel2];
    }
    function calcBreaksForRegEx(line, reg, calcBreak) {
      const sb = [];
      const text = line.line.text.slice(0, line.relEnd);
      for (const m of text.matchAll(offsetRegEx(reg, line.relStart))) {
        const b = calcBreak(m);
        if (b) {
          sb.push(b);
        }
      }
      return sb;
    }
    function genOptionalWordBreaks(line, optionalBreakCharacters) {
      function calcBreaks(m) {
        const i = m.index;
        if (i === void 0)
          return;
        const j = i + m[0].length;
        return {
          offset: i,
          breaks: [
            [i, j],
            ignoreBreak
          ]
        };
      }
      const breaks = [
        calcBreaksForRegEx(line, textRegex_js_1.regExDanglingQuote, calcBreaks),
        calcBreaksForRegEx(line, textRegex_js_1.regExTrailingEndings, calcBreaks)
      ];
      if (optionalBreakCharacters) {
        const regex = new RegExp(`[${(0, regexHelper_js_1.escapeRegEx)(optionalBreakCharacters)}]`, "gu");
        breaks.push(calcBreaksForRegEx(line, regex, calcBreaks));
      }
      return breaks;
    }
    function genSymbolBreaks(line) {
      function calcBreaks(m) {
        const i = m.index;
        if (i === void 0)
          return;
        const j = i + m[0].length;
        return {
          offset: i,
          breaks: [
            [i, j],
            [i, i],
            [j, j],
            ignoreBreak
          ]
        };
      }
      return [
        calcBreaksForRegEx(line, textRegex_js_1.regExPossibleWordBreaks, calcBreaks),
        calcBreaksForRegEx(line, /\d+/g, calcBreaks),
        calcBreaksForRegEx(line, textRegex_js_1.regExEscapeCharacters, calcBreaks)
      ];
    }
    function splitIntoWords(lineSeg, breaks, has) {
      const maxIndex = lineSeg.relEnd;
      const maxAttempts = 1e3;
      const knownPathsByIndex = /* @__PURE__ */ new Map();
      function makeCandidates(p, i, bi, currentCost) {
        const len = maxIndex;
        while (bi < breaks.length && breaks[bi].offset < i) {
          bi += 1;
        }
        if (bi >= breaks.length) {
          return [];
        }
        const br = breaks[bi];
        function c(bp) {
          const d = bp.length < 2 ? len - i : (bp[0] - i) * 0.5 + len - bp[1];
          const ec = currentCost + d;
          return {
            p,
            i,
            bi,
            bp,
            c: currentCost,
            ec,
            text: void 0
          };
        }
        return br.breaks.map(c);
      }
      function toTextOffset(text2, offset) {
        const valid = has({ text: text2, offset });
        return {
          text: text2,
          offset,
          isFound: valid
        };
      }
      function compare2(a, b) {
        return a.ec - b.ec || b.i - a.i;
      }
      function pathToWords(node) {
        const results = [];
        for (let p = node; p; p = p.n) {
          if (p.text) {
            results.push(p.text);
          }
        }
        return results;
      }
      function addToKnownPaths(candidate, path16) {
        for (let can = candidate; can !== void 0; can = can.p) {
          const t = can.text;
          const i = can.i;
          const cost = (!t || t.isFound ? 0 : t.text.length) + (path16?.c ?? 0);
          const exitingPath = knownPathsByIndex.get(i);
          if (exitingPath && exitingPath.c <= cost) {
            return void 0;
          }
          const node = {
            n: path16,
            i,
            c: cost,
            text: t
          };
          knownPathsByIndex.set(i, node);
          path16 = node;
        }
        return path16;
      }
      let maxCost = lineSeg.relEnd - lineSeg.relStart;
      const candidates = new PairingHeap_js_1.PairingHeap(compare2);
      const text = lineSeg.line.text;
      candidates.concat(makeCandidates(void 0, lineSeg.relStart, 0, 0));
      let attempts = 0;
      let bestPath;
      while (maxCost && candidates.length && attempts++ < maxAttempts) {
        const best = candidates.dequeue();
        if (!best || best.c >= maxCost) {
          continue;
        }
        if (best.bp.length) {
          const i = best.bp[0];
          const j = best.bp[1];
          const t = i > best.i ? toTextOffset(text.slice(best.i, i), best.i) : void 0;
          const cost = !t || t.isFound ? 0 : t.text.length;
          const mc = maxIndex - j;
          best.c += cost;
          best.ec = best.c + mc;
          best.text = t;
          const possiblePath = knownPathsByIndex.get(j);
          if (possiblePath) {
            const f = addToKnownPaths(best, possiblePath);
            bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
          } else if (best.c < maxCost) {
            const c = makeCandidates(t ? best : best.p, j, best.bi + 1, best.c);
            candidates.concat(c);
          }
        } else {
          const c = makeCandidates(best.p, best.i, best.bi + 1, best.c);
          candidates.concat(c);
          if (!c.length) {
            const t = maxIndex > best.i ? toTextOffset(text.slice(best.i, maxIndex), best.i) : void 0;
            const cost = !t || t.isFound ? 0 : t.text.length;
            best.c += cost;
            best.ec = best.c;
            best.text = t;
            const segText = t || best.p?.text || toTextOffset("", best.i);
            const can = t ? { ...best, text: segText } : { ...best, ...best.p, text: segText };
            const f = addToKnownPaths(can, void 0);
            bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
          }
        }
        if (bestPath && bestPath.c < maxCost) {
          maxCost = bestPath.c;
        }
      }
      return pathToWords(bestPath);
    }
    function mergeSortedBreaks(...maps) {
      return [].concat(...maps).sort((a, b) => a.offset - b.offset);
    }
    exports.__testing__ = {
      generateWordBreaks,
      findNextWordText
    };
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/isWordValid.js
var require_isWordValid = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/isWordValid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.isWordValidWithEscapeRetry = void 0;
    function hasWordCheck(dict, word) {
      word = word.includes("\\") ? word.replace(/\\/g, "") : word;
      return dict.has(word);
    }
    function isWordValidWithEscapeRetry(dict, wo, line) {
      const firstTry = hasWordCheck(dict, wo.text);
      return firstTry || // Drop the first letter if it is preceded by a '\'.
      line.text[wo.offset - line.offset - 1] === "\\" && hasWordCheck(dict, wo.text.slice(1));
    }
    exports.isWordValidWithEscapeRetry = isWordValidWithEscapeRetry;
    exports.__testing__ = {
      hasWordCheck
    };
  }
});

// node_modules/cspell-lib/dist/cjs/util/TextMap.js
var require_TextMap = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/TextMap.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.doesIntersect = exports.extractTextMapRangeOrigin = void 0;
    var assert_1 = __importDefault(require("assert"));
    function extractTextMapRangeOrigin(textMap, extractRange) {
      const { text: srcTxt, range: srcRange, map: srcMap } = textMap;
      const [r0, r1] = srcRange;
      const startOrig = Math.min(Math.max(extractRange[0], r0), r1);
      const endOrig = Math.min(Math.max(extractRange[1], r0), r1);
      const a = startOrig - r0;
      const b = endOrig - r0;
      const range = [startOrig, endOrig];
      if (!srcMap || !srcMap.length || a === b) {
        const text2 = srcTxt.slice(a, b);
        return { text: text2, range };
      }
      (0, assert_1.default)((srcMap.length & 1) === 0, "Map must be pairs of values.");
      const mapLen = srcMap.length;
      const mapEndSrc = srcMap[mapLen - 2];
      const mapEndDst = srcMap[mapLen - 1];
      const endDiff = srcTxt.length - mapEndDst;
      const head = !srcMap[0] && !srcMap[1] ? [] : [0, 0];
      const tail = [mapEndSrc + endDiff, mapEndDst + endDiff];
      const sMap = head.concat(srcMap).concat(tail);
      let idx = 0;
      for (; idx < sMap.length && a >= sMap[idx]; idx += 2) {
      }
      const aIdx = idx;
      idx -= 2;
      const a0 = a - sMap[idx];
      const a1 = a0 + sMap[idx + 1];
      for (; idx < sMap.length && b > sMap[idx]; idx += 2) {
      }
      const bIdx = idx;
      const b0 = b - sMap[idx];
      const b1 = b0 + sMap[idx + 1];
      const text = srcTxt.slice(a1, b1);
      if (bIdx === aIdx) {
        return { text, range };
      }
      const ab = [a0, a1];
      const map = sMap.slice(aIdx, bIdx + 2).map((v, i) => v - ab[i & 1]);
      return { text, range, map };
    }
    exports.extractTextMapRangeOrigin = extractTextMapRangeOrigin;
    function doesIntersect(textMap, rangeOrigin) {
      const r = textMap.range;
      return r[0] < rangeOrigin[1] && r[1] > rangeOrigin[0];
    }
    exports.doesIntersect = doesIntersect;
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/parsedText.js
var require_parsedText = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/parsedText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMappedTextSegmenter = exports.mapRangeToLocal = exports.mapRangeBackToOriginalPos = exports.mapIssueBackToOriginalPos = void 0;
    var TextMap_js_1 = require_TextMap();
    function mapIssueBackToOriginalPos(mappedText, issue) {
      if (!mappedText.map || mappedText.map.length === 0)
        return issue;
      const textOff = mapTextOffsetBackToOriginalPos(mappedText, issue);
      return {
        ...issue,
        ...textOff
      };
    }
    exports.mapIssueBackToOriginalPos = mapIssueBackToOriginalPos;
    function mapTextOffsetBackToOriginalPos(mappedText, textOff) {
      if (!mappedText.map || !mappedText.map.length)
        return textOff;
      const off = textOff.offset - mappedText.range[0];
      const range = mapRangeBackToOriginalPos([off, off + (textOff.length ?? textOff.text.length)], mappedText.map);
      return {
        text: textOff.text,
        offset: mappedText.range[0] + range[0],
        length: range[1] - range[0]
      };
    }
    function mapRangeBackToOriginalPos(offRange, map) {
      if (!map || !map.length)
        return offRange;
      const [start, end] = offRange;
      let i = 0, j = 0, p = 1;
      while (p < map.length && map[p] < start) {
        i = map[p - 1];
        j = map[p];
        p += 2;
      }
      const iA = start - j + i;
      while (p < map.length && map[p] < end) {
        i = map[p - 1];
        j = map[p];
        p += 2;
      }
      const iB = end - j + i;
      return [iA, iB];
    }
    exports.mapRangeBackToOriginalPos = mapRangeBackToOriginalPos;
    function mapRangeToLocal(rangeOrig, map) {
      if (!map || !map.length)
        return rangeOrig;
      const [start, end] = rangeOrig;
      let i = 0, j = 0, p = 0;
      while (p < map.length && map[p] < start) {
        i = map[p];
        j = map[p + 1];
        p += 2;
      }
      const jA = start - i + j;
      while (p < map.length && map[p] < end) {
        i = map[p];
        j = map[p + 1];
        p += 2;
      }
      const jB = end - i + j;
      return [jA, jB];
    }
    exports.mapRangeToLocal = mapRangeToLocal;
    function createMappedTextSegmenter(includeRanges) {
      let rangePos = 0;
      function* segmenter(pText) {
        if (!includeRanges.length) {
          return;
        }
        const range = pText.range;
        const textEndPos = range[1];
        let textStartPos = range[0];
        while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
          rangePos -= 1;
        }
        const cur = includeRanges[rangePos];
        if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
          yield pText;
          return;
        }
        while (textStartPos < textEndPos) {
          while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
            rangePos += 1;
          }
          if (!includeRanges[rangePos]) {
            break;
          }
          const { startPos, endPos } = includeRanges[rangePos];
          if (textEndPos < startPos) {
            break;
          }
          const a = Math.max(textStartPos, startPos);
          const b = Math.min(textEndPos, endPos);
          if (a !== b) {
            yield (0, TextMap_js_1.extractTextMapRangeOrigin)(pText, [a, b]);
          }
          textStartPos = b;
        }
      }
      return segmenter;
    }
    exports.createMappedTextSegmenter = createMappedTextSegmenter;
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/lineValidatorFactory.js
var require_lineValidatorFactory = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/lineValidatorFactory.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.textValidatorFactory = exports.lineValidatorFactory = void 0;
    var sync_1 = require_sync();
    var cspell_dictionary_1 = require_cjs7();
    var RxPat = __importStar(require_RegExpPatterns());
    var Text2 = __importStar(require_text2());
    var util_js_1 = require_util();
    var wordSplitter_js_1 = require_wordSplitter();
    var defaultConstants_js_1 = require_defaultConstants();
    var isWordValid_js_1 = require_isWordValid();
    var parsedText_js_1 = require_parsedText();
    function lineValidatorFactory(sDict, options) {
      const { minWordLength = defaultConstants_js_1.defaultMinWordLength, flagWords = [], allowCompoundWords = false, ignoreCase = true } = options;
      const hasWordOptions = {
        ignoreCase,
        useCompounds: allowCompoundWords || void 0
        // let the dictionaries decide on useCompounds if allow is false
      };
      const dictCol = (0, cspell_dictionary_1.createCachingDictionary)(sDict, hasWordOptions);
      const setOfFlagWords = new Set(flagWords);
      const setOfKnownSuccessfulWords = /* @__PURE__ */ new Set();
      const rememberFilter = (fn2) => (v) => {
        const keep = fn2(v);
        if (!keep) {
          setOfKnownSuccessfulWords.add(v.text);
        }
        return keep;
      };
      const filterAlreadyChecked = (wo) => {
        return !setOfKnownSuccessfulWords.has(wo.text);
      };
      function testForFlaggedWord(wo) {
        const text = wo.text;
        return setOfFlagWords.has(text) || setOfFlagWords.has(text.toLowerCase()) || dictCol.isForbidden(text);
      }
      function isWordIgnored(word) {
        return dictCol.isNoSuggestWord(word);
      }
      function getSuggestions(word) {
        return dictCol.getPreferredSuggestions(word);
      }
      function isWordFlagged(word) {
        const isIgnored = isWordIgnored(word.text);
        const isFlagged = !isIgnored && testForFlaggedWord(word);
        return isFlagged;
      }
      function annotateIsFlagged(word) {
        word.isFlagged = isWordFlagged(word);
        return word;
      }
      function annotateIssue(issue) {
        const sugs = getSuggestions(issue.text);
        if (sugs && sugs.length) {
          issue.suggestionsEx = sugs;
        }
        return issue;
      }
      function checkWord(word) {
        const isIgnored = isWordIgnored(word.text);
        const { isFlagged = !isIgnored && testForFlaggedWord(word) } = word;
        const isFound = isFlagged ? void 0 : isIgnored || (0, isWordValid_js_1.isWordValidWithEscapeRetry)(dictCol, word, word.line);
        return (0, util_js_1.clean)({ ...word, isFlagged, isFound });
      }
      const fn = (lineSegment) => {
        function splitterIsValid(word) {
          return setOfKnownSuccessfulWords.has(word.text) || !testForFlaggedWord(word) && (0, isWordValid_js_1.isWordValidWithEscapeRetry)(dictCol, word, lineSegment.line);
        }
        function checkFullWord(vr) {
          if (vr.isFlagged) {
            return [vr];
          }
          const codeWordResults = (0, sync_1.toArray)((0, sync_1.pipe)(
            Text2.extractWordsFromCodeTextOffset(vr),
            (0, sync_1.opFilter)(filterAlreadyChecked),
            (0, sync_1.opMap)((t) => ({ ...t, line: vr.line })),
            (0, sync_1.opMap)(annotateIsFlagged),
            (0, sync_1.opFilter)(rememberFilter((wo) => wo.text.length >= minWordLength || !!wo.isFlagged)),
            (0, sync_1.opMap)((wo) => wo.isFlagged ? wo : checkWord(wo)),
            (0, sync_1.opFilter)(rememberFilter((wo) => wo.isFlagged || !wo.isFound)),
            (0, sync_1.opFilter)(rememberFilter((wo) => !RxPat.regExRepeatedChar.test(wo.text))),
            // get back the original text.
            (0, sync_1.opMap)((wo) => ({
              ...wo,
              text: Text2.extractText(lineSegment.segment, wo.offset, wo.offset + wo.text.length)
            }))
          ));
          if (!codeWordResults.length || isWordIgnored(vr.text) || checkWord(vr).isFound) {
            rememberFilter((_) => false)(vr);
            return [];
          }
          return codeWordResults;
        }
        function checkPossibleWords(possibleWord) {
          if (isWordFlagged(possibleWord)) {
            const vr = {
              ...possibleWord,
              line: lineSegment.line,
              isFlagged: true
            };
            return [vr];
          }
          const mismatches = (0, sync_1.toArray)((0, sync_1.pipe)(Text2.extractWordsFromTextOffset(possibleWord), (0, sync_1.opFilter)(filterAlreadyChecked), (0, sync_1.opMap)((wo) => ({ ...wo, line: lineSegment.line })), (0, sync_1.opMap)(annotateIsFlagged), (0, sync_1.opFilter)(rememberFilter((wo) => wo.text.length >= minWordLength || !!wo.isFlagged)), (0, sync_1.opConcatMap)(checkFullWord)));
          if (mismatches.length) {
            const splitResult = (0, wordSplitter_js_1.split)(lineSegment.segment, possibleWord.offset, splitterIsValid);
            const nonMatching = splitResult.words.filter((w) => !w.isFound);
            if (nonMatching.length < mismatches.length) {
              return nonMatching.map((w) => ({ ...w, line: lineSegment.line })).map(annotateIsFlagged);
            }
          }
          return mismatches;
        }
        const checkedPossibleWords = (0, sync_1.pipe)(Text2.extractPossibleWordsFromTextOffset(lineSegment.segment), (0, sync_1.opFilter)(filterAlreadyChecked), (0, sync_1.opConcatMap)(checkPossibleWords), (0, sync_1.opMap)(annotateIssue));
        return checkedPossibleWords;
      };
      return { fn, dict: dictCol };
    }
    exports.lineValidatorFactory = lineValidatorFactory;
    function textValidatorFactory(dict, options) {
      const lineValidator = lineValidatorFactory(dict, options);
      const lineValidatorFn = lineValidator.fn;
      function validate2(pText) {
        const { text, range: srcRange, map } = pText;
        const srcOffset = srcRange[0];
        const segment = { text, offset: 0 };
        const lineSegment = { line: segment, segment };
        function mapBackToOriginSimple(vr) {
          const { text: text2, offset, isFlagged, isFound, suggestionsEx } = vr;
          const r = (0, parsedText_js_1.mapRangeBackToOriginalPos)([offset, offset + text2.length], map);
          const range = [r[0] + srcOffset, r[1] + srcOffset];
          return { text: text2, range, isFlagged, isFound, suggestionsEx };
        }
        return [...lineValidatorFn(lineSegment)].map(mapBackToOriginSimple);
      }
      return {
        validate: validate2,
        lineValidator
      };
    }
    exports.textValidatorFactory = textValidatorFactory;
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/settingsToValidateOptions.js
var require_settingsToValidateOptions = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/settingsToValidateOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.settingsToValidateOptions = void 0;
    function settingsToValidateOptions(settings) {
      const opt = {
        ...settings,
        ignoreCase: !(settings.caseSensitive ?? false)
      };
      return opt;
    }
    exports.settingsToValidateOptions = settingsToValidateOptions;
  }
});

// node_modules/cspell-lib/dist/cjs/util/TextRange.js
var require_TextRange = __commonJS({
  "node_modules/cspell-lib/dist/cjs/util/TextRange.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.extractRangeText = exports.excludeRanges = exports.findMatchingRangesForPatterns = exports.unionRanges = exports.findMatchingRanges = void 0;
    var GS = __importStar(require_dist2());
    function toMatchRangeWithText(m) {
      const index = m.index || 0;
      const _text = m[0];
      return {
        startPos: index,
        endPos: index + _text.length,
        text: _text
      };
    }
    function findMatchingRanges(pattern, text) {
      if (pattern.source === ".*") {
        return [{ startPos: 0, endPos: text.length }];
      }
      const regex = new RegExp(pattern);
      if (!regex.global) {
        const m = text.match(regex);
        if (!m)
          return [];
        return [toMatchRangeWithText(m)];
      }
      return [...text.matchAll(regex)].map(toMatchRangeWithText);
    }
    exports.findMatchingRanges = findMatchingRanges;
    function compareRanges(a, b) {
      return a.startPos - b.startPos || a.endPos - b.endPos;
    }
    function unionRanges(ranges) {
      return makeSortedMatchRangeArray([..._unionRanges(ranges)]);
    }
    exports.unionRanges = unionRanges;
    function* _unionRanges(ranges) {
      const sortedRanges = sortMatchRangeArray(ranges);
      if (!sortedRanges.length)
        return;
      let { startPos, endPos } = sortedRanges[0];
      for (const r of ranges) {
        if (r.startPos > endPos) {
          yield { startPos, endPos };
          startPos = r.startPos;
          endPos = r.endPos;
          continue;
        }
        endPos = Math.max(endPos, r.endPos);
      }
      if (startPos < endPos) {
        yield { startPos, endPos };
      }
    }
    function findMatchingRangesForPatterns(patterns, text) {
      const matchedPatterns = GS.genSequence(patterns).concatMap((pattern) => findMatchingRanges(pattern, text));
      return unionRanges(matchedPatterns.toArray());
    }
    exports.findMatchingRangesForPatterns = findMatchingRangesForPatterns;
    function excludeRanges(includeRanges, excludeRanges2) {
      return [..._excludeRanges(sortMatchRangeArray(includeRanges), sortMatchRangeArray(excludeRanges2))];
    }
    exports.excludeRanges = excludeRanges;
    function* _excludeRanges(includeRanges, excludeRanges2) {
      if (!includeRanges.length)
        return;
      if (!excludeRanges2.length) {
        yield* includeRanges;
        return;
      }
      let exIndex = 0;
      const limit = excludeRanges2.length;
      for (const incRange of includeRanges) {
        const endPos = incRange.endPos;
        let startPos = incRange.startPos;
        for (; exIndex < limit; ++exIndex) {
          const ex = excludeRanges2[exIndex];
          if (ex.startPos >= endPos)
            break;
          if (ex.endPos <= startPos)
            continue;
          if (ex.startPos > startPos) {
            yield { startPos, endPos: ex.startPos };
          }
          startPos = ex.endPos;
          if (startPos >= endPos)
            break;
        }
        if (startPos < endPos) {
          yield { startPos, endPos };
        }
      }
    }
    function extractRangeText(text, ranges) {
      return ranges.map(({ startPos, endPos }) => ({
        startPos,
        endPos,
        text: text.slice(startPos, endPos)
      }));
    }
    exports.extractRangeText = extractRangeText;
    var SymSortedMatchRangeArray = Symbol("SortedMatchRangeArray");
    function sortMatchRangeArray(values) {
      if (isSortedMatchRangeArray(values))
        return values;
      return makeSortedMatchRangeArray(values.sort(compareRanges));
    }
    function isSortedMatchRangeArray(a) {
      return a[SymSortedMatchRangeArray] === true;
    }
    function makeSortedMatchRangeArray(sortedValues) {
      const sorted = sortedValues;
      sorted[SymSortedMatchRangeArray] = true;
      Object.freeze(sorted);
      return sorted;
    }
    exports.__testing__ = {
      makeSortedMatchRangeArray
    };
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/textValidator.js
var require_textValidator = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/textValidator.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._testMethods = exports.mapLineSegmentAgainstRangesFactory = exports.calcTextInclusionRanges = exports.validateText = void 0;
    var sync_1 = require_sync();
    var Text2 = __importStar(require_text2());
    var TextRange = __importStar(require_TextRange());
    var defaultConstants_js_1 = require_defaultConstants();
    var lineValidatorFactory_js_1 = require_lineValidatorFactory();
    function validateText(text, dict, options) {
      const { maxNumberOfProblems = defaultConstants_js_1.defaultMaxNumberOfProblems, maxDuplicateProblems = defaultConstants_js_1.defaultMaxDuplicateProblems } = options;
      const mapOfProblems = /* @__PURE__ */ new Map();
      const includeRanges = calcTextInclusionRanges(text, options);
      const lineValidator = (0, lineValidatorFactory_js_1.lineValidatorFactory)(dict, options);
      const validator = lineValidator.fn;
      const iter = (0, sync_1.pipe)(Text2.extractLinesOfText(text), (0, sync_1.opConcatMap)(mapLineToLineSegments(includeRanges)), (0, sync_1.opConcatMap)(validator), (0, sync_1.opFilter)((wo) => {
        const word = wo.text;
        const n = (mapOfProblems.get(word) || 0) + 1;
        mapOfProblems.set(word, n);
        return n <= maxDuplicateProblems;
      }), (0, sync_1.opTake)(maxNumberOfProblems));
      return iter;
    }
    exports.validateText = validateText;
    function calcTextInclusionRanges(text, options) {
      const { ignoreRegExpList = [], includeRegExpList = [] } = options;
      const filteredIncludeList = includeRegExpList.filter((a) => !!a);
      const finalIncludeList = filteredIncludeList.length ? filteredIncludeList : [/.*/gim];
      const includeRanges = TextRange.excludeRanges(TextRange.findMatchingRangesForPatterns(finalIncludeList, text), TextRange.findMatchingRangesForPatterns(ignoreRegExpList, text));
      return includeRanges;
    }
    exports.calcTextInclusionRanges = calcTextInclusionRanges;
    function mapLineToLineSegments(includeRanges) {
      const mapAgainstRanges = mapLineSegmentAgainstRangesFactory(includeRanges);
      return (line) => {
        const segment = { line, segment: line };
        return mapAgainstRanges(segment);
      };
    }
    function mapLineSegmentAgainstRangesFactory(includeRanges) {
      let rangePos = 0;
      const mapper = (lineSeg) => {
        if (!includeRanges.length) {
          return [];
        }
        const parts = [];
        const { segment, line } = lineSeg;
        const { text, offset, length } = segment;
        const textEndPos = offset + (length ?? text.length);
        let textStartPos = offset;
        while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
          rangePos -= 1;
        }
        const cur = includeRanges[rangePos];
        if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
          return [lineSeg];
        }
        while (textStartPos < textEndPos) {
          while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
            rangePos += 1;
          }
          if (!includeRanges[rangePos]) {
            break;
          }
          const { startPos, endPos } = includeRanges[rangePos];
          if (textEndPos < startPos) {
            break;
          }
          const a = Math.max(textStartPos, startPos);
          const b = Math.min(textEndPos, endPos);
          if (a !== b) {
            parts.push({ line, segment: { offset: a, text: text.slice(a - offset, b - offset) } });
          }
          textStartPos = b;
        }
        return parts;
      };
      return mapper;
    }
    exports.mapLineSegmentAgainstRangesFactory = mapLineSegmentAgainstRangesFactory;
    exports._testMethods = {
      mapWordsAgainstRanges: mapLineSegmentAgainstRangesFactory
    };
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/docValidator.js
var require_docValidator = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/docValidator.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__testing__ = exports.shouldCheckDocument = exports.DocumentValidator = void 0;
    var sync_1 = require_sync();
    var cspell_types_1 = require_cjs9();
    var assert_1 = __importDefault(require("assert"));
    var cspell_glob_1 = require_cjs();
    var path_1 = __importDefault(require("path"));
    var TextDocument_js_1 = require_TextDocument();
    var index_js_1 = require_configLoader2();
    var index_js_2 = require_Settings();
    var InDocSettings_js_1 = require_InDocSettings();
    var index_js_3 = require_SpellingDictionary4();
    var suggestions_js_1 = require_suggestions();
    var errors_js_1 = require_errors3();
    var simpleCache_js_1 = require_simpleCache2();
    var timer_js_1 = require_timer2();
    var Uri_js_1 = require_Uri();
    var defaultConstants_js_1 = require_defaultConstants();
    var determineTextDocumentSettings_js_1 = require_determineTextDocumentSettings();
    var lineValidatorFactory_js_1 = require_lineValidatorFactory();
    var parsedText_js_1 = require_parsedText();
    var settingsToValidateOptions_js_1 = require_settingsToValidateOptions();
    var textValidator_js_1 = require_textValidator();
    var ERROR_NOT_PREPARED = "Validator Must be prepared before calling this function.";
    var skipValidation = false;
    var DocumentValidator = class {
      /**
       * @param doc - Document to validate
       * @param config - configuration to use (not finalized).
       */
      constructor(doc, options, settings) {
        this.settings = settings;
        this._ready = false;
        this.errors = [];
        this._preparationTime = -1;
        this._suggestions = new simpleCache_js_1.AutoCache((text) => this.genSuggestions(text), 1e3);
        this._document = doc;
        this.options = { ...options };
        const numSuggestions = this.options.numSuggestions ?? settings.numSuggestions;
        if (numSuggestions !== void 0) {
          this.options.numSuggestions = numSuggestions;
        }
      }
      get ready() {
        return this._ready;
      }
      /**
       * Prepare to validate a document.
       * This will load all the necessary configuration and dictionaries.
       *
       * @deprecated
       * @deprecationMessage Use the async `prepare` method.
       */
      prepareSync() {
        if (this._ready)
          return;
        const timer = (0, timer_js_1.createTimer)();
        const { options, settings } = this;
        const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
        const optionsConfigFile = options.configFile;
        const localConfigFn = optionsConfigFile ? () => (0, index_js_1.loadConfigSync)(optionsConfigFile, settings) : useSearchForConfig ? () => searchForDocumentConfigSync(this._document, settings, settings) : void 0;
        const localConfig = localConfigFn && (0, errors_js_1.wrapCall)(localConfigFn, (e) => this.addPossibleError(e))();
        this.addPossibleError(localConfig?.__importRef?.error);
        const config = (0, index_js_2.mergeSettings)(settings, localConfig);
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(this._document, config);
        const dict = (0, index_js_3.getDictionaryInternalSync)(docSettings);
        const matcher = new cspell_glob_1.GlobMatcher(localConfig?.ignorePaths || [], { root: process.cwd(), dot: true });
        const uri = this._document.uri;
        const shouldCheck = !matcher.match((0, Uri_js_1.uriToFilePath)(uri)) && (docSettings.enabled ?? true);
        const finalSettings = (0, index_js_2.finalizeSettings)(docSettings);
        const validateOptions = (0, settingsToValidateOptions_js_1.settingsToValidateOptions)(finalSettings);
        const includeRanges = (0, textValidator_js_1.calcTextInclusionRanges)(this._document.text, validateOptions);
        const segmenter = (0, parsedText_js_1.createMappedTextSegmenter)(includeRanges);
        const textValidator = (0, lineValidatorFactory_js_1.textValidatorFactory)(dict, validateOptions);
        this._preparations = {
          config,
          dictionary: dict,
          docSettings,
          finalSettings,
          shouldCheck,
          validateOptions,
          includeRanges,
          segmenter,
          textValidator,
          localConfig,
          localConfigFilepath: localConfig?.__importRef?.filename
        };
        this._ready = true;
        this._preparationTime = timer.elapsed();
      }
      async prepare() {
        if (this._ready)
          return;
        if (this._prepared)
          return this._prepared;
        this._prepared = this._prepareAsync();
        return this._prepared;
      }
      async _prepareAsync() {
        (0, assert_1.default)(!this._ready);
        const timer = (0, timer_js_1.createTimer)();
        const { options, settings } = this;
        const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
        const pLocalConfig = options.configFile ? (0, index_js_2.loadConfig)(options.configFile, settings) : useSearchForConfig ? searchForDocumentConfig(this._document, settings, settings) : void 0;
        const localConfig = await (0, errors_js_1.catchPromiseError)(pLocalConfig, (e) => this.addPossibleError(e)) || {};
        this.addPossibleError(localConfig?.__importRef?.error);
        const config = (0, index_js_2.mergeSettings)(settings, localConfig);
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(this._document, config);
        const dict = await (0, index_js_3.getDictionaryInternal)(docSettings);
        const matcher = new cspell_glob_1.GlobMatcher(localConfig?.ignorePaths || [], { root: process.cwd(), dot: true });
        const uri = this._document.uri;
        const shouldCheck = !matcher.match((0, Uri_js_1.uriToFilePath)(uri)) && (docSettings.enabled ?? true);
        const finalSettings = (0, index_js_2.finalizeSettings)(docSettings);
        const validateOptions = (0, settingsToValidateOptions_js_1.settingsToValidateOptions)(finalSettings);
        const includeRanges = (0, textValidator_js_1.calcTextInclusionRanges)(this._document.text, validateOptions);
        const segmenter = (0, parsedText_js_1.createMappedTextSegmenter)(includeRanges);
        const textValidator = (0, lineValidatorFactory_js_1.textValidatorFactory)(dict, validateOptions);
        this._preparations = {
          config,
          dictionary: dict,
          docSettings,
          finalSettings,
          shouldCheck,
          validateOptions,
          includeRanges,
          segmenter,
          textValidator,
          localConfig,
          localConfigFilepath: localConfig?.__importRef?.filename
        };
        this._ready = true;
        this._preparationTime = timer.elapsed();
      }
      _updatePrep() {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const timer = (0, timer_js_1.createTimer)();
        const prep = this._preparations;
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(this._document, prep.config);
        const dict = (0, index_js_3.getDictionaryInternalSync)(docSettings);
        const shouldCheck = docSettings.enabled ?? true;
        const finalSettings = (0, index_js_2.finalizeSettings)(docSettings);
        const validateOptions = (0, settingsToValidateOptions_js_1.settingsToValidateOptions)(finalSettings);
        const includeRanges = (0, textValidator_js_1.calcTextInclusionRanges)(this._document.text, validateOptions);
        const segmenter = (0, parsedText_js_1.createMappedTextSegmenter)(includeRanges);
        const textValidator = (0, lineValidatorFactory_js_1.textValidatorFactory)(dict, validateOptions);
        this._preparations = {
          ...prep,
          dictionary: dict,
          docSettings,
          shouldCheck,
          validateOptions,
          includeRanges,
          segmenter,
          textValidator
        };
        this._preparationTime = timer.elapsed();
      }
      /**
       * The amount of time in ms to prepare for validation.
       */
      get prepTime() {
        return this._preparationTime;
      }
      get validateDirectives() {
        return this.options.validateDirectives ?? this._preparations?.config.validateDirectives ?? false;
      }
      checkText(range, _text, scope) {
        const text = this._document.text.slice(range[0], range[1]);
        return this.check({ text, range, scope: scope.join(" ") });
      }
      check(parsedText) {
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const { segmenter, textValidator } = this._preparations;
        const document = this._document;
        let line = void 0;
        function mapToIssue(issue) {
          const { range, text, isFlagged, isFound, suggestionsEx } = issue;
          const offset = range[0];
          const length = range[1] - range[0];
          (0, assert_1.default)(!line || line.offset <= offset);
          if (!line || line.offset + line.text.length <= offset) {
            line = document.lineAt(offset);
          }
          return { text, offset, line, length, isFlagged, isFound, suggestionsEx };
        }
        const issues = [...(0, sync_1.pipeSync)(segmenter(parsedText), (0, sync_1.opConcatMap)(textValidator.validate), (0, sync_1.opMap)(mapToIssue))];
        if (!this.options.generateSuggestions) {
          return issues.map((issue) => {
            if (!issue.suggestionsEx)
              return issue;
            const suggestionsEx = this.adjustSuggestions(issue.text, issue.suggestionsEx);
            const suggestions = suggestionsEx.map((s) => s.word);
            return { ...issue, suggestionsEx, suggestions };
          });
        }
        const withSugs = issues.map((t) => {
          const text = t.text;
          const suggestionsEx = this.getSuggestions(text);
          t.suggestionsEx = suggestionsEx;
          t.suggestions = suggestionsEx.map((s) => s.word);
          return t;
        });
        return withSugs;
      }
      /**
       * Check a Document for Validation Issues.
       * @param forceCheck - force a check even if the document would normally be excluded.
       * @returns the validation issues.
       */
      async checkDocumentAsync(forceCheck) {
        await this.prepare();
        return this.checkDocument(forceCheck);
      }
      /**
       * Check a Document for Validation Issues.
       *
       * Note: The validator must be prepared before calling this method.
       * @param forceCheck - force a check even if the document would normally be excluded.
       * @returns the validation issues.
       */
      checkDocument(forceCheck = false) {
        if (skipValidation)
          return [];
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const spellingIssues = forceCheck || this.shouldCheckDocument() ? [...this._checkParsedText(this._parse())] : [];
        const directiveIssues = this.checkDocumentDirectives();
        const allIssues = spellingIssues.concat(directiveIssues).sort((a, b) => a.offset - b.offset);
        return allIssues;
      }
      checkDocumentDirectives(forceCheck = false) {
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const validateDirectives = forceCheck || this.validateDirectives;
        if (!validateDirectives)
          return [];
        const document = this.document;
        const issueType = cspell_types_1.IssueType.directive;
        function toValidationIssue(dirIssue) {
          const { text, range, suggestions, suggestionsEx, message } = dirIssue;
          const offset = range[0];
          const pos = document.positionAt(offset);
          const line = document.getLine(pos.line);
          const issue = { text, offset, line, suggestions, suggestionsEx, message, issueType };
          return issue;
        }
        return [...(0, InDocSettings_js_1.validateInDocumentSettings)(this.document.text, this._preparations.config)].map(toValidationIssue);
      }
      get document() {
        return this._document;
      }
      updateDocumentText(text) {
        (0, TextDocument_js_1.updateTextDocument)(this._document, [{ text }]);
        this._updatePrep();
      }
      defaultParser() {
        return (0, sync_1.pipeSync)(this.document.getLines(), (0, sync_1.opMap)((line) => {
          const { text, offset } = line;
          const range = [offset, offset + text.length];
          return { text, range };
        }));
      }
      *_checkParsedText(parsedTexts) {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const { maxNumberOfProblems = defaultConstants_js_1.defaultMaxNumberOfProblems, maxDuplicateProblems = defaultConstants_js_1.defaultMaxDuplicateProblems } = this._preparations.validateOptions;
        let numProblems = 0;
        const mapOfProblems = /* @__PURE__ */ new Map();
        for (const pText of parsedTexts) {
          for (const issue of this.check(pText)) {
            const { text } = issue;
            const n = (mapOfProblems.get(text) || 0) + 1;
            mapOfProblems.set(text, n);
            if (n > maxDuplicateProblems)
              continue;
            yield issue;
            if (++numProblems >= maxNumberOfProblems)
              return;
          }
        }
      }
      addPossibleError(error2) {
        if (!error2)
          return;
        error2 = this.errors.push((0, errors_js_1.toError)(error2));
      }
      _parse() {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const parser = this._preparations.finalSettings.parserFn;
        if (typeof parser !== "object")
          return this.defaultParser();
        return parser.parse(this.document.text, this.document.uri.path).parsedTexts;
      }
      getSuggestions(text) {
        return this._suggestions.get(text);
      }
      genSuggestions(text) {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const settings = this._preparations.docSettings;
        const dict = this._preparations.dictionary;
        const sugOptions = {
          compoundMethod: 0,
          numSuggestions: this.options.numSuggestions,
          includeTies: false,
          ignoreCase: !(settings.caseSensitive ?? false),
          timeout: settings.suggestionsTimeout,
          numChanges: settings.suggestionNumChanges
        };
        const rawSuggestions = dict.suggest(text, sugOptions);
        return this.adjustSuggestions(text, rawSuggestions);
      }
      adjustSuggestions(text, rawSuggestions) {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        const settings = this._preparations.docSettings;
        const ignoreCase = !(settings.caseSensitive ?? false);
        const locale = this._preparations.config.language;
        const dict = this._preparations.dictionary;
        const sugsWithAlt = (0, suggestions_js_1.calcSuggestionAdjustedToToMatchCase)(text, rawSuggestions.map(mapSug), locale, ignoreCase, dict);
        return sugsWithAlt.map(sanitizeSuggestion);
      }
      getFinalizedDocSettings() {
        (0, assert_1.default)(this._ready);
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        return this._preparations.docSettings;
      }
      /**
       * Returns true if the final result of the configuration calculation results
       * in the document being enabled. Note: in some cases, checking the document
       * might still make sense, for example, the `@cspell/eslint-plugin` relies on
       * `eslint` configuration to make that determination.
       * @returns true if the document settings have resolved to be `enabled`
       */
      shouldCheckDocument() {
        (0, assert_1.default)(this._preparations, ERROR_NOT_PREPARED);
        return this._preparations.shouldCheck;
      }
      /**
       * Internal `cspell-lib` use.
       */
      _getPreparations() {
        return this._preparations;
      }
    };
    exports.DocumentValidator = DocumentValidator;
    function sanitizeSuggestion(sug) {
      const { word, isPreferred, wordAdjustedToMatchCase } = sug;
      if (isPreferred && wordAdjustedToMatchCase)
        return { word, wordAdjustedToMatchCase, isPreferred };
      if (isPreferred)
        return { word, isPreferred };
      if (wordAdjustedToMatchCase)
        return { word, wordAdjustedToMatchCase };
      return { word };
    }
    async function searchForDocumentConfig(document, defaultConfig, pnpSettings) {
      const { uri } = document;
      if (uri.scheme !== "file")
        return Promise.resolve(defaultConfig);
      return (0, index_js_2.searchForConfig)(path_1.default.dirname((0, Uri_js_1.uriToFilePath)(uri)), pnpSettings).then((s) => s || defaultConfig);
    }
    function mapSug(sug) {
      return { cost: 999, ...sug };
    }
    function searchForDocumentConfigSync(document, defaultConfig, pnpSettings) {
      const { uri } = document;
      if (uri.scheme !== "file")
        defaultConfig;
      return (0, index_js_1.searchForConfigSync)((0, Uri_js_1.uriToFilePath)(uri), pnpSettings) || defaultConfig;
    }
    async function shouldCheckDocument2(doc, options, settings) {
      const errors = [];
      function addPossibleError(error2) {
        if (!error2)
          return void 0;
        error2 = errors.push((0, errors_js_1.toError)(error2));
        return void 0;
      }
      async function shouldCheck() {
        const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
        const pLocalConfig = options.configFile ? (0, index_js_2.loadConfig)(options.configFile, settings) : useSearchForConfig ? searchForDocumentConfig(doc, settings, settings) : void 0;
        const localConfig = await (0, errors_js_1.catchPromiseError)(pLocalConfig, addPossibleError) || {};
        addPossibleError(localConfig?.__importRef?.error);
        const config = (0, index_js_2.mergeSettings)(settings, localConfig);
        const matcher = new cspell_glob_1.GlobMatcher(localConfig?.ignorePaths || [], { root: process.cwd(), dot: true });
        const docSettings = (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(doc, config);
        const uri = doc.uri;
        return !matcher.match((0, Uri_js_1.uriToFilePath)(uri)) && (docSettings.enabled ?? true);
      }
      return { errors, shouldCheck: await shouldCheck() };
    }
    exports.shouldCheckDocument = shouldCheckDocument2;
    exports.__testing__ = {
      sanitizeSuggestion
    };
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/validator.js
var require_validator = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/validator.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateText = exports.diagSource = void 0;
    var cspell_types_1 = require_cjs9();
    var TextDocument_js_1 = require_TextDocument();
    var Settings = __importStar(require_Settings());
    var InDocSettings_js_1 = require_InDocSettings();
    var index_js_1 = require_SpellingDictionary4();
    var settingsToValidateOptions_js_1 = require_settingsToValidateOptions();
    var textValidator_js_1 = require_textValidator();
    exports.diagSource = "cSpell Checker";
    async function validateText(text, settings, options = {}) {
      const finalSettings = Settings.finalizeSettings(settings);
      const dict = await (0, index_js_1.getDictionaryInternal)(finalSettings);
      const spellingIssues = [...(0, textValidator_js_1.validateText)(text, dict, (0, settingsToValidateOptions_js_1.settingsToValidateOptions)(finalSettings))];
      const validationIssues = options.validateDirectives || finalSettings.validateDirectives ? (0, InDocSettings_js_1.validateInDocumentSettings)(text, settings) : [];
      const issues = spellingIssues.concat(mapValidationIssues(text, validationIssues));
      if (!options.generateSuggestions) {
        return issues;
      }
      const sugOptions = {
        numSuggestions: options.numSuggestions,
        compoundMethod: index_js_1.CompoundWordsMethod.NONE,
        includeTies: false,
        ignoreCase: !(settings.caseSensitive ?? false),
        timeout: settings.suggestionsTimeout,
        numChanges: settings.suggestionNumChanges
      };
      const withSugs = issues.map((t) => {
        const text2 = t.text;
        const suggestionsEx = dict.suggest(text2, sugOptions).map(({ word, isPreferred }) => isPreferred ? { word, isPreferred } : { word });
        t.suggestions = suggestionsEx.map((s) => s.word);
        t.suggestionsEx = suggestionsEx;
        return t;
      });
      return withSugs;
    }
    exports.validateText = validateText;
    function mapValidationIssues(text, valIssues) {
      const issues = [...valIssues];
      if (!issues.length)
        return [];
      const document = (0, TextDocument_js_1.createTextDocument)({ uri: "", content: text });
      const issueType = cspell_types_1.IssueType.directive;
      function toValidationIssue(dirIssue) {
        const { text: text2, range, suggestions, suggestionsEx, message } = dirIssue;
        const offset = range[0];
        const pos = document.positionAt(offset);
        const line = document.getLine(pos.line);
        const issue = { text: text2, offset, line, suggestions, suggestionsEx, message, issueType };
        return issue;
      }
      return issues.map(toValidationIssue);
    }
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/checkText.js
var require_checkText = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/checkText.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.genCheckText = exports.checkTextDocument = exports.IncludeExcludeFlag = exports.checkTextOld = exports.checkText = void 0;
    var assert_1 = __importDefault(require("assert"));
    var resolveDocument_js_1 = require_resolveDocument();
    var TextDocument_js_1 = require_TextDocument();
    var Settings = __importStar(require_Settings());
    var util_js_1 = require_util();
    var docValidator_js_1 = require_docValidator();
    var textValidator_js_1 = require_textValidator();
    var validator_js_1 = require_validator();
    async function checkText(text, settings) {
      const languageId = settings.languageId || "plaintext";
      const doc = (0, util_js_1.clean)({
        uri: "",
        text,
        languageId: Array.isArray(languageId) ? languageId.join(",") : languageId,
        locale: settings.language
      });
      return checkTextDocument2(doc, { noConfigSearch: true }, { loadDefaultConfiguration: false, ...settings });
    }
    exports.checkText = checkText;
    async function checkTextOld(text, settings) {
      const validationResult = (0, validator_js_1.validateText)(text, settings);
      const finalSettings = Settings.finalizeSettings(settings);
      const includeRanges = (0, textValidator_js_1.calcTextInclusionRanges)(text, finalSettings);
      const issues = await validationResult;
      return genResult(text, issues, includeRanges);
    }
    exports.checkTextOld = checkTextOld;
    var IncludeExcludeFlag2;
    (function(IncludeExcludeFlag3) {
      IncludeExcludeFlag3["INCLUDE"] = "I";
      IncludeExcludeFlag3["EXCLUDE"] = "E";
    })(IncludeExcludeFlag2 || (exports.IncludeExcludeFlag = IncludeExcludeFlag2 = {}));
    async function checkTextDocument2(doc, options, settings = {}) {
      doc = (0, TextDocument_js_1.isTextDocument)(doc) ? doc : await (0, resolveDocument_js_1.resolveDocumentToTextDocument)(doc);
      return genCheckText(new docValidator_js_1.DocumentValidator(doc, options, settings));
    }
    exports.checkTextDocument = checkTextDocument2;
    async function genCheckText(docValidator) {
      await docValidator.prepare();
      const issues = docValidator.checkDocument(true);
      const preparations = docValidator._getPreparations();
      (0, assert_1.default)(preparations);
      return genResult(docValidator.document.text, issues, preparations.includeRanges);
    }
    exports.genCheckText = genCheckText;
    function genResult(text, issues, includeRanges) {
      const result = [];
      let lastPos = 0;
      for (const { startPos, endPos } of includeRanges) {
        result.push({
          text: text.slice(lastPos, startPos),
          startPos: lastPos,
          endPos: startPos,
          flagIE: IncludeExcludeFlag2.EXCLUDE
        });
        result.push({
          text: text.slice(startPos, endPos),
          startPos,
          endPos,
          flagIE: IncludeExcludeFlag2.INCLUDE
        });
        lastPos = endPos;
      }
      result.push({
        text: text.slice(lastPos),
        startPos: lastPos,
        endPos: text.length,
        flagIE: IncludeExcludeFlag2.EXCLUDE
      });
      function* merge() {
        let i = 0;
        for (const r of result) {
          if (i >= issues.length || issues[i].offset >= r.endPos) {
            yield r;
            continue;
          }
          const span = { ...r };
          while (i < issues.length && issues[i].offset < span.endPos) {
            const issue = issues[i];
            const endPos = issue.offset;
            const text2 = span.text.slice(0, endPos - span.startPos);
            const endPosError = issue.offset + issue.text.length;
            yield { ...span, text: text2, endPos };
            yield {
              ...span,
              isError: true,
              startPos: issue.offset,
              endPos: endPosError,
              text: issue.text
            };
            span.text = span.text.slice(endPosError - span.startPos);
            span.startPos = endPosError;
            i += 1;
          }
          yield span;
        }
      }
      return {
        text,
        items: [...merge()].filter((i) => i.startPos < i.endPos)
      };
    }
  }
});

// node_modules/cspell-lib/dist/cjs/textValidation/index.js
var require_textValidation = __commonJS({
  "node_modules/cspell-lib/dist/cjs/textValidation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateText = exports.calcTextInclusionRanges = exports.shouldCheckDocument = exports.DocumentValidator = exports.IncludeExcludeFlag = exports.checkTextDocument = exports.checkText = void 0;
    var checkText_js_1 = require_checkText();
    Object.defineProperty(exports, "checkText", { enumerable: true, get: function() {
      return checkText_js_1.checkText;
    } });
    Object.defineProperty(exports, "checkTextDocument", { enumerable: true, get: function() {
      return checkText_js_1.checkTextDocument;
    } });
    Object.defineProperty(exports, "IncludeExcludeFlag", { enumerable: true, get: function() {
      return checkText_js_1.IncludeExcludeFlag;
    } });
    var docValidator_js_1 = require_docValidator();
    Object.defineProperty(exports, "DocumentValidator", { enumerable: true, get: function() {
      return docValidator_js_1.DocumentValidator;
    } });
    Object.defineProperty(exports, "shouldCheckDocument", { enumerable: true, get: function() {
      return docValidator_js_1.shouldCheckDocument;
    } });
    var textValidator_js_1 = require_textValidator();
    Object.defineProperty(exports, "calcTextInclusionRanges", { enumerable: true, get: function() {
      return textValidator_js_1.calcTextInclusionRanges;
    } });
    var validator_js_1 = require_validator();
    Object.defineProperty(exports, "validateText", { enumerable: true, get: function() {
      return validator_js_1.validateText;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/spellCheckFile.js
var require_spellCheckFile = __commonJS({
  "node_modules/cspell-lib/dist/cjs/spellCheckFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.determineFinalDocumentSettings = exports.spellCheckDocument = exports.spellCheckFile = void 0;
    var isBinaryDoc_js_1 = require_isBinaryDoc();
    var resolveDocument_js_1 = require_resolveDocument();
    var TextDocument_js_1 = require_TextDocument();
    var determineTextDocumentSettings_js_1 = require_determineTextDocumentSettings();
    var index_js_1 = require_textValidation();
    var errors_js_1 = require_errors3();
    var Uri_js_1 = require_Uri();
    function spellCheckFile(file, options, settings) {
      const doc = {
        uri: (0, Uri_js_1.toUri)(file).toString()
      };
      return spellCheckDocument2(doc, options, settings);
    }
    exports.spellCheckFile = spellCheckFile;
    async function spellCheckDocument2(document, options, settings) {
      if ((0, isBinaryDoc_js_1.isBinaryDoc)(document)) {
        return {
          document,
          options,
          settingsUsed: settings,
          localConfigFilepath: void 0,
          issues: [],
          checked: false,
          errors: void 0
        };
      }
      try {
        return spellCheckFullDocument(await (0, resolveDocument_js_1.resolveDocument)(document), options, settings);
      } catch (e) {
        const errors = (0, errors_js_1.isError)(e) ? [e] : [];
        return {
          document,
          options,
          settingsUsed: settings,
          localConfigFilepath: void 0,
          issues: [],
          checked: false,
          errors
        };
      }
    }
    exports.spellCheckDocument = spellCheckDocument2;
    async function spellCheckFullDocument(document, options, settings) {
      const doc = (0, resolveDocument_js_1.documentToTextDocument)(document);
      const docValOptions = options;
      const docValidator = new index_js_1.DocumentValidator(doc, docValOptions, settings);
      await docValidator.prepare();
      const prep = docValidator._getPreparations();
      if (docValidator.errors.length) {
        return {
          document,
          options,
          settingsUsed: prep?.localConfig || settings,
          localConfigFilepath: prep?.localConfigFilepath,
          issues: [],
          checked: false,
          errors: docValidator.errors
        };
      }
      const issues = docValidator.checkDocument();
      const result = {
        document,
        options,
        settingsUsed: docValidator.getFinalizedDocSettings(),
        localConfigFilepath: prep?.localConfigFilepath,
        issues,
        checked: docValidator.shouldCheckDocument(),
        errors: void 0
      };
      return result;
    }
    function determineFinalDocumentSettings(document, settings) {
      const doc = (0, TextDocument_js_1.createTextDocument)({
        uri: document.uri,
        content: document.text,
        languageId: document.languageId,
        locale: document.locale
      });
      return {
        document,
        settings: (0, determineTextDocumentSettings_js_1.determineTextDocumentSettings)(doc, settings)
      };
    }
    exports.determineFinalDocumentSettings = determineFinalDocumentSettings;
  }
});

// node_modules/cspell-lib/dist/cjs/trace.js
var require_trace = __commonJS({
  "node_modules/cspell-lib/dist/cjs/trace.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.traceWordsAsync = exports.traceWords = void 0;
    var gensequence_1 = require_dist2();
    var CSpellSettingsServer_js_1 = require_CSpellSettingsServer();
    var index_js_1 = require_Settings();
    var LanguageSettings_js_1 = require_LanguageSettings();
    var index_js_2 = require_SpellingDictionary4();
    var util = __importStar(require_util());
    async function traceWords(words, settings, options) {
      const results = await util.asyncIterableToArray(traceWordsAsync2(words, settings, options));
      const s = (0, gensequence_1.genSequence)(results).concatMap((p) => p).toArray();
      return s;
    }
    exports.traceWords = traceWords;
    async function* traceWordsAsync2(words, settings, options) {
      const { languageId, locale: language, ignoreCase = true, allowCompoundWords } = options || {};
      async function finalize(config2) {
        const withLocale = (0, index_js_1.mergeSettings)(config2, util.clean({
          language: language || config2.language,
          allowCompoundWords: allowCompoundWords ?? config2.allowCompoundWords
        }));
        const withLanguageId = (0, LanguageSettings_js_1.calcSettingsForLanguageId)(withLocale, languageId ?? withLocale.languageId ?? "plaintext");
        const settings2 = (0, index_js_1.finalizeSettings)(withLanguageId);
        const dictionaries = (settings2.dictionaries || []).concat((settings2.dictionaryDefinitions || []).map((d) => d.name)).filter(util.uniqueFn);
        const dictSettings = (0, CSpellSettingsServer_js_1.toInternalSettings)({ ...settings2, dictionaries });
        const dictBase = await (0, index_js_2.getDictionaryInternal)(settings2);
        const dicts2 = await (0, index_js_2.getDictionaryInternal)(dictSettings);
        const activeDictionaries2 = dictBase.dictionaries.map((d) => d.name);
        return {
          activeDictionaries: activeDictionaries2,
          config: settings2,
          dicts: dicts2
        };
      }
      await (0, index_js_2.refreshDictionaryCache)();
      const { config, dicts, activeDictionaries } = await finalize(settings);
      const setOfActiveDicts = new Set(activeDictionaries);
      const opts = util.clean({ ignoreCase, useCompounds: config.allowCompoundWords });
      function normalizeErrors(errors) {
        if (!errors?.length)
          return void 0;
        return errors;
      }
      function processWord(word) {
        return dicts.dictionaries.map((dict) => ({ dict, findResult: dict.find(word, opts) })).map(({ dict, findResult }) => ({
          word,
          found: !!findResult?.found,
          foundWord: findResult?.found || void 0,
          forbidden: findResult?.forbidden || false,
          noSuggest: findResult?.noSuggest || false,
          dictName: dict.name,
          dictSource: dict.source,
          dictActive: setOfActiveDicts.has(dict.name),
          configSource: config.name || "",
          errors: normalizeErrors(dict.getErrors?.())
        }));
      }
      for await (const word of words) {
        yield processWord(word);
      }
    }
    exports.traceWordsAsync = traceWordsAsync2;
  }
});

// node_modules/cspell-lib/dist/cjs/validator.js
var require_validator2 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateText = exports.IncludeExcludeFlag = exports.checkTextDocument = exports.checkText = void 0;
    var index_js_1 = require_textValidation();
    Object.defineProperty(exports, "checkText", { enumerable: true, get: function() {
      return index_js_1.checkText;
    } });
    Object.defineProperty(exports, "checkTextDocument", { enumerable: true, get: function() {
      return index_js_1.checkTextDocument;
    } });
    Object.defineProperty(exports, "IncludeExcludeFlag", { enumerable: true, get: function() {
      return index_js_1.IncludeExcludeFlag;
    } });
    Object.defineProperty(exports, "validateText", { enumerable: true, get: function() {
      return index_js_1.validateText;
    } });
  }
});

// node_modules/cspell-lib/dist/cjs/clearCachedFiles.js
var require_clearCachedFiles = __commonJS({
  "node_modules/cspell-lib/dist/cjs/clearCachedFiles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clearCachedFiles = void 0;
    var index_js_1 = require_Settings();
    var index_js_2 = require_SpellingDictionary4();
    async function clearCachedFiles() {
      await Promise.all([(0, index_js_1.clearCachedSettingsFiles)(), (0, index_js_2.refreshDictionaryCache)(0)]);
    }
    exports.clearCachedFiles = clearCachedFiles;
  }
});

// node_modules/cspell-lib/dist/cjs/getDictionary.js
var require_getDictionary = __commonJS({
  "node_modules/cspell-lib/dist/cjs/getDictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDictionary = void 0;
    var CSpellSettingsServer_js_1 = require_CSpellSettingsServer();
    var index_js_1 = require_SpellingDictionary4();
    function getDictionary2(settings) {
      return (0, index_js_1.getDictionaryInternal)((0, CSpellSettingsServer_js_1.toInternalSettings)(settings));
    }
    exports.getDictionary = getDictionary2;
  }
});

// node_modules/cspell-lib/dist/cjs/index.js
var require_cjs10 = __commonJS({
  "node_modules/cspell-lib/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.suggestionsForWord = exports.SuggestionError = exports.SpellingDictionaryLoadError = exports.refreshDictionaryCache = exports.isSpellingDictionaryLoadError = exports.createSpellingDictionaryCollection = exports.createSpellingDictionary = exports.CompoundWordsMethod = exports.spellCheckFile = exports.spellCheckDocument = exports.determineFinalDocumentSettings = exports.constructSettingsForText = exports.combineTextAndLanguageSettings = exports.defaultSettingsFilename = exports.sectionCSpell = exports.searchForConfig = exports.readSettingsFiles = exports.readSettings = exports.readRawSettings = exports.mergeSettings = exports.mergeInDocSettings = exports.loadPnPSync = exports.loadPnP = exports.loadConfig = exports.ImportError = exports.getSources = exports.getGlobalSettings = exports.getDefaultSettings = exports.getDefaultBundledSettings = exports.getCachedFileSize = exports.finalizeSettings = exports.extractImportErrors = exports.extractDependencies = exports.ENV_CSPELL_GLOB_ROOT = exports.defaultFileName = exports.defaultConfigFilenames = exports.currentSettingsFileVersion = exports.clearCachedSettingsFiles = exports.checkFilenameMatchesGlob = exports.calcOverrideSettings = exports.updateTextDocument = exports.createTextDocument = exports.getLanguagesForExt = exports.getLanguageIdsForBaseFilename = exports.UnknownFeatureFlagError = exports.getSystemFeatureFlags = exports.FeatureFlags = exports.isBinaryFile = exports.fileToTextDocument = exports.fileToDocument = void 0;
    exports.getDictionary = exports.clearCachedFiles = exports.ExclusionHelper = exports.Text = exports.Link = exports.writeToFileIterableP = exports.writeToFileIterable = exports.writeToFile = exports.readFileSync = exports.readFile = exports.asyncIterableToArray = exports.validateText = exports.IncludeExcludeFlag = exports.checkTextDocument = exports.checkText = exports.resolveFile = exports.setLogger = exports.getLogger = exports.traceWordsAsync = exports.traceWords = exports.shouldCheckDocument = exports.DocumentValidator = exports.suggestionsForWords = void 0;
    var ExclusionHelper = __importStar(require_exclusionHelper());
    exports.ExclusionHelper = ExclusionHelper;
    var Link = __importStar(require_index_link());
    exports.Link = Link;
    var Text2 = __importStar(require_text2());
    exports.Text = Text2;
    var index_js_1 = require_Document();
    Object.defineProperty(exports, "fileToDocument", { enumerable: true, get: function() {
      return index_js_1.fileToDocument;
    } });
    Object.defineProperty(exports, "fileToTextDocument", { enumerable: true, get: function() {
      return index_js_1.fileToTextDocument;
    } });
    Object.defineProperty(exports, "isBinaryFile", { enumerable: true, get: function() {
      return index_js_1.isBinaryFile;
    } });
    var index_js_2 = require_FeatureFlags2();
    Object.defineProperty(exports, "FeatureFlags", { enumerable: true, get: function() {
      return index_js_2.FeatureFlags;
    } });
    Object.defineProperty(exports, "getSystemFeatureFlags", { enumerable: true, get: function() {
      return index_js_2.getSystemFeatureFlags;
    } });
    Object.defineProperty(exports, "UnknownFeatureFlagError", { enumerable: true, get: function() {
      return index_js_2.UnknownFeatureFlagError;
    } });
    var LanguageIds_js_1 = require_LanguageIds();
    Object.defineProperty(exports, "getLanguageIdsForBaseFilename", { enumerable: true, get: function() {
      return LanguageIds_js_1.getLanguagesForBasename;
    } });
    Object.defineProperty(exports, "getLanguagesForExt", { enumerable: true, get: function() {
      return LanguageIds_js_1.getLanguagesForExt;
    } });
    var TextDocument_js_1 = require_TextDocument();
    Object.defineProperty(exports, "createTextDocument", { enumerable: true, get: function() {
      return TextDocument_js_1.createTextDocument;
    } });
    Object.defineProperty(exports, "updateTextDocument", { enumerable: true, get: function() {
      return TextDocument_js_1.updateTextDocument;
    } });
    var index_js_3 = require_Settings();
    Object.defineProperty(exports, "calcOverrideSettings", { enumerable: true, get: function() {
      return index_js_3.calcOverrideSettings;
    } });
    Object.defineProperty(exports, "checkFilenameMatchesGlob", { enumerable: true, get: function() {
      return index_js_3.checkFilenameMatchesGlob;
    } });
    Object.defineProperty(exports, "clearCachedSettingsFiles", { enumerable: true, get: function() {
      return index_js_3.clearCachedSettingsFiles;
    } });
    Object.defineProperty(exports, "currentSettingsFileVersion", { enumerable: true, get: function() {
      return index_js_3.currentSettingsFileVersion;
    } });
    Object.defineProperty(exports, "defaultConfigFilenames", { enumerable: true, get: function() {
      return index_js_3.defaultConfigFilenames;
    } });
    Object.defineProperty(exports, "defaultFileName", { enumerable: true, get: function() {
      return index_js_3.defaultFileName;
    } });
    Object.defineProperty(exports, "ENV_CSPELL_GLOB_ROOT", { enumerable: true, get: function() {
      return index_js_3.ENV_CSPELL_GLOB_ROOT;
    } });
    Object.defineProperty(exports, "extractDependencies", { enumerable: true, get: function() {
      return index_js_3.extractDependencies;
    } });
    Object.defineProperty(exports, "extractImportErrors", { enumerable: true, get: function() {
      return index_js_3.extractImportErrors;
    } });
    Object.defineProperty(exports, "finalizeSettings", { enumerable: true, get: function() {
      return index_js_3.finalizeSettings;
    } });
    Object.defineProperty(exports, "getCachedFileSize", { enumerable: true, get: function() {
      return index_js_3.getCachedFileSize;
    } });
    Object.defineProperty(exports, "getDefaultBundledSettings", { enumerable: true, get: function() {
      return index_js_3.getDefaultBundledSettings;
    } });
    Object.defineProperty(exports, "getDefaultSettings", { enumerable: true, get: function() {
      return index_js_3.getDefaultSettings;
    } });
    Object.defineProperty(exports, "getGlobalSettings", { enumerable: true, get: function() {
      return index_js_3.getGlobalSettings;
    } });
    Object.defineProperty(exports, "getSources", { enumerable: true, get: function() {
      return index_js_3.getSources;
    } });
    Object.defineProperty(exports, "ImportError", { enumerable: true, get: function() {
      return index_js_3.ImportError;
    } });
    Object.defineProperty(exports, "loadConfig", { enumerable: true, get: function() {
      return index_js_3.loadConfig;
    } });
    Object.defineProperty(exports, "loadPnP", { enumerable: true, get: function() {
      return index_js_3.loadPnP;
    } });
    Object.defineProperty(exports, "loadPnPSync", { enumerable: true, get: function() {
      return index_js_3.loadPnPSync;
    } });
    Object.defineProperty(exports, "mergeInDocSettings", { enumerable: true, get: function() {
      return index_js_3.mergeInDocSettings;
    } });
    Object.defineProperty(exports, "mergeSettings", { enumerable: true, get: function() {
      return index_js_3.mergeSettings;
    } });
    Object.defineProperty(exports, "readRawSettings", { enumerable: true, get: function() {
      return index_js_3.readRawSettings;
    } });
    Object.defineProperty(exports, "readSettings", { enumerable: true, get: function() {
      return index_js_3.readSettings;
    } });
    Object.defineProperty(exports, "readSettingsFiles", { enumerable: true, get: function() {
      return index_js_3.readSettingsFiles;
    } });
    Object.defineProperty(exports, "searchForConfig", { enumerable: true, get: function() {
      return index_js_3.searchForConfig;
    } });
    Object.defineProperty(exports, "sectionCSpell", { enumerable: true, get: function() {
      return index_js_3.sectionCSpell;
    } });
    var index_js_4 = require_Settings();
    Object.defineProperty(exports, "defaultSettingsFilename", { enumerable: true, get: function() {
      return index_js_4.defaultFileName;
    } });
    var TextDocumentSettings_js_1 = require_TextDocumentSettings();
    Object.defineProperty(exports, "combineTextAndLanguageSettings", { enumerable: true, get: function() {
      return TextDocumentSettings_js_1.combineTextAndLanguageSettings;
    } });
    Object.defineProperty(exports, "constructSettingsForText", { enumerable: true, get: function() {
      return TextDocumentSettings_js_1.combineTextAndLanguageSettings;
    } });
    var spellCheckFile_js_1 = require_spellCheckFile();
    Object.defineProperty(exports, "determineFinalDocumentSettings", { enumerable: true, get: function() {
      return spellCheckFile_js_1.determineFinalDocumentSettings;
    } });
    Object.defineProperty(exports, "spellCheckDocument", { enumerable: true, get: function() {
      return spellCheckFile_js_1.spellCheckDocument;
    } });
    Object.defineProperty(exports, "spellCheckFile", { enumerable: true, get: function() {
      return spellCheckFile_js_1.spellCheckFile;
    } });
    var index_js_5 = require_SpellingDictionary4();
    Object.defineProperty(exports, "CompoundWordsMethod", { enumerable: true, get: function() {
      return index_js_5.CompoundWordsMethod;
    } });
    Object.defineProperty(exports, "createSpellingDictionary", { enumerable: true, get: function() {
      return index_js_5.createSpellingDictionary;
    } });
    Object.defineProperty(exports, "createSpellingDictionaryCollection", { enumerable: true, get: function() {
      return index_js_5.createCollection;
    } });
    Object.defineProperty(exports, "isSpellingDictionaryLoadError", { enumerable: true, get: function() {
      return index_js_5.isSpellingDictionaryLoadError;
    } });
    Object.defineProperty(exports, "refreshDictionaryCache", { enumerable: true, get: function() {
      return index_js_5.refreshDictionaryCache;
    } });
    Object.defineProperty(exports, "SpellingDictionaryLoadError", { enumerable: true, get: function() {
      return index_js_5.SpellingDictionaryLoadError;
    } });
    var suggestions_js_1 = require_suggestions();
    Object.defineProperty(exports, "SuggestionError", { enumerable: true, get: function() {
      return suggestions_js_1.SuggestionError;
    } });
    Object.defineProperty(exports, "suggestionsForWord", { enumerable: true, get: function() {
      return suggestions_js_1.suggestionsForWord;
    } });
    Object.defineProperty(exports, "suggestionsForWords", { enumerable: true, get: function() {
      return suggestions_js_1.suggestionsForWords;
    } });
    var index_js_6 = require_textValidation();
    Object.defineProperty(exports, "DocumentValidator", { enumerable: true, get: function() {
      return index_js_6.DocumentValidator;
    } });
    Object.defineProperty(exports, "shouldCheckDocument", { enumerable: true, get: function() {
      return index_js_6.shouldCheckDocument;
    } });
    var trace_js_1 = require_trace();
    Object.defineProperty(exports, "traceWords", { enumerable: true, get: function() {
      return trace_js_1.traceWords;
    } });
    Object.defineProperty(exports, "traceWordsAsync", { enumerable: true, get: function() {
      return trace_js_1.traceWordsAsync;
    } });
    var logger_js_1 = require_logger();
    Object.defineProperty(exports, "getLogger", { enumerable: true, get: function() {
      return logger_js_1.getLogger;
    } });
    Object.defineProperty(exports, "setLogger", { enumerable: true, get: function() {
      return logger_js_1.setLogger;
    } });
    var resolveFile_js_1 = require_resolveFile();
    Object.defineProperty(exports, "resolveFile", { enumerable: true, get: function() {
      return resolveFile_js_1.resolveFile;
    } });
    var validator_js_1 = require_validator2();
    Object.defineProperty(exports, "checkText", { enumerable: true, get: function() {
      return validator_js_1.checkText;
    } });
    Object.defineProperty(exports, "checkTextDocument", { enumerable: true, get: function() {
      return validator_js_1.checkTextDocument;
    } });
    Object.defineProperty(exports, "IncludeExcludeFlag", { enumerable: true, get: function() {
      return validator_js_1.IncludeExcludeFlag;
    } });
    Object.defineProperty(exports, "validateText", { enumerable: true, get: function() {
      return validator_js_1.validateText;
    } });
    __exportStar(require_cjs9(), exports);
    var cspell_io_1 = require_cjs3();
    Object.defineProperty(exports, "asyncIterableToArray", { enumerable: true, get: function() {
      return cspell_io_1.asyncIterableToArray;
    } });
    Object.defineProperty(exports, "readFile", { enumerable: true, get: function() {
      return cspell_io_1.readFile;
    } });
    Object.defineProperty(exports, "readFileSync", { enumerable: true, get: function() {
      return cspell_io_1.readFileSync;
    } });
    Object.defineProperty(exports, "writeToFile", { enumerable: true, get: function() {
      return cspell_io_1.writeToFile;
    } });
    Object.defineProperty(exports, "writeToFileIterable", { enumerable: true, get: function() {
      return cspell_io_1.writeToFileIterable;
    } });
    Object.defineProperty(exports, "writeToFileIterableP", { enumerable: true, get: function() {
      return cspell_io_1.writeToFileIterableP;
    } });
    var clearCachedFiles_js_1 = require_clearCachedFiles();
    Object.defineProperty(exports, "clearCachedFiles", { enumerable: true, get: function() {
      return clearCachedFiles_js_1.clearCachedFiles;
    } });
    var getDictionary_js_1 = require_getDictionary();
    Object.defineProperty(exports, "getDictionary", { enumerable: true, get: function() {
      return getDictionary_js_1.getDictionary;
    } });
  }
});

// node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path16 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path16.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path16;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert2();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes2 = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes2.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes2,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag2();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/chalk/source/util.js
var require_util10 = __commonJS({
  "node_modules/chalk/source/util.js"(exports, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates2 = __commonJS({
  "node_modules/chalk/source/templates.js"(exports, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk3, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk3;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk3, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk3, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk3, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles2();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color2();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util10();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk4 = {};
      applyOptions(chalk4, options);
      chalk4.template = (...arguments_) => chalkTag(chalk4.template, ...arguments_);
      Object.setPrototypeOf(chalk4, Chalk.prototype);
      Object.setPrototypeOf(chalk4.template, chalk4);
      chalk4.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk4.template.Instance = ChalkClass;
      return chalk4.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template2;
    var chalkTag = (chalk4, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template2 === void 0) {
        template2 = require_templates2();
      }
      return template2(chalk4, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk3 = Chalk();
    chalk3.supportsColor = stdoutColor;
    chalk3.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk3.stderr.supportsColor = stderrColor;
    module2.exports = chalk3;
  }
});

// node_modules/cspell/dist/lib/uri.cjs
var require_uri = __commonJS({
  "node_modules/cspell/dist/lib/uri.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Utils = exports.URI = void 0;
    var vscode_uri_1 = require_umd();
    Object.defineProperty(exports, "URI", { enumerable: true, get: function() {
      return vscode_uri_1.URI;
    } });
    Object.defineProperty(exports, "Utils", { enumerable: true, get: function() {
      return vscode_uri_1.Utils;
    } });
  }
});

// node_modules/cspell/package.json
var require_package = __commonJS({
  "node_modules/cspell/package.json"(exports, module2) {
    module2.exports = {
      name: "cspell",
      version: "6.31.3",
      description: "A Spelling Checker for Code!",
      funding: "https://github.com/streetsidesoftware/cspell?sponsor=1",
      bin: {
        cspell: "bin.js",
        "cspell-esm": "bin.mjs"
      },
      type: "commonjs",
      main: "dist/cjs/index.js",
      types: "dist/cjs/index.d.ts",
      module: "dist/esm/index.mjs",
      exports: {
        ".": {
          import: "./dist/esm/index.mjs",
          require: "./dist/cjs/index.js"
        },
        "./app": {
          import: "./dist/esm/app.mjs",
          require: "./dist/cjs/app.js"
        },
        "./bin": {
          import: "./bin.mjs",
          require: "./bin.js"
        },
        "./application": {
          import: "./dist/esm/application.mjs",
          require: "./dist/cjs/application.js"
        }
      },
      files: [
        "bin.js",
        "bin.mjs",
        "dist",
        "!dist/esm/**/*.js",
        "!dist/esm/**/*.ts",
        "!**/*.tsbuildInfo",
        "!**/__mocks__",
        "!**/test/**",
        "!**/*.test.*",
        "!**/*.spec.*",
        "!**/*.map"
      ],
      scripts: {
        clean: "shx rm -rf dist coverage temp .tsbuildinfo",
        build: "tsc -b . && ts2mjs dist/esm && pnpm run build:api",
        "build:api": "rollup -c rollup.config.mjs",
        "build:cjs": "tsc -b tsconfig.cjs.json",
        "build:esm": "tsc -b tsconfig.esm.json",
        "build:esm:ts2mjs": "tsc -b tsconfig.esm.json && ts2mjs dist/esm",
        "build:lib": "tsc -b src/lib/tsconfig.json",
        "build:readme": "pnpm build:readme:help",
        "build:readme:help": "pnpm build:readme:help:lint && pnpm build:readme:help:trace && inject-markdown README.md && prettier -w README.md",
        "build:readme:help:lint": "./bin.js lint --help > static/help-lint.txt",
        "build:readme:help:trace": "./bin.js trace --help > static/help-trace.txt",
        "clean-build": "pnpm run clean && pnpm run build",
        coverage: "pnpm coverage:vitest && pnpm coverage:fix",
        "coverage:vitest": "vitest run --coverage",
        "coverage:fix": 'nyc report --temp-dir "$(pwd)/coverage" --reporter lcov --report-dir "$(pwd)/coverage" --cwd ../..',
        "test:watch": "vitest",
        test: "vitest run",
        watch: "tsc -b . -w",
        compile: "tsc -p .",
        "test-watch": "vitest",
        prepublishOnly: "pnpm run clean-build",
        "test:update-snapshot": "vitest run --update"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/streetsidesoftware/cspell.git"
      },
      keywords: [
        "spell",
        "checker",
        "code",
        "camel",
        "case",
        "spelling",
        "spell checker",
        "spelling checker",
        "lint"
      ],
      author: "Jason Dent",
      license: "MIT",
      bugs: {
        url: "https://github.com/streetsidesoftware/cspell/issues"
      },
      homepage: "https://streetsidesoftware.github.io/cspell/",
      dependencies: {
        "@cspell/cspell-json-reporter": "6.31.3",
        "@cspell/cspell-pipe": "6.31.3",
        "@cspell/cspell-types": "6.31.3",
        "@cspell/dynamic-import": "6.31.3",
        chalk: "^4.1.2",
        commander: "^10.0.0",
        "cspell-gitignore": "6.31.3",
        "cspell-glob": "6.31.3",
        "cspell-io": "6.31.3",
        "cspell-lib": "6.31.3",
        "fast-glob": "^3.2.12",
        "fast-json-stable-stringify": "^2.1.0",
        "file-entry-cache": "^6.0.1",
        "get-stdin": "^8.0.0",
        imurmurhash: "^0.1.4",
        semver: "^7.3.8",
        "strip-ansi": "^6.0.1",
        "vscode-uri": "^3.0.7"
      },
      engines: {
        node: ">=14"
      },
      devDependencies: {
        "@types/file-entry-cache": "^5.0.2",
        "@types/glob": "^8.1.0",
        "@types/imurmurhash": "^0.1.1",
        "@types/micromatch": "^4.0.2",
        "@types/semver": "^7.3.13",
        micromatch: "^4.0.5",
        minimatch: "^7.4.4"
      },
      gitHead: "0e8ca7b32f21aea40ade645172ef93017e6a143d"
    };
  }
});

// node_modules/cspell/dist/lib/pkgInfo.cjs
var require_pkgInfo = __commonJS({
  "node_modules/cspell/dist/lib/pkgInfo.cjs"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.npmPackage = exports.pkgDir = void 0;
    var path16 = __importStar(require("path"));
    exports.pkgDir = path16.join(__dirname, "../..");
    exports.npmPackage = require_package();
  }
});

// node_modules/get-stdin/index.js
var require_get_stdin = __commonJS({
  "node_modules/get-stdin/index.js"(exports, module2) {
    "use strict";
    var { stdin } = process;
    module2.exports = async () => {
      let result = "";
      if (stdin.isTTY) {
        return result;
      }
      stdin.setEncoding("utf8");
      for await (const chunk of stdin) {
        result += chunk;
      }
      return result;
    };
    module2.exports.buffer = async () => {
      const result = [];
      let length = 0;
      if (stdin.isTTY) {
        return Buffer.concat([]);
      }
      for await (const chunk of stdin) {
        result.push(chunk);
        length += chunk.length;
      }
      return Buffer.concat(result, length);
    };
  }
});

// node_modules/fast-glob/out/utils/array.js
var require_array2 = __commonJS({
  "node_modules/fast-glob/out/utils/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitWhen = exports.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports.splitWhen = splitWhen;
  }
});

// node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/fast-glob/out/utils/errno.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error2) {
      return error2.code === "ENOENT";
    }
    exports.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "node_modules/fast-glob/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "node_modules/fast-glob/out/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;
    var os = require("os");
    var path16 = require("path");
    var IS_WINDOWS_PLATFORM = os.platform() === "win32";
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([(){}]|^!|[!+@](?=\())/g;
    var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path16.resolve(cwd, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
    exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapePosixPath = escapePosixPath;
    exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/fast-glob/out/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    var path16 = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename3 = path16.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename3);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch.braces(pattern, { expand: true, nodupes: true });
      patterns.sort((a, b) => a.length - b.length);
      return patterns.filter((pattern2) => pattern2 !== "");
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/merge2/index.js"(exports, module2) {
    "use strict";
    var Stream3 = require("stream");
    var PassThrough2 = Stream3.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough2(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough2(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "node_modules/fast-glob/out/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error2) => mergedStream.emit("error", error2));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "node_modules/fast-glob/out/utils/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.isString = void 0;
    function isString2(input) {
      return typeof input === "string";
    }
    exports.isString = isString2;
    function isEmpty(input) {
      return input === "";
    }
    exports.isEmpty = isEmpty;
  }
});

// node_modules/fast-glob/out/utils/index.js
var require_utils7 = __commonJS({
  "node_modules/fast-glob/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    var array = require_array2();
    exports.array = array;
    var errno = require_errno();
    exports.errno = errno;
    var fs6 = require_fs();
    exports.fs = fs6;
    var path16 = require_path();
    exports.path = path16;
    var pattern = require_pattern();
    exports.pattern = pattern;
    var stream = require_stream();
    exports.stream = stream;
    var string = require_string();
    exports.string = string;
  }
});

// node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/fast-glob/out/managers/tasks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    var utils = require_utils7();
    function generate(input, settings) {
      const patterns = processPatterns(input, settings);
      const ignore = processPatterns(settings.ignore, settings);
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
      }
      if (settings.baseNameMatch) {
        patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
      }
      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read2(path16, settings, callback) {
      settings.fs.lstat(path16, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path16, (statError, stat2) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat2.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat2);
        });
      });
    }
    exports.read = read2;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read2(path16, settings) {
      const lstat = settings.fs.lstatSync(path16);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat2 = settings.fs.statSync(path16);
        if (settings.markSymbolicLink) {
          stat2.isSymbolicLink = () => true;
        }
        return stat2;
      } catch (error2) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error2;
      }
    }
    exports.read = read2;
  }
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      stat: fs6.stat,
      lstatSync: fs6.lstatSync,
      statSync: fs6.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs6 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs6.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async();
    var sync = require_sync2();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat2(path16, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path16, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path16, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat2;
    function statSync3(path16, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path16, settings);
    }
    exports.statSync = statSync3;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants6 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils8 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs6 = require_fs3();
    exports.fs = fs6;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants6();
    var utils = require_utils8();
    var common = require_common3();
    function read2(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports.read = read2;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path16 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path16, settings.fsStatSettings, (error2, stats) => {
              if (error2 !== null) {
                done(error2);
                return;
              }
              const entry = {
                name,
                path: path16,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports.readdir = readdir;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants6();
    var utils = require_utils8();
    var common = require_common3();
    function read2(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports.read = read2;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error2) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error2;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir;
  }
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      stat: fs6.stat,
      lstatSync: fs6.lstatSync,
      statSync: fs6.statSync,
      readdir: fs6.readdir,
      readdirSync: fs6.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path16 = require("path");
    var fsStat = require_out();
    var fs6 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs6.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path16.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async2();
    var sync = require_sync3();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path16, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path16, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path16, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path16, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path16, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error: error2
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self.paused)
          return;
        self.paused = false;
        for (var i = 0; i < self.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self.concurrency || self.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self.concurrency || self.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self.drain();
        self.drain = noop;
      }
      function error2(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self = this;
      this.worked = function worked(err, result) {
        var callback = self.callback;
        var errorHandler = self.errorHandler;
        var val = self.value;
        self.value = null;
        self.callback = noop;
        if (self.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self.context, err, result);
        self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve10, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve10(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve10, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve10(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve10) {
            resolve10();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve10) {
          queue.drain = function() {
            previousDrain();
            resolve10();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error2) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error2);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common4();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common4();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error2) => {
          if (error2 !== null) {
            this._handleError(error2);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
          if (error2 !== null) {
            done(error2, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error2) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error2)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error2);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error2) => {
          callFailureCallback(callback, error2);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error2) => {
          this._stream.emit("error", error2);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common4();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error2) {
          this._handleError(error2);
        }
      }
      _handleError(error2) {
        if (!common.isFatalError(this._settings, error2)) {
          return;
        }
        throw error2;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync5 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync4();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path16 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path16.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync5();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/fast-glob/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path16 = require("path");
    var fsStat = require_out();
    var utils = require_utils7();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path16.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error2) {
        return !utils.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
      }
    };
    exports.default = Reader;
  }
});

// node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "node_modules/fast-glob/out/readers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error2) => {
          if (options.errorFilter(error2)) {
            return null;
          }
          throw error2;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve10, reject) => {
          this._stat(filepath, this._fsStatSettings, (error2, stats) => {
            return error2 === null ? resolve10(stats) : reject(error2);
          });
        });
      }
    };
    exports.default = ReaderStream;
  }
});

// node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/fast-glob/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve10, reject) => {
          this._walkAsync(root, options, (error2, entries) => {
            if (error2 === null) {
              resolve10(entries);
            } else {
              reject(error2);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve10, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve10(entries));
        });
      }
    };
    exports.default = ReaderAsync;
  }
});

// node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils7();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports.default = Matcher;
  }
});

// node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info3) => !info3.complete || info3.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports.default = PartialMatcher;
  }
});

// node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils7();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports.default = DeepFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils7();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports.default = EntryFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/error.js
var require_error2 = __commonJS({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils7();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error2) => this._isNonFatalError(error2);
      }
      _isNonFatalError(error2) {
        return utils.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
      }
    };
    exports.default = ErrorFilter;
  }
});

// node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils7();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports.default = EntryTransformer;
  }
});

// node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/fast-glob/out/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path16 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error2();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path16.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports.default = Provider;
  }
});

// node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/fast-glob/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderAsync;
  }
});

// node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "node_modules/fast-glob/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error2) => destination.emit("error", error2)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderStream;
  }
});

// node_modules/fast-glob/out/readers/sync.js
var require_sync6 = __commonJS({
  "node_modules/fast-glob/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error2) {
          if (options.errorFilter(error2)) {
            return null;
          }
          throw error2;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports.default = ReaderSync;
  }
});

// node_modules/fast-glob/out/providers/sync.js
var require_sync7 = __commonJS({
  "node_modules/fast-glob/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync6();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderSync;
  }
});

// node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/fast-glob/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      lstatSync: fs6.lstatSync,
      stat: fs6.stat,
      statSync: fs6.statSync,
      readdir: fs6.readdir,
      readdirSync: fs6.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports.default = Settings;
  }
});

// node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/fast-glob/out/index.js"(exports, module2) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync7();
    var settings_1 = require_settings4();
    var utils = require_utils7();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync;
      FastGlob2.globStream = stream;
      FastGlob2.async = FastGlob2;
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix3;
      (function(posix4) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapePosixPath(source);
        }
        posix4.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix4.convertPathToPattern = convertPathToPattern2;
      })(posix3 = FastGlob2.posix || (FastGlob2.posix = {}));
      let win32;
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// node_modules/flatted/cjs/index.js
var require_cjs11 = __commonJS({
  "node_modules/flatted/cjs/index.js"(exports) {
    "use strict";
    var { parse: $parse, stringify: $stringify } = JSON;
    var { keys } = Object;
    var Primitive = String;
    var primitive = "string";
    var ignore = {};
    var object = "object";
    var noop = (_, value) => value;
    var primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
    var Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;
    var revive = (input, parsed, output, $) => {
      const lazy = [];
      for (let ke = keys(output), { length } = ke, y = 0; y < length; y++) {
        const k = ke[y];
        const value = output[k];
        if (value instanceof Primitive) {
          const tmp = input[value];
          if (typeof tmp === object && !parsed.has(tmp)) {
            parsed.add(tmp);
            output[k] = ignore;
            lazy.push({ k, a: [input, parsed, tmp, $] });
          } else
            output[k] = $.call(output, k, tmp);
        } else if (output[k] !== ignore)
          output[k] = $.call(output, k, value);
      }
      for (let { length } = lazy, i = 0; i < length; i++) {
        const { k, a } = lazy[i];
        output[k] = $.call(output, k, revive.apply(null, a));
      }
      return output;
    };
    var set = (known, input, value) => {
      const index = Primitive(input.push(value) - 1);
      known.set(value, index);
      return index;
    };
    var parse3 = (text, reviver) => {
      const input = $parse(text, Primitives).map(primitives);
      const value = input[0];
      const $ = reviver || noop;
      const tmp = typeof value === object && value ? revive(input, /* @__PURE__ */ new Set(), value, $) : value;
      return $.call({ "": tmp }, "", tmp);
    };
    exports.parse = parse3;
    var stringify2 = (value, replacer, space) => {
      const $ = replacer && typeof replacer === object ? (k, v) => k === "" || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;
      const known = /* @__PURE__ */ new Map();
      const input = [];
      const output = [];
      let i = +set(known, input, $.call({ "": value }, "", value));
      let firstRun = !i;
      while (i < input.length) {
        firstRun = true;
        output[i] = $stringify(input[i++], replace, space);
      }
      return "[" + output.join(",") + "]";
      function replace(key, value2) {
        if (firstRun) {
          firstRun = !firstRun;
          return value2;
        }
        const after = $.call(this, key, value2);
        switch (typeof after) {
          case object:
            if (after === null)
              return after;
          case primitive:
            return known.get(after) || set(known, input, after);
        }
        return after;
      }
    };
    exports.stringify = stringify2;
    var toJSON = (any) => $parse(stringify2(any));
    exports.toJSON = toJSON;
    var fromJSON = (any) => parse3($stringify(any));
    exports.fromJSON = fromJSON;
  }
});

// node_modules/flat-cache/src/utils.js
var require_utils9 = __commonJS({
  "node_modules/flat-cache/src/utils.js"(exports, module2) {
    var fs6 = require("fs");
    var path16 = require("path");
    var flatted = require_cjs11();
    module2.exports = {
      tryParse: function(filePath, defaultValue) {
        var result;
        try {
          result = this.readJSON(filePath);
        } catch (ex) {
          result = defaultValue;
        }
        return result;
      },
      /**
       * Read json file synchronously using flatted
       *
       * @method readJSON
       * @param  {String} filePath Json filepath
       * @returns {*} parse result
       */
      readJSON: function(filePath) {
        return flatted.parse(
          fs6.readFileSync(filePath, {
            encoding: "utf8"
          })
        );
      },
      /**
       * Write json file synchronously using circular-json
       *
       * @method writeJSON
       * @param  {String} filePath Json filepath
       * @param  {*} data Object to serialize
       */
      writeJSON: function(filePath, data) {
        fs6.mkdirSync(path16.dirname(filePath), {
          recursive: true
        });
        fs6.writeFileSync(filePath, flatted.stringify(data));
      }
    };
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows2 = process.platform === "win32";
    var fs6 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows2) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows2) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync2(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows2 && !knownHard[base]) {
          fs6.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat2 = fs6.lstatSync(base);
          if (!stat2.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows2) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs6.statSync(base);
            linkTarget = fs6.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows2)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows2 && !knownHard[base]) {
          fs6.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs6.lstat(base, gotStat);
      }
      function gotStat(err, stat2) {
        if (err)
          return cb(err);
        if (!stat2.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows2) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs6.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs6.readlink(base, function(err3, target) {
            if (!isWindows2)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs5 = __commonJS({
  "node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync2;
    realpath.realpathSync = realpathSync2;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs6 = require("fs");
    var origRealpath = fs6.realpath;
    var origRealpathSync = fs6.realpathSync;
    var version3 = process.version;
    var ok = /^v[0-5]\./.test(version3);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync2(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs6.realpath = realpath;
      fs6.realpathSync = realpathSync2;
    }
    function unmonkeypatch() {
      fs6.realpath = origRealpath;
      fs6.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path16 = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path16.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path16.sep !== "/") {
        pattern = pattern.split(path16.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse3;
    var SUBPARSE = {};
    function parse3(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm2 = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm2.match(f);
      });
      if (mm2.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path16.sep !== "/") {
        f = f.split(path16.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix3(path16) {
      return path16.charAt(0) === "/";
    }
    function win32(path16) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path16);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix3;
    module2.exports.posix = posix3;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common5 = __commonJS({
  "node_modules/glob/common.js"(exports) {
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs6 = require("fs");
    var path16 = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self, options) {
      self.ignore = options.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.fs = options.fs || fs6;
      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self, options);
      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path16.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }
      self.root = options.root || path16.resolve(self.cwd, "/");
      self.root = path16.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir2 = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir2 && !slash)
          m += "/";
        else if (!isDir2 && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path16.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self.changedCwd) {
        abs = path16.resolve(self.cwd, f);
      } else {
        abs = path16.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self, path17) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path17) || !!(item.gmatcher && item.gmatcher.match(path17));
      });
    }
    function childrenIgnored(self, path17) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path17));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync8 = __commonJS({
  "node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs5();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path16 = require("path");
    var assert7 = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common5();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert7.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
          var set = self.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert7.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read2, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path16.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat2;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path16.join(this.root, prefix);
        } else {
          prefix = path16.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat2 = this.statCache[abs];
      if (!stat2) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat2 = this.fs.statSync(abs);
          } catch (er) {
            stat2 = lstat;
          }
        } else {
          stat2 = lstat;
        }
      }
      this.statCache[abs] = stat2;
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob2;
    var rp = require_fs5();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path16 = require("path");
    var assert7 = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync8();
    var common = require_common5();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob2(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob2.sync = globSync;
    var GlobSync = glob2.GlobSync = globSync.GlobSync;
    glob2.glob = glob2;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob2.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob2.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert7(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert7(this instanceof Glob);
      assert7(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read2, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path16.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = "FILE";
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      self.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self, abs, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self = this;
      this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path16.join(this.root, prefix);
        } else {
          prefix = path16.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat2 = this.statCache[abs];
      if (stat2 !== void 0) {
        if (stat2 === false)
          return cb(null, stat2);
        else {
          var type = stat2.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat2);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self.fs.stat(abs, function(er2, stat3) {
            if (er2)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er2, stat3, cb);
          });
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat2, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat2;
      if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
        return cb(null, false, stat2);
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat2);
    };
  }
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/rimraf/rimraf.js"(exports, module2) {
    var assert7 = require("assert");
    var path16 = require("path");
    var fs6 = require("fs");
    var glob2 = void 0;
    try {
      glob2 = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows2 = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs6[m];
        m = m + "Sync";
        options[m] = options[m] || fs6[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob2 === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert7(p, "rimraf: missing path");
      assert7.equal(typeof p, "string", "rimraf: path should be a string");
      assert7.equal(typeof cb, "function", "rimraf: callback function required");
      assert7(options, "rimraf: invalid options argument provided");
      assert7.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob2.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat2) => {
        if (!er)
          return afterGlob(null, [p]);
        glob2(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert7(p);
      assert7(options);
      assert7(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows2)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows2 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert7(p);
      assert7(options);
      assert7(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert7(p);
      assert7(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert7(p);
      assert7(options);
      assert7(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert7(p);
      assert7(options);
      assert7(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path16.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert7(p, "rimraf: missing path");
      assert7.equal(typeof p, "string", "rimraf: path should be a string");
      assert7(options, "rimraf: missing options");
      assert7.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob2.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob2.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows2)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows2 ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert7(p);
      assert7(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert7(p);
      assert7(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path16.join(p, f), options));
      const retries = isWindows2 ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/flat-cache/src/del.js
var require_del = __commonJS({
  "node_modules/flat-cache/src/del.js"(exports, module2) {
    var rimraf = require_rimraf().sync;
    var fs6 = require("fs");
    module2.exports = function del(file) {
      if (fs6.existsSync(file)) {
        rimraf(file, {
          glob: false
        });
        return true;
      }
      return false;
    };
  }
});

// node_modules/flat-cache/src/cache.js
var require_cache = __commonJS({
  "node_modules/flat-cache/src/cache.js"(exports, module2) {
    var path16 = require("path");
    var fs6 = require("fs");
    var utils = require_utils9();
    var del = require_del();
    var writeJSON = utils.writeJSON;
    var cache = {
      /**
       * Load a cache identified by the given Id. If the element does not exists, then initialize an empty
       * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted
       * then the cache module directory `./cache` will be used instead
       *
       * @method load
       * @param docId {String} the id of the cache, would also be used as the name of the file cache
       * @param [cacheDir] {String} directory for the cache entry
       */
      load: function(docId, cacheDir) {
        var me = this;
        me._visited = {};
        me._persisted = {};
        me._pathToFile = cacheDir ? path16.resolve(cacheDir, docId) : path16.resolve(__dirname, "../.cache/", docId);
        if (fs6.existsSync(me._pathToFile)) {
          me._persisted = utils.tryParse(me._pathToFile, {});
        }
      },
      /**
       * Load the cache from the provided file
       * @method loadFile
       * @param  {String} pathToFile the path to the file containing the info for the cache
       */
      loadFile: function(pathToFile) {
        var me = this;
        var dir = path16.dirname(pathToFile);
        var fName = path16.basename(pathToFile);
        me.load(fName, dir);
      },
      /**
       * Returns the entire persisted object
       * @method all
       * @returns {*}
       */
      all: function() {
        return this._persisted;
      },
      keys: function() {
        return Object.keys(this._persisted);
      },
      /**
       * sets a key to a given value
       * @method setKey
       * @param key {string} the key to set
       * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify
       */
      setKey: function(key, value) {
        this._visited[key] = true;
        this._persisted[key] = value;
      },
      /**
       * remove a given key from the cache
       * @method removeKey
       * @param key {String} the key to remove from the object
       */
      removeKey: function(key) {
        delete this._visited[key];
        delete this._persisted[key];
      },
      /**
       * Return the value of the provided key
       * @method getKey
       * @param key {String} the name of the key to retrieve
       * @returns {*} the value from the key
       */
      getKey: function(key) {
        this._visited[key] = true;
        return this._persisted[key];
      },
      /**
       * Remove keys that were not accessed/set since the
       * last time the `prune` method was called.
       * @method _prune
       * @private
       */
      _prune: function() {
        var me = this;
        var obj = {};
        var keys = Object.keys(me._visited);
        if (keys.length === 0) {
          return;
        }
        keys.forEach(function(key) {
          obj[key] = me._persisted[key];
        });
        me._visited = {};
        me._persisted = obj;
      },
      /**
       * Save the state of the cache identified by the docId to disk
       * as a JSON structure
       * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files
       * @method save
       */
      save: function(noPrune) {
        var me = this;
        !noPrune && me._prune();
        writeJSON(me._pathToFile, me._persisted);
      },
      /**
       * remove the file where the cache is persisted
       * @method removeCacheFile
       * @return {Boolean} true or false if the file was successfully deleted
       */
      removeCacheFile: function() {
        return del(this._pathToFile);
      },
      /**
       * Destroy the file cache and cache content.
       * @method destroy
       */
      destroy: function() {
        var me = this;
        me._visited = {};
        me._persisted = {};
        me.removeCacheFile();
      }
    };
    module2.exports = {
      /**
       * Alias for create. Should be considered depreacted. Will be removed in next releases
       *
       * @method load
       * @param docId {String} the id of the cache, would also be used as the name of the file cache
       * @param [cacheDir] {String} directory for the cache entry
       * @returns {cache} cache instance
       */
      load: function(docId, cacheDir) {
        return this.create(docId, cacheDir);
      },
      /**
       * Load a cache identified by the given Id. If the element does not exists, then initialize an empty
       * cache storage.
       *
       * @method create
       * @param docId {String} the id of the cache, would also be used as the name of the file cache
       * @param [cacheDir] {String} directory for the cache entry
       * @returns {cache} cache instance
       */
      create: function(docId, cacheDir) {
        var obj = Object.create(cache);
        obj.load(docId, cacheDir);
        return obj;
      },
      createFromFile: function(filePath) {
        var obj = Object.create(cache);
        obj.loadFile(filePath);
        return obj;
      },
      /**
       * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly
       *
       * @method clearCache
       * @param docId {String} the id of the cache, would also be used as the name of the file cache
       * @param cacheDir {String} the directory where the cache file was written
       * @returns {Boolean} true if the cache folder was deleted. False otherwise
       */
      clearCacheById: function(docId, cacheDir) {
        var filePath = cacheDir ? path16.resolve(cacheDir, docId) : path16.resolve(__dirname, "../.cache/", docId);
        return del(filePath);
      },
      /**
       * Remove all cache stored in the cache directory
       * @method clearAll
       * @returns {Boolean} true if the cache folder was deleted. False otherwise
       */
      clearAll: function(cacheDir) {
        var filePath = cacheDir ? path16.resolve(cacheDir) : path16.resolve(__dirname, "../.cache/");
        return del(filePath);
      }
    };
  }
});

// node_modules/file-entry-cache/cache.js
var require_cache2 = __commonJS({
  "node_modules/file-entry-cache/cache.js"(exports, module2) {
    var path16 = require("path");
    var crypto5 = require("crypto");
    module2.exports = {
      createFromFile: function(filePath, useChecksum) {
        var fname = path16.basename(filePath);
        var dir = path16.dirname(filePath);
        return this.create(fname, dir, useChecksum);
      },
      create: function(cacheId, _path, useChecksum) {
        var fs6 = require("fs");
        var flatCache = require_cache();
        var cache = flatCache.load(cacheId, _path);
        var normalizedEntries = {};
        var removeNotFoundFiles = function removeNotFoundFiles2() {
          const cachedEntries = cache.keys();
          cachedEntries.forEach(function remover(fPath) {
            try {
              fs6.statSync(fPath);
            } catch (err) {
              if (err.code === "ENOENT") {
                cache.removeKey(fPath);
              }
            }
          });
        };
        removeNotFoundFiles();
        return {
          /**
           * the flat cache storage used to persist the metadata of the `files
           * @type {Object}
           */
          cache,
          /**
           * Given a buffer, calculate md5 hash of its content.
           * @method getHash
           * @param  {Buffer} buffer   buffer to calculate hash on
           * @return {String}          content hash digest
           */
          getHash: function(buffer) {
            return crypto5.createHash("md5").update(buffer).digest("hex");
          },
          /**
           * Return whether or not a file has changed since last time reconcile was called.
           * @method hasFileChanged
           * @param  {String}  file  the filepath to check
           * @return {Boolean}       wheter or not the file has changed
           */
          hasFileChanged: function(file) {
            return this.getFileDescriptor(file).changed;
          },
          /**
           * given an array of file paths it return and object with three arrays:
           *  - changedFiles: Files that changed since previous run
           *  - notChangedFiles: Files that haven't change
           *  - notFoundFiles: Files that were not found, probably deleted
           *
           * @param  {Array} files the files to analyze and compare to the previous seen files
           * @return {[type]}       [description]
           */
          analyzeFiles: function(files) {
            var me = this;
            files = files || [];
            var res = {
              changedFiles: [],
              notFoundFiles: [],
              notChangedFiles: []
            };
            me.normalizeEntries(files).forEach(function(entry) {
              if (entry.changed) {
                res.changedFiles.push(entry.key);
                return;
              }
              if (entry.notFound) {
                res.notFoundFiles.push(entry.key);
                return;
              }
              res.notChangedFiles.push(entry.key);
            });
            return res;
          },
          getFileDescriptor: function(file) {
            var fstat;
            try {
              fstat = fs6.statSync(file);
            } catch (ex) {
              this.removeEntry(file);
              return { key: file, notFound: true, err: ex };
            }
            if (useChecksum) {
              return this._getFileDescriptorUsingChecksum(file);
            }
            return this._getFileDescriptorUsingMtimeAndSize(file, fstat);
          },
          _getFileDescriptorUsingMtimeAndSize: function(file, fstat) {
            var meta = cache.getKey(file);
            var cacheExists = !!meta;
            var cSize = fstat.size;
            var cTime = fstat.mtime.getTime();
            var isDifferentDate;
            var isDifferentSize;
            if (!meta) {
              meta = { size: cSize, mtime: cTime };
            } else {
              isDifferentDate = cTime !== meta.mtime;
              isDifferentSize = cSize !== meta.size;
            }
            var nEntry = normalizedEntries[file] = {
              key: file,
              changed: !cacheExists || isDifferentDate || isDifferentSize,
              meta
            };
            return nEntry;
          },
          _getFileDescriptorUsingChecksum: function(file) {
            var meta = cache.getKey(file);
            var cacheExists = !!meta;
            var contentBuffer;
            try {
              contentBuffer = fs6.readFileSync(file);
            } catch (ex) {
              contentBuffer = "";
            }
            var isDifferent = true;
            var hash = this.getHash(contentBuffer);
            if (!meta) {
              meta = { hash };
            } else {
              isDifferent = hash !== meta.hash;
            }
            var nEntry = normalizedEntries[file] = {
              key: file,
              changed: !cacheExists || isDifferent,
              meta
            };
            return nEntry;
          },
          /**
           * Return the list o the files that changed compared
           * against the ones stored in the cache
           *
           * @method getUpdated
           * @param files {Array} the array of files to compare against the ones in the cache
           * @returns {Array}
           */
          getUpdatedFiles: function(files) {
            var me = this;
            files = files || [];
            return me.normalizeEntries(files).filter(function(entry) {
              return entry.changed;
            }).map(function(entry) {
              return entry.key;
            });
          },
          /**
           * return the list of files
           * @method normalizeEntries
           * @param files
           * @returns {*}
           */
          normalizeEntries: function(files) {
            files = files || [];
            var me = this;
            var nEntries = files.map(function(file) {
              return me.getFileDescriptor(file);
            });
            return nEntries;
          },
          /**
           * Remove an entry from the file-entry-cache. Useful to force the file to still be considered
           * modified the next time the process is run
           *
           * @method removeEntry
           * @param entryName
           */
          removeEntry: function(entryName) {
            delete normalizedEntries[entryName];
            cache.removeKey(entryName);
          },
          /**
           * Delete the cache file from the disk
           * @method deleteCacheFile
           */
          deleteCacheFile: function() {
            cache.removeCacheFile();
          },
          /**
           * remove the cache from the file and clear the memory cache
           */
          destroy: function() {
            normalizedEntries = {};
            cache.destroy();
          },
          _getMetaForFileUsingCheckSum: function(cacheEntry) {
            var contentBuffer = fs6.readFileSync(cacheEntry.key);
            var hash = this.getHash(contentBuffer);
            var meta = Object.assign(cacheEntry.meta, { hash });
            delete meta.size;
            delete meta.mtime;
            return meta;
          },
          _getMetaForFileUsingMtimeAndSize: function(cacheEntry) {
            var stat2 = fs6.statSync(cacheEntry.key);
            var meta = Object.assign(cacheEntry.meta, {
              size: stat2.size,
              mtime: stat2.mtime.getTime()
            });
            delete meta.hash;
            return meta;
          },
          /**
           * Sync the files and persist them to the cache
           * @method reconcile
           */
          reconcile: function(noPrune) {
            removeNotFoundFiles();
            noPrune = typeof noPrune === "undefined" ? true : noPrune;
            var entries = normalizedEntries;
            var keys = Object.keys(entries);
            if (keys.length === 0) {
              return;
            }
            var me = this;
            keys.forEach(function(entryName) {
              var cacheEntry = entries[entryName];
              try {
                var meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);
                cache.setKey(entryName, meta);
              } catch (err) {
                if (err.code !== "ENOENT") {
                  throw err;
                }
              }
            });
            cache.save(noPrune);
          }
        };
      }
    };
  }
});

// node_modules/cspell/dist/lib/file-entry-cache.cjs
var require_file_entry_cache = __commonJS({
  "node_modules/cspell/dist/lib/file-entry-cache.cjs"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFromFile = void 0;
    var file_entry_cache = __importStar(require_cache2());
    function createFromFile3(pathToCache, useChecksum) {
      return file_entry_cache.createFromFile(pathToCache, useChecksum);
    }
    exports.createFromFile = createFromFile3;
  }
});

// node_modules/import-meta-resolve/lib/errors.js
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
function createError(sym, value, def) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = 0;
    const error2 = new Base();
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = limit;
    const message = getMessage(key, args, error2);
    Object.defineProperties(error2, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error2);
    error2.code = key;
    return error2;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}
function getMessage(key, args, self) {
  const message = messages.get(key);
  (0, import_node_assert.default)(typeof message !== "undefined", "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert.default)(
      message.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, args);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null)
    expectedLength++;
  (0, import_node_assert.default)(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  );
  if (args.length === 0)
    return message;
  args.unshift(message);
  return Reflect.apply(import_node_util.format, null, args);
}
var import_node_v8, import_node_process, import_node_assert, import_node_util, isWindows, own, codes, messages, nodeInternalPrefix, userStackTraceLimit, captureLargerStackTrace;
var init_errors = __esm({
  "node_modules/import-meta-resolve/lib/errors.js"() {
    import_node_v8 = __toESM(require("node:v8"), 1);
    import_node_process = __toESM(require("node:process"), 1);
    import_node_assert = __toESM(require("node:assert"), 1);
    import_node_util = require("node:util");
    isWindows = import_node_process.default.platform === "win32";
    own = {}.hasOwnProperty;
    codes = {};
    messages = /* @__PURE__ */ new Map();
    nodeInternalPrefix = "__node_internal_";
    codes.ERR_INVALID_MODULE_SPECIFIER = createError(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base = void 0) => {
        return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
      },
      TypeError
    );
    codes.ERR_INVALID_PACKAGE_CONFIG = createError(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path16, base, message) => {
        return `Invalid package config ${path16}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
      },
      Error
    );
    codes.ERR_INVALID_PACKAGE_TARGET = createError(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} pkgPath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (pkgPath, key, target, isImport = false, base = void 0) => {
        const relError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
        if (key === ".") {
          (0, import_node_assert.default)(isImport === false);
          return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }
        return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    codes.ERR_MODULE_NOT_FOUND = createError(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {string} [type]
       */
      (path16, base, type = "package") => {
        return `Cannot find ${type} '${path16}' imported from ${base}`;
      },
      Error
    );
    codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base) => {
        return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
      },
      TypeError
    );
    codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} pkgPath
       * @param {string} subpath
       * @param {string} [base]
       */
      (pkgPath, subpath, base = void 0) => {
        if (subpath === ".")
          return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
        return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
      },
      Error
    );
    codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} ext
       * @param {string} path
       */
      (ext, path16) => {
        return `Unknown file extension "${ext}" for ${path16}`;
      },
      TypeError
    );
    codes.ERR_INVALID_ARG_VALUE = createError(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name, value, reason = "is invalid") => {
        let inspected = (0, import_node_util.inspect)(value);
        if (inspected.length > 128) {
          inspected = `${inspected.slice(0, 128)}...`;
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError(
      "ERR_UNSUPPORTED_ESM_URL_SCHEME",
      /**
       * @param {URL} url
       * @param {Array<string>} supported
       */
      (url, supported) => {
        let message = `Only URLs with a scheme in: ${formatList(
          supported
        )} are supported by the default ESM loader`;
        if (isWindows && url.protocol.length === 2) {
          message += ". On Windows, absolute paths must be valid file:// URLs";
        }
        message += `. Received protocol '${url.protocol}'`;
        return message;
      },
      Error
    );
    captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error2) {
        const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        if (stackTraceLimitIsWritable) {
          userStackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        }
        Error.captureStackTrace(error2);
        if (stackTraceLimitIsWritable)
          Error.stackTraceLimit = userStackTraceLimit;
        return error2;
      }
    );
  }
});

// node_modules/import-meta-resolve/lib/package-json-reader.js
function read(jsonPath) {
  try {
    const string = import_node_fs.default.readFileSync(
      import_node_path.default.toNamespacedPath(import_node_path.default.join(import_node_path.default.dirname(jsonPath), "package.json")),
      "utf8"
    );
    return { string };
  } catch (error2) {
    const exception = (
      /** @type {ErrnoException} */
      error2
    );
    if (exception.code === "ENOENT") {
      return { string: void 0 };
    }
    throw exception;
  }
}
var import_node_fs, import_node_path, reader, package_json_reader_default;
var init_package_json_reader = __esm({
  "node_modules/import-meta-resolve/lib/package-json-reader.js"() {
    import_node_fs = __toESM(require("node:fs"), 1);
    import_node_path = __toESM(require("node:path"), 1);
    reader = { read };
    package_json_reader_default = reader;
  }
});

// node_modules/import-meta-resolve/lib/package-config.js
function getPackageConfig(path16, specifier, base) {
  const existing = packageJsonCache.get(path16);
  if (existing !== void 0) {
    return existing;
  }
  const source = package_json_reader_default.read(path16).string;
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path16,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJsonCache.set(path16, packageConfig2);
    return packageConfig2;
  }
  let packageJson;
  try {
    packageJson = JSON.parse(source);
  } catch (error2) {
    const exception = (
      /** @type {ErrnoException} */
      error2
    );
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path16,
      (base ? `"${specifier}" from ` : "") + (0, import_node_url.fileURLToPath)(base || specifier),
      exception.message
    );
  }
  const { exports, imports, main, name, type } = packageJson;
  const packageConfig = {
    pjsonPath: path16,
    exists: true,
    main: typeof main === "string" ? main : void 0,
    name: typeof name === "string" ? name : void 0,
    type: type === "module" || type === "commonjs" ? type : "none",
    // @ts-expect-error Assume `Record<string, unknown>`.
    exports,
    // @ts-expect-error Assume `Record<string, unknown>`.
    imports: imports && typeof imports === "object" ? imports : void 0
  };
  packageJsonCache.set(path16, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved) {
  let packageJsonUrl = new import_node_url.URL("package.json", resolved);
  while (true) {
    const packageJsonPath2 = packageJsonUrl.pathname;
    if (packageJsonPath2.endsWith("node_modules/package.json"))
      break;
    const packageConfig2 = getPackageConfig(
      (0, import_node_url.fileURLToPath)(packageJsonUrl),
      resolved
    );
    if (packageConfig2.exists)
      return packageConfig2;
    const lastPackageJsonUrl = packageJsonUrl;
    packageJsonUrl = new import_node_url.URL("../package.json", packageJsonUrl);
    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname)
      break;
  }
  const packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  const packageConfig = {
    pjsonPath: packageJsonPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJsonCache.set(packageJsonPath, packageConfig);
  return packageConfig;
}
var import_node_url, ERR_INVALID_PACKAGE_CONFIG, packageJsonCache;
var init_package_config = __esm({
  "node_modules/import-meta-resolve/lib/package-config.js"() {
    import_node_url = require("node:url");
    init_errors();
    init_package_json_reader();
    ({ ERR_INVALID_PACKAGE_CONFIG } = codes);
    packageJsonCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/import-meta-resolve/lib/resolve-get-package-type.js
function getPackageType(url) {
  const packageConfig = getPackageScopeConfig(url);
  return packageConfig.type;
}
var init_resolve_get_package_type = __esm({
  "node_modules/import-meta-resolve/lib/resolve-get-package-type.js"() {
    init_package_config();
  }
});

// node_modules/import-meta-resolve/lib/get-format.js
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json")
    return "json";
  return null;
}
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  const filepath = (0, import_node_url2.fileURLToPath)(url);
  const ext = import_node_path2.default.extname(filepath);
  if (ext === ".js") {
    return getPackageType(url) === "module" ? "module" : "commonjs";
  }
  const format5 = extensionFormatMap[ext];
  if (format5)
    return format5;
  if (ignoreErrors) {
    return void 0;
  }
  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url, context) {
  if (!hasOwnProperty.call(protocolHandlers, url.protocol)) {
    return null;
  }
  return protocolHandlers[url.protocol](url, context, true) || null;
}
var import_node_path2, import_node_url2, ERR_UNKNOWN_FILE_EXTENSION, hasOwnProperty, extensionFormatMap, protocolHandlers;
var init_get_format = __esm({
  "node_modules/import-meta-resolve/lib/get-format.js"() {
    import_node_path2 = __toESM(require("node:path"), 1);
    import_node_url2 = require("node:url");
    init_resolve_get_package_type();
    init_errors();
    ({ ERR_UNKNOWN_FILE_EXTENSION } = codes);
    hasOwnProperty = {}.hasOwnProperty;
    extensionFormatMap = {
      // @ts-expect-error: hush.
      __proto__: null,
      ".cjs": "commonjs",
      ".js": "module",
      ".json": "json",
      ".mjs": "module"
    };
    protocolHandlers = {
      // @ts-expect-error: hush.
      __proto__: null,
      "data:": getDataProtocolModuleFormat,
      "file:": getFileProtocolModuleFormat,
      "http:": getHttpProtocolModuleFormat,
      "https:": getHttpProtocolModuleFormat,
      "node:"() {
        return "builtin";
      }
    };
  }
});

// node_modules/import-meta-resolve/lib/utils.js
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== void 0 && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE(
        "conditions",
        conditions,
        "expected an array"
      );
    }
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}
var ERR_INVALID_ARG_VALUE, DEFAULT_CONDITIONS, DEFAULT_CONDITIONS_SET;
var init_utils = __esm({
  "node_modules/import-meta-resolve/lib/utils.js"() {
    init_errors();
    ({ ERR_INVALID_ARG_VALUE } = codes);
    DEFAULT_CONDITIONS = Object.freeze(["node", "import"]);
    DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
  }
});

// node_modules/import-meta-resolve/lib/resolve.js
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  const pjsonPath = (0, import_node_url3.fileURLToPath)(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  import_node_process2.default.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url3.fileURLToPath)(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  const format5 = defaultGetFormatWithoutErrors(url, { parentURL: base.href });
  if (format5 !== "module")
    return;
  const path16 = (0, import_node_url3.fileURLToPath)(url.href);
  const pkgPath = (0, import_node_url3.fileURLToPath)(new import_node_url3.URL(".", packageJsonUrl));
  const basePath = (0, import_node_url3.fileURLToPath)(base);
  if (main)
    import_node_process2.default.emitWarning(
      `Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path16.slice(
        pkgPath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  else
    import_node_process2.default.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path16.slice(
        pkgPath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
}
function tryStatSync(path16) {
  try {
    return (0, import_node_fs2.statSync)(path16);
  } catch {
    return new import_node_fs2.Stats();
  }
}
function fileExists(url) {
  const stats = (0, import_node_fs2.statSync)(url, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new import_node_url3.URL(packageConfig.main, packageJsonUrl);
    if (fileExists(guess))
      return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new import_node_url3.URL(tries2[i2], packageJsonUrl);
      if (fileExists(guess))
        break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new import_node_url3.URL(tries[i], packageJsonUrl);
    if (fileExists(guess))
      break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    (0, import_node_url3.fileURLToPath)(new import_node_url3.URL(".", packageJsonUrl)),
    (0, import_node_url3.fileURLToPath)(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSepRegEx.exec(resolved.pathname) !== null)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      (0, import_node_url3.fileURLToPath)(base)
    );
  const filePath = (0, import_node_url3.fileURLToPath)(resolved);
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats.isDirectory()) {
    const error2 = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, import_node_url3.fileURLToPath)(base));
    error2.url = String(resolved);
    throw error2;
  }
  if (!stats.isFile()) {
    throw new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && (0, import_node_url3.fileURLToPath)(base),
      "module"
    );
  }
  if (!preserveSymlinks) {
    const real = (0, import_node_fs2.realpathSync)(filePath);
    const { search, hash } = resolved;
    resolved = (0, import_node_url3.pathToFileURL)(real + (filePath.endsWith(import_node_path3.default.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && (0, import_node_url3.fileURLToPath)(new import_node_url3.URL(".", packageJsonUrl)),
    (0, import_node_url3.fileURLToPath)(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    (0, import_node_url3.fileURLToPath)(new import_node_url3.URL(".", packageJsonUrl)),
    subpath,
    base && (0, import_node_url3.fileURLToPath)(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, import_node_url3.fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && (0, import_node_url3.fileURLToPath)(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    (0, import_node_url3.fileURLToPath)(new import_node_url3.URL(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && (0, import_node_url3.fileURLToPath)(base)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new import_node_url3.URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new import_node_url3.URL(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new import_node_url3.URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new import_node_url3.URL(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new import_node_url3.URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key)
    return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0)
      return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error2) {
        const exception = (
          /** @type {ErrnoException} */
          error2
        );
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET")
          continue;
        throw error2;
      }
      if (resolveResult === void 0)
        continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys.length) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG2(
          (0, import_node_url3.fileURLToPath)(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys.length) {
      const key = keys[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === "string" || Array.isArray(exports))
    return true;
  if (typeof exports !== "object" || exports === null)
    return false;
  const keys = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let j = -1;
  while (++j < keys.length) {
    const key = keys[j];
    const curIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG2(
        (0, import_node_url3.fileURLToPath)(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = (0, import_node_url3.fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  import_node_process2.default.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url3.fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
    exports = { ".": exports };
  }
  if (own2.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i < keys.length) {
    const key = keys[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB)
    return -1;
  if (baseLengthB > baseLengthA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, import_node_url3.fileURLToPath)(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, import_node_url3.pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own2.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys.length) {
          const key = keys[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      (0, import_node_url3.fileURLToPath)(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (import_node_module.builtinModules.includes(specifier)) {
    return new import_node_url3.URL("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = (0, import_node_url3.pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
    }
  }
  let packageJsonUrl = new import_node_url3.URL(
    "./node_modules/" + packageName + "/package.json",
    base
  );
  let packageJsonPath = (0, import_node_url3.fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat2 = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat2.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new import_node_url3.URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = (0, import_node_url3.fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig2 = getPackageConfig(packageJsonPath, specifier, base);
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new import_node_url3.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, (0, import_node_url3.fileURLToPath)(base));
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/")
      return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "")
    return false;
  if (specifier[0] === "/")
    return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const isRemote = base.protocol === "http:" || base.protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    resolved = new import_node_url3.URL(specifier, base);
  } else if (!isRemote && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new import_node_url3.URL(specifier);
    } catch {
      if (!isRemote) {
        resolved = packageResolve(specifier, base, conditions);
      }
    }
  }
  (0, import_node_assert2.default)(typeof resolved !== "undefined", "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsed && parsedParentURL && (parsedParentURL.protocol === "http:" || parsedParentURL.protocol === "https:")) {
    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
      if (parsed && parsed.protocol !== "https:" && parsed.protocol !== "http:") {
        throw new ERR_NETWORK_IMPORT_DISALLOWED(
          specifier,
          parsedParentURL,
          "remote imports cannot import from a local location."
        );
      }
      return { url: parsed.href };
    }
    if (import_node_module.builtinModules.includes(specifier)) {
      throw new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "remote imports cannot import from a local location."
      );
    }
    throw new ERR_NETWORK_IMPORT_DISALLOWED(
      specifier,
      parsedParentURL,
      "only relative and absolute specifiers are supported."
    );
  }
}
function throwIfUnsupportedURLProtocol(url) {
  if (url.protocol !== "file:" && url.protocol !== "data:" && url.protocol !== "node:") {
    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url);
  }
}
function throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports2) {
  if (parsed && parsed.protocol !== "file:" && parsed.protocol !== "data:" && (!experimentalNetworkImports2 || parsed.protocol !== "https:" && parsed.protocol !== "http:")) {
    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(
      parsed,
      ["file", "data"].concat(
        experimentalNetworkImports2 ? ["https", "http"] : []
      )
    );
  }
}
function defaultResolve(specifier, context = {}) {
  const { parentURL } = context;
  (0, import_node_assert2.default)(typeof parentURL !== "undefined", "expected `parentURL` to be defined");
  let parsedParentURL;
  if (parentURL) {
    try {
      parsedParentURL = new import_node_url3.URL(parentURL);
    } catch {
    }
  }
  let parsed;
  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new import_node_url3.URL(specifier, parsedParentURL) : new import_node_url3.URL(specifier);
    if (parsed.protocol === "data:" || experimentalNetworkImports && (parsed.protocol === "https:" || parsed.protocol === "http:")) {
      return { url: parsed.href, format: null };
    }
  } catch {
  }
  const maybeReturn = checkIfDisallowedImport(
    specifier,
    parsed,
    parsedParentURL
  );
  if (maybeReturn)
    return maybeReturn;
  if (parsed && parsed.protocol === "node:")
    return { url: specifier };
  throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports);
  const conditions = getConditionsSet(context.conditions);
  const url = moduleResolve(specifier, new import_node_url3.URL(parentURL), conditions, false);
  throwIfUnsupportedURLProtocol(url);
  return {
    // Do NOT cast `url` to a string: that will work even when there are real
    // problems, silencing them
    url: url.href,
    format: defaultGetFormatWithoutErrors(url, { parentURL })
  };
}
var import_node_assert2, import_node_fs2, import_node_process2, import_node_url3, import_node_path3, import_node_module, RegExpPrototypeSymbolReplace, experimentalNetworkImports, ERR_NETWORK_IMPORT_DISALLOWED, ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG2, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_ESM_URL_SCHEME, own2, invalidSegmentRegEx, deprecatedInvalidSegmentRegEx, invalidPackageNameRegEx, patternRegEx, encodedSepRegEx, emittedPackageWarnings, doubleSlashRegEx;
var init_resolve = __esm({
  "node_modules/import-meta-resolve/lib/resolve.js"() {
    import_node_assert2 = __toESM(require("node:assert"), 1);
    import_node_fs2 = require("node:fs");
    import_node_process2 = __toESM(require("node:process"), 1);
    import_node_url3 = require("node:url");
    import_node_path3 = __toESM(require("node:path"), 1);
    import_node_module = require("node:module");
    init_get_format();
    init_errors();
    init_package_config();
    init_utils();
    RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
    experimentalNetworkImports = false;
    ({
      ERR_NETWORK_IMPORT_DISALLOWED,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_ESM_URL_SCHEME
    } = codes);
    own2 = {}.hasOwnProperty;
    invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
    deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
    invalidPackageNameRegEx = /^\.|%|\\/;
    patternRegEx = /\*/g;
    encodedSepRegEx = /%2f|%5c/i;
    emittedPackageWarnings = /* @__PURE__ */ new Set();
    doubleSlashRegEx = /[/\\]{2}/;
  }
});

// node_modules/import-meta-resolve/index.js
var import_meta_resolve_exports = {};
__export(import_meta_resolve_exports, {
  moduleResolve: () => moduleResolve,
  resolve: () => resolve7
});
async function resolve7(specifier, parent) {
  if (!parent) {
    throw new Error(
      "Please pass `parent`: `import-meta-resolve` cannot ponyfill that"
    );
  }
  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error2) {
    const exception = (
      /** @type {ErrnoException} */
      error2
    );
    return exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" && typeof exception.url === "string" ? exception.url : Promise.reject(error2);
  }
}
var init_import_meta_resolve = __esm({
  "node_modules/import-meta-resolve/index.js"() {
    init_resolve();
    init_resolve();
  }
});

// src/main.ts
var core4 = __toESM(require_core());
var import_github2 = __toESM(require_github());
var import_context = __toESM(require_context());

// src/error.ts
var AppError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function isError(e) {
  if (!e)
    return false;
  if (typeof e !== "object")
    return false;
  const err = e;
  return err.message !== void 0 && err.name !== void 0 && (err.stack === void 0 || typeof err.stack === "string");
}
function isAppError(e) {
  return e instanceof AppError;
}

// src/action.ts
var core3 = __toESM(require_core());

// node_modules/cspell-glob/dist/esm/globHelper.mjs
var Path = __toESM(require("path"), 1);
var { posix } = Path;
var relRegExp = /^\.[\\/]/;
var isGlobalPatternRegExp = /^!*[*]{2}/;
function fileOrGlobToGlob(fileOrGlob, root, path16 = Path) {
  const pathToGlob = path16.sep === "\\" ? (p) => p.replace(/\\/g, "/") : (p) => p;
  const isGlobalPattern = false;
  if (isGlobPatternWithOptionalRoot(fileOrGlob)) {
    const useRoot = fileOrGlob.root ?? root;
    const isGlobalPattern2 = isGlobPatternWithRoot(fileOrGlob) ? fileOrGlob.isGlobalPattern : isGlobalGlob(fileOrGlob.glob);
    return { ...fileOrGlob, root: useRoot, isGlobalPattern: isGlobalPattern2 };
  }
  if (doesRootContainPath(root, fileOrGlob, path16) || relRegExp.test(fileOrGlob)) {
    const rel = path16.relative(root, path16.resolve(root, fileOrGlob));
    return { glob: pathToGlob(rel), root, isGlobalPattern };
  }
  return { glob: pathToGlob(fileOrGlob), root, isGlobalPattern };
}
function doesRootContainPath(root, child, path16) {
  if (child.startsWith(root))
    return true;
  const rel = path16.relative(root, child);
  return !rel || rel !== child && !rel.startsWith("..") && !path16.isAbsolute(rel);
}
function isGlobPatternWithOptionalRoot(g) {
  return typeof g !== "string" && typeof g.glob === "string";
}
function isGlobPatternWithRoot(g) {
  return typeof g.root === "string" && "isGlobalPattern" in g;
}
function isGlobPatternNormalized(g) {
  if (!isGlobPatternWithOptionalRoot(g))
    return false;
  if (!isGlobPatternWithRoot(g))
    return false;
  const gr = g;
  return "rawGlob" in gr && "rawRoot" in gr && typeof gr.rawGlob === "string";
}
function normalizePattern(pattern, nested) {
  pattern = pattern.replace(/^(!!)+/, "");
  const isNeg = pattern.startsWith("!");
  const prefix = isNeg ? "!" : "";
  pattern = isNeg ? pattern.slice(1) : pattern;
  const patterns = nested ? normalizePatternNested(pattern) : normalizePatternGeneral(pattern);
  return patterns.map((p) => prefix + p);
}
function normalizePatternNested(pattern) {
  if (!pattern.includes("/")) {
    if (pattern === "**")
      return ["**"];
    return ["**/" + pattern, "**/" + pattern + "/**"];
  }
  const hasLeadingSlash = pattern.startsWith("/");
  pattern = hasLeadingSlash ? pattern.slice(1) : pattern;
  if (pattern.endsWith("/")) {
    return hasLeadingSlash || pattern.slice(0, -1).includes("/") ? [pattern + "**/*"] : ["**/" + pattern + "**/*"];
  }
  if (pattern.endsWith("**")) {
    return [pattern];
  }
  return [pattern, pattern + "/**"];
}
function normalizePatternGeneral(pattern) {
  pattern = pattern.startsWith("/") ? pattern.slice(1) : pattern;
  pattern = pattern.endsWith("/") ? pattern + "**/*" : pattern;
  return [pattern];
}
function normalizeGlobPatterns(patterns, options) {
  function* normalize() {
    for (const glob2 of patterns) {
      if (isGlobPatternNormalized(glob2)) {
        yield glob2;
        continue;
      }
      yield* normalizeGlobPattern(glob2, options);
    }
  }
  return [...normalize()];
}
function normalizeGlobPattern(g, options) {
  const { root, nodePath: path16 = Path, nested, cwd = Path.resolve() } = options;
  g = !isGlobPatternWithOptionalRoot(g) ? { glob: g } : g;
  const gr = { ...g, root: g.root ?? root };
  const rawRoot = gr.root;
  const rawGlob = g.glob;
  gr.glob = gr.glob.trim();
  if (gr.glob.startsWith("${cwd}")) {
    gr.glob = gr.glob.replace("${cwd}", "");
    gr.root = "${cwd}";
  }
  if (gr.root.startsWith("${cwd}")) {
    gr.root = path16.resolve(gr.root.replace("${cwd}", cwd));
  }
  const isGlobalPattern = isGlobalGlob(gr.glob);
  gr.root = path16.resolve(root, path16.normalize(gr.root));
  const globs = normalizePattern(gr.glob, nested);
  return globs.map((glob2) => ({ ...gr, glob: glob2, rawGlob, rawRoot, isGlobalPattern }));
}
function normalizeGlobToRoot(glob2, root, path16) {
  function relToGlob(relativePath2) {
    return path16.sep === "\\" ? relativePath2.replace(/\\/g, "/") : relativePath2;
  }
  if (glob2.root === root) {
    return glob2;
  }
  const relFromRootToGlob = path16.relative(root, glob2.root);
  if (!relFromRootToGlob) {
    return glob2;
  }
  if (glob2.isGlobalPattern) {
    return { ...glob2, root };
  }
  const relFromGlobToRoot = path16.relative(glob2.root, root);
  const globIsUnderRoot = relFromRootToGlob[0] !== "." && !path16.isAbsolute(relFromRootToGlob);
  const rootIsUnderGlob = relFromGlobToRoot[0] !== "." && !path16.isAbsolute(relFromGlobToRoot);
  if (!globIsUnderRoot && !rootIsUnderGlob) {
    return glob2;
  }
  const isNeg = glob2.glob.startsWith("!");
  const g = isNeg ? glob2.glob.slice(1) : glob2.glob;
  const prefix = isNeg ? "!" : "";
  if (globIsUnderRoot) {
    const relGlob2 = relToGlob(relFromRootToGlob);
    return {
      ...glob2,
      glob: prefix + posix.join(relGlob2, g),
      root
    };
  }
  const relGlob = relToGlob(relFromGlobToRoot) + "/";
  const rebasedGlob = rebaseGlob(g, relGlob);
  return rebasedGlob ? { ...glob2, glob: prefix + rebasedGlob, root } : glob2;
}
function rebaseGlob(glob2, rebaseTo) {
  if (!rebaseTo || rebaseTo === "/")
    return glob2;
  if (glob2.startsWith("**"))
    return glob2;
  rebaseTo = rebaseTo.endsWith("/") ? rebaseTo : rebaseTo + "/";
  if (glob2.startsWith(rebaseTo)) {
    return glob2.slice(rebaseTo.length);
  }
  const relParts = rebaseTo.split("/");
  const globParts = glob2.split("/");
  for (let i = 0; i < relParts.length && i < globParts.length; ++i) {
    const relSeg = relParts[i];
    const globSeg = globParts[i];
    if (!relSeg || globSeg === "**") {
      return globParts.slice(i).join("/");
    }
    if (relSeg !== globSeg && globSeg !== "*") {
      break;
    }
  }
  return void 0;
}
function isGlobalGlob(glob2) {
  return isGlobalPatternRegExp.test(glob2);
}

// node_modules/cspell-glob/dist/esm/GlobMatcher.mjs
var import_micromatch = __toESM(require_micromatch(), 1);
var Path2 = __toESM(require("path"), 1);
var GlobMatcher = class {
  constructor(patterns, rootOrOptions, _nodePath) {
    _nodePath = _nodePath ?? Path2;
    const options = typeof rootOrOptions === "string" ? { root: rootOrOptions } : rootOrOptions ?? {};
    const { mode = "exclude" } = options;
    const isExcludeMode = mode !== "include";
    _nodePath = options.nodePath ?? _nodePath;
    const { root = _nodePath.resolve(), dot = isExcludeMode, nodePath = _nodePath, nested = isExcludeMode, cwd = process.cwd(), nobrace } = options;
    const normalizedRoot = nodePath.resolve(nodePath.normalize(root));
    this.options = { root: normalizedRoot, dot, nodePath, nested, mode, nobrace, cwd };
    patterns = Array.isArray(patterns) ? patterns : typeof patterns === "string" ? patterns.split(/\r?\n/g) : [patterns];
    const globPatterns = normalizeGlobPatterns(patterns, this.options);
    this.patternsNormalizedToRoot = globPatterns.map((g) => normalizeGlobToRoot(g, normalizedRoot, nodePath)).filter((g) => nodePath.relative(g.root, normalizedRoot) === "");
    this.patterns = globPatterns;
    this.root = normalizedRoot;
    this.path = nodePath;
    this.dot = dot;
    this.matchEx = buildMatcherFn(this.patterns, this.options);
  }
  /**
   * Check to see if a filename matches any of the globs.
   * If filename is relative, it is considered relative to the root.
   * If filename is absolute and contained within the root, it will be made relative before being tested for a glob match.
   * If filename is absolute and not contained within the root, it will be tested as is.
   * @param filename full path of the file to check.
   */
  match(filename) {
    return this.matchEx(filename).matched;
  }
};
function buildMatcherFn(patterns, options) {
  const { nodePath: path16, dot, nobrace } = options;
  const makeReOptions = { dot, nobrace };
  const rules = patterns.map((pattern, index) => ({ pattern, index })).filter((r) => !!r.pattern.glob).filter((r) => !r.pattern.glob.startsWith("#")).map(({ pattern, index }) => {
    const matchNeg = pattern.glob.match(/^!/);
    const glob2 = pattern.glob.replace(/^!/, "");
    const isNeg = matchNeg && matchNeg[0].length & 1 && true || false;
    const reg = import_micromatch.default.makeRe(glob2, makeReOptions);
    const fn2 = (filename) => {
      const match = filename.match(reg);
      return !!match;
    };
    return { pattern, index, isNeg, fn: fn2, reg };
  });
  const negRules = rules.filter((r) => r.isNeg);
  const posRules = rules.filter((r) => !r.isNeg);
  const fn = (filename) => {
    filename = path16.resolve(path16.normalize(filename));
    function testRules(rules2, matched) {
      for (const rule of rules2) {
        const pattern = rule.pattern;
        const root = pattern.root;
        const isRelPat = !pattern.isGlobalPattern;
        if (isRelPat && !doesRootContainPath(root, filename, path16)) {
          continue;
        }
        const relName = isRelPat ? path16.relative(root, filename) : filename;
        const fname = path16.sep === "\\" ? relName.replace(/\\/g, "/") : relName;
        if (rule.fn(fname)) {
          return {
            matched,
            glob: pattern.glob,
            root,
            pattern,
            index: rule.index,
            isNeg: rule.isNeg
          };
        }
      }
    }
    return testRules(negRules, false) || testRules(posRules, true) || { matched: false };
  };
  return fn;
}

// src/action.ts
var path15 = __toESM(require("path"));

// src/ActionParams.ts
var import_fs = require("fs");
var defaultActionParams = {
  github_token: "",
  files: "",
  incremental_files_only: "true",
  config: "",
  root: "",
  inline: "warning",
  strict: "true",
  verbose: "false",
  check_dot_files: "explicit"
};
function applyDefaults(params) {
  const results = { ...params };
  const alias = results;
  for (const [key, value] of Object.entries(defaultActionParams)) {
    alias[key] = alias[key] || value;
  }
  return results;
}
function validateToken(params) {
  const token = params.github_token;
  return !token ? "Missing GITHUB Token" : void 0;
}
function validateConfig(params) {
  const config = params.config;
  const success = !config || (0, import_fs.existsSync)(config);
  return !success ? `Configuration file "${config}" not found.` : void 0;
}
function validateRoot(params) {
  const root = params.root;
  const success = !root || (0, import_fs.existsSync)(root);
  return !success ? `Root path does not exist: "${root}"` : void 0;
}
function validateInlineLevel(params) {
  const inline = params.inline;
  const success = isInlineWorkflowCommand(inline);
  return !success ? `Invalid inline level (${inline}), must be one of (error, warning, none)` : void 0;
}
var validateStrict = validateTrueFalse("strict", "Invalid strict setting, must be one of (true, false)");
var validateIncrementalFilesOnly = validateTrueFalse(
  "incremental_files_only",
  "Invalid incremental_files_only setting, must be one of (true, false)"
);
var validateVerbose = validateTrueFalse("verbose", "Invalid verbose setting, must be one of (true, false)");
function validateTrueFalse(key, msg) {
  return (params) => {
    const value = params[key];
    const success = value === "true" || value === "false";
    return !success ? msg : void 0;
  };
}
var inlineWorkflowCommandSet = {
  error: true,
  warning: true,
  none: true
};
function isInlineWorkflowCommand(cmd) {
  return !!inlineWorkflowCommandSet[cmd];
}
function validateActionParams(params, logError) {
  const validations = [
    validateToken,
    validateConfig,
    validateRoot,
    validateInlineLevel,
    validateStrict,
    validateIncrementalFilesOnly,
    validateVerbose
  ];
  const success = validations.map((fn) => fn(params)).map((msg) => !msg || (logError(msg), false)).reduce((a, b) => a && b, true);
  if (!success) {
    throw new AppError("Bad Configuration.");
  }
}

// src/getActionParams.ts
var core = __toESM(require_core());
function getActionParams() {
  return applyDefaults({
    github_token: core.getInput("github_token", { required: true }),
    files: core.getInput("files"),
    incremental_files_only: tf(core.getInput("incremental_files_only")),
    config: core.getInput("config"),
    root: core.getInput("root"),
    inline: core.getInput("inline").toLowerCase(),
    strict: tf(core.getInput("strict")),
    verbose: tf(core.getInput("verbose")),
    check_dot_files: tf(core.getInput("check_dot_files"))
  });
}
function tf(v) {
  const mapValues = {
    true: "true",
    t: "true",
    false: "false",
    f: "false",
    "0": "false",
    "1": "true"
  };
  v = typeof v === "boolean" || typeof v === "number" ? v ? "true" : "false" : v;
  v = v.toString();
  v = v.toLowerCase();
  v = mapValues[v] || v;
  return v;
}

// src/github.ts
var import_plugin_rest_endpoint_methods = __toESM(require_dist_node11());
async function getPullRequestFiles(git, prRef) {
  const { owner, repo, pull_number } = prRef;
  const { rest } = (0, import_plugin_rest_endpoint_methods.restEndpointMethods)(git);
  const commits = await rest.pulls.listCommits({ owner, repo, pull_number });
  return fetchFilesForCommits(git, prRef, commits.data.map((c) => c.sha).filter(isString));
}
function isString(s) {
  return typeof s === "string";
}
async function fetchFilesForCommits(git, context, commitIds) {
  const files = /* @__PURE__ */ new Set();
  for await (const file of fetchFilesForCommitsX(git, context, commitIds)) {
    files.add(file);
  }
  return files;
}
async function* fetchFilesForCommitsX(git, context, commitIds) {
  const { owner, repo } = context;
  const { rest } = (0, import_plugin_rest_endpoint_methods.restEndpointMethods)(git);
  for (const ref of commitIds) {
    const commit = await rest.repos.getCommit({ owner, repo, ref });
    const files = commit.data.files;
    if (!files)
      continue;
    for (const f of files) {
      if (f.filename) {
        yield f.filename;
      }
    }
  }
}

// src/reporter.ts
var core2 = __toESM(require_core());
var import_command = __toESM(require_command());
var import_vscode_uri = __toESM(require_umd());
var path = __toESM(require("path"));
function nullEmitter(_msg) {
}
var CSpellReporterForGithubAction = class {
  constructor(reportIssueCommand, options, logger = core2) {
    this.reportIssueCommand = reportIssueCommand;
    this.options = options;
    this.logger = logger;
    this.issues = [];
    this.issueCounts = /* @__PURE__ */ new Map();
    this.result = {
      files: -1,
      filesWithIssues: /* @__PURE__ */ new Set(),
      issues: -1,
      errors: -1,
      cachedFiles: 0
    };
    this.finished = false;
    this.reporter = {
      debug: (...args) => this._debug(...args),
      error: (...args) => this._error(...args),
      info: (...args) => this._info(...args),
      issue: (...args) => this._issue(...args),
      progress: (...args) => this._progress(...args),
      result: (...args) => this._result(...args)
    };
    this.verbose = options.verbose;
  }
  _issue(issue) {
    const { issues, issueCounts } = this;
    const uri = issue.uri;
    uri && issueCounts.set(uri, (issueCounts.get(uri) || 0) + 1);
    issues.push(issue);
  }
  _info(message, _msgType) {
    this._debug(message);
  }
  _debug(message) {
    nullEmitter(message);
  }
  _progress(progress) {
    if (!this.verbose || !isProgressFileComplete(progress)) {
      return;
    }
    const { issueCounts, logger } = this;
    const issueCount = issueCounts.get(progress.filename) || 0;
    const { fileNum, fileCount, filename, elapsedTimeMs } = progress;
    const issues = issueCount ? ` issues: ${issueCount}` : "";
    const timeMsg = elapsedTimeMs ? `(${elapsedTimeMs.toFixed(2)}ms)` : "-";
    logger.info(`${fileNum}/${fileCount} ${filename}${issues} ${timeMsg}`);
  }
  _error(message, error2) {
    const { logger } = this;
    logger.error(`${message}
        name: ${error2.name}
        msg: ${error2.message}
        stack:
${error2.stack}
        `);
    return;
  }
  _result(result) {
    Object.assign(this.result, result);
    this.finished = true;
    const command = this.reportIssueCommand;
    if (!["error", "warning"].includes(command)) {
      return;
    }
    const cwd = process.cwd();
    this.issues.forEach((item) => {
      (0, import_command.issueCommand)(
        command,
        {
          file: relative2(cwd, item.uri || ""),
          line: item.row,
          col: item.col
        },
        `Unknown word (${item.text})`
      );
      console.warn(`${relative2(cwd, item.uri || "")}:${item.row}:${item.col} Unknown word (${item.text})`);
    });
  }
};
function isProgressFileComplete(p) {
  return p.type === "ProgressFileComplete";
}
function relative2(cwd, fileUri) {
  const fsPath = import_vscode_uri.URI.parse(fileUri).fsPath;
  return path.relative(cwd, fsPath);
}

// node_modules/@cspell/cspell-pipe/dist/esm/helpers/iteratorToIterable.mjs
function* iteratorToIterable(iterator) {
  let n;
  while (!(n = iterator.next()).done) {
    yield n.value;
  }
}
async function* asyncIteratorToAsyncIterable(iterator) {
  let n;
  while (!(n = await iterator.next()).done) {
    yield n.value;
  }
}

// node_modules/@cspell/cspell-pipe/dist/esm/helpers/util.mjs
function toPipeFn(syncFn, asyncFn) {
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}
function isAsyncIterable(i) {
  return typeof i[Symbol.asyncIterator] === "function";
}

// node_modules/@cspell/cspell-pipe/dist/esm/helpers/toArray.mjs
function toArray(i) {
  return isAsyncIterable(i) ? toArrayAsync(i) : toArraySync(i);
}
function toArraySync(iter) {
  return [...iter];
}
async function toArrayAsync(iter) {
  const collection = [];
  for await (const i of iter) {
    collection.push(i);
  }
  return collection;
}

// node_modules/@cspell/cspell-pipe/dist/esm/helpers/toAsyncIterable.mjs
async function* mergeAsyncIterables(iter, ...rest) {
  for await (const i of [iter, ...rest]) {
    yield* i;
  }
}
var toAsyncIterable = mergeAsyncIterables;

// node_modules/@cspell/cspell-pipe/dist/esm/operators/index.mjs
var operators_exports = {};
__export(operators_exports, {
  opAppend: () => opAppend,
  opAppendAsync: () => opAppendAsync,
  opAppendSync: () => opAppendSync,
  opAwaitAsync: () => opAwaitAsync,
  opCombineAsync: () => opCombineAsync,
  opCombineSync: () => opCombineSync,
  opConcatMap: () => opConcatMap,
  opConcatMapAsync: () => opConcatMapAsync,
  opConcatMapSync: () => opConcatMapSync,
  opFilter: () => opFilter,
  opFilterAsync: () => opFilterAsync,
  opFilterSync: () => opFilterSync,
  opFirst: () => opFirst,
  opFirstAsync: () => opFirstAsync,
  opFirstSync: () => opFirstSync,
  opFlatten: () => opFlatten,
  opFlattenAsync: () => opFlattenAsync,
  opFlattenSync: () => opFlattenSync,
  opJoinStrings: () => opJoinStrings,
  opJoinStringsAsync: () => opJoinStringsAsync,
  opJoinStringsSync: () => opJoinStringsSync,
  opLast: () => opLast,
  opLastAsync: () => opLastAsync,
  opLastSync: () => opLastSync,
  opMap: () => opMap,
  opMapAsync: () => opMapAsync,
  opMapSync: () => opMapSync,
  opReduceAsync: () => opReduceAsync,
  opReduceSync: () => opReduceSync,
  opSkip: () => opSkip,
  opSkipAsync: () => opSkipAsync,
  opSkipSync: () => opSkipSync,
  opTake: () => opTake,
  opTakeAsync: () => opTakeAsync,
  opTakeSync: () => opTakeSync,
  opTap: () => opTap,
  opTapAsync: () => opTapAsync,
  opTapSync: () => opTapSync,
  opUnique: () => opUnique,
  opUniqueAsync: () => opUniqueAsync,
  opUniqueSync: () => opUniqueSync
});

// node_modules/@cspell/cspell-pipe/dist/esm/operators/append.mjs
function opAppendAsync(...iterablesToAppend) {
  async function* fn(iter) {
    yield* iter;
    for (const i of iterablesToAppend) {
      yield* i;
    }
  }
  return fn;
}
function opAppendSync(...iterablesToAppend) {
  function* fn(iter) {
    yield* iter;
    for (const i of iterablesToAppend) {
      yield* i;
    }
  }
  return fn;
}
function opAppend(...iterablesToAppend) {
  function _(i) {
    return isAsyncIterable(i) ? opAppendAsync(...iterablesToAppend)(i) : opAppendSync(...iterablesToAppend)(i);
  }
  return _;
}

// node_modules/@cspell/cspell-pipe/dist/esm/operators/await.mjs
async function* _asyncAwait(iter) {
  for await (const v of iter) {
    yield v;
  }
}
function opAwaitAsync() {
  return _asyncAwait;
}

// node_modules/@cspell/cspell-pipe/dist/esm/operators/combine.mjs
function opCombineAsync(...fns) {
  function combine(iter) {
    for (const fn of fns) {
      iter = fn(iter);
    }
    return iter;
  }
  return combine;
}
function opCombineSync(...fns) {
  function combine(iter) {
    for (const fn of fns) {
      iter = fn(iter);
    }
    return iter;
  }
  return combine;
}

// node_modules/@cspell/cspell-pipe/dist/esm/operators/concatMap.mjs
function opConcatMapAsync(mapFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      yield* mapFn(v);
    }
  }
  return fn;
}
function opConcatMapSync(mapFn) {
  function* fn(iter) {
    for (const v of iter) {
      yield* mapFn(v);
    }
  }
  return fn;
}
var opConcatMap = (fn) => toPipeFn(opConcatMapSync(fn), opConcatMapAsync(fn));

// node_modules/@cspell/cspell-pipe/dist/esm/operators/filter.mjs
function opFilterAsync(filterFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      const pass = await filterFn(v);
      if (pass)
        yield v;
    }
  }
  return fn;
}
function opFilterSync(filterFn) {
  function* fn(iter) {
    for (const v of iter) {
      if (filterFn(v))
        yield v;
    }
  }
  return fn;
}
function opFilter(fn) {
  const asyncFn = opFilterAsync(fn);
  const syncFn = opFilterSync(fn);
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}

// node_modules/@cspell/cspell-pipe/dist/esm/operators/first.mjs
function opFirstAsync(firstFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      const pass = await firstFn(v);
      if (pass) {
        yield v;
        break;
      }
    }
  }
  return fn;
}
function opFirstSync(firstFn) {
  function* fn(iter) {
    for (const v of iter) {
      if (firstFn(v)) {
        yield v;
        break;
      }
    }
  }
  return fn;
}
function opFirst(fn) {
  const asyncFn = opFirstAsync(fn);
  const syncFn = opFirstSync(fn);
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}

// node_modules/@cspell/cspell-pipe/dist/esm/operators/flatten.mjs
function opFlattenAsync() {
  async function* fn(iter) {
    for await (const v of iter) {
      yield* v;
    }
  }
  return fn;
}
function opFlattenSync() {
  function* fn(iter) {
    for (const v of iter) {
      yield* v;
    }
  }
  return fn;
}
var opFlatten = () => toPipeFn(opFlattenSync(), opFlattenAsync());

// node_modules/@cspell/cspell-pipe/dist/esm/operators/joinStrings.mjs
function opJoinStringsAsync(joinCharacter = ",") {
  async function* fn(iter) {
    for await (const v of iter) {
      const a = await toArray(v);
      yield a.join(joinCharacter);
    }
  }
  return fn;
}
function opJoinStringsSync(joinCharacter = ",") {
  function* fn(iter) {
    for (const v of iter) {
      const a = toArray(v);
      yield a.join(joinCharacter);
    }
  }
  return fn;
}
var opJoinStrings = (joinCharacter) => toPipeFn(opJoinStringsSync(joinCharacter), opJoinStringsAsync(joinCharacter));

// node_modules/@cspell/cspell-pipe/dist/esm/operators/last.mjs
var symNotFound = Symbol("LastNotFound");
function opLastAsync(lastFn) {
  async function* fn(iter) {
    let last = symNotFound;
    for await (const v of iter) {
      const pass = await lastFn(v);
      if (pass) {
        last = v;
      }
    }
    if (last !== symNotFound)
      yield last;
  }
  return fn;
}
function opLastSync(lastFn) {
  function* fn(iter) {
    let last = symNotFound;
    for (const v of iter) {
      if (lastFn(v)) {
        last = v;
      }
    }
    if (last !== symNotFound)
      yield last;
  }
  return fn;
}
function opLast(fn) {
  const asyncFn = opLastAsync(fn);
  const syncFn = opLastSync(fn);
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}

// node_modules/@cspell/cspell-pipe/dist/esm/operators/map.mjs
function opMapAsync(mapFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      yield mapFn(v);
    }
  }
  return fn;
}
function opMapSync(mapFn) {
  function* fn(iter) {
    for (const v of iter) {
      yield mapFn(v);
    }
  }
  return fn;
}
var opMap = (fn) => toPipeFn(opMapSync(fn), opMapAsync(fn));

// node_modules/@cspell/cspell-pipe/dist/esm/operators/reduce.mjs
function opReduceAsync(reduceFn, initialValue) {
  async function* reduce2(head, tail) {
    for await (const v of tail) {
      head = reduceFn(head, v);
    }
    yield head;
  }
  async function* fn(iter) {
    const ht = initialValue === void 0 ? await headTailAsync(iter) : { head: await initialValue, tail: iter };
    if (!ht)
      return;
    yield* reduce2(ht.head, ht.tail);
  }
  return fn;
}
function opReduceSync(reduceFn, initialValue) {
  function* reduce2(head, tail) {
    for (const v of tail) {
      head = reduceFn(head, v);
    }
    yield head;
  }
  function* fn(iter) {
    const ht = initialValue === void 0 ? headTail(iter) : { head: initialValue, tail: iter };
    if (!ht)
      return;
    yield* reduce2(ht.head, ht.tail);
  }
  return fn;
}
function headTail(iter) {
  const iterator = iter[Symbol.iterator]();
  const first = iterator.next();
  if (first.done)
    return void 0;
  return { head: first.value, tail: iteratorToIterable(iterator) };
}
async function headTailAsync(iter) {
  const iterator = isIterable(iter) ? iter[Symbol.iterator]() : iter[Symbol.asyncIterator]();
  const first = await iterator.next();
  if (first.done)
    return void 0;
  return { head: first.value, tail: asyncIteratorToAsyncIterable(iterator) };
}
function isIterable(i) {
  return typeof i[Symbol.iterator] === "function";
}

// node_modules/@cspell/cspell-pipe/dist/esm/operators/skip.mjs
function opSkipAsync(count) {
  async function* fn(iter) {
    for await (const v of iter) {
      if (count > 0) {
        --count;
        continue;
      }
      yield v;
    }
  }
  return fn;
}
function opSkipSync(count) {
  function* fn(iter) {
    for (const v of iter) {
      if (count > 0) {
        --count;
        continue;
      }
      yield v;
    }
  }
  return fn;
}
var opSkip = (count) => toPipeFn(opSkipSync(count), opSkipAsync(count));

// node_modules/@cspell/cspell-pipe/dist/esm/operators/take.mjs
function opTakeAsync(count) {
  async function* fn(iter) {
    if (count <= 0)
      return;
    for await (const v of iter) {
      yield v;
      if (--count <= 0)
        return;
    }
  }
  return fn;
}
function opTakeSync(count) {
  function* fn(iter) {
    if (count <= 0)
      return;
    for (const v of iter) {
      yield v;
      if (--count <= 0)
        return;
    }
  }
  return fn;
}
var opTake = (count) => toPipeFn(opTakeSync(count), opTakeAsync(count));

// node_modules/@cspell/cspell-pipe/dist/esm/operators/tap.mjs
function opTapAsync(tapFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      tapFn(v);
      yield v;
    }
  }
  return fn;
}
function opTapSync(tapFn) {
  function* fn(iter) {
    for (const v of iter) {
      tapFn(v);
      yield v;
    }
  }
  return fn;
}
var opTap = (fn) => toPipeFn(opTapSync(fn), opTapAsync(fn));

// node_modules/@cspell/cspell-pipe/dist/esm/operators/unique.mjs
function opUniqueAsync(k) {
  function fnK(k2) {
    async function* fn2(iter) {
      const s = /* @__PURE__ */ new Set();
      for await (const v of iter) {
        const kk = k2(v);
        if (s.has(kk))
          continue;
        s.add(kk);
        yield v;
      }
    }
    return fn2;
  }
  async function* fn(iter) {
    const s = /* @__PURE__ */ new Set();
    for await (const v of iter) {
      if (s.has(v))
        continue;
      s.add(v);
      yield v;
    }
  }
  return k ? fnK(k) : fn;
}
function opUniqueSync(k) {
  function fnK(key) {
    function* fn2(iter) {
      const s = /* @__PURE__ */ new Set();
      for (const v of iter) {
        const kk = key(v);
        if (s.has(kk))
          continue;
        s.add(kk);
        yield v;
      }
    }
    return fn2;
  }
  function* fn(iter) {
    const s = /* @__PURE__ */ new Set();
    for (const v of iter) {
      if (s.has(v))
        continue;
      s.add(v);
      yield v;
    }
  }
  return k ? fnK(k) : fn;
}
var opUnique = (getKey) => toPipeFn(opUniqueSync(getKey), opUniqueAsync(getKey));

// node_modules/@cspell/cspell-pipe/dist/esm/pipe.mjs
function pipeAsync(i, ...fns) {
  const iter = toAsyncIterable(i);
  return opCombineAsync(...fns)(iter);
}
function pipeSync(i, ...fns) {
  return opCombineSync(...fns)(i);
}

// node_modules/@cspell/cspell-pipe/dist/esm/index.mjs
var operators = operators_exports;

// node_modules/cspell/dist/esm/application.mjs
var import_cspell_lib4 = __toESM(require_cjs10(), 1);

// node_modules/cspell/dist/esm/cli-reporter.mjs
var import_chalk = __toESM(require_source(), 1);
var import_cspell_lib = __toESM(require_cjs10(), 1);
var path2 = __toESM(require("path"), 1);
var import_uri = __toESM(require_uri(), 1);
var templateIssue = `{green $filename}:{yellow $row:$col} - $message ({red $text}) $quickFix`;
var templateIssueNoFix = `{green $filename}:{yellow $row:$col} - $message ({red $text})`;
var templateIssueWithSuggestions = `{green $filename}:{yellow $row:$col} - $message ({red $text}) Suggestions: {yellow [$suggestions]}`;
var templateIssueWithContext = `{green $filename}:{yellow $row:$col} $padRowCol- $message ({red $text})$padContext -- {gray $contextLeft}{red {underline $text}}{gray $contextRight}`;
var templateIssueWithContextWithSuggestions = `{green $filename}:{yellow $row:$col} $padRowCol- $message ({red $text})$padContext -- {gray $contextLeft}{red {underline $text}}{gray $contextRight}
	 Suggestions: {yellow [$suggestions]}`;
var templateIssueLegacy = `${import_chalk.default.green("$filename")}[$row, $col]: $message: ${import_chalk.default.red("$text")}`;
var templateIssueWordsOnly = "$text";
function genIssueEmitter(template2) {
  const defaultWidth = 10;
  let maxWidth = defaultWidth;
  let uri;
  return function issueEmitter(issue) {
    if (uri !== issue.uri) {
      maxWidth = defaultWidth;
      uri = issue.uri;
    }
    maxWidth = Math.max(maxWidth * 0.999, issue.text.length, 10);
    console.log(formatIssue(template2, issue, Math.ceil(maxWidth)));
  };
}
function errorEmitter(message, error2) {
  if ((0, import_cspell_lib.isSpellingDictionaryLoadError)(error2)) {
    error2 = error2.cause;
  }
  console.error(import_chalk.default.red(message), error2.toString());
}
function nullEmitter2() {
}
function relativeFilename(filename, cwd = process.cwd()) {
  const rel = path2.relative(cwd, filename);
  if (rel.startsWith(".."))
    return filename;
  return "." + path2.sep + rel;
}
function relativeUriFilename(uri, fsPathRoot) {
  const fsPath = import_uri.URI.parse(uri).fsPath;
  const rel = path2.relative(fsPathRoot, fsPath);
  if (rel.startsWith(".."))
    return fsPath;
  return "." + path2.sep + rel;
}
function reportProgress(p) {
  if (p.type === "ProgressFileComplete") {
    return reportProgressFileComplete(p);
  }
  if (p.type === "ProgressFileBegin") {
    return reportProgressFileBegin(p);
  }
}
function reportProgressFileBegin(p) {
  const fc = "" + p.fileCount;
  const fn = (" ".repeat(fc.length) + p.fileNum).slice(-fc.length);
  const idx = fn + "/" + fc;
  const filename = import_chalk.default.gray(relativeFilename(p.filename));
  process.stderr.write(`\r${idx} ${filename}`);
}
function reportProgressFileComplete(p) {
  const time = reportTime(p.elapsedTimeMs, !!p.cached);
  const skipped = p.processed === false ? " skipped" : "";
  const hasErrors = p.numErrors ? import_chalk.default.red` X` : "";
  console.error(` ${time}${skipped}${hasErrors}`);
}
function reportTime(elapsedTimeMs, cached) {
  if (cached)
    return import_chalk.default.green("cached");
  if (elapsedTimeMs === void 0)
    return "-";
  const color = elapsedTimeMs < 1e3 ? import_chalk.default.white : elapsedTimeMs < 2e3 ? import_chalk.default.yellow : import_chalk.default.redBright;
  return color(elapsedTimeMs.toFixed(2) + "ms");
}
function getReporter(options) {
  const issueTemplate = options.wordsOnly ? templateIssueWordsOnly : options.legacy ? templateIssueLegacy : options.showContext ? options.showSuggestions ? templateIssueWithContextWithSuggestions : templateIssueWithContext : options.showSuggestions ? templateIssueWithSuggestions : options.showSuggestions === false ? templateIssueNoFix : templateIssue;
  const { fileGlobs, silent, summary, issues, progress, verbose, debug } = options;
  const emitters = {
    Debug: !silent && debug ? (s) => console.info(import_chalk.default.cyan(s)) : nullEmitter2,
    Info: !silent && verbose ? (s) => console.info(import_chalk.default.yellow(s)) : nullEmitter2,
    Warning: (s) => console.info(import_chalk.default.yellow(s))
  };
  function infoEmitter(message, msgType) {
    emitters[msgType]?.(message);
  }
  const root = import_uri.URI.file(options.root || process.cwd());
  const fsPathRoot = root.fsPath;
  function relativeIssue(fn) {
    const fnFilename = options.relative ? (uri) => relativeUriFilename(uri, fsPathRoot) : (uri) => import_uri.URI.parse(uri).fsPath;
    return (i) => {
      const filename = i.uri ? fnFilename(i.uri) : "";
      const r = { ...i, filename };
      fn(r);
    };
  }
  const resultEmitter = (result) => {
    if (!fileGlobs.length && !result.files) {
      return;
    }
    if (result.cachedFiles) {
      console.error("CSpell: Files checked: %d (%d from cache), Issues found: %d in %d files", result.files, result.cachedFiles, result.issues, result.filesWithIssues.size);
      return;
    }
    console.error("CSpell: Files checked: %d, Issues found: %d in %d files", result.files, result.issues, result.filesWithIssues.size);
  };
  return {
    issue: relativeIssue(silent || !issues ? nullEmitter2 : genIssueEmitter(issueTemplate)),
    error: silent ? nullEmitter2 : errorEmitter,
    info: infoEmitter,
    debug: emitters.Debug,
    progress: !silent && progress ? reportProgress : nullEmitter2,
    result: !silent && summary ? resultEmitter : nullEmitter2
  };
}
function formatIssue(templateStr, issue, maxIssueTextWidth) {
  function clean2(t2) {
    return t2.replace(/\s+/, " ");
  }
  const { uri = "", filename, row, col, text, context, offset } = issue;
  const contextLeft = clean2(context.text.slice(0, offset - context.offset));
  const contextRight = clean2(context.text.slice(offset + text.length - context.offset));
  const contextFull = clean2(context.text);
  const padContext = " ".repeat(Math.max(maxIssueTextWidth - text.length, 0));
  const rowText = row.toString();
  const colText = col.toString();
  const padRowCol = " ".repeat(Math.max(1, 8 - (rowText.length + colText.length)));
  const suggestions = formatSuggestions(issue);
  const msg = issue.message || (issue.isFlagged ? "Forbidden word" : "Unknown word");
  const message = issue.isFlagged ? `{yellow ${msg}}` : msg;
  const substitutions = {
    $col: colText,
    $contextFull: contextFull,
    $contextLeft: contextLeft,
    $contextRight: contextRight,
    $filename: filename,
    $padContext: padContext,
    $padRowCol: padRowCol,
    $row: rowText,
    $suggestions: suggestions,
    $text: text,
    $uri: uri,
    $quickFix: formatQuickFix(issue)
  };
  const t = template(templateStr.replace(/\$message/g, message));
  return substitute((0, import_chalk.default)(t), substitutions).trimEnd();
}
function formatSuggestions(issue) {
  if (issue.suggestionsEx) {
    return issue.suggestionsEx.map((sug) => sug.isPreferred ? import_chalk.default.italic(import_chalk.default.bold(sug.wordAdjustedToMatchCase || sug.word)) + "*" : sug.wordAdjustedToMatchCase || sug.word).join(", ");
  }
  if (issue.suggestions) {
    return issue.suggestions.join(", ");
  }
  return "";
}
function formatQuickFix(issue) {
  if (!issue.suggestionsEx?.length)
    return "";
  const preferred = issue.suggestionsEx.filter((sug) => sug.isPreferred).map((sug) => sug.wordAdjustedToMatchCase || sug.word);
  if (!preferred.length)
    return "";
  const fixes = preferred.map((w) => import_chalk.default.italic(import_chalk.default.yellow(w)));
  return `fix: (${fixes.join(", ")})`;
}
var TS = class extends Array {
  constructor(s) {
    super(s);
    this.raw = [s];
  }
};
function template(s) {
  return new TS(s);
}
function substitute(text, substitutions) {
  const subs = [];
  for (const [match, replaceWith] of Object.entries(substitutions)) {
    const len = match.length;
    for (let i2 = text.indexOf(match); i2 >= 0; i2 = text.indexOf(match, i2 + 1)) {
      subs.push([i2, i2 + len, replaceWith]);
    }
  }
  subs.sort((a, b) => a[0] - b[0]);
  let i = 0;
  function sub(r) {
    const [a, b, t] = r;
    const prefix = text.slice(i, a);
    i = b;
    return prefix + t;
  }
  const parts = subs.map(sub);
  return parts.join("") + text.slice(i);
}

// node_modules/cspell/dist/esm/featureFlags/featureFlags.mjs
var import_cspell_lib2 = __toESM(require_cjs10(), 1);
function getFeatureFlags() {
  return (0, import_cspell_lib2.getSystemFeatureFlags)();
}

// node_modules/@cspell/cspell-types/dist/esm/CSpellReporter.mjs
var IssueType;
(function(IssueType2) {
  IssueType2[IssueType2["spelling"] = 0] = "spelling";
  IssueType2[IssueType2["directive"] = 1] = "directive";
})(IssueType || (IssueType = {}));
var MessageTypes = {
  Debug: "Debug",
  Info: "Info",
  Warning: "Warning"
};

// node_modules/cspell/dist/esm/lint/lint.mjs
var import_chalk2 = __toESM(require_source(), 1);

// node_modules/cspell-gitignore/dist/esm/GitIgnore.mjs
var path5 = __toESM(require("path"), 1);

// node_modules/cspell-gitignore/dist/esm/GitIgnoreFile.mjs
var import_fs2 = require("fs");
var path4 = __toESM(require("path"), 1);

// node_modules/cspell-gitignore/dist/esm/helpers.mjs
var import_find_up = __toESM(require_find_up(), 1);
var path3 = __toESM(require("path"), 1);
function factoryPathHelper(path16) {
  function directoryRoot2(directory) {
    const p = path16.parse(directory);
    return p.root;
  }
  async function findRepoRoot2(directory) {
    const found = await (0, import_find_up.default)(".git", { cwd: directory, type: "directory" });
    if (!found)
      return void 0;
    return path16.dirname(found);
  }
  function isParentOf2(parent, child) {
    const rel = path16.relative(parent, child);
    return !!rel && !path16.isAbsolute(rel) && rel[0] !== ".";
  }
  function contains2(parent, child) {
    const rel = path16.relative(parent, child);
    return !rel || !path16.isAbsolute(rel) && rel[0] !== ".";
  }
  function makeRelativeTo2(child, parent) {
    const rel = path16.relative(parent, child);
    if (path16.isAbsolute(rel) || rel[0] === ".")
      return void 0;
    return normalizePath3(rel);
  }
  function normalizePath3(path17) {
    return path17.replace(/\\/g, "/");
  }
  return {
    directoryRoot: directoryRoot2,
    findRepoRoot: findRepoRoot2,
    isParentOf: isParentOf2,
    contains: contains2,
    normalizePath: normalizePath3,
    makeRelativeTo: makeRelativeTo2
  };
}
var defaultHelper = factoryPathHelper(path3);
var directoryRoot = defaultHelper.directoryRoot;
var findRepoRoot = defaultHelper.findRepoRoot;
var isParentOf = defaultHelper.isParentOf;
var contains = defaultHelper.contains;
var makeRelativeTo = defaultHelper.makeRelativeTo;
var normalizePath = defaultHelper.normalizePath;
function isDefined(v) {
  return v !== void 0 && v !== null;
}

// node_modules/cspell-gitignore/dist/esm/GitIgnoreFile.mjs
var GitIgnoreFile = class _GitIgnoreFile {
  constructor(matcher, gitignore) {
    this.matcher = matcher;
    this.gitignore = gitignore;
  }
  get root() {
    return this.matcher.root;
  }
  isIgnored(file) {
    return this.matcher.match(file);
  }
  isIgnoredEx(file) {
    const m = this.matcher.matchEx(file);
    const { matched } = m;
    const partial = m;
    const pattern = partial.pattern;
    const glob2 = pattern?.rawGlob ?? partial.glob;
    const root = partial.root;
    const line = pattern?.line;
    return { glob: glob2, matched, gitIgnoreFile: this.gitignore, root, line };
  }
  getGlobPatters() {
    return this.matcher.patterns;
  }
  getGlobs(relativeTo) {
    return this.getGlobPatters().map((pat) => globToString(pat, relativeTo)).filter(isDefined);
  }
  static parseGitignore(content, gitignoreFilename) {
    const options = { root: path4.dirname(gitignoreFilename) };
    const globs = content.split(/\r?\n/g).map((glob2, index) => ({
      glob: glob2.replace(/^#.*/, ""),
      source: gitignoreFilename,
      line: index + 1
    })).filter((g) => !!g.glob);
    const globMatcher = new GlobMatcher(globs, options);
    return new _GitIgnoreFile(globMatcher, gitignoreFilename);
  }
  static async loadGitignore(gitignore) {
    gitignore = path4.resolve(gitignore);
    const content = await import_fs2.promises.readFile(gitignore, "utf8");
    return this.parseGitignore(content, gitignore);
  }
};
var GitIgnoreHierarchy = class {
  constructor(gitIgnoreChain) {
    this.gitIgnoreChain = gitIgnoreChain;
    mustBeHierarchical(gitIgnoreChain);
  }
  isIgnored(file) {
    for (const git of this.gitIgnoreChain) {
      if (git.isIgnored(file))
        return true;
    }
    return false;
  }
  /**
   * Check to see which `.gitignore` file ignored the given file.
   * @param file - fsPath to check.
   * @returns IsIgnoredExResult of the match or undefined if there was no match.
   */
  isIgnoredEx(file) {
    for (const git of this.gitIgnoreChain) {
      const r = git.isIgnoredEx(file);
      if (r.matched)
        return r;
    }
    return void 0;
  }
  getGlobPatters() {
    return this.gitIgnoreChain.flatMap((gf) => gf.getGlobPatters());
  }
  getGlobs(relativeTo) {
    return this.gitIgnoreChain.flatMap((gf) => gf.getGlobs(relativeTo));
  }
};
async function loadGitIgnore(dir) {
  const file = path4.join(dir, ".gitignore");
  try {
    return await GitIgnoreFile.loadGitignore(file);
  } catch (e) {
    return void 0;
  }
}
function mustBeHierarchical(chain) {
  let root = "";
  for (const file of chain) {
    if (!file.root.startsWith(root)) {
      throw new Error("Hierarchy violation - files are not nested");
    }
    root = file.root;
  }
}
function globToString(glob2, relativeTo) {
  if (glob2.isGlobalPattern)
    return glob2.glob;
  if (isParentOf(glob2.root, relativeTo) && glob2.glob.startsWith("**/"))
    return glob2.glob;
  const base = makeRelativeTo(glob2.root, relativeTo);
  if (base === void 0)
    return void 0;
  return (base ? base + "/" : "") + glob2.glob;
}

// node_modules/cspell-gitignore/dist/esm/GitIgnore.mjs
var GitIgnore = class {
  /**
   * @param roots - (search roots) an optional array of root paths to prevent searching for `.gitignore` files above the root.
   *   If a file is under multiple roots, the closest root will apply. If a file is not under any root, then
   *   the search for `.gitignore` will go all the way to the system root of the file.
   */
  constructor(roots = []) {
    this.resolvedGitIgnoreHierarchies = /* @__PURE__ */ new Map();
    this.knownGitIgnoreHierarchies = /* @__PURE__ */ new Map();
    this._sortedRoots = resolveAndSortRoots(roots);
    this._roots = new Set(this._sortedRoots);
  }
  findResolvedGitIgnoreHierarchy(directory) {
    return this.resolvedGitIgnoreHierarchies.get(directory);
  }
  isIgnoredQuick(file) {
    const gh = this.findResolvedGitIgnoreHierarchy(path5.dirname(file));
    return gh?.isIgnored(file);
  }
  async isIgnored(file) {
    const gh = await this.findGitIgnoreHierarchy(path5.dirname(file));
    return gh.isIgnored(file);
  }
  async isIgnoredEx(file) {
    const gh = await this.findGitIgnoreHierarchy(path5.dirname(file));
    return gh.isIgnoredEx(file);
  }
  async findGitIgnoreHierarchy(directory) {
    const known = this.knownGitIgnoreHierarchies.get(directory);
    if (known) {
      return known;
    }
    const find = this._findGitIgnoreHierarchy(directory);
    this.knownGitIgnoreHierarchies.set(directory, find);
    const found = await find;
    this.resolvedGitIgnoreHierarchies.set(directory, found);
    return find;
  }
  filterOutIgnored(files) {
    const iter = this.filterOutIgnoredAsync(files);
    return isAsyncIterable2(files) ? iter : asyncIterableToArray(iter);
  }
  async *filterOutIgnoredAsync(files) {
    for await (const file of files) {
      const isIgnored = this.isIgnoredQuick(file) ?? await this.isIgnored(file);
      if (!isIgnored) {
        yield file;
      }
    }
  }
  get roots() {
    return this._sortedRoots;
  }
  addRoots(roots) {
    const rootsToAdd = roots.map((p) => path5.resolve(p)).filter((r) => !this._roots.has(r));
    if (!rootsToAdd.length)
      return;
    rootsToAdd.forEach((r) => this._roots.add(r));
    this._sortedRoots = resolveAndSortRoots([...this._roots]);
    this.cleanCachedEntries();
  }
  peekGitIgnoreHierarchy(directory) {
    return this.knownGitIgnoreHierarchies.get(directory);
  }
  async getGlobs(directory) {
    const hierarchy = await this.findGitIgnoreHierarchy(directory);
    return hierarchy.getGlobs(directory);
  }
  cleanCachedEntries() {
    this.knownGitIgnoreHierarchies.clear();
    this.resolvedGitIgnoreHierarchies.clear();
  }
  async _findGitIgnoreHierarchy(directory) {
    const root = this.determineRoot(directory);
    const parent = path5.dirname(directory);
    const parentHierarchy = parent !== directory && contains(root, parent) ? await this.findGitIgnoreHierarchy(parent) : void 0;
    const git = await loadGitIgnore(directory);
    if (!git) {
      return parentHierarchy || new GitIgnoreHierarchy([]);
    }
    const chain = parentHierarchy?.gitIgnoreChain.concat([git]) ?? [git];
    return new GitIgnoreHierarchy(chain);
  }
  determineRoot(directory) {
    const roots = this.roots;
    for (let i = roots.length - 1; i >= 0; --i) {
      const r = roots[i];
      if (contains(r, directory))
        return r;
    }
    return path5.parse(directory).root;
  }
};
function resolveAndSortRoots(roots) {
  const sortedRoots = roots.map((a) => path5.resolve(a));
  sortRoots(sortedRoots);
  Object.freeze(sortedRoots);
  return sortedRoots;
}
function sortRoots(roots) {
  roots.sort((a, b) => a.length - b.length);
  return roots;
}
function isAsyncIterable2(i) {
  const as = i;
  return typeof as[Symbol.asyncIterator] === "function";
}
async function asyncIterableToArray(iter) {
  const r = [];
  for await (const t of iter) {
    r.push(t);
  }
  return r;
}

// node_modules/cspell/dist/esm/lint/lint.mjs
var cspell2 = __toESM(require_cjs10(), 1);
var path13 = __toESM(require("path"), 1);
var import_util23 = require("util");
var import_pkgInfo2 = __toESM(require_pkgInfo(), 1);
var import_uri3 = __toESM(require_uri(), 1);

// node_modules/cspell/dist/esm/util/cache/createCache.mjs
var import_assert3 = __toESM(require("assert"), 1);
var import_promises = require("fs/promises");
var import_path3 = __toESM(require("path"), 1);

// node_modules/cspell/dist/esm/util/errors.mjs
var import_util14 = require("util");
var CheckFailed = class extends Error {
  constructor(message, exitCode = 1) {
    super(message);
    this.exitCode = exitCode;
  }
};
var ApplicationError = class extends Error {
  constructor(message, exitCode = 1, cause) {
    super(message);
    this.exitCode = exitCode;
    this.cause = cause;
  }
};
var IOError = class extends ApplicationError {
  constructor(message, cause) {
    super(message, void 0, cause);
    this.cause = cause;
  }
  get code() {
    return this.cause.code;
  }
  isNotFound() {
    return this.cause.code === "ENOENT";
  }
};
function toError(e) {
  if (isError2(e))
    return e;
  const message = (0, import_util14.format)(e);
  return {
    name: "error",
    message,
    toString: () => message
  };
}
function isError2(e) {
  if (e instanceof Error)
    return true;
  if (!e || typeof e !== "object")
    return false;
  const ex = e;
  return typeof ex.message === "string";
}
function toApplicationError(e, message) {
  if (e instanceof ApplicationError && !message)
    return e;
  const err = toError(e);
  return new ApplicationError(message ?? err.message, void 0, err);
}

// node_modules/cspell/dist/esm/util/cache/DiskCache.mjs
var import_assert2 = __toESM(require("assert"), 1);
var crypto4 = __toESM(require("crypto"), 1);
var fs4 = __toESM(require("fs"), 1);
var import_path2 = require("path");

// node_modules/@cspell/cspell-service-bus/dist/esm/errors.mjs
var ErrorUnhandledRequest = class extends Error {
  constructor(request) {
    super(`Unhandled Request: ${request.type}`);
    this.request = request;
  }
};
var ErrorServiceRequestDepthExceeded = class extends Error {
  constructor(request, depth) {
    super(`Service Request Depth ${depth} Exceeded: ${request.type}`);
    this.request = request;
    this.depth = depth;
  }
};
var UnhandledHandlerError = class extends Error {
  constructor(handlerName, handlerDescription, cause) {
    super(`Unhandled Error in Handler: ${handlerName}`);
    this.handlerName = handlerName;
    this.handlerDescription = handlerDescription;
    this.cause = cause;
  }
};

// node_modules/@cspell/cspell-service-bus/dist/esm/request.mjs
var BaseServiceRequest = class {
  constructor(type, params) {
    this.type = type;
    this.params = params;
  }
};
var ServiceRequestCls = class extends BaseServiceRequest {
  constructor(type, params) {
    super(type, params);
  }
};
function createResponse(value, _req) {
  return { value };
}
function createResponseFail(_request, error2) {
  return { error: error2 };
}
function isServiceResponseSuccess(res) {
  return "value" in res && res.error === void 0;
}
function isServiceResponseFailure(res) {
  return res.error !== void 0;
}

// node_modules/@cspell/cspell-service-bus/dist/esm/bus.mjs
var MAX_DEPTH = 10;
var ServiceBus = class {
  constructor(handlers = []) {
    this.handlers = [];
    handlers.forEach((h) => this.addHandler(h));
  }
  addHandler(handler, name = "anonymous", description) {
    const h = typeof handler === "function" ? { fn: handler, name, description } : handler;
    const { fn, name: _name, description: _description } = h;
    this.handlers.push({ fn, name: _name, description: _description });
    return this;
  }
  dispatch(request) {
    let depth = 0;
    const dispatcher = { dispatch };
    const handler = this.reduceHandlers(this.handlers, request, dispatcher, this.defaultHandler);
    function dispatch(request2) {
      ++depth;
      if (depth >= MAX_DEPTH) {
        return createResponseFail(request2, new ErrorServiceRequestDepthExceeded(request2, depth));
      }
      const response = handler(request2);
      --depth;
      return response;
    }
    return dispatch(request);
  }
  defaultHandler(request) {
    return createResponseFail(request, new ErrorUnhandledRequest(request));
  }
  reduceHandlers(handlers, request, dispatcher, defaultHandler) {
    const _handlers = handlers.map((m) => ({ ...m, fn: m.fn(dispatcher) }));
    const handler = _handlers.reduce((next, h) => {
      const fn = h.fn(next);
      return (req) => {
        try {
          return fn(req);
        } catch (e) {
          return createResponseFail(request, new UnhandledHandlerError(h.name, h.description, e));
        }
      };
    }, defaultHandler);
    return handler;
  }
};

// node_modules/@cspell/cspell-service-bus/dist/esm/createRequestHandler.mjs
function createRequestHandler(requestDef, fn, name, description) {
  return createIsRequestHandler(requestDef.is, fn, name ?? requestDef.type, description);
}
function createIsRequestHandlerFn(isA, fn) {
  return (dispatcher) => (next) => (request) => isA(request) ? fn(request, next, dispatcher) : next(request);
}
function createIsRequestHandler(isA, fn, name, description) {
  return {
    fn: createIsRequestHandlerFn(isA, fn),
    name,
    description
  };
}

// node_modules/@cspell/cspell-service-bus/dist/esm/requestFactory.mjs
function requestFactory(requestType) {
  class RequestClass extends ServiceRequestCls {
    constructor(params) {
      super(requestType, params);
    }
    static is(req) {
      return req instanceof RequestClass && req.type === requestType;
    }
    static create(params) {
      return new RequestClass(params);
    }
    static createRequestHandler(fn, name, description) {
      return createRequestHandler(RequestClass, fn, name, description);
    }
  }
  RequestClass.type = requestType;
  return RequestClass;
}

// node_modules/cspell-io/dist/esm/common/stat.mjs
function compareStats(left, right) {
  if (left === right)
    return 0;
  if (left.eTag || right.eTag)
    return left.eTag === right.eTag ? 0 : (left.eTag || "") < (right.eTag || "") ? -1 : 1;
  const diff = left.size - right.size || left.mtimeMs - right.mtimeMs;
  return diff < 0 ? -1 : diff > 0 ? 1 : 0;
}

// node_modules/cspell-io/dist/esm/errors/ErrorNotImplemented.mjs
var ErrorNotImplemented = class extends Error {
  constructor(method) {
    super(`Method ${method} is not supported.`);
    this.method = method;
  }
};

// node_modules/cspell-io/dist/esm/handlers/node/file.mjs
var import_assert = __toESM(require("assert"), 1);
var import_fs3 = require("fs");
var import_url2 = require("url");
var import_zlib = require("zlib");

// node_modules/cspell-io/dist/esm/common/encode-decode.mjs
var BOM_BE = 65279;
var BOM_LE = 65534;
function decodeUtf16LE(buf) {
  const bom = buf[0] << 8 | buf[1];
  buf = bom === BOM_LE ? buf.subarray(2) : buf;
  return buf.toString("utf16le");
}
function decodeUtf16BE(buf) {
  return decodeUtf16LE(swapBytes(buf));
}
function decode(buf, encoding) {
  switch (encoding) {
    case "utf16be":
      return decodeUtf16BE(buf);
    case "utf16le":
      return decodeUtf16LE(buf);
  }
  if (buf.length < 2 || encoding && !encoding.startsWith("utf"))
    return buf.toString(encoding);
  const bom = buf[0] << 8 | buf[1];
  if (bom === BOM_BE || buf[0] === 0 && buf[1] !== 0)
    return decodeUtf16BE(buf);
  if (bom === BOM_LE || buf[0] !== 0 && buf[1] === 0)
    return decodeUtf16LE(buf);
  return buf.toString(encoding);
}
function swapBytesInPlace(buf) {
  for (let i = 0; i < buf.length - 1; i += 2) {
    const v = buf[i];
    buf[i] = buf[i + 1];
    buf[i + 1] = v;
  }
  return buf;
}
function swapBytes(buf) {
  const tBuf = Buffer.from(buf);
  return swapBytesInPlace(tBuf);
}

// node_modules/cspell-io/dist/esm/errors/error.mjs
function toError2(e) {
  if (e instanceof Error)
    return e;
  if (typeof e === "object" && e && typeof e.message === "string") {
    return e;
  }
  return Error(e && e.toString());
}

// node_modules/cspell-io/dist/esm/node/file/util.mjs
var import_url = require("url");
var isURLRegExp = /^(\w{2,64}:\/\/|data:)/i;
function isUrlLike(filename) {
  return filename instanceof URL || isURLRegExp.test(filename);
}
function toURL(filename) {
  return filename instanceof URL || typeof filename !== "string" ? filename : isUrlLike(filename) ? new URL(filename) : (0, import_url.pathToFileURL)(filename);
}
var regMatchFilename = /filename=([^;,]*)/;
function urlBasename(url) {
  function guessDataUrlName(header) {
    const filenameMatch = header.match(regMatchFilename);
    if (filenameMatch)
      return filenameMatch[1];
    const mime = header.split(";", 1)[0];
    return mime.replace(/\W/g, ".");
  }
  if (typeof url === "string" && url.startsWith("data:")) {
    return guessDataUrlName(url.split(",", 1)[0].split(":", 2)[1]);
  }
  url = toURL(url);
  if (url.protocol === "data:") {
    return guessDataUrlName(url.pathname.split(",", 1)[0]);
  }
  return basename(url.pathname);
}
function urlDirname(url) {
  if (typeof url === "string" && url.startsWith("data:")) {
    return toURL("data:");
  }
  url = toURL(url);
  if (url.protocol === "data:") {
    return toURL("data:");
  }
  return new URL(url.pathname.endsWith("/") ? ".." : ".", url);
}
function basename(path16) {
  path16 = path16.endsWith("/") ? path16.slice(0, path16.length - 1) : path16;
  const idx = path16.lastIndexOf("/");
  return idx >= 0 ? path16.slice(idx + 1) || "" : path16;
}

// node_modules/cspell-io/dist/esm/node/dataUrl.mjs
var dataUrlRegExHead = /^data:(?<mediaType>[^;,]*)(?<attributes>(?:;[^=]+=[^;,]*)*)(?<base64>;base64)?$/;
function decodeDataUrl(url) {
  url = url.toString();
  const [head, encodedData] = url.split(",", 2);
  if (!head || encodedData === void 0)
    throw Error("Not a data url");
  const match = head.match(dataUrlRegExHead);
  if (!match || !match.groups)
    throw Error("Not a data url");
  const mediaType = match.groups["mediaType"] || "";
  const rawAttributes = (match.groups["attributes"] || "").split(";").filter((a) => !!a).map((entry) => entry.split("=", 2)).map(([key, value]) => [key, decodeURIComponent(value)]);
  const attributes = new Map(rawAttributes);
  const encoding = attributes.get("charset");
  const isBase64 = !!match.groups["base64"];
  const data = isBase64 ? Buffer.from(encodedData, "base64url") : Buffer.from(decodeURIComponent(encodedData));
  return { mediaType, data, encoding, attributes };
}

// node_modules/cspell-io/dist/esm/node/file/fetch.mjs
var import_node_fetch = __toESM(require_lib3(), 1);

// node_modules/cspell-io/dist/esm/node/file/FetchError.mjs
var FetchUrlError = class _FetchUrlError extends Error {
  constructor(message, code, status, url) {
    super(message);
    this.code = code;
    this.status = status;
    this.url = url;
    this.name = "FetchUrlError";
  }
  static create(url, status, message) {
    if (status === 404)
      return new _FetchUrlError(message || "URL not found.", "ENOENT", status, url);
    if (status >= 400 && status < 500)
      return new _FetchUrlError(message || "Permission denied.", "EACCES", status, url);
    return new _FetchUrlError(message || "Fatal Error", "ECONNREFUSED", status, url);
  }
};

// node_modules/cspell-io/dist/esm/node/file/fetch.mjs
var fetch = import_node_fetch.default;
async function fetchHead(request) {
  const r = await fetch(request, { method: "HEAD" });
  return r.headers;
}
async function fetchURL(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw FetchUrlError.create(url, response.status);
  }
  return Buffer.from(await response.arrayBuffer());
}

// node_modules/cspell-io/dist/esm/node/file/stat.mjs
async function getStatHttp(url) {
  const headers = await fetchHead(url);
  const eTag = headers.get("etag") || void 0;
  const guessSize = Number.parseInt(headers.get("content-length") || "0", 10);
  return {
    size: eTag ? -1 : guessSize,
    mtimeMs: 0,
    eTag
  };
}

// node_modules/cspell-io/dist/esm/requests/RequestFsReadBinaryFile.mjs
var RequestType = "fs:readBinaryFile";
var RequestFsReadBinaryFile = requestFactory(RequestType);
var RequestTypeSync = "fs:readBinaryFileSync";
var RequestFsReadBinaryFileSync = requestFactory(RequestTypeSync);

// node_modules/cspell-io/dist/esm/requests/RequestFsReadFile.mjs
var RequestType2 = "fs:readFile";
var RequestFsReadFile = requestFactory(RequestType2);

// node_modules/cspell-io/dist/esm/requests/RequestFsReadFileSync.mjs
var RequestType3 = "fs:readFileSync";
var RequestFsReadFileSync = requestFactory(RequestType3);

// node_modules/cspell-io/dist/esm/requests/RequestFsStat.mjs
var RequestTypeStat = "fs:stat";
var RequestFsStat = requestFactory(RequestTypeStat);
var RequestTypeStatSync = "fs:statSync";
var RequestFsStatSync = requestFactory(RequestTypeStatSync);

// node_modules/cspell-io/dist/esm/requests/RequestFsWriteFile.mjs
var RequestType4 = "fs:writeFile";
var RequestFsWriteFile = requestFactory(RequestType4);

// node_modules/cspell-io/dist/esm/requests/RequestZlibInflate.mjs
var RequestType5 = "zlib:inflate";
var RequestZlibInflate = requestFactory(RequestType5);

// node_modules/cspell-io/dist/esm/handlers/node/file.mjs
var isGzFileRegExp = /\.gz($|[?#])/;
function isGzFile(url) {
  return isGzFileRegExp.test(url.pathname);
}
var handleRequestFsReadBinaryFile = RequestFsReadBinaryFile.createRequestHandler(({ params }) => createResponse(import_fs3.promises.readFile((0, import_url2.fileURLToPath)(params.url)).then((content) => ({ url: params.url, content }))), void 0, "Node: Read Binary File.");
var handleRequestFsReadBinaryFileSync = RequestFsReadBinaryFileSync.createRequestHandler(({ params }) => createResponse({ url: params.url, content: (0, import_fs3.readFileSync)((0, import_url2.fileURLToPath)(params.url)) }), void 0, "Node: Sync Read Binary File.");
var handleRequestFsReadFile = RequestFsReadFile.createRequestHandler((req, _, dispatcher) => {
  const { url, encoding } = req.params;
  const res = dispatcher.dispatch(RequestFsReadBinaryFile.create({ url }));
  if (!isServiceResponseSuccess(res)) {
    (0, import_assert.default)(isServiceResponseFailure(res));
    return createResponseFail(req, res.error);
  }
  return createResponse(res.value.then((res2) => ({
    url,
    content: bufferToText(res2.content, encoding),
    baseFilename: res2.baseFilename
  })));
}, void 0, "Node: Read Text File.");
var handleRequestFsReadFileSync = RequestFsReadFileSync.createRequestHandler((req, _, dispatcher) => {
  const { url, encoding } = req.params;
  const res = dispatcher.dispatch(RequestFsReadBinaryFileSync.create({ url }));
  if (!isServiceResponseSuccess(res)) {
    (0, import_assert.default)(isServiceResponseFailure(res));
    return createResponseFail(req, res.error);
  }
  return createResponse({
    ...res.value,
    content: bufferToText(res.value.content, encoding)
  });
}, void 0, "Node: Sync Read Text File.");
var handleRequestZlibInflate = RequestZlibInflate.createRequestHandler(({ params }) => createResponse((0, import_zlib.gunzipSync)(params.data).toString("utf-8")), void 0, "Node: gz deflate.");
var supportedFetchProtocols = { "http:": true, "https:": true };
var handleRequestFsReadBinaryFileHttp = RequestFsReadBinaryFile.createRequestHandler((req, next) => {
  const { url } = req.params;
  if (!(url.protocol in supportedFetchProtocols))
    return next(req);
  return createResponse(fetchURL(url).then((content) => ({ url, content })));
}, void 0, "Node: Read Http(s) file.");
var handleRequestFsReadBinaryFileSyncData = RequestFsReadBinaryFileSync.createRequestHandler((req, next) => {
  const { url } = req.params;
  if (url.protocol !== "data:")
    return next(req);
  const data = decodeDataUrl(url);
  return createResponse({ url, content: data.data, baseFilename: data.attributes.get("filename") });
}, void 0, "Node: Read data: urls.");
var handleRequestFsReadBinaryFileData = RequestFsReadBinaryFile.createRequestHandler((req, next, dispatcher) => {
  const { url } = req.params;
  if (url.protocol !== "data:")
    return next(req);
  const res = dispatcher.dispatch(RequestFsReadBinaryFileSync.create(req.params));
  if (!isServiceResponseSuccess(res))
    return res;
  return createResponse(Promise.resolve(res.value));
}, void 0, "Node: Read data: urls.");
function bufferToText(buf, encoding) {
  return buf[0] === 31 && buf[1] === 139 ? decode((0, import_zlib.gunzipSync)(buf), encoding) : decode(buf, encoding);
}
var handleRequestFsStat = RequestFsStat.createRequestHandler(({ params }) => createResponse(import_fs3.promises.stat((0, import_url2.fileURLToPath)(params.url))), void 0, "Node: fs.stat.");
var handleRequestFsStatSync = RequestFsStatSync.createRequestHandler((req) => {
  const { params } = req;
  try {
    return createResponse((0, import_fs3.statSync)((0, import_url2.fileURLToPath)(params.url)));
  } catch (e) {
    return createResponseFail(req, toError2(e));
  }
}, void 0, "Node: fs.stat.");
var handleRequestFsStatHttp = RequestFsStat.createRequestHandler((req, next) => {
  const { url } = req.params;
  if (!(url.protocol in supportedFetchProtocols))
    return next(req);
  return createResponse(getStatHttp(url));
}, void 0, "Node: http get stat");
var handleRequestFsWriteFile = RequestFsWriteFile.createRequestHandler(({ params }) => createResponse(import_fs3.promises.writeFile(params.url, params.content)), void 0, "Node: fs.writeFile");
var handleRequestFsWriteFileGz = RequestFsWriteFile.createRequestHandler((req, next) => {
  const { url, content } = req.params;
  if (!isGzFile(url))
    return next(req);
  return createResponse(import_fs3.promises.writeFile(url, (0, import_zlib.gzipSync)(content)));
}, void 0, "Node: http get stat");
function registerHandlers(serviceBus) {
  const handlers = [
    handleRequestFsWriteFile,
    handleRequestFsWriteFileGz,
    handleRequestFsReadBinaryFile,
    handleRequestFsReadBinaryFileSync,
    handleRequestFsReadBinaryFileHttp,
    handleRequestFsReadBinaryFileData,
    handleRequestFsReadBinaryFileSyncData,
    handleRequestFsReadFile,
    handleRequestFsReadFileSync,
    handleRequestZlibInflate,
    handleRequestFsStatSync,
    handleRequestFsStat,
    handleRequestFsStatHttp
  ];
  handlers.forEach((handler) => serviceBus.addHandler(handler));
}

// node_modules/cspell-io/dist/esm/CSpellIONode.mjs
var defaultCSpellIONode = void 0;
var CSpellIONode = class {
  constructor(serviceBus = new ServiceBus()) {
    this.serviceBus = serviceBus;
    registerHandlers(serviceBus);
  }
  readFile(uriOrFilename, encoding = "utf8") {
    const url = toURL(uriOrFilename);
    const res = this.serviceBus.dispatch(RequestFsReadFile.create({ url, encoding }));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readFile");
    }
    return res.value;
  }
  readFileSync(uriOrFilename, encoding = "utf8") {
    const url = toURL(uriOrFilename);
    const res = this.serviceBus.dispatch(RequestFsReadFileSync.create({ url, encoding }));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readFileSync");
    }
    return res.value;
  }
  writeFile(uriOrFilename, content) {
    const url = toURL(uriOrFilename);
    const res = this.serviceBus.dispatch(RequestFsWriteFile.create({ url, content }));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "writeFile");
    }
    return res.value;
  }
  getStat(uriOrFilename) {
    const url = toURL(uriOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStat.create({ url }));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "getStat");
    }
    return res.value;
  }
  getStatSync(uriOrFilename) {
    const url = toURL(uriOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStatSync.create({ url }));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "getStatSync");
    }
    return res.value;
  }
  compareStats(left, right) {
    return compareStats(left, right);
  }
  toURL(uriOrFilename) {
    return toURL(uriOrFilename);
  }
  uriBasename(uriOrFilename) {
    return urlBasename(uriOrFilename);
  }
  uriDirname(uriOrFilename) {
    return urlDirname(uriOrFilename);
  }
};
function genError(err, alt) {
  return err || new ErrorNotImplemented(alt);
}
function getDefaultCSpellIO() {
  if (defaultCSpellIONode)
    return defaultCSpellIONode;
  const cspellIO = new CSpellIONode();
  defaultCSpellIONode = cspellIO;
  return cspellIO;
}

// node_modules/cspell-io/dist/esm/node/file/fileReader.mjs
var Stream = __toESM(require("stream"), 1);
var import_util18 = require("util");
var pipeline2 = (0, import_util18.promisify)(Stream.pipeline);

// node_modules/cspell-io/dist/esm/node/file/fileWriter.mjs
var Stream2 = __toESM(require("stream"), 1);
var import_util20 = require("util");
var pipeline4 = (0, import_util20.promisify)(Stream2.pipeline);

// node_modules/cspell-io/dist/esm/file/file.mjs
var readFile2 = function(filename, encoding) {
  return getDefaultCSpellIO().readFile(filename, encoding).then((fr) => fr.content);
};

// node_modules/cspell/dist/esm/util/fileHelper.mjs
var cspell = __toESM(require_cjs10(), 1);
var import_cspell_lib3 = __toESM(require_cjs10(), 1);
var import_fs5 = require("fs");
var import_get_stdin = __toESM(require_get_stdin(), 1);
var path7 = __toESM(require("path"), 1);
var import_url3 = require("url");
var import_uri2 = __toESM(require_uri(), 1);

// node_modules/cspell/dist/esm/util/async.mjs
var { opMapAsync: asyncMap, opFilterAsync: asyncFilter, opAwaitAsync: asyncAwait, opFlattenAsync: asyncFlatten } = operators;

// node_modules/cspell/dist/esm/util/constants.mjs
var UTF8 = "utf8";
var STDIN = "stdin";
var STDINProtocol = "stdin://";
var FileProtocol = "file://";

// node_modules/cspell/dist/esm/util/glob.mjs
var import_fast_glob = __toESM(require_out4(), 1);
var import_fs4 = require("fs");
var path6 = __toESM(require("path"), 1);
var import_path = require("path");

// node_modules/cspell/dist/esm/util/util.mjs
var uniqueFn = uniqueFilterFnGenerator;
function uniqueFilterFnGenerator(extractFn) {
  const values = /* @__PURE__ */ new Set();
  const extractor = extractFn || ((a) => a);
  return (v) => {
    const vv = extractor(v);
    const ret = !values.has(vv);
    values.add(vv);
    return ret;
  };
}
function clean(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === void 0) {
      delete r[key];
    }
  }
  return r;
}

// node_modules/cspell/dist/esm/util/glob.mjs
var defaultExcludeGlobs = ["node_modules/**"];
async function globP(pattern, options) {
  const cwd = options?.root || options?.cwd || process.cwd();
  const ignore = typeof options?.ignore === "string" ? [options.ignore] : options?.ignore;
  const onlyFiles = options?.nodir;
  const dot = options?.dot;
  const patterns = typeof pattern === "string" ? [pattern] : pattern;
  const useOptions = clean({
    cwd,
    onlyFiles,
    dot,
    ignore,
    absolute: true,
    followSymbolicLinks: false
  });
  const compare2 = new Intl.Collator("en").compare;
  const absolutePaths = (await (0, import_fast_glob.default)(patterns, useOptions)).sort(compare2);
  const relativePaths = absolutePaths.map((absFilename) => path6.relative(cwd, absFilename));
  return relativePaths;
}
function calcGlobs(commandLineExclude) {
  const globs = new Set((commandLineExclude || []).flatMap((glob2) => glob2.split(/(?<!\\)\s+/g)).map((g) => g.replace(/\\ /g, " ")));
  const commandLineExcludes = {
    globs: [...globs],
    source: "arguments"
  };
  const defaultExcludes = {
    globs: defaultExcludeGlobs,
    source: "default"
  };
  return commandLineExcludes.globs.length ? commandLineExcludes : defaultExcludes;
}
function extractPatterns(globs) {
  const r = globs.reduce((info3, g) => {
    const source = g.source;
    const patterns = g.matcher.patternsNormalizedToRoot;
    return info3.concat(patterns.map((glob2) => ({ glob: glob2, source })));
  }, []);
  return r;
}
function calcExcludeGlobInfo(root, commandLineExclude) {
  commandLineExclude = typeof commandLineExclude === "string" ? [commandLineExclude] : commandLineExclude;
  const choice = calcGlobs(commandLineExclude);
  const matcher = new GlobMatcher(choice.globs, { root, dot: true });
  return [
    {
      matcher,
      source: choice.source
    }
  ];
}
function buildGlobMatcher(globs, root, isExclude) {
  const withRoots = globs.map((g) => {
    const source = typeof g === "string" ? "command line" : void 0;
    return { source, ...fileOrGlobToGlob(g, root) };
  });
  return new GlobMatcher(withRoots, { root, mode: isExclude ? "exclude" : "include" });
}
function extractGlobsFromMatcher(globMatcher) {
  return globMatcher.patternsNormalizedToRoot.map((g) => g.glob);
}
function normalizeGlobsToRoot(globs, root, isExclude) {
  const urls = globs.filter((g) => typeof g === "string" && isPossibleUrlRegExp.test(g));
  const onlyGlobs = globs.filter((g) => typeof g !== "string" || !isPossibleUrlRegExp.test(g));
  return [urls, extractGlobsFromMatcher(buildGlobMatcher(onlyGlobs, root, isExclude))].flatMap((a) => a);
}
var isPossibleGlobRegExp = /[*{}()?[]/;
var isPossibleUrlRegExp = /^[-a-z_0-9]{3,}:\/\//;
async function adjustPossibleDirectory(glob2, root) {
  const g = typeof glob2 === "string" ? {
    glob: glob2,
    root
  } : {
    glob: glob2.glob,
    root: glob2.root ?? root
  };
  if (isPossibleGlobRegExp.test(g.glob)) {
    return glob2;
  }
  if (isPossibleUrlRegExp.test(g.glob)) {
    return glob2;
  }
  const dirPath = path6.resolve(g.root, g.glob);
  try {
    const stat2 = await import_fs4.promises.stat(dirPath);
    if (stat2.isDirectory()) {
      const useGlob = import_path.posix.join(posixPath(g.glob), "**");
      return typeof glob2 === "string" ? useGlob : { ...glob2, glob: useGlob };
    }
  } catch (e) {
    return glob2;
  }
  return glob2;
}
function posixPath(p) {
  return path6.sep === "\\" ? p.replace(/\\/g, "/") : p;
}
async function normalizeFileOrGlobsToRoot(globs, root) {
  const adjustedGlobs = await Promise.all(globs.map((g) => adjustPossibleDirectory(g, root)));
  return normalizeGlobsToRoot(adjustedGlobs, root, false);
}

// node_modules/cspell/dist/esm/util/stdin.mjs
var readline = __toESM(require("readline"), 1);
function readStdin() {
  return readline.createInterface(process.stdin);
}

// node_modules/cspell/dist/esm/util/fileHelper.mjs
var doesMatchUrl = /^(file|stdin|https?):\/\//;
async function readConfig(configFile, root) {
  if (configFile) {
    const config2 = await cspell.loadConfig(configFile) || {};
    return { source: configFile, config: config2 };
  }
  const config = await cspell.searchForConfig(root);
  return { source: config?.__importRef?.filename || "None found", config: config || {} };
}
function fileInfoToDocument(fileInfo, languageId, locale) {
  const { filename, text } = fileInfo;
  languageId = languageId || void 0;
  locale = locale || void 0;
  const uri = filenameToUrlString(filename);
  if (uri.startsWith(STDINProtocol)) {
    return clean({
      uri,
      text,
      languageId,
      locale
    });
  }
  return (0, import_cspell_lib3.fileToDocument)(uri, text, languageId, locale);
}
function filenameToUrlString(filename, cwd = ".") {
  if (filename === STDIN)
    return "stdin:///";
  if (filename.startsWith(STDINProtocol)) {
    const filePath = filename.slice(STDINProtocol.length);
    const fullPath = path7.resolve(cwd, filePath);
    return (0, import_url3.pathToFileURL)(fullPath).toString();
  }
  if (doesMatchUrl.test(filename))
    return filename;
  return (0, import_url3.pathToFileURL)(path7.resolve(cwd, filename)).toString();
}
function filenameToUri(filename, cwd) {
  return import_uri2.URI.parse(filenameToUrlString(filename, cwd));
}
function isBinaryFile(filename, cwd) {
  const uri = filenameToUri(filename, cwd);
  if (uri.scheme.startsWith("stdin"))
    return false;
  return (0, import_cspell_lib3.isBinaryFile)(uri);
}
function resolveFilename(filename, cwd) {
  cwd = cwd || process.cwd();
  if (filename === STDIN)
    return STDINProtocol;
  if (filename.startsWith(FileProtocol)) {
    const url = new URL(filename.slice(FileProtocol.length), (0, import_url3.pathToFileURL)(cwd + path7.sep));
    return (0, import_url3.fileURLToPath)(url);
  }
  const scheme = filename.startsWith(STDINProtocol) ? STDINProtocol : "";
  const pathname = filename.slice(scheme.length);
  return scheme + path7.resolve(cwd, pathname);
}
function readFileInfo(filename, encoding = UTF8, handleNotFound = false) {
  filename = resolveFilename(filename);
  const pText = filename.startsWith(STDINProtocol) ? (0, import_get_stdin.default)() : readFile2(filename, encoding);
  return pText.then((text) => ({ text, filename }), (e) => {
    const error2 = toError(e);
    return handleNotFound && error2.code === "EISDIR" ? Promise.resolve({ text: "", filename, errorCode: error2.code }) : handleNotFound && error2.code === "ENOENT" ? Promise.resolve({ text: "", filename, errorCode: error2.code }) : Promise.reject(new IOError(`Error reading file: "${filename}"`, error2));
  });
}
function readFile3(filename, encoding = UTF8) {
  return readFileInfo(filename, encoding).then((info3) => info3.text);
}
async function findFiles(globPatterns, options) {
  const stdin = [];
  const globPats = globPatterns.filter((filename) => filename !== STDIN && !filename.startsWith(STDINProtocol) && !filename.startsWith(FileProtocol) ? true : (stdin.push(filename), false));
  const globResults = globPats.length ? await globP(globPats, options) : [];
  const cwd = options.cwd || process.cwd();
  return [...stdin, ...globResults].map((filename) => resolveFilename(filename, cwd));
}
var resolveFilenames = asyncMap(resolveFilename);
function readFileListFiles(listFiles) {
  let useStdin = false;
  const files = listFiles.filter((file) => {
    const isStdin = file === "stdin";
    useStdin = useStdin || isStdin;
    return !isStdin;
  });
  const found = pipeAsync(files, asyncMap((file) => readFileListFile(file)), asyncAwait(), asyncFlatten());
  const stdin = useStdin ? readStdin() : [];
  return pipeAsync(toAsyncIterable(found, stdin), resolveFilenames);
}
async function readFileListFile(listFile) {
  try {
    const relTo = path7.resolve(path7.dirname(listFile));
    const content = await readFile3(listFile);
    const lines = content.split("\n").map((a) => a.trim()).filter((a) => !!a).map((file) => path7.resolve(relTo, file));
    return lines;
  } catch (err) {
    throw toApplicationError(err, `Error reading file list from: "${listFile}"`);
  }
}
async function isDir(filename) {
  try {
    const stat2 = await import_fs5.promises.stat(filename);
    return stat2.isDirectory();
  } catch (e) {
    return false;
  }
}
function isNotDir(filename) {
  return isDir(filename).then((a) => !a);
}

// node_modules/cspell/dist/esm/util/cache/fileEntryCache.mjs
var import_fs6 = require("fs");
var path8 = __toESM(require("path"), 1);
var import_worker_threads = require("worker_threads");
var fec = __toESM(require_file_entry_cache(), 1);
function createFromFile2(pathToCache, useCheckSum, useRelative) {
  const absPathToCache = path8.resolve(pathToCache);
  const relDir = path8.dirname(absPathToCache);
  (0, import_fs6.mkdirSync)(relDir, { recursive: true });
  const create = wrap(() => fec.createFromFile(absPathToCache, useCheckSum));
  const feCache = create();
  const cacheWrapper = {
    get cache() {
      return feCache.cache;
    },
    getHash(buffer) {
      return feCache.getHash(buffer);
    },
    hasFileChanged: wrap((cwd, file) => {
      console.log(file);
      return feCache.hasFileChanged(resolveFile(cwd, file));
    }),
    analyzeFiles: wrap((cwd, files) => {
      return feCache.analyzeFiles(resolveFiles(cwd, files));
    }),
    getFileDescriptor: wrap((cwd, file) => {
      return feCache.getFileDescriptor(resolveFile(cwd, file));
    }),
    getUpdatedFiles: wrap((cwd, files) => {
      return feCache.getUpdatedFiles(resolveFiles(cwd, files));
    }),
    normalizeEntries: wrap((cwd, files) => {
      return feCache.normalizeEntries(resolveFiles(cwd, files));
    }),
    removeEntry: wrap((cwd, file) => {
      console.log(file);
      return feCache.removeEntry(resolveFile(cwd, file));
    }),
    deleteCacheFile() {
      feCache.deleteCacheFile();
    },
    destroy() {
      feCache.destroy();
    },
    reconcile: wrap((_cwd, noPrune) => {
      feCache.reconcile(noPrune);
    })
  };
  return cacheWrapper;
  function resolveFile(cwd, file) {
    if (!useRelative)
      return file;
    const r = path8.relative(relDir, path8.resolve(cwd, file));
    return normalizePath2(r);
  }
  function resolveFiles(cwd, files) {
    return files?.map((file) => resolveFile(cwd, file));
  }
  function wrap(fn) {
    return (...params) => {
      const cwd = process.cwd();
      try {
        import_worker_threads.isMainThread && process.chdir(relDir);
        return fn(cwd, ...params);
      } finally {
        import_worker_threads.isMainThread && process.chdir(cwd);
      }
    };
  }
}
function normalizePath2(filePath) {
  return filePath;
}

// node_modules/cspell/dist/esm/util/cache/ObjectCollection.mjs
var compare = Intl.Collator().compare;
var ShallowObjectCollection = class {
  constructor() {
    this.tree = {};
  }
  get(v) {
    if (typeof v !== "object" || v === null) {
      return v;
    }
    const keys = Object.entries(v).filter((entry) => entry[1] !== void 0).sort((a, b) => compare(a[0], b[0]));
    let t = this.tree;
    for (const [key, obj] of keys) {
      if (!t.c) {
        t.c = /* @__PURE__ */ new Map();
      }
      const c0 = t.c.get(key);
      const cc = c0 || /* @__PURE__ */ new Map();
      if (!c0) {
        t.c.set(key, cc);
      }
      const c1 = cc.get(obj);
      const ccc = c1 || {};
      if (!c1) {
        cc.set(obj, ccc);
      }
      t = ccc;
    }
    if (t.v)
      return t.v;
    t.v = v;
    return v;
  }
};

// node_modules/cspell/dist/esm/util/cache/DiskCache.mjs
var cacheDataKeys = {
  v: "v",
  r: "r",
  d: "d"
};
var META_DATA_BASE_VERSION = "1";
var META_DATA_VERSION_SUFFIX = "-" + META_DATA_BASE_VERSION + "-" + Object.keys(cacheDataKeys).join("|");
var DiskCache = class {
  constructor(cacheFileLocation, useCheckSum, cspellVersion, useUniversalCache) {
    this.useCheckSum = useCheckSum;
    this.cspellVersion = cspellVersion;
    this.useUniversalCache = useUniversalCache;
    this.dependencyCache = /* @__PURE__ */ new Map();
    this.dependencyCacheTree = {};
    this.objectCollection = new ShallowObjectCollection();
    this.ocCacheFileResult = new ShallowObjectCollection();
    this.cacheFileLocation = (0, import_path2.resolve)(cacheFileLocation);
    this.cacheDir = (0, import_path2.dirname)(this.cacheFileLocation);
    this.fileEntryCache = createFromFile2(this.cacheFileLocation, useCheckSum, useUniversalCache);
    this.version = calcVersion(cspellVersion);
  }
  async getCachedLintResults(filename) {
    filename = normalizePath2(filename);
    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filename);
    const meta = fileDescriptor.meta;
    const data = meta?.data;
    const result = data?.r;
    const versionMatches = this.version === data?.v;
    if (fileDescriptor.notFound || fileDescriptor.changed || !meta || !result || !versionMatches || !this.checkDependencies(data.d)) {
      return void 0;
    }
    const dd = { ...data };
    if (dd.d) {
      dd.d = setTreeEntry(this.dependencyCacheTree, dd.d);
    }
    dd.r = dd.r && this.normalizeResult(dd.r);
    meta.data = this.objectCollection.get(dd);
    const hasErrors = !!result && (result.errors > 0 || result.configErrors > 0 || result.issues.length > 0);
    const cached = true;
    const shouldReadFile = cached && hasErrors;
    return {
      ...result,
      elapsedTimeMs: void 0,
      fileInfo: shouldReadFile ? await readFileInfo(filename) : { filename },
      cached
    };
  }
  setCachedLintResults({ fileInfo, elapsedTimeMs: _, cached: __, ...result }, dependsUponFiles) {
    const fileDescriptor = this.fileEntryCache.getFileDescriptor(fileInfo.filename);
    const meta = fileDescriptor.meta;
    if (fileDescriptor.notFound || !meta) {
      return;
    }
    const data = this.objectCollection.get({
      v: this.version,
      r: this.normalizeResult(result),
      d: this.calcDependencyHashes(dependsUponFiles)
    });
    meta.data = data;
  }
  reconcile() {
    this.fileEntryCache.reconcile();
  }
  reset() {
    this.fileEntryCache.destroy();
    this.dependencyCache.clear();
    this.dependencyCacheTree = {};
    this.objectCollection = new ShallowObjectCollection();
    this.ocCacheFileResult = new ShallowObjectCollection();
  }
  normalizeResult(result) {
    const { issues, processed, errors, configErrors, ...rest } = result;
    if (!Object.keys(rest).length) {
      return this.ocCacheFileResult.get(result);
    }
    return this.ocCacheFileResult.get({ issues, processed, errors, configErrors });
  }
  calcDependencyHashes(dependsUponFiles) {
    dependsUponFiles.sort();
    const c = getTreeEntry(this.dependencyCacheTree, dependsUponFiles);
    if (c?.d) {
      return c.d;
    }
    const dependencies = dependsUponFiles.map((f) => this.getDependency(f));
    return setTreeEntry(this.dependencyCacheTree, dependencies);
  }
  checkDependency(dep) {
    const depFile = this.resolveFile(dep.f);
    const cDep = this.dependencyCache.get(depFile);
    if (cDep && compDep(dep, cDep))
      return true;
    if (cDep)
      return false;
    const d = this.getFileDep(depFile);
    if (compDep(dep, d)) {
      this.dependencyCache.set(depFile, dep);
      return true;
    }
    this.dependencyCache.set(depFile, d);
    return false;
  }
  getDependency(file) {
    const dep = this.dependencyCache.get(file);
    if (dep)
      return dep;
    const d = this.getFileDep(file);
    this.dependencyCache.set(file, d);
    return d;
  }
  getFileDep(file) {
    (0, import_assert2.default)((0, import_path2.isAbsolute)(file), `Dependency must be absolute "${file}"`);
    const f = this.toRelFile(file);
    let h;
    try {
      const buffer = fs4.readFileSync(file);
      h = this.getHash(buffer);
    } catch (e) {
      return { f };
    }
    return { f, h };
  }
  checkDependencies(dependencies) {
    if (!dependencies)
      return false;
    for (const dep of dependencies) {
      if (!this.checkDependency(dep)) {
        return false;
      }
    }
    return true;
  }
  getHash(buffer) {
    return crypto4.createHash("md5").update(buffer).digest("hex");
  }
  resolveFile(file) {
    return normalizePath2((0, import_path2.resolve)(this.cacheDir, file));
  }
  toRelFile(file) {
    return normalizePath2(this.useUniversalCache ? (0, import_path2.relative)(this.cacheDir, file) : file);
  }
};
function getTreeEntry(tree, keys) {
  let r = tree;
  for (const k of keys) {
    r = r.c?.get(k);
    if (!r)
      return r;
  }
  return r;
}
function setTreeEntry(tree, deps, update = false) {
  let r = tree;
  for (const d2 of deps) {
    const k = d2.f;
    if (!r.c) {
      r.c = /* @__PURE__ */ new Map();
    }
    const cn = r.c.get(k);
    const n = cn ?? {};
    if (!cn) {
      r.c.set(k, n);
    }
    r = n;
  }
  let d = r.d;
  if (!d || r.d && update) {
    r.d = deps;
    d = deps;
  }
  return d;
}
function compDep(a, b) {
  return a.f === b.f && a.h === b.h;
}
function calcVersion(version3) {
  return version3 + META_DATA_VERSION_SUFFIX;
}

// node_modules/cspell/dist/esm/util/cache/DummyCache.mjs
var DummyCache = class {
  getCachedLintResults() {
    return Promise.resolve(void 0);
  }
  setCachedLintResults() {
    return;
  }
  reconcile() {
    return;
  }
  reset() {
    return;
  }
};

// node_modules/cspell/dist/esm/util/cache/createCache.mjs
var DEFAULT_CACHE_LOCATION = ".cspellcache";
var versionSuffix = "";
function createCache(options) {
  const { useCache, cacheLocation, cacheStrategy, reset } = options;
  const location = import_path3.default.resolve(cacheLocation);
  const useChecksum = cacheStrategy === "content";
  const version3 = normalizeVersion(options.version);
  const useUniversal = options.cacheFormat === "universal";
  const cache = useCache ? new DiskCache(location, useChecksum, version3, useUniversal) : new DummyCache();
  reset && cache.reset();
  return cache;
}
async function calcCacheSettings(config, cacheOptions, root) {
  const cs = config.cache ?? {};
  const useCache = cacheOptions.cache ?? cs.useCache ?? false;
  const cacheLocation = await resolveCacheLocation(import_path3.default.resolve(root, cacheOptions.cacheLocation ?? cs.cacheLocation ?? DEFAULT_CACHE_LOCATION));
  const cacheStrategy = cacheOptions.cacheStrategy ?? cs.cacheStrategy ?? "metadata";
  const cacheFormat = cacheOptions.cacheFormat ?? cs.cacheFormat ?? "legacy";
  const optionals = {};
  if (cacheOptions.cacheReset) {
    optionals.reset = true;
  }
  return {
    ...optionals,
    useCache,
    cacheLocation,
    cacheStrategy,
    version: cacheOptions.version,
    cacheFormat
  };
}
async function resolveCacheLocation(cacheLocation) {
  try {
    const s = await (0, import_promises.stat)(cacheLocation);
    if (s.isFile())
      return cacheLocation;
    return import_path3.default.join(cacheLocation, DEFAULT_CACHE_LOCATION);
  } catch (err) {
    if (isError2(err) && err.code === "ENOENT") {
      return cacheLocation;
    }
    throw err;
  }
}
function normalizeVersion(version3) {
  const parts = version3.split(".").slice(0, 2);
  (0, import_assert3.default)(parts.length === 2);
  return parts.join(".") + versionSuffix;
}

// node_modules/cspell/dist/esm/util/prefetch.mjs
var import_assert4 = __toESM(require("assert"), 1);
function* prefetchIterable(iterable, size) {
  (0, import_assert4.default)(size >= 0);
  const iter = iterable[Symbol.iterator]();
  const buffer = [];
  for (let next = iter.next(); !next.done; next = iter.next()) {
    buffer.push(next.value);
    if (buffer.length >= size - 1) {
      const value = buffer[0];
      buffer.shift();
      yield value;
    }
  }
  yield* buffer;
}

// node_modules/@cspell/dynamic-import/dist/esm/dynamicImport.mjs
var import_path4 = require("path");
var import_url4 = require("url");
var isWindowsPath = /^[a-z]:\\/i;
async function dynamicImportFrom(moduleName, paths) {
  paths = Array.isArray(paths) ? paths : paths ? [paths] : void 0;
  const modulesNameToImport = typeof moduleName === "string" && isWindowsPath.test(moduleName) ? (0, import_url4.pathToFileURL)(moduleName) : moduleName;
  if (!paths || !paths.length || typeof moduleName !== "string") {
    try {
      return await import(modulesNameToImport.toString());
    } catch (e) {
      const err = toError3(e);
      throw err;
    }
  }
  const importResolveModule = await Promise.resolve().then(() => (init_import_meta_resolve(), import_meta_resolve_exports));
  const { resolve: resolve10 } = importResolveModule;
  let lastError = void 0;
  for (const parent of paths) {
    const url = typeof parent === "string" ? parent.startsWith("file://") ? new URL(parent) : (0, import_url4.pathToFileURL)(parent + import_path4.sep) : parent;
    let resolved = "";
    let location = "";
    try {
      resolved = await resolve10(modulesNameToImport.toString(), url.toString());
      location = isWindowsPath.test(resolved) ? (0, import_url4.pathToFileURL)(resolved).toString() : resolved;
      return await import(location);
    } catch (err) {
      lastError = err;
    }
  }
  throw lastError;
}
function toError3(e) {
  if (isError3(e))
    return e;
  return new Error(e?.toString());
}
function isError3(e) {
  return e instanceof Error;
}

// node_modules/cspell/dist/esm/util/reporters.mjs
var import_pkgInfo = __toESM(require_pkgInfo(), 1);
function callAll(methods) {
  return (...p) => {
    for (const method of methods) {
      method(...p);
    }
    return;
  };
}
function extractEmitter(reporters, emitterName) {
  return reporters.map((r) => r[emitterName]?.bind(r)).filter((r) => !!r);
}
function mergeResultEmitters(reporters) {
  return async (result) => {
    await Promise.all(reporters.map((reporter) => reporter.result?.(result)));
  };
}
function mergeReporters(...reporters) {
  return {
    issue: callAll(extractEmitter(reporters, "issue")),
    info: callAll(extractEmitter(reporters, "info")),
    debug: callAll(extractEmitter(reporters, "debug")),
    progress: callAll(extractEmitter(reporters, "progress")),
    error: callAll(extractEmitter(reporters, "error")),
    result: mergeResultEmitters(reporters)
  };
}
async function loadReporters(reporters, defaultReporter, config) {
  async function loadReporter(reporterSettings) {
    if (reporterSettings === "default")
      return defaultReporter;
    if (!Array.isArray(reporterSettings)) {
      reporterSettings = [reporterSettings];
    }
    const [moduleName, settings] = reporterSettings;
    try {
      const { getReporter: getReporter2 } = await dynamicImportFrom(moduleName, [process.cwd(), import_pkgInfo.pkgDir]);
      return getReporter2(settings, config);
    } catch (e) {
      throw new ApplicationError(`Failed to load reporter ${moduleName}: ${toError(e).message}`);
    }
  }
  reporters = !reporters || !reporters.length ? ["default"] : [...reporters];
  const loadedReporters = await Promise.all(reporters.map(loadReporter));
  return loadedReporters.filter((v) => v !== void 0);
}
function finalizeReporter(reporter) {
  return reporter && mergeReporters(reporter);
}

// node_modules/cspell/dist/esm/util/timer.mjs
function getTimeMeasurer() {
  const start = process.hrtime();
  return () => hrTimeToMs(process.hrtime(start));
}
function hrTimeToMs(hrTime) {
  return hrTime[0] * 1e3 + hrTime[1] * 1e-6;
}

// node_modules/cspell/dist/esm/lint/lint.mjs
var version2 = import_pkgInfo2.npmPackage.version;
var BATCH_SIZE = 8;
var { opFilterAsync: opFilterAsync2 } = operators;
async function runLint(cfg) {
  let { reporter } = cfg;
  cspell2.setLogger(getLoggerFromReporter(reporter));
  const configErrors = /* @__PURE__ */ new Set();
  const timer = getTimeMeasurer();
  const lintResult = await run2();
  await reporter.result(lintResult);
  const elapsed = timer();
  if (getFeatureFlags().getFlag("timer")) {
    console.log(`Elapsed Time: ${elapsed.toFixed(2)}ms`);
  }
  return lintResult;
  function prefetch(filename, configInfo, cache) {
    if (isBinaryFile(filename, cfg.root))
      return { filename, result: Promise.resolve({ skip: true }) };
    async function fetch2() {
      const getElapsedTimeMs = getTimeMeasurer();
      const cachedResult = await cache.getCachedLintResults(filename);
      if (cachedResult) {
        reporter.debug(`Filename: ${filename}, using cache`);
        const fileResult = { ...cachedResult, elapsedTimeMs: getElapsedTimeMs() };
        return { fileResult };
      }
      const uri = filenameToUri(filename, cfg.root);
      const checkResult = await cspell2.shouldCheckDocument({ uri }, {}, configInfo.config);
      if (!checkResult.shouldCheck)
        return { skip: true };
      const fileInfo = await readFileInfo(filename, void 0, true);
      return { fileInfo };
    }
    const result = fetch2();
    return { filename, result };
  }
  async function processFile(filename, configInfo, cache, prefetch2) {
    if (prefetch2?.fileResult)
      return prefetch2.fileResult;
    const getElapsedTimeMs = getTimeMeasurer();
    const cachedResult = await cache.getCachedLintResults(filename);
    if (cachedResult) {
      reporter.debug(`Filename: ${filename}, using cache`);
      return { ...cachedResult, elapsedTimeMs: getElapsedTimeMs() };
    }
    const result = {
      fileInfo: {
        filename
      },
      issues: [],
      processed: false,
      errors: 0,
      configErrors: 0,
      elapsedTimeMs: 0
    };
    const fileInfo = prefetch2?.fileInfo || await readFileInfo(filename, void 0, true);
    if (fileInfo.errorCode) {
      if (fileInfo.errorCode !== "EISDIR" && cfg.options.mustFindFiles) {
        const err = toError(`File not found: "${filename}"`);
        reporter.error("Linter:", err);
        result.errors += 1;
      }
      return result;
    }
    const doc = fileInfoToDocument(fileInfo, cfg.options.languageId, cfg.locale);
    const { text } = fileInfo;
    result.fileInfo = fileInfo;
    let spellResult = {};
    reporter.info(`Checking: ${filename}, File type: ${doc.languageId ?? "auto"}, Language: ${doc.locale ?? "default"}`, MessageTypes.Info);
    try {
      const { showSuggestions: generateSuggestions, validateDirectives } = cfg.options;
      const numSuggestions = configInfo.config.numSuggestions ?? 5;
      const validateOptions = clean({ generateSuggestions, numSuggestions, validateDirectives });
      const r = await cspell2.spellCheckDocument(doc, validateOptions, configInfo.config);
      spellResult = r;
      result.processed = r.checked;
      result.issues = cspell2.Text.calculateTextDocumentOffsets(doc.uri, text, r.issues).map(mapIssue);
    } catch (e) {
      reporter.error(`Failed to process "${filename}"`, toError(e));
      result.errors += 1;
    }
    result.elapsedTimeMs = getElapsedTimeMs();
    const config = spellResult.settingsUsed ?? {};
    result.configErrors += await reportConfigurationErrors(config);
    const elapsed2 = result.elapsedTimeMs / 1e3;
    const dictionaries = config.dictionaries || [];
    reporter.info(`Checked: ${filename}, File type: ${config.languageId}, Language: ${config.language} ... Issues: ${result.issues.length} ${elapsed2}S`, MessageTypes.Info);
    reporter.info(`Config file Used: ${spellResult.localConfigFilepath || configInfo.source}`, MessageTypes.Info);
    reporter.info(`Dictionaries Used: ${dictionaries.join(", ")}`, MessageTypes.Info);
    if (cfg.options.debug) {
      const { id: _id, name: _name, __imports, __importRef, ...cfg2 } = config;
      const debugCfg = {
        filename,
        languageId: doc.languageId ?? cfg2.languageId ?? "default",
        config: { ...cfg2, source: null },
        source: spellResult.localConfigFilepath
      };
      reporter.debug(JSON.stringify(debugCfg, void 0, 2));
    }
    const dep = calcDependencies(config);
    cache.setCachedLintResults(result, dep.files);
    return result;
  }
  function mapIssue({ doc: _, ...tdo }) {
    const context = cfg.showContext ? extractContext(tdo, cfg.showContext) : { text: tdo.line.text.trimEnd(), offset: tdo.line.offset };
    return clean({ ...tdo, context });
  }
  async function processFiles(files, configInfo, cacheSettings) {
    const fileCount = files instanceof Array ? files.length : void 0;
    const status = runResult();
    const cache = createCache(cacheSettings);
    const failFast = cfg.options.failFast ?? configInfo.config.failFast ?? false;
    const emitProgressBegin = (filename, fileNum, fileCount2) => reporter.progress({
      type: "ProgressFileBegin",
      fileNum,
      fileCount: fileCount2,
      filename
    });
    const emitProgressComplete = (filename, fileNum, fileCount2, result) => reporter.progress(clean({
      type: "ProgressFileComplete",
      fileNum,
      fileCount: fileCount2,
      filename,
      elapsedTimeMs: result?.elapsedTimeMs,
      processed: result?.processed,
      numErrors: result?.issues.length || result?.errors,
      cached: result?.cached
    }));
    function* prefetchFiles(files2) {
      const iter = prefetchIterable(pipeSync(files2, opMapSync((filename) => prefetch(filename, configInfo, cache))), BATCH_SIZE);
      for (const v of iter) {
        yield v;
      }
    }
    async function* prefetchFilesAsync(files2) {
      for await (const filename of files2) {
        yield prefetch(filename, configInfo, cache);
      }
    }
    const emptyResult = {
      fileInfo: { filename: "" },
      issues: [],
      processed: false,
      errors: 0,
      configErrors: 0,
      elapsedTimeMs: 1
    };
    async function processPrefetchFileResult(pf, index) {
      const { filename, result: pFetchResult } = pf;
      const getElapsedTimeMs = getTimeMeasurer();
      const fetchResult = await pFetchResult;
      emitProgressBegin(filename, index, fileCount ?? index);
      if (fetchResult?.skip) {
        return {
          filename,
          fileNum: index,
          result: { ...emptyResult, fileInfo: { filename }, elapsedTimeMs: getElapsedTimeMs() }
        };
      }
      const result = await processFile(filename, configInfo, cache, fetchResult);
      return { filename, fileNum: index, result };
    }
    async function* loadAndProcessFiles() {
      let i = 0;
      if (isAsyncIterable(files)) {
        for await (const pf of prefetchFilesAsync(files)) {
          yield processPrefetchFileResult(pf, ++i);
        }
      } else {
        for (const pf of prefetchFiles(files)) {
          await pf.result;
          yield await processPrefetchFileResult(pf, ++i);
        }
      }
    }
    for await (const fileP of loadAndProcessFiles()) {
      const { filename, fileNum, result } = await fileP;
      status.files += 1;
      status.cachedFiles = (status.cachedFiles || 0) + (result.cached ? 1 : 0);
      emitProgressComplete(filename, fileNum, fileCount ?? fileNum, result);
      result.issues.filter(cfg.uniqueFilter).forEach((issue) => reporter.issue(issue));
      if (result.issues.length || result.errors) {
        status.filesWithIssues.add(filename);
        status.issues += result.issues.length;
        status.errors += result.errors;
        if (failFast) {
          return status;
        }
      }
      status.errors += result.configErrors;
    }
    cache.reconcile();
    return status;
  }
  function calcDependencies(config) {
    const { configFiles, dictionaryFiles } = cspell2.extractDependencies(config);
    return { files: configFiles.concat(dictionaryFiles) };
  }
  async function reportConfigurationErrors(config) {
    const errors = cspell2.extractImportErrors(config);
    let count = 0;
    errors.forEach((ref) => {
      const key = ref.error.toString();
      if (configErrors.has(key))
        return;
      configErrors.add(key);
      count += 1;
      reporter.error("Configuration", ref.error);
    });
    const dictCollection = await cspell2.getDictionary(config);
    dictCollection.dictionaries.forEach((dict) => {
      const dictErrors = dict.getErrors?.() || [];
      const msg = `Dictionary Error with (${dict.name})`;
      dictErrors.forEach((error2) => {
        const key = msg + error2.toString();
        if (configErrors.has(key))
          return;
        configErrors.add(key);
        count += 1;
        reporter.error(msg, error2);
      });
    });
    return count;
  }
  function countConfigErrors(configInfo) {
    return reportConfigurationErrors(configInfo.config);
  }
  async function run2() {
    if (cfg.options.root) {
      process.env[cspell2.ENV_CSPELL_GLOB_ROOT] = cfg.root;
    }
    const configInfo = await readConfig(cfg.configFile, cfg.root);
    if (cfg.options.defaultConfiguration !== void 0) {
      configInfo.config.loadDefaultConfiguration = cfg.options.defaultConfiguration;
    }
    const reporterConfig = clean({
      maxNumberOfProblems: configInfo.config.maxNumberOfProblems,
      maxDuplicateProblems: configInfo.config.maxDuplicateProblems,
      minWordLength: configInfo.config.minWordLength,
      ...cfg.options
    });
    const reporters = cfg.options.reporter ?? configInfo.config.reporters;
    reporter = mergeReporters(...await loadReporters(reporters, cfg.reporter, reporterConfig));
    cspell2.setLogger(getLoggerFromReporter(reporter));
    const globInfo = await determineGlobs(configInfo, cfg);
    const { fileGlobs, excludeGlobs } = globInfo;
    const hasFileLists = !!cfg.fileLists.length;
    if (!fileGlobs.length && !hasFileLists) {
      return runResult();
    }
    header(fileGlobs, excludeGlobs);
    checkGlobs(fileGlobs, reporter);
    reporter.info(`Config Files Found:
    ${configInfo.source}
`, MessageTypes.Info);
    const configErrors2 = await countConfigErrors(configInfo);
    if (configErrors2)
      return runResult({ errors: configErrors2 });
    const { root } = cfg;
    try {
      const cacheSettings = await calcCacheSettings(configInfo.config, { ...cfg.options, version: version2 }, root);
      const files = await determineFilesToCheck(configInfo, cfg, reporter, globInfo);
      return await processFiles(files, configInfo, cacheSettings);
    } catch (e) {
      const err = toApplicationError(e);
      reporter.error("Linter", err);
      return runResult({ errors: 1 });
    }
  }
  function header(files, cliExcludes) {
    const formattedFiles = files.length > 100 ? files.slice(0, 100).concat(["..."]) : files;
    reporter.info(`
cspell;
Date: ${(/* @__PURE__ */ new Date()).toUTCString()}
Options:
    verbose:   ${yesNo(!!cfg.options.verbose)}
    config:    ${cfg.configFile || "default"}
    exclude:   ${cliExcludes.join("\n               ")}
    files:     ${formattedFiles}
    wordsOnly: ${yesNo(!!cfg.options.wordsOnly)}
    unique:    ${yesNo(!!cfg.options.unique)}
`, MessageTypes.Info);
  }
}
function checkGlobs(globs, reporter) {
  globs.filter((g) => g.startsWith("'") || g.endsWith("'")).map((glob2) => import_chalk2.default.yellow(glob2)).forEach((glob2) => reporter.error("Linter", new CheckFailed(`Glob starting or ending with ' (single quote) is not likely to match any files: ${glob2}.`)));
}
async function determineGlobs(configInfo, cfg) {
  const useGitignore = cfg.options.gitignore ?? configInfo.config.useGitignore ?? false;
  const gitignoreRoots = cfg.options.gitignoreRoot ?? configInfo.config.gitignoreRoot;
  const gitIgnore = useGitignore ? await generateGitIgnore(gitignoreRoots) : void 0;
  const cliGlobs = cfg.fileGlobs;
  const allGlobs = cliGlobs.length ? cliGlobs : configInfo.config.files || [];
  const combinedGlobs = await normalizeFileOrGlobsToRoot(allGlobs, cfg.root);
  const cliExcludeGlobs = extractPatterns(cfg.excludes).map((p) => p.glob);
  const normalizedExcludes = normalizeGlobsToRoot(cliExcludeGlobs, cfg.root, true);
  const includeGlobs = combinedGlobs.filter((g) => !g.startsWith("!"));
  const excludeGlobs = combinedGlobs.filter((g) => g.startsWith("!")).concat(normalizedExcludes);
  const fileGlobs = includeGlobs;
  const appGlobs = { allGlobs, gitIgnore, fileGlobs, excludeGlobs, normalizedExcludes };
  return appGlobs;
}
async function determineFilesToCheck(configInfo, cfg, reporter, globInfo) {
  async function _determineFilesToCheck() {
    const { fileLists } = cfg;
    const hasFileLists = !!fileLists.length;
    const { allGlobs, gitIgnore, fileGlobs, excludeGlobs, normalizedExcludes } = globInfo;
    const { root } = cfg;
    const globsToExclude = (configInfo.config.ignorePaths || []).concat(excludeGlobs);
    const globMatcher = buildGlobMatcher(globsToExclude, root, true);
    const ignoreGlobs = extractGlobsFromMatcher(globMatcher);
    const globOptions = {
      root,
      cwd: root,
      ignore: ignoreGlobs.concat(normalizedExcludes),
      nodir: true
    };
    const enableGlobDot = cfg.enableGlobDot ?? configInfo.config.enableGlobDot;
    if (enableGlobDot !== void 0) {
      globOptions.dot = enableGlobDot;
    }
    const filterFiles2 = opFilter(filterFilesFn(globMatcher));
    const foundFiles = await (hasFileLists ? useFileLists(fileLists, allGlobs, root, enableGlobDot) : findFiles(fileGlobs, globOptions));
    const filtered = gitIgnore ? await gitIgnore.filterOutIgnored(foundFiles) : foundFiles;
    const files = isAsyncIterable(filtered) ? pipeAsync(filtered, filterFiles2) : [...pipeSync(filtered, filterFiles2)];
    return files;
  }
  function isExcluded(filename, globMatcherExclude) {
    if (cspell2.isBinaryFile(import_uri3.URI.file(filename))) {
      return true;
    }
    const { root } = cfg;
    const absFilename = path13.resolve(root, filename);
    const r = globMatcherExclude.matchEx(absFilename);
    if (r.matched) {
      const { glob: glob2, source } = extractGlobSource(r.pattern);
      reporter.info(`Excluded File: ${path13.relative(root, absFilename)}; Excluded by ${glob2} from ${source}`, MessageTypes.Info);
    }
    return r.matched;
  }
  function filterFilesFn(globMatcherExclude) {
    const patterns = globMatcherExclude.patterns;
    const excludeInfo = patterns.map(extractGlobSource).map(({ glob: glob2, source }) => `Glob: ${glob2} from ${source}`).filter(uniqueFn());
    reporter.info(`Exclusion Globs: 
    ${excludeInfo.join("\n    ")}
`, MessageTypes.Info);
    return (filename) => !isExcluded(filename, globMatcherExclude);
  }
  return _determineFilesToCheck();
}
function extractContext(tdo, contextRange) {
  const { line, offset } = tdo;
  const textOffsetInLine = offset - line.offset;
  let left = Math.max(textOffsetInLine - contextRange, 0);
  let right = Math.min(line.text.length, textOffsetInLine + contextRange + tdo.text.length);
  const lineText = line.text;
  const isLetter = /^[a-z]$/i;
  const isSpace = /^\s$/;
  for (let n = contextRange / 2; n > 0 && left > 0; n--, left--) {
    if (!isLetter.test(lineText[left - 1])) {
      break;
    }
  }
  for (let n = contextRange / 2; n > 0 && right < lineText.length; n--, right++) {
    if (!isLetter.test(lineText[right])) {
      break;
    }
  }
  for (; left < textOffsetInLine && isSpace.test(lineText[left]); left++) {
  }
  const context = {
    text: line.text.slice(left, right).trimEnd(),
    offset: left + line.offset
  };
  return context;
}
function extractGlobSource(g) {
  const { glob: glob2, rawGlob, source } = g;
  return {
    glob: rawGlob || glob2,
    source
  };
}
function runResult(init = {}) {
  const { files = 0, filesWithIssues = /* @__PURE__ */ new Set(), issues = 0, errors = 0, cachedFiles = 0 } = init;
  return { files, filesWithIssues, issues, errors, cachedFiles };
}
function yesNo(value) {
  return value ? "Yes" : "No";
}
function getLoggerFromReporter(reporter) {
  const log = (...params) => {
    const msg = (0, import_util23.format)(...params);
    reporter.info(msg, "Info");
  };
  const error2 = (...params) => {
    const msg = (0, import_util23.format)(...params);
    const err = { message: "", name: "error", toString: () => "" };
    reporter.error(msg, err);
  };
  const warn = (...params) => {
    const msg = (0, import_util23.format)(...params);
    reporter.info(msg, "Warning");
  };
  return {
    log,
    warn,
    error: error2
  };
}
async function generateGitIgnore(roots) {
  const root = (typeof roots === "string" ? [roots].filter((r) => !!r) : roots) || [];
  if (!root?.length) {
    const cwd = process.cwd();
    const repo = await findRepoRoot(cwd) || cwd;
    root.push(repo);
  }
  return new GitIgnore(root?.map((p) => path13.resolve(p)));
}
async function useFileLists(fileListFiles, includeGlobPatterns, root, dot) {
  includeGlobPatterns = includeGlobPatterns.length ? includeGlobPatterns : ["**"];
  const options = { root, mode: "include" };
  if (dot !== void 0) {
    options.dot = dot;
  }
  const globMatcher = new GlobMatcher(includeGlobPatterns, options);
  const filterFiles2 = (file) => globMatcher.match(file);
  const files = readFileListFiles(fileListFiles);
  return pipeAsync(files, opFilter(filterFiles2), opFilterAsync2(isNotDir));
}

// node_modules/cspell/dist/esm/lint/LintRequest.mjs
var path14 = __toESM(require("path"), 1);
var defaultContextRange = 20;
var LintRequest = class {
  constructor(fileGlobs, options, reporter) {
    this.fileGlobs = fileGlobs;
    this.options = options;
    this.reporter = reporter;
    this.root = path14.resolve(options.root || process.cwd());
    this.configFile = options.config;
    this.excludes = calcExcludeGlobInfo(this.root, options.exclude);
    this.locale = options.locale || "";
    this.enableGlobDot = options.dot;
    this.uniqueFilter = options.unique ? uniqueFilterFnGenerator((issue) => issue.text) : () => true;
    this.showContext = options.showContext === true ? defaultContextRange : options.showContext ? options.showContext : 0;
    this.fileLists = (options.fileList ?? options.fileLists) || [];
  }
};

// node_modules/cspell/dist/esm/options.mjs
function fixLegacy(opts) {
  const { local, ...rest } = opts;
  if (local && !rest.locale) {
    rest.locale = local;
  }
  return rest;
}

// node_modules/cspell/dist/esm/repl/index.mjs
var readline2 = __toESM(require("readline"), 1);
var SimpleRepl = class {
  constructor(prompt = "> ") {
    this.prompt = prompt;
    this._history = [];
    this.rl = readline2.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt,
      history: this._history,
      historySize: 100,
      completer: (line) => this._completer(line)
    });
    this.rl.on("history", (h) => (this._history = h, void 0));
  }
  question(query) {
    return new Promise((resolve10) => {
      this.rl.question(query, resolve10);
    });
  }
  _completer(line) {
    if (this.completer)
      return this.completer(line);
    const hist = this._history.filter((h) => h.startsWith(line));
    return [hist, line];
  }
  get history() {
    return this._history;
  }
  [Symbol.asyncIterator]() {
    const next = () => {
      if (this.beforeEach)
        this.beforeEach();
      return this.question(this.prompt).then((value) => ({ value })).catch(() => ({ done: true, value: void 0 }));
    };
    return { next };
  }
};

// node_modules/cspell/dist/esm/application.mjs
var import_cspell_lib5 = __toESM(require_cjs10(), 1);
function lint(fileGlobs, options, reporter) {
  options = fixLegacy(options);
  const cfg = new LintRequest(fileGlobs, options, finalizeReporter(reporter) ?? getReporter({ ...options, fileGlobs }));
  return runLint(cfg);
}

// src/spell.ts
async function lint2(files, lintOptions, reporter) {
  const { root, config, checkDotFiles } = lintOptions;
  const options = { root, config };
  if (checkDotFiles) {
    options.dot = true;
  } else if (checkDotFiles === false) {
    options.dot = false;
  }
  await lint(files, options, reporter);
}

// src/action.ts
var supportedIncrementalEvents = /* @__PURE__ */ new Set(["push", "pull_request"]);
async function gatherPullRequestFiles(context) {
  const { github, githubContext } = context;
  const pull_number = githubContext.payload.pull_request?.number;
  if (!pull_number)
    return /* @__PURE__ */ new Set();
  return getPullRequestFiles(github, { ...githubContext.repo, pull_number });
}
async function gatherPushFiles(context) {
  const { github, githubContext } = context;
  const push = githubContext.payload;
  const commits = push.commits?.map((c) => c.id);
  const files = commits && await fetchFilesForCommits(github, githubContext.repo, commits);
  return files || /* @__PURE__ */ new Set();
}
var checkDotMap = {
  true: true,
  false: false,
  explicit: void 0
};
async function checkSpelling(params, files) {
  const options = {
    root: params.root || process.cwd(),
    config: params.config || void 0,
    checkDotFiles: checkDotMap[params.check_dot_files]
  };
  if (!files.length) {
    return true;
  }
  const reporterOptions = {
    verbose: params.verbose === "true"
  };
  const collector = new CSpellReporterForGithubAction(params.inline, reporterOptions, core3);
  await lint2(files, options, collector.reporter);
  return collector.result;
}
function friendlyEventName(eventName) {
  switch (eventName) {
    case "push":
      return "Push";
    case "pull_request":
      return "Pull Request";
    default:
      return `'${eventName}'`;
  }
}
function isSupportedEvent(eventName) {
  return supportedIncrementalEvents.has(eventName);
}
async function gatherFilesFromContext(context) {
  if (context.useEventFiles) {
    const eventFiles = await gatherFiles(context);
    return filterFiles(context.files, eventFiles, context.dot);
  }
  const files = new Set(
    context.files.split("\n").map((a) => a.trim()).filter((a) => !!a)
  );
  return files;
}
async function gatherFiles(context) {
  const eventName = context.githubContext.eventName;
  switch (eventName) {
    case "push":
      return gatherPushFiles(context);
    case "pull_request":
      return gatherPullRequestFiles(context);
  }
  return /* @__PURE__ */ new Set();
}
function filterFiles(globPattern, files, dot) {
  if (!globPattern)
    return files;
  const matchingFiles = /* @__PURE__ */ new Set();
  const g = new GlobMatcher(globPattern, { mode: "include", dot });
  for (const p of files) {
    if (g.match(p)) {
      matchingFiles.add(p);
    }
  }
  return matchingFiles;
}
async function action(githubContext, octokit) {
  const params = getActionParams();
  validateActionParams(params, core3.error);
  const eventName = githubContext.eventName;
  if (params.incremental_files_only === "true" && !isSupportedEvent(eventName)) {
    params.files = params.files || "**";
    core3.warning("Unable to determine which files have changed, checking files: " + params.files);
    params.incremental_files_only = "false";
  }
  params.files = params.files || (params.incremental_files_only !== "true" ? "**" : "");
  const dot = !!checkDotMap[params.check_dot_files];
  const context = {
    githubContext,
    github: octokit,
    files: params.files,
    useEventFiles: params.incremental_files_only === "true",
    dot
  };
  core3.info(friendlyEventName(eventName));
  const files = await gatherFilesFromContext(context);
  const result = await checkSpelling(params, [...files]);
  if (result === true) {
    return true;
  }
  const message = `Files checked: ${result.files}, Issues found: ${result.issues} in ${result.filesWithIssues.size} files.`;
  core3.info(message);
  outputResult(result);
  const fnS = (n) => n === 1 ? "" : "s";
  if (params.strict === "true" && result.issues) {
    const filesWithIssues = result.filesWithIssues.size;
    const err = `${result.issues} spelling issue${fnS(result.issues)} found in ${filesWithIssues} of the ${result.files} file${fnS(result.files)} checked.`;
    core3.setFailed(err);
  }
  return !(result.issues + result.errors);
}
function outputResult(runResult2) {
  const result = normalizeResult(runResult2);
  core3.setOutput("success", result.success);
  core3.setOutput("number_of_files_checked", result.number_of_files_checked);
  core3.setOutput("number_of_issues", result.number_of_issues);
  core3.setOutput("number_of_files_with_issues", result.files_with_issues.length);
  core3.setOutput("files_with_issues", normalizeFiles(result.files_with_issues));
  core3.setOutput("result", result);
}
function normalizeResult(result) {
  const { issues: number_of_issues, files: number_of_files_checked, filesWithIssues } = result;
  return {
    success: !number_of_issues,
    number_of_issues,
    number_of_files_checked,
    files_with_issues: normalizeFiles(filesWithIssues).slice(0, 1e3)
  };
}
function normalizeFiles(files) {
  const cwd = process.cwd();
  return [...files].map((file) => path15.relative(cwd, file));
}

// src/main.ts
var import_util24 = require("util");
function getGithubToken() {
  const t0 = core4.getInput("github_token", { required: true });
  if (t0[0] !== "$") {
    return t0;
  }
  return process.env[t0.slice(1)] || "undefined";
}
async function run() {
  try {
    core4.info("cspell-action");
    const githubContext = new import_context.Context();
    const githubToken = getGithubToken();
    await action(githubContext, (0, import_github2.getOctokit)(githubToken));
    core4.info("Done.");
  } catch (error2) {
    console.error(error2);
    core4.setFailed(isAppError(error2) ? error2.message : isError(error2) ? error2 : (0, import_util24.format)(error2));
  }
}

// src/main_root.ts
run();
/*! Bundled license information:

is-plain-object/dist/is-plain-object.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

flatted/cjs/index.js:
  (*! (c) 2020 Andrea Giammarchi *)
*/

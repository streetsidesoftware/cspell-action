"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name2 in all3)
    __defProp(target, name2, { get: all3[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toCommandProperties = exports2.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports2.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports2.toCommandProperties = toCommandProperties;
  }
});

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.issue = exports2.issueCommand = void 0;
    var os6 = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand2(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os6.EOL);
    }
    exports2.issueCommand = issueCommand2;
    function issue(name2, message = "") {
      issueCommand2(name2, {}, message);
    }
    exports2.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first3 = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first3) {
                  first3 = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareKeyValueMessage = exports2.issueFileCommand = void 0;
    var crypto2 = __importStar(require("crypto"));
    var fs6 = __importStar(require("fs"));
    var os6 = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs6.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs6.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os6.EOL}`, {
        encoding: "utf8"
      });
    }
    exports2.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${crypto2.randomUUID()}`;
      const convertedValue = (0, utils_1.toCommandValue)(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os6.EOL}${convertedValue}${os6.EOL}${delimiter}`;
    }
    exports2.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// ../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkBypass = exports2.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new DecodedURL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new DecodedURL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports2.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports2.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
    var DecodedURL = class extends URL {
      constructor(url2, base) {
        super(url2, base);
        this._decodedUsername = decodeURIComponent(super.username);
        this._decodedPassword = decodeURIComponent(super.password);
      }
      get username() {
        return this._decodedUsername;
      }
      get password() {
        return this._decodedPassword;
      }
    };
  }
});

// ../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert19 = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self = this;
      self.options = options || {};
      self.proxyOptions = self.options.proxy || {};
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
      self.requests = [];
      self.sockets = [];
      self.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions2(host, port, localAddress);
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self = this;
      var options = mergeOptions({ request: req }, self.options, toOptions2(host, port, localAddress));
      if (self.sockets.length >= this.maxSockets) {
        self.requests.push(options);
        return;
      }
      self.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this;
      var placeholder = {};
      self.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug5("making CONNECT request");
      var connectReq = self.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug5(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error4 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error4.code = "ECONNRESET";
          options.request.emit("error", error4);
          self.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug5("got illegal response body from proxy");
          socket.destroy();
          var error4 = new Error("got illegal response body from proxy");
          error4.code = "ECONNRESET";
          options.request.emit("error", error4);
          self.removeSocket(placeholder);
          return;
        }
        debug5("tunneling connection has established");
        self.sockets[self.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug5(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error4 = new Error("tunneling socket could not be established, cause=" + cause.message);
        error4.code = "ECONNRESET";
        options.request.emit("error", error4);
        self.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self = this;
      TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self.sockets[self.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions2(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys3 = Object.keys(overrides);
          for (var j = 0, keyLen = keys3.length; j < keyLen; ++j) {
            var k = keys3[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug5;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug5 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug5 = function() {
      };
    }
    exports2.debug = debug5;
  }
});

// ../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable")
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/constants.js"(exports2, module2) {
    "use strict";
    var headerNameLowerCasedRecord = {};
    var wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module2.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert19 = require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require("http");
    var stream = require("stream");
    var net = require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = require("buffer");
    var nodeUtil = require("util");
    var { stringify: stringify4 } = require("querystring");
    var { headerNameLowerCasedRecord } = require_constants();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url2, queryParams) {
      if (url2.includes("?") || url2.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify4(queryParams);
      if (stringified) {
        url2 += "?" + stringified;
      }
      return url2;
    }
    function parseURL(url2) {
      if (typeof url2 === "string") {
        url2 = new URL(url2);
        if (!/^https?:/.test(url2.origin || url2.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url2;
      }
      if (!url2 || typeof url2 !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url2.origin || url2.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url2 instanceof URL)) {
        if (url2.port != null && url2.port !== "" && !Number.isFinite(parseInt(url2.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url2.path != null && typeof url2.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url2.pathname != null && typeof url2.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url2.hostname != null && typeof url2.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url2.origin != null && typeof url2.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url2.port != null ? url2.port : url2.protocol === "https:" ? 443 : 80;
        let origin = url2.origin != null ? url2.origin : `${url2.protocol}//${url2.hostname}:${port}`;
        let path17 = url2.path != null ? url2.path : `${url2.pathname || ""}${url2.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path17 && !path17.startsWith("/")) {
          path17 = `/${path17}`;
        }
        url2 = new URL(origin + path17);
      }
      return url2;
    }
    function parseOrigin(url2) {
      url2 = parseURL(url2);
      if (url2.pathname !== "/" || url2.search || url2.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url2;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx3 = host.indexOf("]");
        assert19(idx3 !== -1);
        return host.substring(1, idx3);
      }
      const idx2 = host.indexOf(":");
      if (idx2 === -1) return host;
      return host.substring(0, idx2);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert19.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable3(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable4(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable: isIterable4,
      isAsyncIterable: isAsyncIterable3,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx2 = 0;
      while (idx2 < len) {
        const timer = fastTimers[idx2];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx2 !== len - 1) {
            fastTimers[idx2] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx2 += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter2);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module2.exports = SBMH;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports2, module2) {
    "use strict";
    var inherits = require("node:util").inherits;
    var ReadableStream = require("node:stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module2.exports = PartStream;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = function getLimit(limits, name2, defaultLimit) {
      if (!limits || limits[name2] === void 0 || limits[name2] === null) {
        return defaultLimit;
      }
      if (typeof limits[name2] !== "number" || isNaN(limits[name2])) {
        throw new TypeError("Limit " + name2 + " is not a valid number");
      }
      return limits[name2];
    };
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter2.call(this);
      cfg = cfg || {};
      const self = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self.maxed) {
          if (self.nread + end - start >= self.maxHeaderSize) {
            end = self.maxHeaderSize - self.nread + start;
            self.nread = self.maxHeaderSize;
            self.maxed = true;
          } else {
            self.nread += end - start;
          }
          self.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter2);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module2.exports = HeaderParser;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var inherits = require("node:util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self._inHeader = false;
        self._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self = this;
          process.nextTick(function() {
            self.emit("error", new Error("Unexpected end of multipart data"));
            if (self._part && !self._ignoreData) {
              const type = self._isPreamble ? "Preamble" : "Part";
              self._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self._part.push(null);
              process.nextTick(function() {
                self._realFinish = true;
                self.emit("finish");
                self._realFinish = false;
              });
              return;
            }
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self._parts === 0) {
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self._parts === 0) {
                if (self._finished) {
                  self._realFinish = true;
                  self.emit("finish");
                  self._realFinish = false;
                } else {
                  self._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module2.exports = Dicer;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports2, module2) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports2.toString())) {
          try {
            return textDecoders.get(exports2).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module2.exports = decodeText;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports2, module2) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match2) {
      return EncodedLookup[match2];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module2.exports = parseParams;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js"(exports2, module2) {
    "use strict";
    module2.exports = function basename5(path17) {
      if (typeof path17 !== "string") {
        return "";
      }
      for (var i = path17.length - 1; i >= 0; --i) {
        switch (path17.charCodeAt(i)) {
          case 47:
          // '/'
          case 92:
            path17 = path17.slice(i + 1);
            return path17 === ".." || path17 === "." ? "" : path17;
        }
      }
      return path17 === ".." || path17 === "." ? "" : path17;
    };
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable: Readable2 } = require("node:stream");
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename5 = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self._needDrain = false;
        if (self._cb && !self._pause) {
          const cb = self._cb;
          self._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self._nparts > partsLimit) {
          self.parser.removeListener("part", onPart);
          self.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename5(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self._pause = false;
              checkFinished();
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self._pause) {
                return;
              }
              self._pause = false;
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self = this;
      if (self.parser.writable) {
        self.parser.end();
      } else if (!self._boy._done) {
        process.nextTick(function() {
          self._boy._done = true;
          self._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable2.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable2);
    FileStream.prototype._read = function(n) {
    };
    module2.exports = Multipart;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports2, module2) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module2.exports = UrlEncoded;
  }
});

// ../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert19 = require("assert");
    var { isUint8Array } = require("util/types");
    var supportedHashes = [];
    var crypto2;
    try {
      crypto2 = require("crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url2 = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url2) && badPortsSet.has(url2.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike2(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert19(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        // eslint-disable-line
        /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * request’s current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
        case "no-referrer-when-downgrade":
        // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * request’s current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url2, originOnly) {
      assert19(url2 instanceof URL);
      if (url2.protocol === "file:" || url2.protocol === "about:" || url2.protocol === "blank:") {
        return "no-referrer";
      }
      url2.username = "";
      url2.password = "";
      url2.hash = "";
      if (originOnly) {
        url2.pathname = "";
        url2.search = "";
      }
      return url2;
    }
    function isURLPotentiallyTrustworthy(url2) {
      if (!(url2 instanceof URL)) {
        return false;
      }
      if (url2.href === "about:blank" || url2.href === "about:srcdoc") {
        return true;
      }
      if (url2.protocol === "data:") return true;
      if (url2.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(url2.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto2 === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve5, reject) => {
        res = resolve5;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert19(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name2, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name2} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name2} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert19(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url2) {
      assert19("protocol" in url2);
      const protocol = url2.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url2) {
      if (typeof url2 === "string") {
        return url2.startsWith("https:");
      }
      return url2.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url2) {
      assert19("protocol" in url2);
      const protocol = url2.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn2 = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn: hasOwn2,
      isErrorLike: isErrorLike2,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require("util");
    var { hasOwn: hasOwn2, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if (opts?.strict !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min3, ctx) {
      if (length < min3) {
        throw webidl.errors.exception({
          message: `${min3} argument${min3 !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = V?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys4 = Object.keys(O);
          for (const key of keys4) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys3 = Reflect.ownKeys(O);
        for (const key of keys3) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn2(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn2(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert19 = require("assert");
    var { atob: atob2 } = require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert19(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url2, excludeFragment = false) {
      if (!excludeFragment) {
        return url2.href;
      }
      const href = url2.href;
      const hashLength = url2.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx2 = input.indexOf(char, position.position);
      const start = position.position;
      if (idx2 === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx2;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue2) {
      const positionStart = position.position;
      let value = "";
      assert19(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert19(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue2) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert19(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name2, value] of parameters.entries()) {
        serialization += ";";
        serialization += name2;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { types } = require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder = new TextEncoder();
    var File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var File = NativeFile ?? UndiciFile;
    var FormData = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name2, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name2 = webidl.converters.USVString(name2);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name2, value, filename);
        this[kState].push(entry);
      }
      delete(name2) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name2 = webidl.converters.USVString(name2);
        this[kState] = this[kState].filter((entry) => entry.name !== name2);
      }
      get(name2) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name2 = webidl.converters.USVString(name2);
        const idx2 = this[kState].findIndex((entry) => entry.name === name2);
        if (idx2 === -1) {
          return null;
        }
        return this[kState][idx2].value;
      }
      getAll(name2) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name2 = webidl.converters.USVString(name2);
        return this[kState].filter((entry) => entry.name === name2).map((entry) => entry.value);
      }
      has(name2) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name2 = webidl.converters.USVString(name2);
        return this[kState].findIndex((entry) => entry.name === name2) !== -1;
      }
      set(name2, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name2 = webidl.converters.USVString(name2);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name2, value, filename);
        const idx2 = this[kState].findIndex((entry2) => entry2.name === name2);
        if (idx2 !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx2),
            entry,
            ...this[kState].slice(idx2 + 1).filter((entry2) => entry2.name !== name2)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name2, value, filename) {
      name2 = Buffer.from(name2).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name: name2, value };
    }
    module2.exports = { FormData };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_main();
    var util = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants2();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert19 = require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var random;
    try {
      const crypto2 = require("node:crypto");
      random = (max4) => crypto2.randomInt(0, max4);
    } catch {
      random = (max4) => Math.floor(Math.random(max4));
    }
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile ?? UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert19(isReadableStreamLike(stream));
      let action2 = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name2, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name2))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name2))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action2 = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action2 != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action2(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert19(!util.isDisturbed(object), "The body has already been consumed.");
        assert19(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name2, value) => {
              responseFormData.append(name2, value);
            });
            busboy.on("file", (name2, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name2, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name2, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve5, reject) => {
              busboy.on("finish", resolve5);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name2, value] of entries) {
              formData.append(name2, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error4) => promise.reject(error4);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert19 = require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request2 = class _Request {
      constructor(origin, {
        path: path17,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path17 !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path17[0] !== "/" && !(path17.startsWith("http://") || path17.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path17) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path17, query) : path17;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys3 = Object.keys(headers);
          for (let i = 0; i < keys3.length; i++) {
            const key = keys3[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert19(!this.aborted);
        assert19(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert19(!this.aborted);
        assert19(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert19(!this.aborted);
        assert19(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert19(!this.aborted);
        assert19(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert19(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error4) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error: error4 });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error4);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys3 = Object.keys(headers);
          for (let i = 0; i < keys3.length; i++) {
            const key = keys3[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0) continue;
          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request2;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var Dispatcher = class extends EventEmitter2 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve5, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve5(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve5, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve5(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var assert19 = require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert19(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert19(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert19 = require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert19(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert19(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error4) {
        this.handler.onError(error4);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path17 = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path17;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name2 = util.headerNameToString(header);
        return name2 === "authorization" || name2 === "cookie" || name2 === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert19(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js
var require_client = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert19 = require("assert");
    var net = require("net");
    var http = require("http");
    var { pipeline: pipeline3 } = require("stream");
    var util = require_util();
    var timers = require_timers();
    var Request2 = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http2;
    try {
      http2 = require("http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url2, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url2);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request2[kHTTP2BuildRequest](origin, opts, handler) : Request2[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve5) => {
          if (!this[kSize]) {
            resolve5(null);
          } else {
            this[kClosedResolve] = resolve5;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve5) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve5();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert19(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert19(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert19(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants = require_constants3();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert19.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert19.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert19.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert19.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert19.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert19.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert19.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert19(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert19(this.ptr != null);
        assert19(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert19(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert19(this.ptr != null);
        assert19(currentParser == null);
        assert19(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert19(this.ptr != null);
        assert19(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert19(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert19(request);
        assert19(!socket.destroyed);
        assert19(socket === client[kSocket]);
        assert19(!this.paused);
        assert19(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert19(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert19(!this.upgrade);
        assert19(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert19.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert19(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert19(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert19(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert19(request);
        assert19.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert19(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert19(request);
        assert19(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert19(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert19.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser2) {
      const { socket, timeoutType, client } = parser2;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert19(!parser2.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser2.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert19(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser2 } = this;
      if (parser2) {
        parser2.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser2 } = this;
      assert19(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser2.statusCode && !parser2.shouldKeepAlive) {
          parser2.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert19(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert19(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser2, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser2.statusCode && !parser2.shouldKeepAlive) {
          parser2.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser2 } = this;
      if (client[kHTTPConnVersion] === "h1" && parser2) {
        if (!this[kError] && parser2.statusCode && !parser2.shouldKeepAlive) {
          parser2.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert19(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert19(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert19(!client[kConnecting]);
      assert19(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx2 = hostname.indexOf("]");
        assert19(idx2 !== -1);
        const ip = hostname.substring(1, idx2);
        assert19(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve5, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve5(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert19(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert19(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert19(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path: path17, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path17} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert19(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert19(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream2({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert19(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path: path17, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string") headers = Request2[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path17;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert19(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert19(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream2({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert19(false);
        }
      }
    }
    function writeStream2({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert19(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe2 = pipeline3(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe2.on("data", onPipeData);
        pipe2.once("end", () => {
          pipe2.removeListener("data", onPipeData);
          util.destroy(pipe2);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert19(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert19(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert19(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve5, reject) => {
        assert19(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve5;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert19(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert19(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool2) {
        this[kPool] = pool2;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool2 = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool2[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool2[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool2[kNeedDrain]) {
            pool2[kNeedDrain] = false;
            pool2.emit("drain", origin, [pool2, ...targets]);
          }
          if (pool2[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool2[kClients].map((c) => c.close())).then(pool2[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool2.emit("connect", origin, [pool2, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool2.emit("disconnect", origin, [pool2, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool2.emit("connectionError", origin, [pool2, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve5) => {
            this[kClosedResolve] = resolve5;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx2 = this[kClients].indexOf(client);
          if (idx2 !== -1) {
            this[kClients].splice(idx2, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connectionError", (origin2, targets, error4) => {
          for (const target of targets) {
            const idx2 = this[kClients].indexOf(target);
            if (idx2 !== -1) {
              this[kClients].splice(idx2, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0) return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true)) {
          return this;
        }
        const pool2 = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool2);
        pool2.on("connect", () => {
          pool2[kWeight] = Math.min(this[kMaxWeightPerServer], pool2[kWeight] + this[kErrorPenalty]);
        });
        pool2.on("connectionError", () => {
          pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool2.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool2 = this[kClients].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true);
        if (pool2) {
          this[kRemoveClient](pool2);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool2) => pool2[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool2) => !pool2[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool2 = this[kClients][this[kIndex]];
          if (pool2[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool2[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool2[kWeight] >= this[kCurrentWeight] && !pool2[kNeedDrain]) {
            return pool2;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert19 = require("assert");
    var { Readable: Readable2 } = require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    var noop = () => {
    };
    module2.exports = class BodyReadable extends Readable2 {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert19(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve5, reject) => {
          const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve5(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self) {
      return self[kBody] && self[kBody].locked === true || self[kConsume];
    }
    function isUnusable(self) {
      return util.isDisturbed(self) || isLocked(self);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert19(!stream[kConsume]);
      return new Promise((resolve5, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve: resolve5,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve: resolve5, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve5(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve5(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve5(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = require("buffer").Blob;
          }
          resolve5(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/util.js"(exports2, module2) {
    var assert19 = require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert19(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module2.exports = { getResolveErrorBodyCallback };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self) {
      if (self.abort) {
        self.abort();
      } else {
        self.onError(new RequestAbortedError());
      }
    }
    function addSignal(self, signal) {
      self[kSignal] = null;
      self[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self);
        return;
      }
      self[kSignal] = signal;
      self[kListener] = () => {
        abort(self);
      };
      addAbortListener(self[kSignal], self[kListener]);
    }
    function removeSignal(self) {
      if (!self[kSignal]) {
        return;
      }
      if ("removeEventListener" in self[kSignal]) {
        self[kSignal].removeEventListener("abort", self[kListener]);
      } else {
        self[kSignal].removeListener("abort", self[kListener]);
      }
      self[kSignal] = null;
      self[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable2 = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable2({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough: PassThrough2 } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough2();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable: Readable2,
      Duplex,
      PassThrough: PassThrough2
    } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert19 = require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable2 {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable2 {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert19(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline3(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough2().destroy(err);
      }
    }
    module2.exports = pipeline3;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert19 = require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert19.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = require("http");
    var {
      types: {
        isPromise
      }
    } = require("util");
    function matchValue(match2, value) {
      if (typeof match2 === "string") {
        return match2 === value;
      }
      if (match2 instanceof RegExp) {
        return match2.test(value);
      }
      if (typeof match2 === "function") {
        return match2(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path17) {
      if (typeof path17 !== "string") {
        return path17;
      }
      const pathSegments = path17.split("?");
      if (pathSegments.length !== 2) {
        return path17;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path: path17, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path17);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path17 }) => matchValue(safeUrl(path17), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path: path17, method, body, headers, query } = opts;
      return {
        path: path17,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error: error4 }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error4 !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error4);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error4) {
            if (error4 instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error4.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error4.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error4;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url2 = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url2.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error4) {
        if (typeof error4 === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error4 });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify: promisify3 } = require("util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify3(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify: promisify3 } = require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify3(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count3) {
        const one = count3 === 1;
        const keys3 = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys3, count: count3, noun };
      }
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { Console: Console2 } = require("console");
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console2({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path: path17, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path17,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL3 } = require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL3(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL3(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RetryHandler.js"(exports2, module2) {
    var assert19 = require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;
      return diff;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size, end = size } = contentRange;
          assert19(this.start === start, "content-range mismatch");
          assert19(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size, end = size } = range;
            assert19(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert19(Number.isFinite(start));
            assert19(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert19(Number.isFinite(this.start));
          assert19(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var util = require("util");
    var { webidl } = require_webidl();
    var assert19 = require("assert");
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys3 = Object.keys(object);
        for (let i = 0; i < keys3.length; ++i) {
          appendHeader(headers, keys3[i], object[keys3[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name2, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name2)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name2,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
      }
      return headers[kHeadersList].append(name2, value);
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      constructor(init) {
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name2) {
        name2 = name2.toLowerCase();
        return this[kHeadersMap].has(name2);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name2, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name2.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name: name2, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name2, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name2.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name: name2, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name2) {
        this[kHeadersSortedMap] = null;
        name2 = name2.toLowerCase();
        if (name2 === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name2);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name2) {
        const value = this[kHeadersMap].get(name2.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name2, { value }] of this[kHeadersMap]) {
          yield [name2, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name: name2, value } of this[kHeadersMap].values()) {
            headers[name2] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init = void 0) {
        if (init === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name2, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name2 = webidl.converters.ByteString(name2);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name2, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name2) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name2 = webidl.converters.ByteString(name2);
        if (!isValidHeaderName(name2)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name2,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name2)) {
          return;
        }
        this[kHeadersList].delete(name2);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name2) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name2 = webidl.converters.ByteString(name2);
        if (!isValidHeaderName(name2)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name2,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name2);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name2) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name2 = webidl.converters.ByteString(name2);
        if (!isValidHeaderName(name2)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name2,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name2);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name2, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name2 = webidl.converters.ByteString(name2);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name2)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name2,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        this[kHeadersList].set(name2, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i = 0; i < names.length; ++i) {
          const [name2, value] = names[i];
          if (name2 === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name2, cookies[j]]);
            }
          } else {
            assert19(value !== null);
            headers.push([name2, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike: isErrorLike2,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert19 = require("assert");
    var { types } = require("util");
    var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url2, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url2 = webidl.converters.USVString(url2);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url2, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url2), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns response’s type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url2 = urlList[urlList.length - 1] ?? null;
        if (url2 === null) {
          return "";
        }
        return URLSerializer(url2, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns response’s status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether response’s status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns response’s status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns response’s headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError6 = isErrorLike2(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError6 ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert19(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert19(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert19(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants2();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert19 = require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
    var TransformStream = globalThis.TransformStream;
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request2 = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert19(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window}' must be null`);
        }
        if ("window" in init) {
          window = "no-window";
        }
        request = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client This’s relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window,
          // priority request’s priority.
          priority: request.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer request’s referrer.
          referrer: request.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode request’s mode.
          mode: request.mode,
          // credentials mode request’s credentials mode.
          credentials: request.credentials,
          // cache mode request’s cache mode.
          cache: request.cache,
          // redirect mode request’s redirect mode.
          redirect: request.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request.integrity,
          // keepalive request’s keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request2);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request2.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request2
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request2) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request: Request2, makeRequest };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request: Request2, makeRequest } = require_request2();
    var zlib = require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike: isErrorLike2,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert19 = require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants2();
    var { kHeadersList } = require_symbols();
    var EE = require("events");
    var { Readable: Readable2, pipeline: pipeline3 } = require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error4) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error4) {
          error4 = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error4;
        this.connection?.destroy(error4);
        this.emit("terminated", error4);
      }
    };
    function fetch(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request2(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert19(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error4) {
      if (!error4) {
        error4 = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error4);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error4).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error4).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert19(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - request’s current URL’s origin is same origin with request’s origin,
            //   and request’s response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // request’s current URL’s scheme is "data"
            currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert19(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert19(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert19(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // response’s status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert19(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike2(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url2 = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve5, reject) => agent.dispatch(
          {
            path: url2.pathname + url2.search,
            origin: url2.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys3 = Object.keys(headersList);
                for (const key of keys3) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable2({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve5({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline3(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error4) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error4);
              fetchParams.controller.terminate(error4);
              reject(error4);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve5({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants2();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = require("util");
    var { StringDecoder } = require("string_decoder");
    var { btoa: btoa2 } = require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error4) {
                  fr[kError] = error4;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error4) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error4;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa2(decoder.write(chunk));
          }
          dataURL += btoa2(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode2(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode2(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/util.js"(exports2, module2) {
    "use strict";
    var assert19 = require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert19(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response();
    var { Request: Request2 } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert19 = require("assert");
    var { getGlobalDispatcher } = require_global2();
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request2) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request2(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request2(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request2) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request2(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request2) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert19(typeof request === "string");
          r = new Request2(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request2) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request2(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request2("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache5 = this.#relevantRequestResponseList;
        const backupCache = [...cache5];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx2 = cache5.indexOf(requestResponse);
                assert19(idx2 !== -1);
                cache5.splice(idx2, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx2 = cache5.indexOf(requestResponse);
                assert19(idx2 !== -1);
                cache5.splice(idx2, 1);
              }
              cache5.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache5 = new Cache(kConstruct, cacheList);
            return await cache5.match(request, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache5 = new Cache(kConstruct, cacheList);
            const response = await cache5.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (this.#caches.has(cacheName)) {
          const cache6 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache6);
        }
        const cache5 = [];
        this.#caches.set(cacheName, cache5);
        return new Cache(kConstruct, cache5);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys3 = this.#caches.keys();
        return [...keys3];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name2) {
      for (const char of name2) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path17) {
      for (const char of path17) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify4(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module2.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify: stringify4
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert19 = require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name2 = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name2 = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name2 = name2.trim();
      value = value.trim();
      if (name2.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name: name2,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert19(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify: stringify4 } = require_util6();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name2, ...value] = piece.split("=");
        out[name2.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name2, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name2 = webidl.converters.DOMString(name2);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name: name2,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify4(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify4(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = require("worker_threads");
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants5();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require("diagnostics_channel");
    var { uid, states } = require_constants5();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto2;
    try {
      crypto2 = require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url2, protocols, ws, onEstablish, options) {
      const requestURL = url2;
      requestURL.protocol = url2.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto2.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error4) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error4);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants5();
    var crypto2;
    try {
      crypto2 = require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto2.randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var diagnosticsChannel = require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var ByteParser = class extends Writable {
      #buffers = [];
      #byteOffset = 0;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      constructor(ws) {
        super();
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (true) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.fin = (buffer[0] & 128) !== 0;
            this.#info.opcode = buffer[0] & 15;
            this.#info.originalOpcode ??= this.#info.opcode;
            this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
            if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (this.#info.fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              this.#info.closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (this.#info.opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              this.#state = parserStates.INFO;
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (this.#info.opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            } else if (this.#byteOffset >= this.#info.payloadLength) {
              const body = this.consume(this.#info.payloadLength);
              this.#fragments.push(body);
              if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                this.#info = {};
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            }
          }
          if (this.#byteOffset > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > this.#byteOffset) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (this.#buffers[0].length === n) {
          this.#byteOffset -= this.#buffers[0].length;
          return this.#buffers.shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = this.#buffers[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            this.#buffers[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += next.length;
          }
        }
        this.#byteOffset -= n;
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module2.exports = {
      ByteParser
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants2();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require("util");
    var experimentalWarned = false;
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url2, protocols = []) {
        super();
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url2 = webidl.converters.USVString(url2);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url2, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += ab.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        this[kResponse] = response;
        const parser2 = new ByteParser(this);
        parser2.on("drain", function onParserDrain() {
          this.ws[kResponse].socket.resume();
        });
        response.socket.ws = this;
        this[kByteParser] = parser2;
        this[kReadyState] = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// ../node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js
var require_undici = __commonJS({
  "../node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url2, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url2 || typeof url2 !== "string" && typeof url2 !== "object" && !(url2 instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path17 = opts.path;
          if (!opts.path.startsWith("/")) {
            path17 = `/${path17}`;
          }
          url2 = new URL(util.parseOrigin(url2).origin + path17);
        } else {
          if (!opts) {
            opts = typeof url2 === "object" ? url2 : {};
          }
          url2 = util.parseURL(url2);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url2.origin,
          path: url2.search ? `${url2.pathname}${url2.search}` : url2.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// ../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.isHttps = exports2.HttpClientResponse = exports2.HttpClientError = exports2.getProxyUrl = exports2.MediaTypes = exports2.Headers = exports2.HttpCodes = void 0;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var pm2 = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var undici_1 = require_undici();
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers || (exports2.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports2.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm2.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports2.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports2.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve5) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve5(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve5) => __awaiter(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            });
            this.message.on("end", () => {
              resolve5(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info5 = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info5, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info5, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info5 = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info5, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info5, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve5, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve5(res);
              }
            }
            this.requestRawWithCallback(info5, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info5, data, onResult) {
        if (typeof data === "string") {
          if (!info5.options.headers) {
            info5.options.headers = {};
          }
          info5.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info5.httpModule.request(info5.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info5.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm2.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info5 = {};
        info5.parsedUrl = requestUrl;
        const usingSsl = info5.parsedUrl.protocol === "https:";
        info5.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info5.options = {};
        info5.options.host = info5.parsedUrl.hostname;
        info5.options.port = info5.parsedUrl.port ? parseInt(info5.parsedUrl.port) : defaultPort;
        info5.options.path = (info5.parsedUrl.pathname || "") + (info5.parsedUrl.search || "");
        info5.options.method = method;
        info5.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info5.options.headers["user-agent"] = this.userAgent;
        }
        info5.options.agent = this._getAgent(info5.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info5.options);
          }
        }
        return info5;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm2.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (!useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (!agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve5) => setTimeout(() => resolve5(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve5, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve5(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve5(response);
            }
          }));
        });
      }
    };
    exports2.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  }
});

// ../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/auth.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error4) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error4.statusCode}
 
        Error Message: ${error4.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            (0, core_1.debug)(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            (0, core_1.setSecret)(id_token);
            return id_token;
          } catch (error4) {
            throw new Error(`Error message: ${error4.message}`);
          }
        });
      }
    };
    exports2.OidcClient = OidcClient;
  }
});

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.summary = exports2.markdownSummary = exports2.SUMMARY_DOCS_URL = exports2.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os");
    var fs_1 = require("fs");
    var { access, appendFile, writeFile: writeFile3 } = fs_1.promises;
    exports2.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports2.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports2.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports2.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile3 : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports2.markdownSummary = _summary;
    exports2.summary = _summary;
  }
});

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = void 0;
    var path17 = __importStar(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports2.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports2.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path17.sep);
    }
    exports2.toPlatformPath = toPlatformPath;
  }
});

// ../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCmdPath = exports2.tryGetExecutablePath = exports2.isRooted = exports2.isDirectory = exports2.exists = exports2.READONLY = exports2.UV_FS_O_EXLOCK = exports2.IS_WINDOWS = exports2.unlink = exports2.symlink = exports2.stat = exports2.rmdir = exports2.rm = exports2.rename = exports2.readlink = exports2.readdir = exports2.open = exports2.mkdir = exports2.lstat = exports2.copyFile = exports2.chmod = void 0;
    var fs6 = __importStar(require("fs"));
    var path17 = __importStar(require("path"));
    _a = fs6.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.open = _a.open, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rm = _a.rm, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
    exports2.IS_WINDOWS = process.platform === "win32";
    exports2.UV_FS_O_EXLOCK = 268435456;
    exports2.READONLY = fs6.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports2.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports2.exists = exists;
    function isDirectory2(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats2 = useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath);
        return stats2.isDirectory();
      });
    }
    exports2.isDirectory = isDirectory2;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports2.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports2.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats2 = void 0;
        try {
          stats2 = yield exports2.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats2 && stats2.isFile()) {
          if (exports2.IS_WINDOWS) {
            const upperExt = path17.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats2)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats2 = void 0;
          try {
            stats2 = yield exports2.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats2 && stats2.isFile()) {
            if (exports2.IS_WINDOWS) {
              try {
                const directory = path17.dirname(filePath);
                const upperName = path17.basename(filePath).toUpperCase();
                for (const actualName of yield exports2.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path17.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats2)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports2.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports2.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats2) {
      return (stats2.mode & 1) > 0 || (stats2.mode & 8) > 0 && stats2.gid === process.getgid() || (stats2.mode & 64) > 0 && stats2.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports2.getCmdPath = getCmdPath;
  }
});

// ../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findInPath = exports2.which = exports2.mkdirP = exports2.rmRF = exports2.mv = exports2.cp = void 0;
    var assert_1 = require("assert");
    var path17 = __importStar(require("path"));
    var ioUtil = __importStar(require_io_util());
    function cp(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path17.join(dest, path17.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path17.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports2.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path17.join(dest, path17.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path17.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports2.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
        }
        try {
          yield ioUtil.rm(inputPath, {
            force: true,
            maxRetries: 3,
            recursive: true,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports2.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports2.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports2.which = which;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path17.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path17.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p of process.env.PATH.split(path17.delimiter)) {
            if (p) {
              directories.push(p);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path17.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports2.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e) {
            if (e.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// ../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argStringToArray = exports2.ToolRunner = void 0;
    var os6 = __importStar(require("os"));
    var events = __importStar(require("events"));
    var child = __importStar(require("child_process"));
    var path17 = __importStar(require("path"));
    var io = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var timers_1 = require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString();
          let n = s.indexOf(os6.EOL);
          while (n > -1) {
            const line = s.substring(0, n);
            onLine(line);
            s = s.substring(n + os6.EOL.length);
            n = s.indexOf(os6.EOL);
          }
          return s;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x) => x === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path17.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io.which(this.toolPath, true);
          return new Promise((resolve5, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os6.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp.stdout) {
              cp.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp.stderr) {
              cp.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error4, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp.removeAllListeners();
              if (error4) {
                reject(error4);
              } else {
                resolve5(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp.stdin) {
                throw new Error("child process missing stdin");
              }
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports2.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c) {
        if (escaped && c !== '"') {
          arg += "\\";
        }
        arg += c;
        escaped = false;
      }
      for (let i = 0; i < argString.length; i++) {
        const c = argString.charAt(i);
        if (c === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c);
          }
          continue;
        }
        if (c === "\\" && escaped) {
          append(c);
          continue;
        }
        if (c === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports2.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error4;
        if (this.processExited) {
          if (this.processError) {
            error4 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error4 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error4 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error4, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// ../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExecOutput = exports2.exec = void 0;
    var string_decoder_1 = require("string_decoder");
    var tr = __importStar(require_toolrunner());
    function exec2(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports2.exec = exec2;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec2(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports2.getExecOutput = getExecOutput;
  }
});

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDetails = exports2.isLinux = exports2.isMacOS = exports2.isWindows = exports2.arch = exports2.platform = void 0;
    var os_1 = __importDefault(require("os"));
    var exec2 = __importStar(require_exec());
    var getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout: version3 } = yield exec2.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: true
      });
      const { stdout: name2 } = yield exec2.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: true
      });
      return {
        name: name2.trim(),
        version: version3.trim()
      };
    });
    var getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { stdout } = yield exec2.getExecOutput("sw_vers", void 0, {
        silent: true
      });
      const version3 = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      const name2 = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
      return {
        name: name2,
        version: version3
      };
    });
    var getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout } = yield exec2.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: true
      });
      const [name2, version3] = stdout.trim().split("\n");
      return {
        name: name2,
        version: version3
      };
    });
    exports2.platform = os_1.default.platform();
    exports2.arch = os_1.default.arch();
    exports2.isWindows = exports2.platform === "win32";
    exports2.isMacOS = exports2.platform === "darwin";
    exports2.isLinux = exports2.platform === "linux";
    function getDetails() {
      return __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports2.isWindows ? getWindowsInfo() : exports2.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
          platform: exports2.platform,
          arch: exports2.arch,
          isWindows: exports2.isWindows,
          isMacOS: exports2.isMacOS,
          isLinux: exports2.isLinux
        });
      });
    }
    exports2.getDetails = getDetails;
  }
});

// ../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P || (P = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.platform = exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = exports2.markdownSummary = exports2.summary = exports2.getIDToken = exports2.getState = exports2.saveState = exports2.group = exports2.endGroup = exports2.startGroup = exports2.info = exports2.notice = exports2.warning = exports2.error = exports2.debug = exports2.isDebug = exports2.setFailed = exports2.setCommandEcho = exports2.setOutput = exports2.getBooleanInput = exports2.getMultilineInput = exports2.getInput = exports2.addPath = exports2.setSecret = exports2.exportVariable = exports2.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os6 = __importStar(require("os"));
    var path17 = __importStar(require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode || (exports2.ExitCode = ExitCode = {}));
    function exportVariable(name2, val) {
      const convertedVal = (0, utils_1.toCommandValue)(val);
      process.env[name2] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name2, val));
      }
      (0, command_1.issueCommand)("set-env", { name: name2 }, convertedVal);
    }
    exports2.exportVariable = exportVariable;
    function setSecret(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports2.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        (0, file_command_1.issueFileCommand)("PATH", inputPath);
      } else {
        (0, command_1.issueCommand)("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path17.delimiter}${process.env["PATH"]}`;
    }
    exports2.addPath = addPath;
    function getInput2(name2, options) {
      const val = process.env[`INPUT_${name2.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name2}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports2.getInput = getInput2;
    function getMultilineInput(name2, options) {
      const inputs = getInput2(name2, options).split("\n").filter((x) => x !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports2.getMultilineInput = getMultilineInput;
    function getBooleanInput(name2, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput2(name2, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name2}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports2.getBooleanInput = getBooleanInput;
    function setOutput2(name2, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name2, value));
      }
      process.stdout.write(os6.EOL);
      (0, command_1.issueCommand)("set-output", { name: name2 }, (0, utils_1.toCommandValue)(value));
    }
    exports2.setOutput = setOutput2;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports2.setCommandEcho = setCommandEcho;
    function setFailed3(message) {
      process.exitCode = ExitCode.Failure;
      error4(message);
    }
    exports2.setFailed = setFailed3;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports2.isDebug = isDebug;
    function debug5(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports2.debug = debug5;
    function error4(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.error = error4;
    function warning4(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.warning = warning4;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.notice = notice;
    function info5(message) {
      process.stdout.write(message + os6.EOL);
    }
    exports2.info = info5;
    function startGroup(name2) {
      (0, command_1.issue)("group", name2);
    }
    exports2.startGroup = startGroup;
    function endGroup() {
      (0, command_1.issue)("endgroup");
    }
    exports2.endGroup = endGroup;
    function group(name2, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name2);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports2.group = group;
    function saveState(name2, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name2, value));
      }
      (0, command_1.issueCommand)("save-state", { name: name2 }, (0, utils_1.toCommandValue)(value));
    }
    exports2.saveState = saveState;
    function getState(name2) {
      return process.env[`STATE_${name2}`] || "";
    }
    exports2.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports2.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports2, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports2, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports2, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports2, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports2, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports2.platform = __importStar(require_platform());
  }
});

// ../node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/context.js
var require_context = __commonJS({
  "../node_modules/.pnpm/@actions+github@6.0.1/node_modules/@actions/github/lib/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Context = void 0;
    var fs_1 = require("fs");
    var os_1 = require("os");
    var Context2 = class {
      /**
       * Hydrate the context from the environment
       */
      constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
          if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
            this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
          } else {
            const path17 = process.env.GITHUB_EVENT_PATH;
            process.stdout.write(`GITHUB_EVENT_PATH ${path17} does not exist${os_1.EOL}`);
          }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
      }
      get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
      }
      get repo() {
        if (process.env.GITHUB_REPOSITORY) {
          const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
          return { owner, repo };
        }
        if (this.payload.repository) {
          return {
            owner: this.payload.repository.owner.login,
            repo: this.payload.repository.name
          };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
      }
    };
    exports2.Context = Context2;
  }
});

// ../node_modules/.pnpm/@cspell+cspell-resolver@9.1.5/node_modules/@cspell/cspell-resolver/dist/requireResolve.js
var require_requireResolve = __commonJS({
  "../node_modules/.pnpm/@cspell+cspell-resolver@9.1.5/node_modules/@cspell/cspell-resolver/dist/requireResolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.requireResolve = requireResolve2;
    function requireResolve2(filename, paths) {
      try {
        return require.resolve(filename, paths ? { paths } : void 0);
      } catch {
        return void 0;
      }
    }
  }
});

// ../node_modules/.pnpm/ini@4.1.1/node_modules/ini/lib/ini.js
var require_ini = __commonJS({
  "../node_modules/.pnpm/ini@4.1.1/node_modules/ini/lib/ini.js"(exports2, module2) {
    var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
    var encode = (obj, opt = {}) => {
      if (typeof opt === "string") {
        opt = { section: opt };
      }
      opt.align = opt.align === true;
      opt.newline = opt.newline === true;
      opt.sort = opt.sort === true;
      opt.whitespace = opt.whitespace === true || opt.align === true;
      opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
      opt.bracketedArray = opt.bracketedArray !== false;
      const eol = opt.platform === "win32" ? "\r\n" : "\n";
      const separator = opt.whitespace ? " = " : "=";
      const children = [];
      const keys3 = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
      let padToChars = 0;
      if (opt.align) {
        padToChars = safe(
          keys3.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)
        ).length;
      }
      let out = "";
      const arraySuffix = opt.bracketedArray ? "[]" : "";
      for (const k of keys3) {
        const val = obj[k];
        if (val && Array.isArray(val)) {
          for (const item of val) {
            out += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol;
          }
        } else if (val && typeof val === "object") {
          children.push(k);
        } else {
          out += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol;
        }
      }
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + (opt.newline ? eol + eol : eol) + out;
      }
      for (const k of children) {
        const nk = splitSections(k, ".").join("\\.");
        const section = (opt.section ? opt.section + "." : "") + nk;
        const child = encode(obj[k], {
          ...opt,
          section
        });
        if (out.length && child.length) {
          out += eol;
        }
        out += child;
      }
      return out;
    };
    function splitSections(str, separator) {
      var lastMatchIndex = 0;
      var lastSeparatorIndex = 0;
      var nextIndex = 0;
      var sections = [];
      do {
        nextIndex = str.indexOf(separator, lastMatchIndex);
        if (nextIndex !== -1) {
          lastMatchIndex = nextIndex + separator.length;
          if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
            continue;
          }
          sections.push(str.slice(lastSeparatorIndex, nextIndex));
          lastSeparatorIndex = nextIndex + separator.length;
        }
      } while (nextIndex !== -1);
      sections.push(str.slice(lastSeparatorIndex));
      return sections;
    }
    var decode2 = (str, opt = {}) => {
      opt.bracketedArray = opt.bracketedArray !== false;
      const out = /* @__PURE__ */ Object.create(null);
      let p = out;
      let section = null;
      const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
      const lines = str.split(/[\r\n]+/g);
      const duplicates = {};
      for (const line of lines) {
        if (!line || line.match(/^\s*[;#]/) || line.match(/^\s*$/)) {
          continue;
        }
        const match2 = line.match(re);
        if (!match2) {
          continue;
        }
        if (match2[1] !== void 0) {
          section = unsafe(match2[1]);
          if (section === "__proto__") {
            p = /* @__PURE__ */ Object.create(null);
            continue;
          }
          p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
          continue;
        }
        const keyRaw = unsafe(match2[2]);
        let isArray3;
        if (opt.bracketedArray) {
          isArray3 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
        } else {
          duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
          isArray3 = duplicates[keyRaw] > 1;
        }
        const key = isArray3 ? keyRaw.slice(0, -2) : keyRaw;
        if (key === "__proto__") {
          continue;
        }
        const valueRaw = match2[3] ? unsafe(match2[4]) : true;
        const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
        if (isArray3) {
          if (!hasOwnProperty4.call(p, key)) {
            p[key] = [];
          } else if (!Array.isArray(p[key])) {
            p[key] = [p[key]];
          }
        }
        if (Array.isArray(p[key])) {
          p[key].push(value);
        } else {
          p[key] = value;
        }
      }
      const remove = [];
      for (const k of Object.keys(out)) {
        if (!hasOwnProperty4.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k])) {
          continue;
        }
        const parts = splitSections(k, ".");
        p = out;
        const l = parts.pop();
        const nl = l.replace(/\\\./g, ".");
        for (const part of parts) {
          if (part === "__proto__") {
            continue;
          }
          if (!hasOwnProperty4.call(p, part) || typeof p[part] !== "object") {
            p[part] = /* @__PURE__ */ Object.create(null);
          }
          p = p[part];
        }
        if (p === out && nl === l) {
          continue;
        }
        p[nl] = out[k];
        remove.push(k);
      }
      for (const del of remove) {
        delete out[del];
      }
      return out;
    };
    var isQuoted = (val) => {
      return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
    };
    var safe = (val) => {
      if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
        return JSON.stringify(val);
      }
      return val.split(";").join("\\;").split("#").join("\\#");
    };
    var unsafe = (val, doUnesc) => {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") {
          val = val.slice(1, -1);
        }
        try {
          val = JSON.parse(val);
        } catch {
        }
      } else {
        let esc = false;
        let unesc = "";
        for (let i = 0, l = val.length; i < l; i++) {
          const c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1) {
              unesc += c;
            } else {
              unesc += "\\" + c;
            }
            esc = false;
          } else if (";#".indexOf(c) !== -1) {
            break;
          } else if (c === "\\") {
            esc = true;
          } else {
            unesc += c;
          }
        }
        if (esc) {
          unesc += "\\";
        }
        return unesc.trim();
      }
      return val;
    };
    module2.exports = {
      parse: decode2,
      decode: decode2,
      stringify: encode,
      encode,
      safe,
      unsafe
    };
  }
});

// ../node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "../node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js"(exports2, module2) {
    "use strict";
    var path17 = require("path");
    var Module = require("module");
    var fs6 = require("fs");
    var resolveFrom2 = (fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs6.realpathSync(fromDirectory);
      } catch (error4) {
        if (error4.code === "ENOENT") {
          fromDirectory = path17.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error4;
        }
      }
      const fromFile = path17.join(fromDirectory, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error4) {
          return;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId);
    module2.exports.silent = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId, true);
  }
});

// ../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/constants.js
var require_constants6 = __commonJS({
  "../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS({
  "../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants6();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
        return match2 === "\\" ? "" : match2;
      });
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx2 = input.lastIndexOf(char, lastIdx);
      if (idx2 === -1) return input;
      if (input[idx2 - 1] === "\\") return exports2.escapeLast(input, char, idx2 - 1);
      return `${input.slice(0, idx2)}\\${input.slice(idx2)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports2.basename = (path17, { windows: windows2 } = {}) => {
      const segs = path17.split(windows2 ? /[\\/]/ : "/");
      const last = segs[segs.length - 1];
      if (last === "") {
        return segs[segs.length - 2];
      }
      return last;
    };
  }
});

// ../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants6();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan3 = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob2 = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2) glob2 = utils.removeBackslashes(glob2);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx2 = 0; idx2 < slashes.length; idx2++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx2];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx2 === 0 && start !== 0) {
              tokens[idx2].isPrefix = true;
              tokens[idx2].value = prefix;
            } else {
              tokens[idx2].value = value;
            }
            depth(tokens[idx2]);
            state.maxDepth += tokens[idx2].depth;
          }
          if (idx2 !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan3;
  }
});

// ../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants6();
    var utils = require_utils3();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange2 = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants.globChars(opts.windows);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count3 = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count3++;
        }
        if (count3 % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse3(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first3, rest, index) => {
          if (first3 === "\\") {
            backslashes = true;
            return m;
          }
          if (first3 === "?") {
            if (esc) {
              return esc + first3 + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first3 === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first3 === "*") {
            if (esc) {
              return esc + first3 + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx2 = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx2);
                const rest2 = prev.value.slice(idx2 + 2);
                const posix4 = POSIX_REGEX_SOURCE[rest2];
                if (posix4) {
                  prev.value = pre + posix4;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange2(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2) return;
            const source2 = create(match2[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match2[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse3;
  }
});

// ../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var scan3 = require_scan();
    var parse3 = require_parse2();
    var utils = require_utils3();
    var constants = require_constants6();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob2, options, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch2(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix4 = opts.windows;
      const regex = isState ? picomatch2.compileRe(glob2, options) : picomatch2.makeRe(glob2, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match2, output } = picomatch2.test(input, regex, options, { glob: glob2, posix: posix4 });
        const result = { glob: glob2, state, regex, posix: posix4, input, output, match: match2, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch2.test = (input, regex, options, { glob: glob2, posix: posix4 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format4 = opts.format || (posix4 ? utils.toPosixSlashes : null);
      let match2 = input === glob2;
      let output = match2 && format4 ? format4(input) : input;
      if (match2 === false) {
        output = format4 ? format4(input) : input;
        match2 = output === glob2;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch2.matchBase(input, regex, options, posix4);
        } else {
          match2 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch2.matchBase = (input, glob2, options) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch2.makeRe(glob2, options);
      return regex.test(utils.basename(input));
    };
    picomatch2.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
    picomatch2.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch2.parse(p, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch2.scan = (input, options) => scan3(input, options);
    picomatch2.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch2.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch2.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch2.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch2.constants = constants;
    module2.exports = picomatch2;
  }
});

// ../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    var pico = require_picomatch();
    var utils = require_utils3();
    function picomatch2(glob2, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob2, options, returnState);
    }
    Object.assign(picomatch2, pico);
    module2.exports = picomatch2;
  }
});

// ../node_modules/.pnpm/esprima@4.0.1/node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS({
  "../node_modules/.pnpm/esprima@4.0.1/node_modules/esprima/dist/esprima.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports2 === "object")
        exports2["esprima"] = factory();
      else
        root["esprima"] = factory();
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module3 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.loaded = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var comment_handler_1 = __webpack_require__(1);
            var jsx_parser_1 = __webpack_require__(3);
            var parser_1 = __webpack_require__(8);
            var tokenizer_1 = __webpack_require__(15);
            function parse3(code, options, delegate) {
              var commentHandler = null;
              var proxyDelegate = function(node, metadata) {
                if (delegate) {
                  delegate(node, metadata);
                }
                if (commentHandler) {
                  commentHandler.visit(node, metadata);
                }
              };
              var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
              var collectComment = false;
              if (options) {
                collectComment = typeof options.comment === "boolean" && options.comment;
                var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
                if (collectComment || attachComment) {
                  commentHandler = new comment_handler_1.CommentHandler();
                  commentHandler.attach = attachComment;
                  options.comment = true;
                  parserDelegate = proxyDelegate;
                }
              }
              var isModule = false;
              if (options && typeof options.sourceType === "string") {
                isModule = options.sourceType === "module";
              }
              var parser2;
              if (options && typeof options.jsx === "boolean" && options.jsx) {
                parser2 = new jsx_parser_1.JSXParser(code, options, parserDelegate);
              } else {
                parser2 = new parser_1.Parser(code, options, parserDelegate);
              }
              var program = isModule ? parser2.parseModule() : parser2.parseScript();
              var ast = program;
              if (collectComment && commentHandler) {
                ast.comments = commentHandler.comments;
              }
              if (parser2.config.tokens) {
                ast.tokens = parser2.tokens;
              }
              if (parser2.config.tolerant) {
                ast.errors = parser2.errorHandler.errors;
              }
              return ast;
            }
            exports3.parse = parse3;
            function parseModule(code, options, delegate) {
              var parsingOptions = options || {};
              parsingOptions.sourceType = "module";
              return parse3(code, parsingOptions, delegate);
            }
            exports3.parseModule = parseModule;
            function parseScript(code, options, delegate) {
              var parsingOptions = options || {};
              parsingOptions.sourceType = "script";
              return parse3(code, parsingOptions, delegate);
            }
            exports3.parseScript = parseScript;
            function tokenize(code, options, delegate) {
              var tokenizer = new tokenizer_1.Tokenizer(code, options);
              var tokens;
              tokens = [];
              try {
                while (true) {
                  var token = tokenizer.getNextToken();
                  if (!token) {
                    break;
                  }
                  if (delegate) {
                    token = delegate(token);
                  }
                  tokens.push(token);
                }
              } catch (e) {
                tokenizer.errorHandler.tolerate(e);
              }
              if (tokenizer.errorHandler.tolerant) {
                tokens.errors = tokenizer.errors();
              }
              return tokens;
            }
            exports3.tokenize = tokenize;
            var syntax_1 = __webpack_require__(2);
            exports3.Syntax = syntax_1.Syntax;
            exports3.version = "4.0.1";
          },
          /* 1 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var syntax_1 = __webpack_require__(2);
            var CommentHandler = function() {
              function CommentHandler2() {
                this.attach = false;
                this.comments = [];
                this.stack = [];
                this.leading = [];
                this.trailing = [];
              }
              CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
                if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                  var innerComments = [];
                  for (var i = this.leading.length - 1; i >= 0; --i) {
                    var entry = this.leading[i];
                    if (metadata.end.offset >= entry.start) {
                      innerComments.unshift(entry.comment);
                      this.leading.splice(i, 1);
                      this.trailing.splice(i, 1);
                    }
                  }
                  if (innerComments.length) {
                    node.innerComments = innerComments;
                  }
                }
              };
              CommentHandler2.prototype.findTrailingComments = function(metadata) {
                var trailingComments = [];
                if (this.trailing.length > 0) {
                  for (var i = this.trailing.length - 1; i >= 0; --i) {
                    var entry_1 = this.trailing[i];
                    if (entry_1.start >= metadata.end.offset) {
                      trailingComments.unshift(entry_1.comment);
                    }
                  }
                  this.trailing.length = 0;
                  return trailingComments;
                }
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.node.trailingComments) {
                  var firstComment = entry.node.trailingComments[0];
                  if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                    trailingComments = entry.node.trailingComments;
                    delete entry.node.trailingComments;
                  }
                }
                return trailingComments;
              };
              CommentHandler2.prototype.findLeadingComments = function(metadata) {
                var leadingComments = [];
                var target;
                while (this.stack.length > 0) {
                  var entry = this.stack[this.stack.length - 1];
                  if (entry && entry.start >= metadata.start.offset) {
                    target = entry.node;
                    this.stack.pop();
                  } else {
                    break;
                  }
                }
                if (target) {
                  var count3 = target.leadingComments ? target.leadingComments.length : 0;
                  for (var i = count3 - 1; i >= 0; --i) {
                    var comment = target.leadingComments[i];
                    if (comment.range[1] <= metadata.start.offset) {
                      leadingComments.unshift(comment);
                      target.leadingComments.splice(i, 1);
                    }
                  }
                  if (target.leadingComments && target.leadingComments.length === 0) {
                    delete target.leadingComments;
                  }
                  return leadingComments;
                }
                for (var i = this.leading.length - 1; i >= 0; --i) {
                  var entry = this.leading[i];
                  if (entry.start <= metadata.start.offset) {
                    leadingComments.unshift(entry.comment);
                    this.leading.splice(i, 1);
                  }
                }
                return leadingComments;
              };
              CommentHandler2.prototype.visitNode = function(node, metadata) {
                if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                  return;
                }
                this.insertInnerComments(node, metadata);
                var trailingComments = this.findTrailingComments(metadata);
                var leadingComments = this.findLeadingComments(metadata);
                if (leadingComments.length > 0) {
                  node.leadingComments = leadingComments;
                }
                if (trailingComments.length > 0) {
                  node.trailingComments = trailingComments;
                }
                this.stack.push({
                  node,
                  start: metadata.start.offset
                });
              };
              CommentHandler2.prototype.visitComment = function(node, metadata) {
                var type = node.type[0] === "L" ? "Line" : "Block";
                var comment = {
                  type,
                  value: node.value
                };
                if (node.range) {
                  comment.range = node.range;
                }
                if (node.loc) {
                  comment.loc = node.loc;
                }
                this.comments.push(comment);
                if (this.attach) {
                  var entry = {
                    comment: {
                      type,
                      value: node.value,
                      range: [metadata.start.offset, metadata.end.offset]
                    },
                    start: metadata.start.offset
                  };
                  if (node.loc) {
                    entry.comment.loc = node.loc;
                  }
                  node.type = type;
                  this.leading.push(entry);
                  this.trailing.push(entry);
                }
              };
              CommentHandler2.prototype.visit = function(node, metadata) {
                if (node.type === "LineComment") {
                  this.visitComment(node, metadata);
                } else if (node.type === "BlockComment") {
                  this.visitComment(node, metadata);
                } else if (this.attach) {
                  this.visitNode(node, metadata);
                }
              };
              return CommentHandler2;
            }();
            exports3.CommentHandler = CommentHandler;
          },
          /* 2 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.Syntax = {
              AssignmentExpression: "AssignmentExpression",
              AssignmentPattern: "AssignmentPattern",
              ArrayExpression: "ArrayExpression",
              ArrayPattern: "ArrayPattern",
              ArrowFunctionExpression: "ArrowFunctionExpression",
              AwaitExpression: "AwaitExpression",
              BlockStatement: "BlockStatement",
              BinaryExpression: "BinaryExpression",
              BreakStatement: "BreakStatement",
              CallExpression: "CallExpression",
              CatchClause: "CatchClause",
              ClassBody: "ClassBody",
              ClassDeclaration: "ClassDeclaration",
              ClassExpression: "ClassExpression",
              ConditionalExpression: "ConditionalExpression",
              ContinueStatement: "ContinueStatement",
              DoWhileStatement: "DoWhileStatement",
              DebuggerStatement: "DebuggerStatement",
              EmptyStatement: "EmptyStatement",
              ExportAllDeclaration: "ExportAllDeclaration",
              ExportDefaultDeclaration: "ExportDefaultDeclaration",
              ExportNamedDeclaration: "ExportNamedDeclaration",
              ExportSpecifier: "ExportSpecifier",
              ExpressionStatement: "ExpressionStatement",
              ForStatement: "ForStatement",
              ForOfStatement: "ForOfStatement",
              ForInStatement: "ForInStatement",
              FunctionDeclaration: "FunctionDeclaration",
              FunctionExpression: "FunctionExpression",
              Identifier: "Identifier",
              IfStatement: "IfStatement",
              ImportDeclaration: "ImportDeclaration",
              ImportDefaultSpecifier: "ImportDefaultSpecifier",
              ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
              ImportSpecifier: "ImportSpecifier",
              Literal: "Literal",
              LabeledStatement: "LabeledStatement",
              LogicalExpression: "LogicalExpression",
              MemberExpression: "MemberExpression",
              MetaProperty: "MetaProperty",
              MethodDefinition: "MethodDefinition",
              NewExpression: "NewExpression",
              ObjectExpression: "ObjectExpression",
              ObjectPattern: "ObjectPattern",
              Program: "Program",
              Property: "Property",
              RestElement: "RestElement",
              ReturnStatement: "ReturnStatement",
              SequenceExpression: "SequenceExpression",
              SpreadElement: "SpreadElement",
              Super: "Super",
              SwitchCase: "SwitchCase",
              SwitchStatement: "SwitchStatement",
              TaggedTemplateExpression: "TaggedTemplateExpression",
              TemplateElement: "TemplateElement",
              TemplateLiteral: "TemplateLiteral",
              ThisExpression: "ThisExpression",
              ThrowStatement: "ThrowStatement",
              TryStatement: "TryStatement",
              UnaryExpression: "UnaryExpression",
              UpdateExpression: "UpdateExpression",
              VariableDeclaration: "VariableDeclaration",
              VariableDeclarator: "VariableDeclarator",
              WhileStatement: "WhileStatement",
              WithStatement: "WithStatement",
              YieldExpression: "YieldExpression"
            };
          },
          /* 3 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var __extends = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports3, "__esModule", { value: true });
            var character_1 = __webpack_require__(4);
            var JSXNode = __webpack_require__(5);
            var jsx_syntax_1 = __webpack_require__(6);
            var Node = __webpack_require__(7);
            var parser_1 = __webpack_require__(8);
            var token_1 = __webpack_require__(13);
            var xhtml_entities_1 = __webpack_require__(14);
            token_1.TokenName[
              100
              /* Identifier */
            ] = "JSXIdentifier";
            token_1.TokenName[
              101
              /* Text */
            ] = "JSXText";
            function getQualifiedElementName(elementName) {
              var qualifiedName;
              switch (elementName.type) {
                case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                  var id = elementName;
                  qualifiedName = id.name;
                  break;
                case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                  var ns = elementName;
                  qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                  break;
                case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                  var expr = elementName;
                  qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                  break;
                /* istanbul ignore next */
                default:
                  break;
              }
              return qualifiedName;
            }
            var JSXParser = function(_super) {
              __extends(JSXParser2, _super);
              function JSXParser2(code, options, delegate) {
                return _super.call(this, code, options, delegate) || this;
              }
              JSXParser2.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
              };
              JSXParser2.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index;
                this.scanner.lineNumber = this.startMarker.line;
                this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              };
              JSXParser2.prototype.finishJSX = function() {
                this.nextToken();
              };
              JSXParser2.prototype.reenterJSX = function() {
                this.startJSX();
                this.expectJSX("}");
                if (this.config.tokens) {
                  this.tokens.pop();
                }
              };
              JSXParser2.prototype.createJSXNode = function() {
                this.collectComments();
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              };
              JSXParser2.prototype.createJSXChildNode = function() {
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              };
              JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                var result = "&";
                var valid = true;
                var terminated = false;
                var numeric = false;
                var hex = false;
                while (!this.scanner.eof() && valid && !terminated) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === quote) {
                    break;
                  }
                  terminated = ch === ";";
                  result += ch;
                  ++this.scanner.index;
                  if (!terminated) {
                    switch (result.length) {
                      case 2:
                        numeric = ch === "#";
                        break;
                      case 3:
                        if (numeric) {
                          hex = ch === "x";
                          valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                          numeric = numeric && !hex;
                        }
                        break;
                      default:
                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                        break;
                    }
                  }
                }
                if (valid && terminated && result.length > 2) {
                  var str = result.substr(1, result.length - 2);
                  if (numeric && str.length > 1) {
                    result = String.fromCharCode(parseInt(str.substr(1), 10));
                  } else if (hex && str.length > 2) {
                    result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                  } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                    result = xhtml_entities_1.XHTMLEntities[str];
                  }
                }
                return result;
              };
              JSXParser2.prototype.lexJSX = function() {
                var cp = this.scanner.source.charCodeAt(this.scanner.index);
                if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                  var value = this.scanner.source[this.scanner.index++];
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index - 1,
                    end: this.scanner.index
                  };
                }
                if (cp === 34 || cp === 39) {
                  var start = this.scanner.index;
                  var quote = this.scanner.source[this.scanner.index++];
                  var str = "";
                  while (!this.scanner.eof()) {
                    var ch = this.scanner.source[this.scanner.index++];
                    if (ch === quote) {
                      break;
                    } else if (ch === "&") {
                      str += this.scanXHTMLEntity(quote);
                    } else {
                      str += ch;
                    }
                  }
                  return {
                    type: 8,
                    value: str,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 46) {
                  var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                  var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                  var value = n1 === 46 && n2 === 46 ? "..." : ".";
                  var start = this.scanner.index;
                  this.scanner.index += value.length;
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 96) {
                  return {
                    type: 10,
                    value: "",
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index,
                    end: this.scanner.index
                  };
                }
                if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                  var start = this.scanner.index;
                  ++this.scanner.index;
                  while (!this.scanner.eof()) {
                    var ch = this.scanner.source.charCodeAt(this.scanner.index);
                    if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                      ++this.scanner.index;
                    } else if (ch === 45) {
                      ++this.scanner.index;
                    } else {
                      break;
                    }
                  }
                  var id = this.scanner.source.slice(start, this.scanner.index);
                  return {
                    type: 100,
                    value: id,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                return this.scanner.lex();
              };
              JSXParser2.prototype.nextJSXToken = function() {
                this.collectComments();
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var token = this.lexJSX();
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                if (this.config.tokens) {
                  this.tokens.push(this.convertToken(token));
                }
                return token;
              };
              JSXParser2.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var start = this.scanner.index;
                var text = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === "{" || ch === "<") {
                    break;
                  }
                  ++this.scanner.index;
                  text += ch;
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    ++this.scanner.lineNumber;
                    if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                      ++this.scanner.index;
                    }
                    this.scanner.lineStart = this.scanner.index;
                  }
                }
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var token = {
                  type: 101,
                  value: text,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
                if (text.length > 0 && this.config.tokens) {
                  this.tokens.push(this.convertToken(token));
                }
                return token;
              };
              JSXParser2.prototype.peekJSXToken = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.lexJSX();
                this.scanner.restoreState(state);
                return next;
              };
              JSXParser2.prototype.expectJSX = function(value) {
                var token = this.nextJSXToken();
                if (token.type !== 7 || token.value !== value) {
                  this.throwUnexpectedToken(token);
                }
              };
              JSXParser2.prototype.matchJSX = function(value) {
                var next = this.peekJSXToken();
                return next.type === 7 && next.value === value;
              };
              JSXParser2.prototype.parseJSXIdentifier = function() {
                var node = this.createJSXNode();
                var token = this.nextJSXToken();
                if (token.type !== 100) {
                  this.throwUnexpectedToken(token);
                }
                return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
              };
              JSXParser2.prototype.parseJSXElementName = function() {
                var node = this.createJSXNode();
                var elementName = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = elementName;
                  this.expectJSX(":");
                  var name_1 = this.parseJSXIdentifier();
                  elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
                } else if (this.matchJSX(".")) {
                  while (this.matchJSX(".")) {
                    var object = elementName;
                    this.expectJSX(".");
                    var property = this.parseJSXIdentifier();
                    elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                  }
                }
                return elementName;
              };
              JSXParser2.prototype.parseJSXAttributeName = function() {
                var node = this.createJSXNode();
                var attributeName;
                var identifier = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = identifier;
                  this.expectJSX(":");
                  var name_2 = this.parseJSXIdentifier();
                  attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
                } else {
                  attributeName = identifier;
                }
                return attributeName;
              };
              JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                var node = this.createJSXNode();
                var token = this.nextJSXToken();
                if (token.type !== 8) {
                  this.throwUnexpectedToken(token);
                }
                var raw = this.getTokenRaw(token);
                return this.finalize(node, new Node.Literal(token.value, raw));
              };
              JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                this.finishJSX();
                if (this.match("}")) {
                  this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                }
                var expression = this.parseAssignmentExpression();
                this.reenterJSX();
                return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              };
              JSXParser2.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              };
              JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                var node = this.createJSXNode();
                var name2 = this.parseJSXAttributeName();
                var value = null;
                if (this.matchJSX("=")) {
                  this.expectJSX("=");
                  value = this.parseJSXAttributeValue();
                }
                return this.finalize(node, new JSXNode.JSXAttribute(name2, value));
              };
              JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                this.expectJSX("...");
                this.finishJSX();
                var argument = this.parseAssignmentExpression();
                this.reenterJSX();
                return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
              };
              JSXParser2.prototype.parseJSXAttributes = function() {
                var attributes = [];
                while (!this.matchJSX("/") && !this.matchJSX(">")) {
                  var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  attributes.push(attribute);
                }
                return attributes;
              };
              JSXParser2.prototype.parseJSXOpeningElement = function() {
                var node = this.createJSXNode();
                this.expectJSX("<");
                var name2 = this.parseJSXElementName();
                var attributes = this.parseJSXAttributes();
                var selfClosing = this.matchJSX("/");
                if (selfClosing) {
                  this.expectJSX("/");
                }
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
              };
              JSXParser2.prototype.parseJSXBoundaryElement = function() {
                var node = this.createJSXNode();
                this.expectJSX("<");
                if (this.matchJSX("/")) {
                  this.expectJSX("/");
                  var name_3 = this.parseJSXElementName();
                  this.expectJSX(">");
                  return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
                }
                var name2 = this.parseJSXElementName();
                var attributes = this.parseJSXAttributes();
                var selfClosing = this.matchJSX("/");
                if (selfClosing) {
                  this.expectJSX("/");
                }
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
              };
              JSXParser2.prototype.parseJSXEmptyExpression = function() {
                var node = this.createJSXChildNode();
                this.collectComments();
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                return this.finalize(node, new JSXNode.JSXEmptyExpression());
              };
              JSXParser2.prototype.parseJSXExpressionContainer = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                var expression;
                if (this.matchJSX("}")) {
                  expression = this.parseJSXEmptyExpression();
                  this.expectJSX("}");
                } else {
                  this.finishJSX();
                  expression = this.parseAssignmentExpression();
                  this.reenterJSX();
                }
                return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              };
              JSXParser2.prototype.parseJSXChildren = function() {
                var children = [];
                while (!this.scanner.eof()) {
                  var node = this.createJSXChildNode();
                  var token = this.nextJSXText();
                  if (token.start < token.end) {
                    var raw = this.getTokenRaw(token);
                    var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                    children.push(child);
                  }
                  if (this.scanner.source[this.scanner.index] === "{") {
                    var container = this.parseJSXExpressionContainer();
                    children.push(container);
                  } else {
                    break;
                  }
                }
                return children;
              };
              JSXParser2.prototype.parseComplexJSXElement = function(el) {
                var stack = [];
                while (!this.scanner.eof()) {
                  el.children = el.children.concat(this.parseJSXChildren());
                  var node = this.createJSXChildNode();
                  var element = this.parseJSXBoundaryElement();
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                    var opening = element;
                    if (opening.selfClosing) {
                      var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                      el.children.push(child);
                    } else {
                      stack.push(el);
                      el = { node, opening, closing: null, children: [] };
                    }
                  }
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                    el.closing = element;
                    var open_1 = getQualifiedElementName(el.opening.name);
                    var close_1 = getQualifiedElementName(el.closing.name);
                    if (open_1 !== close_1) {
                      this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                    }
                    if (stack.length > 0) {
                      var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                      el = stack[stack.length - 1];
                      el.children.push(child);
                      stack.pop();
                    } else {
                      break;
                    }
                  }
                }
                return el;
              };
              JSXParser2.prototype.parseJSXElement = function() {
                var node = this.createJSXNode();
                var opening = this.parseJSXOpeningElement();
                var children = [];
                var closing = null;
                if (!opening.selfClosing) {
                  var el = this.parseComplexJSXElement({ node, opening, closing, children });
                  children = el.children;
                  closing = el.closing;
                }
                return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
              };
              JSXParser2.prototype.parseJSXRoot = function() {
                if (this.config.tokens) {
                  this.tokens.pop();
                }
                this.startJSX();
                var element = this.parseJSXElement();
                this.finishJSX();
                return element;
              };
              JSXParser2.prototype.isStartOfExpression = function() {
                return _super.prototype.isStartOfExpression.call(this) || this.match("<");
              };
              return JSXParser2;
            }(parser_1.Parser);
            exports3.JSXParser = JSXParser;
          },
          /* 4 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var Regex = {
              // Unicode v8.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
              // Unicode v8.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            exports3.Character = {
              /* tslint:disable:no-bitwise */
              fromCodePoint: function(cp) {
                return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
              },
              // https://tc39.github.io/ecma262/#sec-white-space
              isWhiteSpace: function(cp) {
                return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
              },
              // https://tc39.github.io/ecma262/#sec-line-terminators
              isLineTerminator: function(cp) {
                return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
              },
              // https://tc39.github.io/ecma262/#sec-names-and-keywords
              isIdentifierStart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports3.Character.fromCodePoint(cp));
              },
              isIdentifierPart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports3.Character.fromCodePoint(cp));
              },
              // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
              isDecimalDigit: function(cp) {
                return cp >= 48 && cp <= 57;
              },
              isHexDigit: function(cp) {
                return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
              },
              isOctalDigit: function(cp) {
                return cp >= 48 && cp <= 55;
              }
            };
          },
          /* 5 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var jsx_syntax_1 = __webpack_require__(6);
            var JSXClosingElement = /* @__PURE__ */ function() {
              function JSXClosingElement2(name2) {
                this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                this.name = name2;
              }
              return JSXClosingElement2;
            }();
            exports3.JSXClosingElement = JSXClosingElement;
            var JSXElement = /* @__PURE__ */ function() {
              function JSXElement2(openingElement, children, closingElement) {
                this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                this.openingElement = openingElement;
                this.children = children;
                this.closingElement = closingElement;
              }
              return JSXElement2;
            }();
            exports3.JSXElement = JSXElement;
            var JSXEmptyExpression = /* @__PURE__ */ function() {
              function JSXEmptyExpression2() {
                this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
              }
              return JSXEmptyExpression2;
            }();
            exports3.JSXEmptyExpression = JSXEmptyExpression;
            var JSXExpressionContainer = /* @__PURE__ */ function() {
              function JSXExpressionContainer2(expression) {
                this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                this.expression = expression;
              }
              return JSXExpressionContainer2;
            }();
            exports3.JSXExpressionContainer = JSXExpressionContainer;
            var JSXIdentifier = /* @__PURE__ */ function() {
              function JSXIdentifier2(name2) {
                this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                this.name = name2;
              }
              return JSXIdentifier2;
            }();
            exports3.JSXIdentifier = JSXIdentifier;
            var JSXMemberExpression = /* @__PURE__ */ function() {
              function JSXMemberExpression2(object, property) {
                this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                this.object = object;
                this.property = property;
              }
              return JSXMemberExpression2;
            }();
            exports3.JSXMemberExpression = JSXMemberExpression;
            var JSXAttribute = /* @__PURE__ */ function() {
              function JSXAttribute2(name2, value) {
                this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                this.name = name2;
                this.value = value;
              }
              return JSXAttribute2;
            }();
            exports3.JSXAttribute = JSXAttribute;
            var JSXNamespacedName = /* @__PURE__ */ function() {
              function JSXNamespacedName2(namespace, name2) {
                this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                this.namespace = namespace;
                this.name = name2;
              }
              return JSXNamespacedName2;
            }();
            exports3.JSXNamespacedName = JSXNamespacedName;
            var JSXOpeningElement = /* @__PURE__ */ function() {
              function JSXOpeningElement2(name2, selfClosing, attributes) {
                this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                this.name = name2;
                this.selfClosing = selfClosing;
                this.attributes = attributes;
              }
              return JSXOpeningElement2;
            }();
            exports3.JSXOpeningElement = JSXOpeningElement;
            var JSXSpreadAttribute = /* @__PURE__ */ function() {
              function JSXSpreadAttribute2(argument) {
                this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                this.argument = argument;
              }
              return JSXSpreadAttribute2;
            }();
            exports3.JSXSpreadAttribute = JSXSpreadAttribute;
            var JSXText = /* @__PURE__ */ function() {
              function JSXText2(value, raw) {
                this.type = jsx_syntax_1.JSXSyntax.JSXText;
                this.value = value;
                this.raw = raw;
              }
              return JSXText2;
            }();
            exports3.JSXText = JSXText;
          },
          /* 6 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.JSXSyntax = {
              JSXAttribute: "JSXAttribute",
              JSXClosingElement: "JSXClosingElement",
              JSXElement: "JSXElement",
              JSXEmptyExpression: "JSXEmptyExpression",
              JSXExpressionContainer: "JSXExpressionContainer",
              JSXIdentifier: "JSXIdentifier",
              JSXMemberExpression: "JSXMemberExpression",
              JSXNamespacedName: "JSXNamespacedName",
              JSXOpeningElement: "JSXOpeningElement",
              JSXSpreadAttribute: "JSXSpreadAttribute",
              JSXText: "JSXText"
            };
          },
          /* 7 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var syntax_1 = __webpack_require__(2);
            var ArrayExpression = /* @__PURE__ */ function() {
              function ArrayExpression2(elements) {
                this.type = syntax_1.Syntax.ArrayExpression;
                this.elements = elements;
              }
              return ArrayExpression2;
            }();
            exports3.ArrayExpression = ArrayExpression;
            var ArrayPattern = /* @__PURE__ */ function() {
              function ArrayPattern2(elements) {
                this.type = syntax_1.Syntax.ArrayPattern;
                this.elements = elements;
              }
              return ArrayPattern2;
            }();
            exports3.ArrayPattern = ArrayPattern;
            var ArrowFunctionExpression = /* @__PURE__ */ function() {
              function ArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression;
                this.id = null;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = expression;
                this.async = false;
              }
              return ArrowFunctionExpression2;
            }();
            exports3.ArrowFunctionExpression = ArrowFunctionExpression;
            var AssignmentExpression = /* @__PURE__ */ function() {
              function AssignmentExpression2(operator, left, right) {
                this.type = syntax_1.Syntax.AssignmentExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
              }
              return AssignmentExpression2;
            }();
            exports3.AssignmentExpression = AssignmentExpression;
            var AssignmentPattern = /* @__PURE__ */ function() {
              function AssignmentPattern2(left, right) {
                this.type = syntax_1.Syntax.AssignmentPattern;
                this.left = left;
                this.right = right;
              }
              return AssignmentPattern2;
            }();
            exports3.AssignmentPattern = AssignmentPattern;
            var AsyncArrowFunctionExpression = /* @__PURE__ */ function() {
              function AsyncArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression;
                this.id = null;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = expression;
                this.async = true;
              }
              return AsyncArrowFunctionExpression2;
            }();
            exports3.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
            var AsyncFunctionDeclaration = /* @__PURE__ */ function() {
              function AsyncFunctionDeclaration2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionDeclaration;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = false;
                this.async = true;
              }
              return AsyncFunctionDeclaration2;
            }();
            exports3.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
            var AsyncFunctionExpression = /* @__PURE__ */ function() {
              function AsyncFunctionExpression2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionExpression;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = false;
                this.async = true;
              }
              return AsyncFunctionExpression2;
            }();
            exports3.AsyncFunctionExpression = AsyncFunctionExpression;
            var AwaitExpression = /* @__PURE__ */ function() {
              function AwaitExpression2(argument) {
                this.type = syntax_1.Syntax.AwaitExpression;
                this.argument = argument;
              }
              return AwaitExpression2;
            }();
            exports3.AwaitExpression = AwaitExpression;
            var BinaryExpression = /* @__PURE__ */ function() {
              function BinaryExpression2(operator, left, right) {
                var logical = operator === "||" || operator === "&&";
                this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
              }
              return BinaryExpression2;
            }();
            exports3.BinaryExpression = BinaryExpression;
            var BlockStatement = /* @__PURE__ */ function() {
              function BlockStatement2(body) {
                this.type = syntax_1.Syntax.BlockStatement;
                this.body = body;
              }
              return BlockStatement2;
            }();
            exports3.BlockStatement = BlockStatement;
            var BreakStatement = /* @__PURE__ */ function() {
              function BreakStatement2(label) {
                this.type = syntax_1.Syntax.BreakStatement;
                this.label = label;
              }
              return BreakStatement2;
            }();
            exports3.BreakStatement = BreakStatement;
            var CallExpression = /* @__PURE__ */ function() {
              function CallExpression2(callee, args) {
                this.type = syntax_1.Syntax.CallExpression;
                this.callee = callee;
                this.arguments = args;
              }
              return CallExpression2;
            }();
            exports3.CallExpression = CallExpression;
            var CatchClause = /* @__PURE__ */ function() {
              function CatchClause2(param, body) {
                this.type = syntax_1.Syntax.CatchClause;
                this.param = param;
                this.body = body;
              }
              return CatchClause2;
            }();
            exports3.CatchClause = CatchClause;
            var ClassBody = /* @__PURE__ */ function() {
              function ClassBody2(body) {
                this.type = syntax_1.Syntax.ClassBody;
                this.body = body;
              }
              return ClassBody2;
            }();
            exports3.ClassBody = ClassBody;
            var ClassDeclaration = /* @__PURE__ */ function() {
              function ClassDeclaration2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassDeclaration;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
              }
              return ClassDeclaration2;
            }();
            exports3.ClassDeclaration = ClassDeclaration;
            var ClassExpression = /* @__PURE__ */ function() {
              function ClassExpression2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassExpression;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
              }
              return ClassExpression2;
            }();
            exports3.ClassExpression = ClassExpression;
            var ComputedMemberExpression = /* @__PURE__ */ function() {
              function ComputedMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression;
                this.computed = true;
                this.object = object;
                this.property = property;
              }
              return ComputedMemberExpression2;
            }();
            exports3.ComputedMemberExpression = ComputedMemberExpression;
            var ConditionalExpression = /* @__PURE__ */ function() {
              function ConditionalExpression2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.ConditionalExpression;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
              }
              return ConditionalExpression2;
            }();
            exports3.ConditionalExpression = ConditionalExpression;
            var ContinueStatement = /* @__PURE__ */ function() {
              function ContinueStatement2(label) {
                this.type = syntax_1.Syntax.ContinueStatement;
                this.label = label;
              }
              return ContinueStatement2;
            }();
            exports3.ContinueStatement = ContinueStatement;
            var DebuggerStatement = /* @__PURE__ */ function() {
              function DebuggerStatement2() {
                this.type = syntax_1.Syntax.DebuggerStatement;
              }
              return DebuggerStatement2;
            }();
            exports3.DebuggerStatement = DebuggerStatement;
            var Directive = /* @__PURE__ */ function() {
              function Directive2(expression, directive) {
                this.type = syntax_1.Syntax.ExpressionStatement;
                this.expression = expression;
                this.directive = directive;
              }
              return Directive2;
            }();
            exports3.Directive = Directive;
            var DoWhileStatement = /* @__PURE__ */ function() {
              function DoWhileStatement2(body, test) {
                this.type = syntax_1.Syntax.DoWhileStatement;
                this.body = body;
                this.test = test;
              }
              return DoWhileStatement2;
            }();
            exports3.DoWhileStatement = DoWhileStatement;
            var EmptyStatement = /* @__PURE__ */ function() {
              function EmptyStatement2() {
                this.type = syntax_1.Syntax.EmptyStatement;
              }
              return EmptyStatement2;
            }();
            exports3.EmptyStatement = EmptyStatement;
            var ExportAllDeclaration = /* @__PURE__ */ function() {
              function ExportAllDeclaration2(source) {
                this.type = syntax_1.Syntax.ExportAllDeclaration;
                this.source = source;
              }
              return ExportAllDeclaration2;
            }();
            exports3.ExportAllDeclaration = ExportAllDeclaration;
            var ExportDefaultDeclaration = /* @__PURE__ */ function() {
              function ExportDefaultDeclaration2(declaration) {
                this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                this.declaration = declaration;
              }
              return ExportDefaultDeclaration2;
            }();
            exports3.ExportDefaultDeclaration = ExportDefaultDeclaration;
            var ExportNamedDeclaration = /* @__PURE__ */ function() {
              function ExportNamedDeclaration2(declaration, specifiers, source) {
                this.type = syntax_1.Syntax.ExportNamedDeclaration;
                this.declaration = declaration;
                this.specifiers = specifiers;
                this.source = source;
              }
              return ExportNamedDeclaration2;
            }();
            exports3.ExportNamedDeclaration = ExportNamedDeclaration;
            var ExportSpecifier = /* @__PURE__ */ function() {
              function ExportSpecifier2(local, exported) {
                this.type = syntax_1.Syntax.ExportSpecifier;
                this.exported = exported;
                this.local = local;
              }
              return ExportSpecifier2;
            }();
            exports3.ExportSpecifier = ExportSpecifier;
            var ExpressionStatement = /* @__PURE__ */ function() {
              function ExpressionStatement2(expression) {
                this.type = syntax_1.Syntax.ExpressionStatement;
                this.expression = expression;
              }
              return ExpressionStatement2;
            }();
            exports3.ExpressionStatement = ExpressionStatement;
            var ForInStatement = /* @__PURE__ */ function() {
              function ForInStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForInStatement;
                this.left = left;
                this.right = right;
                this.body = body;
                this.each = false;
              }
              return ForInStatement2;
            }();
            exports3.ForInStatement = ForInStatement;
            var ForOfStatement = /* @__PURE__ */ function() {
              function ForOfStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForOfStatement;
                this.left = left;
                this.right = right;
                this.body = body;
              }
              return ForOfStatement2;
            }();
            exports3.ForOfStatement = ForOfStatement;
            var ForStatement = /* @__PURE__ */ function() {
              function ForStatement2(init, test, update, body) {
                this.type = syntax_1.Syntax.ForStatement;
                this.init = init;
                this.test = test;
                this.update = update;
                this.body = body;
              }
              return ForStatement2;
            }();
            exports3.ForStatement = ForStatement;
            var FunctionDeclaration = /* @__PURE__ */ function() {
              function FunctionDeclaration2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionDeclaration;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.async = false;
              }
              return FunctionDeclaration2;
            }();
            exports3.FunctionDeclaration = FunctionDeclaration;
            var FunctionExpression = /* @__PURE__ */ function() {
              function FunctionExpression2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionExpression;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.async = false;
              }
              return FunctionExpression2;
            }();
            exports3.FunctionExpression = FunctionExpression;
            var Identifier = /* @__PURE__ */ function() {
              function Identifier2(name2) {
                this.type = syntax_1.Syntax.Identifier;
                this.name = name2;
              }
              return Identifier2;
            }();
            exports3.Identifier = Identifier;
            var IfStatement = /* @__PURE__ */ function() {
              function IfStatement2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.IfStatement;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
              }
              return IfStatement2;
            }();
            exports3.IfStatement = IfStatement;
            var ImportDeclaration = /* @__PURE__ */ function() {
              function ImportDeclaration2(specifiers, source) {
                this.type = syntax_1.Syntax.ImportDeclaration;
                this.specifiers = specifiers;
                this.source = source;
              }
              return ImportDeclaration2;
            }();
            exports3.ImportDeclaration = ImportDeclaration;
            var ImportDefaultSpecifier = /* @__PURE__ */ function() {
              function ImportDefaultSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                this.local = local;
              }
              return ImportDefaultSpecifier2;
            }();
            exports3.ImportDefaultSpecifier = ImportDefaultSpecifier;
            var ImportNamespaceSpecifier = /* @__PURE__ */ function() {
              function ImportNamespaceSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                this.local = local;
              }
              return ImportNamespaceSpecifier2;
            }();
            exports3.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            var ImportSpecifier = /* @__PURE__ */ function() {
              function ImportSpecifier2(local, imported) {
                this.type = syntax_1.Syntax.ImportSpecifier;
                this.local = local;
                this.imported = imported;
              }
              return ImportSpecifier2;
            }();
            exports3.ImportSpecifier = ImportSpecifier;
            var LabeledStatement = /* @__PURE__ */ function() {
              function LabeledStatement2(label, body) {
                this.type = syntax_1.Syntax.LabeledStatement;
                this.label = label;
                this.body = body;
              }
              return LabeledStatement2;
            }();
            exports3.LabeledStatement = LabeledStatement;
            var Literal = /* @__PURE__ */ function() {
              function Literal2(value, raw) {
                this.type = syntax_1.Syntax.Literal;
                this.value = value;
                this.raw = raw;
              }
              return Literal2;
            }();
            exports3.Literal = Literal;
            var MetaProperty = /* @__PURE__ */ function() {
              function MetaProperty2(meta, property) {
                this.type = syntax_1.Syntax.MetaProperty;
                this.meta = meta;
                this.property = property;
              }
              return MetaProperty2;
            }();
            exports3.MetaProperty = MetaProperty;
            var MethodDefinition = /* @__PURE__ */ function() {
              function MethodDefinition2(key, computed, value, kind, isStatic) {
                this.type = syntax_1.Syntax.MethodDefinition;
                this.key = key;
                this.computed = computed;
                this.value = value;
                this.kind = kind;
                this.static = isStatic;
              }
              return MethodDefinition2;
            }();
            exports3.MethodDefinition = MethodDefinition;
            var Module = /* @__PURE__ */ function() {
              function Module2(body) {
                this.type = syntax_1.Syntax.Program;
                this.body = body;
                this.sourceType = "module";
              }
              return Module2;
            }();
            exports3.Module = Module;
            var NewExpression = /* @__PURE__ */ function() {
              function NewExpression2(callee, args) {
                this.type = syntax_1.Syntax.NewExpression;
                this.callee = callee;
                this.arguments = args;
              }
              return NewExpression2;
            }();
            exports3.NewExpression = NewExpression;
            var ObjectExpression = /* @__PURE__ */ function() {
              function ObjectExpression2(properties) {
                this.type = syntax_1.Syntax.ObjectExpression;
                this.properties = properties;
              }
              return ObjectExpression2;
            }();
            exports3.ObjectExpression = ObjectExpression;
            var ObjectPattern = /* @__PURE__ */ function() {
              function ObjectPattern2(properties) {
                this.type = syntax_1.Syntax.ObjectPattern;
                this.properties = properties;
              }
              return ObjectPattern2;
            }();
            exports3.ObjectPattern = ObjectPattern;
            var Property = /* @__PURE__ */ function() {
              function Property2(kind, key, computed, value, method, shorthand) {
                this.type = syntax_1.Syntax.Property;
                this.key = key;
                this.computed = computed;
                this.value = value;
                this.kind = kind;
                this.method = method;
                this.shorthand = shorthand;
              }
              return Property2;
            }();
            exports3.Property = Property;
            var RegexLiteral = /* @__PURE__ */ function() {
              function RegexLiteral2(value, raw, pattern, flags) {
                this.type = syntax_1.Syntax.Literal;
                this.value = value;
                this.raw = raw;
                this.regex = { pattern, flags };
              }
              return RegexLiteral2;
            }();
            exports3.RegexLiteral = RegexLiteral;
            var RestElement = /* @__PURE__ */ function() {
              function RestElement2(argument) {
                this.type = syntax_1.Syntax.RestElement;
                this.argument = argument;
              }
              return RestElement2;
            }();
            exports3.RestElement = RestElement;
            var ReturnStatement = /* @__PURE__ */ function() {
              function ReturnStatement2(argument) {
                this.type = syntax_1.Syntax.ReturnStatement;
                this.argument = argument;
              }
              return ReturnStatement2;
            }();
            exports3.ReturnStatement = ReturnStatement;
            var Script = /* @__PURE__ */ function() {
              function Script2(body) {
                this.type = syntax_1.Syntax.Program;
                this.body = body;
                this.sourceType = "script";
              }
              return Script2;
            }();
            exports3.Script = Script;
            var SequenceExpression = /* @__PURE__ */ function() {
              function SequenceExpression2(expressions) {
                this.type = syntax_1.Syntax.SequenceExpression;
                this.expressions = expressions;
              }
              return SequenceExpression2;
            }();
            exports3.SequenceExpression = SequenceExpression;
            var SpreadElement = /* @__PURE__ */ function() {
              function SpreadElement2(argument) {
                this.type = syntax_1.Syntax.SpreadElement;
                this.argument = argument;
              }
              return SpreadElement2;
            }();
            exports3.SpreadElement = SpreadElement;
            var StaticMemberExpression = /* @__PURE__ */ function() {
              function StaticMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression;
                this.computed = false;
                this.object = object;
                this.property = property;
              }
              return StaticMemberExpression2;
            }();
            exports3.StaticMemberExpression = StaticMemberExpression;
            var Super = /* @__PURE__ */ function() {
              function Super2() {
                this.type = syntax_1.Syntax.Super;
              }
              return Super2;
            }();
            exports3.Super = Super;
            var SwitchCase = /* @__PURE__ */ function() {
              function SwitchCase2(test, consequent) {
                this.type = syntax_1.Syntax.SwitchCase;
                this.test = test;
                this.consequent = consequent;
              }
              return SwitchCase2;
            }();
            exports3.SwitchCase = SwitchCase;
            var SwitchStatement = /* @__PURE__ */ function() {
              function SwitchStatement2(discriminant, cases) {
                this.type = syntax_1.Syntax.SwitchStatement;
                this.discriminant = discriminant;
                this.cases = cases;
              }
              return SwitchStatement2;
            }();
            exports3.SwitchStatement = SwitchStatement;
            var TaggedTemplateExpression = /* @__PURE__ */ function() {
              function TaggedTemplateExpression2(tag, quasi) {
                this.type = syntax_1.Syntax.TaggedTemplateExpression;
                this.tag = tag;
                this.quasi = quasi;
              }
              return TaggedTemplateExpression2;
            }();
            exports3.TaggedTemplateExpression = TaggedTemplateExpression;
            var TemplateElement = /* @__PURE__ */ function() {
              function TemplateElement2(value, tail) {
                this.type = syntax_1.Syntax.TemplateElement;
                this.value = value;
                this.tail = tail;
              }
              return TemplateElement2;
            }();
            exports3.TemplateElement = TemplateElement;
            var TemplateLiteral = /* @__PURE__ */ function() {
              function TemplateLiteral2(quasis, expressions) {
                this.type = syntax_1.Syntax.TemplateLiteral;
                this.quasis = quasis;
                this.expressions = expressions;
              }
              return TemplateLiteral2;
            }();
            exports3.TemplateLiteral = TemplateLiteral;
            var ThisExpression = /* @__PURE__ */ function() {
              function ThisExpression2() {
                this.type = syntax_1.Syntax.ThisExpression;
              }
              return ThisExpression2;
            }();
            exports3.ThisExpression = ThisExpression;
            var ThrowStatement = /* @__PURE__ */ function() {
              function ThrowStatement2(argument) {
                this.type = syntax_1.Syntax.ThrowStatement;
                this.argument = argument;
              }
              return ThrowStatement2;
            }();
            exports3.ThrowStatement = ThrowStatement;
            var TryStatement = /* @__PURE__ */ function() {
              function TryStatement2(block, handler, finalizer) {
                this.type = syntax_1.Syntax.TryStatement;
                this.block = block;
                this.handler = handler;
                this.finalizer = finalizer;
              }
              return TryStatement2;
            }();
            exports3.TryStatement = TryStatement;
            var UnaryExpression = /* @__PURE__ */ function() {
              function UnaryExpression2(operator, argument) {
                this.type = syntax_1.Syntax.UnaryExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = true;
              }
              return UnaryExpression2;
            }();
            exports3.UnaryExpression = UnaryExpression;
            var UpdateExpression = /* @__PURE__ */ function() {
              function UpdateExpression2(operator, argument, prefix) {
                this.type = syntax_1.Syntax.UpdateExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = prefix;
              }
              return UpdateExpression2;
            }();
            exports3.UpdateExpression = UpdateExpression;
            var VariableDeclaration = /* @__PURE__ */ function() {
              function VariableDeclaration2(declarations, kind) {
                this.type = syntax_1.Syntax.VariableDeclaration;
                this.declarations = declarations;
                this.kind = kind;
              }
              return VariableDeclaration2;
            }();
            exports3.VariableDeclaration = VariableDeclaration;
            var VariableDeclarator = /* @__PURE__ */ function() {
              function VariableDeclarator2(id, init) {
                this.type = syntax_1.Syntax.VariableDeclarator;
                this.id = id;
                this.init = init;
              }
              return VariableDeclarator2;
            }();
            exports3.VariableDeclarator = VariableDeclarator;
            var WhileStatement = /* @__PURE__ */ function() {
              function WhileStatement2(test, body) {
                this.type = syntax_1.Syntax.WhileStatement;
                this.test = test;
                this.body = body;
              }
              return WhileStatement2;
            }();
            exports3.WhileStatement = WhileStatement;
            var WithStatement = /* @__PURE__ */ function() {
              function WithStatement2(object, body) {
                this.type = syntax_1.Syntax.WithStatement;
                this.object = object;
                this.body = body;
              }
              return WithStatement2;
            }();
            exports3.WithStatement = WithStatement;
            var YieldExpression = /* @__PURE__ */ function() {
              function YieldExpression2(argument, delegate) {
                this.type = syntax_1.Syntax.YieldExpression;
                this.argument = argument;
                this.delegate = delegate;
              }
              return YieldExpression2;
            }();
            exports3.YieldExpression = YieldExpression;
          },
          /* 8 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var assert_1 = __webpack_require__(9);
            var error_handler_1 = __webpack_require__(10);
            var messages_1 = __webpack_require__(11);
            var Node = __webpack_require__(7);
            var scanner_1 = __webpack_require__(12);
            var syntax_1 = __webpack_require__(2);
            var token_1 = __webpack_require__(13);
            var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
            var Parser = function() {
              function Parser2(code, options, delegate) {
                if (options === void 0) {
                  options = {};
                }
                this.config = {
                  range: typeof options.range === "boolean" && options.range,
                  loc: typeof options.loc === "boolean" && options.loc,
                  source: null,
                  tokens: typeof options.tokens === "boolean" && options.tokens,
                  comment: typeof options.comment === "boolean" && options.comment,
                  tolerant: typeof options.tolerant === "boolean" && options.tolerant
                };
                if (this.config.loc && options.source && options.source !== null) {
                  this.config.source = String(options.source);
                }
                this.delegate = delegate;
                this.errorHandler = new error_handler_1.ErrorHandler();
                this.errorHandler.tolerant = this.config.tolerant;
                this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                this.scanner.trackComment = this.config.comment;
                this.operatorPrecedence = {
                  ")": 0,
                  ";": 0,
                  ",": 0,
                  "=": 0,
                  "]": 0,
                  "||": 1,
                  "&&": 2,
                  "|": 3,
                  "^": 4,
                  "&": 5,
                  "==": 6,
                  "!=": 6,
                  "===": 6,
                  "!==": 6,
                  "<": 7,
                  ">": 7,
                  "<=": 7,
                  ">=": 7,
                  "<<": 8,
                  ">>": 8,
                  ">>>": 8,
                  "+": 9,
                  "-": 9,
                  "*": 11,
                  "/": 11,
                  "%": 11
                };
                this.lookahead = {
                  type: 2,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: 0,
                  start: 0,
                  end: 0
                };
                this.hasLineTerminator = false;
                this.context = {
                  isModule: false,
                  await: false,
                  allowIn: true,
                  allowStrictDirective: true,
                  allowYield: true,
                  firstCoverInitializedNameError: null,
                  isAssignmentTarget: false,
                  isBindingElement: false,
                  inFunctionBody: false,
                  inIteration: false,
                  inSwitch: false,
                  labelSet: {},
                  strict: false
                };
                this.tokens = [];
                this.startMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                };
                this.lastMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                };
                this.nextToken();
                this.lastMarker = {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }
              Parser2.prototype.throwError = function(messageFormat) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  values[_i - 1] = arguments[_i];
                }
                var args = Array.prototype.slice.call(arguments, 1);
                var msg = messageFormat.replace(/%(\d)/g, function(whole, idx2) {
                  assert_1.assert(idx2 < args.length, "Message reference must be in range");
                  return args[idx2];
                });
                var index = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                throw this.errorHandler.createError(index, line, column, msg);
              };
              Parser2.prototype.tolerateError = function(messageFormat) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  values[_i - 1] = arguments[_i];
                }
                var args = Array.prototype.slice.call(arguments, 1);
                var msg = messageFormat.replace(/%(\d)/g, function(whole, idx2) {
                  assert_1.assert(idx2 < args.length, "Message reference must be in range");
                  return args[idx2];
                });
                var index = this.lastMarker.index;
                var line = this.scanner.lineNumber;
                var column = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(index, line, column, msg);
              };
              Parser2.prototype.unexpectedTokenError = function(token, message) {
                var msg = message || messages_1.Messages.UnexpectedToken;
                var value;
                if (token) {
                  if (!message) {
                    msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                    if (token.type === 4) {
                      if (this.scanner.isFutureReservedWord(token.value)) {
                        msg = messages_1.Messages.UnexpectedReserved;
                      } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                        msg = messages_1.Messages.StrictReservedWord;
                      }
                    }
                  }
                  value = token.value;
                } else {
                  value = "ILLEGAL";
                }
                msg = msg.replace("%0", value);
                if (token && typeof token.lineNumber === "number") {
                  var index = token.start;
                  var line = token.lineNumber;
                  var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                  var column = token.start - lastMarkerLineStart + 1;
                  return this.errorHandler.createError(index, line, column, msg);
                } else {
                  var index = this.lastMarker.index;
                  var line = this.lastMarker.line;
                  var column = this.lastMarker.column + 1;
                  return this.errorHandler.createError(index, line, column, msg);
                }
              };
              Parser2.prototype.throwUnexpectedToken = function(token, message) {
                throw this.unexpectedTokenError(token, message);
              };
              Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
                this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
              };
              Parser2.prototype.collectComments = function() {
                if (!this.config.comment) {
                  this.scanner.scanComments();
                } else {
                  var comments = this.scanner.scanComments();
                  if (comments.length > 0 && this.delegate) {
                    for (var i = 0; i < comments.length; ++i) {
                      var e = comments[i];
                      var node = void 0;
                      node = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
                      };
                      if (this.config.range) {
                        node.range = e.range;
                      }
                      if (this.config.loc) {
                        node.loc = e.loc;
                      }
                      var metadata = {
                        start: {
                          line: e.loc.start.line,
                          column: e.loc.start.column,
                          offset: e.range[0]
                        },
                        end: {
                          line: e.loc.end.line,
                          column: e.loc.end.column,
                          offset: e.range[1]
                        }
                      };
                      this.delegate(node, metadata);
                    }
                  }
                }
              };
              Parser2.prototype.getTokenRaw = function(token) {
                return this.scanner.source.slice(token.start, token.end);
              };
              Parser2.prototype.convertToken = function(token) {
                var t = {
                  type: token_1.TokenName[token.type],
                  value: this.getTokenRaw(token)
                };
                if (this.config.range) {
                  t.range = [token.start, token.end];
                }
                if (this.config.loc) {
                  t.loc = {
                    start: {
                      line: this.startMarker.line,
                      column: this.startMarker.column
                    },
                    end: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    }
                  };
                }
                if (token.type === 9) {
                  var pattern = token.pattern;
                  var flags = token.flags;
                  t.regex = { pattern, flags };
                }
                return t;
              };
              Parser2.prototype.nextToken = function() {
                var token = this.lookahead;
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                this.collectComments();
                if (this.scanner.index !== this.startMarker.index) {
                  this.startMarker.index = this.scanner.index;
                  this.startMarker.line = this.scanner.lineNumber;
                  this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                }
                var next = this.scanner.lex();
                this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                if (next && this.context.strict && next.type === 3) {
                  if (this.scanner.isStrictModeReservedWord(next.value)) {
                    next.type = 4;
                  }
                }
                this.lookahead = next;
                if (this.config.tokens && next.type !== 2) {
                  this.tokens.push(this.convertToken(next));
                }
                return token;
              };
              Parser2.prototype.nextRegexToken = function() {
                this.collectComments();
                var token = this.scanner.scanRegExp();
                if (this.config.tokens) {
                  this.tokens.pop();
                  this.tokens.push(this.convertToken(token));
                }
                this.lookahead = token;
                this.nextToken();
                return token;
              };
              Parser2.prototype.createNode = function() {
                return {
                  index: this.startMarker.index,
                  line: this.startMarker.line,
                  column: this.startMarker.column
                };
              };
              Parser2.prototype.startNode = function(token, lastLineStart) {
                if (lastLineStart === void 0) {
                  lastLineStart = 0;
                }
                var column = token.start - token.lineStart;
                var line = token.lineNumber;
                if (column < 0) {
                  column += lastLineStart;
                  line--;
                }
                return {
                  index: token.start,
                  line,
                  column
                };
              };
              Parser2.prototype.finalize = function(marker, node) {
                if (this.config.range) {
                  node.range = [marker.index, this.lastMarker.index];
                }
                if (this.config.loc) {
                  node.loc = {
                    start: {
                      line: marker.line,
                      column: marker.column
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column
                    }
                  };
                  if (this.config.source) {
                    node.loc.source = this.config.source;
                  }
                }
                if (this.delegate) {
                  var metadata = {
                    start: {
                      line: marker.line,
                      column: marker.column,
                      offset: marker.index
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column,
                      offset: this.lastMarker.index
                    }
                  };
                  this.delegate(node, metadata);
                }
                return node;
              };
              Parser2.prototype.expect = function(value) {
                var token = this.nextToken();
                if (token.type !== 7 || token.value !== value) {
                  this.throwUnexpectedToken(token);
                }
              };
              Parser2.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var token = this.lookahead;
                  if (token.type === 7 && token.value === ",") {
                    this.nextToken();
                  } else if (token.type === 7 && token.value === ";") {
                    this.nextToken();
                    this.tolerateUnexpectedToken(token);
                  } else {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                  }
                } else {
                  this.expect(",");
                }
              };
              Parser2.prototype.expectKeyword = function(keyword) {
                var token = this.nextToken();
                if (token.type !== 4 || token.value !== keyword) {
                  this.throwUnexpectedToken(token);
                }
              };
              Parser2.prototype.match = function(value) {
                return this.lookahead.type === 7 && this.lookahead.value === value;
              };
              Parser2.prototype.matchKeyword = function(keyword) {
                return this.lookahead.type === 4 && this.lookahead.value === keyword;
              };
              Parser2.prototype.matchContextualKeyword = function(keyword) {
                return this.lookahead.type === 3 && this.lookahead.value === keyword;
              };
              Parser2.prototype.matchAssign = function() {
                if (this.lookahead.type !== 7) {
                  return false;
                }
                var op = this.lookahead.value;
                return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
              };
              Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement;
                var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true;
                this.context.isAssignmentTarget = true;
                this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                if (this.context.firstCoverInitializedNameError !== null) {
                  this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                }
                this.context.isBindingElement = previousIsBindingElement;
                this.context.isAssignmentTarget = previousIsAssignmentTarget;
                this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                return result;
              };
              Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement;
                var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true;
                this.context.isAssignmentTarget = true;
                this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                return result;
              };
              Parser2.prototype.consumeSemicolon = function() {
                if (this.match(";")) {
                  this.nextToken();
                } else if (!this.hasLineTerminator) {
                  if (this.lookahead.type !== 2 && !this.match("}")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  this.lastMarker.index = this.startMarker.index;
                  this.lastMarker.line = this.startMarker.line;
                  this.lastMarker.column = this.startMarker.column;
                }
              };
              Parser2.prototype.parsePrimaryExpression = function() {
                var node = this.createNode();
                var expr;
                var token, raw;
                switch (this.lookahead.type) {
                  case 3:
                    if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    if (this.context.strict && this.lookahead.octal) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(token.value, raw));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(null, raw));
                    break;
                  case 10:
                    expr = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = false;
                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        this.scanner.index = this.startMarker.index;
                        token = this.nextRegexToken();
                        raw = this.getTokenRaw(token);
                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                        break;
                      default:
                        expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                      expr = this.parseIdentifierName();
                    } else if (!this.context.strict && this.matchKeyword("let")) {
                      expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                    } else {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      if (this.matchKeyword("function")) {
                        expr = this.parseFunctionExpression();
                      } else if (this.matchKeyword("this")) {
                        this.nextToken();
                        expr = this.finalize(node, new Node.ThisExpression());
                      } else if (this.matchKeyword("class")) {
                        expr = this.parseClassExpression();
                      } else {
                        expr = this.throwUnexpectedToken(this.nextToken());
                      }
                    }
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                return expr;
              };
              Parser2.prototype.parseSpreadElement = function() {
                var node = this.createNode();
                this.expect("...");
                var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(node, new Node.SpreadElement(arg));
              };
              Parser2.prototype.parseArrayInitializer = function() {
                var node = this.createNode();
                var elements = [];
                this.expect("[");
                while (!this.match("]")) {
                  if (this.match(",")) {
                    this.nextToken();
                    elements.push(null);
                  } else if (this.match("...")) {
                    var element = this.parseSpreadElement();
                    if (!this.match("]")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.expect(",");
                    }
                    elements.push(element);
                  } else {
                    elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                    if (!this.match("]")) {
                      this.expect(",");
                    }
                  }
                }
                this.expect("]");
                return this.finalize(node, new Node.ArrayExpression(elements));
              };
              Parser2.prototype.parsePropertyMethod = function(params) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = params.simple;
                var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                if (this.context.strict && params.firstRestricted) {
                  this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                }
                if (this.context.strict && params.stricted) {
                  this.tolerateUnexpectedToken(params.stricted, params.message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                return body;
              };
              Parser2.prototype.parsePropertyMethodFunction = function() {
                var isGenerator = false;
                var node = this.createNode();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var params = this.parseFormalParameters();
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              };
              Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
                var node = this.createNode();
                var previousAllowYield = this.context.allowYield;
                var previousAwait = this.context.await;
                this.context.allowYield = false;
                this.context.await = true;
                var params = this.parseFormalParameters();
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                this.context.await = previousAwait;
                return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
              };
              Parser2.prototype.parseObjectPropertyKey = function() {
                var node = this.createNode();
                var token = this.nextToken();
                var key;
                switch (token.type) {
                  case 8:
                  case 6:
                    if (this.context.strict && token.octal) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                    }
                    var raw = this.getTokenRaw(token);
                    key = this.finalize(node, new Node.Literal(token.value, raw));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    key = this.finalize(node, new Node.Identifier(token.value));
                    break;
                  case 7:
                    if (token.value === "[") {
                      key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      this.expect("]");
                    } else {
                      key = this.throwUnexpectedToken(token);
                    }
                    break;
                  default:
                    key = this.throwUnexpectedToken(token);
                }
                return key;
              };
              Parser2.prototype.isPropertyKey = function(key, value) {
                return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
              };
              Parser2.prototype.parseObjectProperty = function(hasProto) {
                var node = this.createNode();
                var token = this.lookahead;
                var kind;
                var key = null;
                var value = null;
                var computed = false;
                var method = false;
                var shorthand = false;
                var isAsync = false;
                if (token.type === 3) {
                  var id = token.value;
                  this.nextToken();
                  computed = this.match("[");
                  isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                  key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
                } else if (this.match("*")) {
                  this.nextToken();
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value = this.parseGetterMethod();
                } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseSetterMethod();
                } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                  kind = "init";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseGeneratorMethod();
                  method = true;
                } else {
                  if (!key) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  kind = "init";
                  if (this.match(":") && !isAsync) {
                    if (!computed && this.isPropertyKey(key, "__proto__")) {
                      if (hasProto.value) {
                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                      }
                      hasProto.value = true;
                    }
                    this.nextToken();
                    value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  } else if (this.match("(")) {
                    value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                    method = true;
                  } else if (token.type === 3) {
                    var id = this.finalize(node, new Node.Identifier(token.value));
                    if (this.match("=")) {
                      this.context.firstCoverInitializedNameError = this.lookahead;
                      this.nextToken();
                      shorthand = true;
                      var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      value = this.finalize(node, new Node.AssignmentPattern(id, init));
                    } else {
                      shorthand = true;
                      value = id;
                    }
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                }
                return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
              };
              Parser2.prototype.parseObjectInitializer = function() {
                var node = this.createNode();
                this.expect("{");
                var properties = [];
                var hasProto = { value: false };
                while (!this.match("}")) {
                  properties.push(this.parseObjectProperty(hasProto));
                  if (!this.match("}")) {
                    this.expectCommaSeparator();
                  }
                }
                this.expect("}");
                return this.finalize(node, new Node.ObjectExpression(properties));
              };
              Parser2.prototype.parseTemplateHead = function() {
                assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
                var node = this.createNode();
                var token = this.nextToken();
                var raw = token.value;
                var cooked = token.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
              };
              Parser2.prototype.parseTemplateElement = function() {
                if (this.lookahead.type !== 10) {
                  this.throwUnexpectedToken();
                }
                var node = this.createNode();
                var token = this.nextToken();
                var raw = token.value;
                var cooked = token.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
              };
              Parser2.prototype.parseTemplateLiteral = function() {
                var node = this.createNode();
                var expressions = [];
                var quasis = [];
                var quasi = this.parseTemplateHead();
                quasis.push(quasi);
                while (!quasi.tail) {
                  expressions.push(this.parseExpression());
                  quasi = this.parseTemplateElement();
                  quasis.push(quasi);
                }
                return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
              };
              Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                  case syntax_1.Syntax.MemberExpression:
                  case syntax_1.Syntax.RestElement:
                  case syntax_1.Syntax.AssignmentPattern:
                    break;
                  case syntax_1.Syntax.SpreadElement:
                    expr.type = syntax_1.Syntax.RestElement;
                    this.reinterpretExpressionAsPattern(expr.argument);
                    break;
                  case syntax_1.Syntax.ArrayExpression:
                    expr.type = syntax_1.Syntax.ArrayPattern;
                    for (var i = 0; i < expr.elements.length; i++) {
                      if (expr.elements[i] !== null) {
                        this.reinterpretExpressionAsPattern(expr.elements[i]);
                      }
                    }
                    break;
                  case syntax_1.Syntax.ObjectExpression:
                    expr.type = syntax_1.Syntax.ObjectPattern;
                    for (var i = 0; i < expr.properties.length; i++) {
                      this.reinterpretExpressionAsPattern(expr.properties[i].value);
                    }
                    break;
                  case syntax_1.Syntax.AssignmentExpression:
                    expr.type = syntax_1.Syntax.AssignmentPattern;
                    delete expr.operator;
                    this.reinterpretExpressionAsPattern(expr.left);
                    break;
                  default:
                    break;
                }
              };
              Parser2.prototype.parseGroupExpression = function() {
                var expr;
                this.expect("(");
                if (this.match(")")) {
                  this.nextToken();
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [],
                    async: false
                  };
                } else {
                  var startToken = this.lookahead;
                  var params = [];
                  if (this.match("...")) {
                    expr = this.parseRestElement(params);
                    this.expect(")");
                    if (!this.match("=>")) {
                      this.expect("=>");
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [expr],
                      async: false
                    };
                  } else {
                    var arrow = false;
                    this.context.isBindingElement = true;
                    expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    if (this.match(",")) {
                      var expressions = [];
                      this.context.isAssignmentTarget = false;
                      expressions.push(expr);
                      while (this.lookahead.type !== 2) {
                        if (!this.match(",")) {
                          break;
                        }
                        this.nextToken();
                        if (this.match(")")) {
                          this.nextToken();
                          for (var i = 0; i < expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          }
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: false
                          };
                        } else if (this.match("...")) {
                          if (!this.context.isBindingElement) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          expressions.push(this.parseRestElement(params));
                          this.expect(")");
                          if (!this.match("=>")) {
                            this.expect("=>");
                          }
                          this.context.isBindingElement = false;
                          for (var i = 0; i < expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          }
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: false
                          };
                        } else {
                          expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        }
                        if (arrow) {
                          break;
                        }
                      }
                      if (!arrow) {
                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                      }
                    }
                    if (!arrow) {
                      this.expect(")");
                      if (this.match("=>")) {
                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: [expr],
                            async: false
                          };
                        }
                        if (!arrow) {
                          if (!this.context.isBindingElement) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          if (expr.type === syntax_1.Syntax.SequenceExpression) {
                            for (var i = 0; i < expr.expressions.length; i++) {
                              this.reinterpretExpressionAsPattern(expr.expressions[i]);
                            }
                          } else {
                            this.reinterpretExpressionAsPattern(expr);
                          }
                          var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: parameters,
                            async: false
                          };
                        }
                      }
                      this.context.isBindingElement = false;
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")")) {
                  while (true) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                    args.push(expr);
                    if (this.match(")")) {
                      break;
                    }
                    this.expectCommaSeparator();
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return args;
              };
              Parser2.prototype.isIdentifierName = function(token) {
                return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
              };
              Parser2.prototype.parseIdentifierName = function() {
                var node = this.createNode();
                var token = this.nextToken();
                if (!this.isIdentifierName(token)) {
                  this.throwUnexpectedToken(token);
                }
                return this.finalize(node, new Node.Identifier(token.value));
              };
              Parser2.prototype.parseNewExpression = function() {
                var node = this.createNode();
                var id = this.parseIdentifierName();
                assert_1.assert(id.name === "new", "New expression must start with `new`");
                var expr;
                if (this.match(".")) {
                  this.nextToken();
                  if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                    var property = this.parseIdentifierName();
                    expr = new Node.MetaProperty(id, property);
                  } else {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                } else {
                  var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                  var args = this.match("(") ? this.parseArguments() : [];
                  expr = new Node.NewExpression(callee, args);
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                }
                return this.finalize(node, expr);
              };
              Parser2.prototype.parseAsyncArgument = function() {
                var arg = this.parseAssignmentExpression();
                this.context.firstCoverInitializedNameError = null;
                return arg;
              };
              Parser2.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")")) {
                  while (true) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                    args.push(expr);
                    if (this.match(")")) {
                      break;
                    }
                    this.expectCommaSeparator();
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return args;
              };
              Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var startToken = this.lookahead;
                var maybeAsync = this.matchContextualKeyword("async");
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var expr;
                if (this.matchKeyword("super") && this.context.inFunctionBody) {
                  expr = this.createNode();
                  this.nextToken();
                  expr = this.finalize(expr, new Node.Super());
                  if (!this.match("(") && !this.match(".") && !this.match("[")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                } else {
                  expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                }
                while (true) {
                  if (this.match(".")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                  } else if (this.match("(")) {
                    var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = false;
                    var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                    expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                    if (asyncArrow && this.match("=>")) {
                      for (var i = 0; i < args.length; ++i) {
                        this.reinterpretExpressionAsPattern(args[i]);
                      }
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: args,
                        async: true
                      };
                    }
                  } else if (this.match("[")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]");
                    expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                  } else {
                    break;
                  }
                }
                this.context.allowIn = previousAllowIn;
                return expr;
              };
              Parser2.prototype.parseSuper = function() {
                var node = this.createNode();
                this.expectKeyword("super");
                if (!this.match("[") && !this.match(".")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                return this.finalize(node, new Node.Super());
              };
              Parser2.prototype.parseLeftHandSideExpression = function() {
                assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                var node = this.startNode(this.lookahead);
                var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                while (true) {
                  if (this.match("[")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]");
                    expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                  } else if (this.match(".")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                  } else {
                    break;
                  }
                }
                return expr;
              };
              Parser2.prototype.parseUpdateExpression = function() {
                var expr;
                var startToken = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var node = this.startNode(startToken);
                  var token = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                    this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                  }
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  var prefix = true;
                  expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                } else {
                  expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                  if (!this.hasLineTerminator && this.lookahead.type === 7) {
                    if (this.match("++") || this.match("--")) {
                      if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                      }
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var operator = this.nextToken().value;
                      var prefix = false;
                      expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseAwaitExpression = function() {
                var node = this.createNode();
                this.nextToken();
                var argument = this.parseUnaryExpression();
                return this.finalize(node, new Node.AwaitExpression(argument));
              };
              Parser2.prototype.parseUnaryExpression = function() {
                var expr;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var node = this.startNode(this.lookahead);
                  var token = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                  expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
                  if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                    this.tolerateError(messages_1.Messages.StrictDelete);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                } else if (this.context.await && this.matchContextualKeyword("await")) {
                  expr = this.parseAwaitExpression();
                } else {
                  expr = this.parseUpdateExpression();
                }
                return expr;
              };
              Parser2.prototype.parseExponentiationExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken();
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var left = expr;
                  var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
                }
                return expr;
              };
              Parser2.prototype.binaryPrecedence = function(token) {
                var op = token.value;
                var precedence;
                if (token.type === 7) {
                  precedence = this.operatorPrecedence[op] || 0;
                } else if (token.type === 4) {
                  precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                } else {
                  precedence = 0;
                }
                return precedence;
              };
              Parser2.prototype.parseBinaryExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
                var token = this.lookahead;
                var prec = this.binaryPrecedence(token);
                if (prec > 0) {
                  this.nextToken();
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var markers = [startToken, this.lookahead];
                  var left = expr;
                  var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  var stack = [left, token.value, right];
                  var precedences = [prec];
                  while (true) {
                    prec = this.binaryPrecedence(this.lookahead);
                    if (prec <= 0) {
                      break;
                    }
                    while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                      right = stack.pop();
                      var operator = stack.pop();
                      precedences.pop();
                      left = stack.pop();
                      markers.pop();
                      var node = this.startNode(markers[markers.length - 1]);
                      stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                    }
                    stack.push(this.nextToken().value);
                    precedences.push(prec);
                    markers.push(this.lookahead);
                    stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var i = stack.length - 1;
                  expr = stack[i];
                  var lastMarker = markers.pop();
                  while (i > 1) {
                    var marker = markers.pop();
                    var lastLineStart = lastMarker && lastMarker.lineStart;
                    var node = this.startNode(marker, lastLineStart);
                    var operator = stack[i - 1];
                    expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                    i -= 2;
                    lastMarker = marker;
                  }
                }
                return expr;
              };
              Parser2.prototype.parseConditionalExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = true;
                  var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  this.expect(":");
                  var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                }
                return expr;
              };
              Parser2.prototype.checkPatternParam = function(options, param) {
                switch (param.type) {
                  case syntax_1.Syntax.Identifier:
                    this.validateParam(options, param, param.name);
                    break;
                  case syntax_1.Syntax.RestElement:
                    this.checkPatternParam(options, param.argument);
                    break;
                  case syntax_1.Syntax.AssignmentPattern:
                    this.checkPatternParam(options, param.left);
                    break;
                  case syntax_1.Syntax.ArrayPattern:
                    for (var i = 0; i < param.elements.length; i++) {
                      if (param.elements[i] !== null) {
                        this.checkPatternParam(options, param.elements[i]);
                      }
                    }
                    break;
                  case syntax_1.Syntax.ObjectPattern:
                    for (var i = 0; i < param.properties.length; i++) {
                      this.checkPatternParam(options, param.properties[i].value);
                    }
                    break;
                  default:
                    break;
                }
                options.simple = options.simple && param instanceof Node.Identifier;
              };
              Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
                var params = [expr];
                var options;
                var asyncArrow = false;
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                    break;
                  case ArrowParameterPlaceHolder:
                    params = expr.params;
                    asyncArrow = expr.async;
                    break;
                  default:
                    return null;
                }
                options = {
                  simple: true,
                  paramSet: {}
                };
                for (var i = 0; i < params.length; ++i) {
                  var param = params[i];
                  if (param.type === syntax_1.Syntax.AssignmentPattern) {
                    if (param.right.type === syntax_1.Syntax.YieldExpression) {
                      if (param.right.argument) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      param.right.type = syntax_1.Syntax.Identifier;
                      param.right.name = "yield";
                      delete param.right.argument;
                      delete param.right.delegate;
                    }
                  } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  this.checkPatternParam(options, param);
                  params[i] = param;
                }
                if (this.context.strict || !this.context.allowYield) {
                  for (var i = 0; i < params.length; ++i) {
                    var param = params[i];
                    if (param.type === syntax_1.Syntax.YieldExpression) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                }
                if (options.message === messages_1.Messages.StrictParamDupe) {
                  var token = this.context.strict ? options.stricted : options.firstRestricted;
                  this.throwUnexpectedToken(token, options.message);
                }
                return {
                  simple: options.simple,
                  params,
                  stricted: options.stricted,
                  firstRestricted: options.firstRestricted,
                  message: options.message
                };
              };
              Parser2.prototype.parseAssignmentExpression = function() {
                var expr;
                if (!this.context.allowYield && this.matchKeyword("yield")) {
                  expr = this.parseYieldExpression();
                } else {
                  var startToken = this.lookahead;
                  var token = startToken;
                  expr = this.parseConditionalExpression();
                  if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                    if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                      var arg = this.parsePrimaryExpression();
                      this.reinterpretExpressionAsPattern(arg);
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [arg],
                        async: true
                      };
                    }
                  }
                  if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var isAsync = expr.async;
                    var list = this.reinterpretAsCoverFormalsList(expr);
                    if (list) {
                      if (this.hasLineTerminator) {
                        this.tolerateUnexpectedToken(this.lookahead);
                      }
                      this.context.firstCoverInitializedNameError = null;
                      var previousStrict = this.context.strict;
                      var previousAllowStrictDirective = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = list.simple;
                      var previousAllowYield = this.context.allowYield;
                      var previousAwait = this.context.await;
                      this.context.allowYield = true;
                      this.context.await = isAsync;
                      var node = this.startNode(startToken);
                      this.expect("=>");
                      var body = void 0;
                      if (this.match("{")) {
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = true;
                        body = this.parseFunctionSourceElements();
                        this.context.allowIn = previousAllowIn;
                      } else {
                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      }
                      var expression = body.type !== syntax_1.Syntax.BlockStatement;
                      if (this.context.strict && list.firstRestricted) {
                        this.throwUnexpectedToken(list.firstRestricted, list.message);
                      }
                      if (this.context.strict && list.stricted) {
                        this.tolerateUnexpectedToken(list.stricted, list.message);
                      }
                      expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                      this.context.strict = previousStrict;
                      this.context.allowStrictDirective = previousAllowStrictDirective;
                      this.context.allowYield = previousAllowYield;
                      this.context.await = previousAwait;
                    }
                  } else {
                    if (this.matchAssign()) {
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                        var id = expr;
                        if (this.scanner.isRestrictedWord(id.name)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                        }
                        if (this.scanner.isStrictModeReservedWord(id.name)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        }
                      }
                      if (!this.match("=")) {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                      } else {
                        this.reinterpretExpressionAsPattern(expr);
                      }
                      token = this.nextToken();
                      var operator = token.value;
                      var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                      this.context.firstCoverInitializedNameError = null;
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseExpression = function() {
                var startToken = this.lookahead;
                var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  expressions.push(expr);
                  while (this.lookahead.type !== 2) {
                    if (!this.match(",")) {
                      break;
                    }
                    this.nextToken();
                    expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  }
                  expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                }
                return expr;
              };
              Parser2.prototype.parseStatementListItem = function() {
                var statement;
                this.context.isAssignmentTarget = true;
                this.context.isBindingElement = true;
                if (this.lookahead.type === 4) {
                  switch (this.lookahead.value) {
                    case "export":
                      if (!this.context.isModule) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                      }
                      statement = this.parseExportDeclaration();
                      break;
                    case "import":
                      if (!this.context.isModule) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                      }
                      statement = this.parseImportDeclaration();
                      break;
                    case "const":
                      statement = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "class":
                      statement = this.parseClassDeclaration();
                      break;
                    case "let":
                      statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                      break;
                    default:
                      statement = this.parseStatement();
                      break;
                  }
                } else {
                  statement = this.parseStatement();
                }
                return statement;
              };
              Parser2.prototype.parseBlock = function() {
                var node = this.createNode();
                this.expect("{");
                var block = [];
                while (true) {
                  if (this.match("}")) {
                    break;
                  }
                  block.push(this.parseStatementListItem());
                }
                this.expect("}");
                return this.finalize(node, new Node.BlockStatement(block));
              };
              Parser2.prototype.parseLexicalBinding = function(kind, options) {
                var node = this.createNode();
                var params = [];
                var id = this.parsePattern(params, kind);
                if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(id.name)) {
                    this.tolerateError(messages_1.Messages.StrictVarName);
                  }
                }
                var init = null;
                if (kind === "const") {
                  if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                    if (this.match("=")) {
                      this.nextToken();
                      init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    } else {
                      this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                    }
                  }
                } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                  this.expect("=");
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                }
                return this.finalize(node, new Node.VariableDeclarator(id, init));
              };
              Parser2.prototype.parseBindingList = function(kind, options) {
                var list = [this.parseLexicalBinding(kind, options)];
                while (this.match(",")) {
                  this.nextToken();
                  list.push(this.parseLexicalBinding(kind, options));
                }
                return list;
              };
              Parser2.prototype.isLexicalDeclaration = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                this.scanner.restoreState(state);
                return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
              };
              Parser2.prototype.parseLexicalDeclaration = function(options) {
                var node = this.createNode();
                var kind = this.nextToken().value;
                assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                var declarations = this.parseBindingList(kind, options);
                this.consumeSemicolon();
                return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
              };
              Parser2.prototype.parseBindingRestElement = function(params, kind) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params, kind);
                return this.finalize(node, new Node.RestElement(arg));
              };
              Parser2.prototype.parseArrayPattern = function(params, kind) {
                var node = this.createNode();
                this.expect("[");
                var elements = [];
                while (!this.match("]")) {
                  if (this.match(",")) {
                    this.nextToken();
                    elements.push(null);
                  } else {
                    if (this.match("...")) {
                      elements.push(this.parseBindingRestElement(params, kind));
                      break;
                    } else {
                      elements.push(this.parsePatternWithDefault(params, kind));
                    }
                    if (!this.match("]")) {
                      this.expect(",");
                    }
                  }
                }
                this.expect("]");
                return this.finalize(node, new Node.ArrayPattern(elements));
              };
              Parser2.prototype.parsePropertyPattern = function(params, kind) {
                var node = this.createNode();
                var computed = false;
                var shorthand = false;
                var method = false;
                var key;
                var value;
                if (this.lookahead.type === 3) {
                  var keyToken = this.lookahead;
                  key = this.parseVariableIdentifier();
                  var init = this.finalize(node, new Node.Identifier(keyToken.value));
                  if (this.match("=")) {
                    params.push(keyToken);
                    shorthand = true;
                    this.nextToken();
                    var expr = this.parseAssignmentExpression();
                    value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
                  } else if (!this.match(":")) {
                    params.push(keyToken);
                    shorthand = true;
                    value = init;
                  } else {
                    this.expect(":");
                    value = this.parsePatternWithDefault(params, kind);
                  }
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.expect(":");
                  value = this.parsePatternWithDefault(params, kind);
                }
                return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
              };
              Parser2.prototype.parseObjectPattern = function(params, kind) {
                var node = this.createNode();
                var properties = [];
                this.expect("{");
                while (!this.match("}")) {
                  properties.push(this.parsePropertyPattern(params, kind));
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                return this.finalize(node, new Node.ObjectPattern(properties));
              };
              Parser2.prototype.parsePattern = function(params, kind) {
                var pattern;
                if (this.match("[")) {
                  pattern = this.parseArrayPattern(params, kind);
                } else if (this.match("{")) {
                  pattern = this.parseObjectPattern(params, kind);
                } else {
                  if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                  }
                  params.push(this.lookahead);
                  pattern = this.parseVariableIdentifier(kind);
                }
                return pattern;
              };
              Parser2.prototype.parsePatternWithDefault = function(params, kind) {
                var startToken = this.lookahead;
                var pattern = this.parsePattern(params, kind);
                if (this.match("=")) {
                  this.nextToken();
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = true;
                  var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = previousAllowYield;
                  pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
                }
                return pattern;
              };
              Parser2.prototype.parseVariableIdentifier = function(kind) {
                var node = this.createNode();
                var token = this.nextToken();
                if (token.type === 4 && token.value === "yield") {
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                  } else if (!this.context.allowYield) {
                    this.throwUnexpectedToken(token);
                  }
                } else if (token.type !== 3) {
                  if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                  } else {
                    if (this.context.strict || token.value !== "let" || kind !== "var") {
                      this.throwUnexpectedToken(token);
                    }
                  }
                } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                  this.tolerateUnexpectedToken(token);
                }
                return this.finalize(node, new Node.Identifier(token.value));
              };
              Parser2.prototype.parseVariableDeclaration = function(options) {
                var node = this.createNode();
                var params = [];
                var id = this.parsePattern(params, "var");
                if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(id.name)) {
                    this.tolerateError(messages_1.Messages.StrictVarName);
                  }
                }
                var init = null;
                if (this.match("=")) {
                  this.nextToken();
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                  this.expect("=");
                }
                return this.finalize(node, new Node.VariableDeclarator(id, init));
              };
              Parser2.prototype.parseVariableDeclarationList = function(options) {
                var opt = { inFor: options.inFor };
                var list = [];
                list.push(this.parseVariableDeclaration(opt));
                while (this.match(",")) {
                  this.nextToken();
                  list.push(this.parseVariableDeclaration(opt));
                }
                return list;
              };
              Parser2.prototype.parseVariableStatement = function() {
                var node = this.createNode();
                this.expectKeyword("var");
                var declarations = this.parseVariableDeclarationList({ inFor: false });
                this.consumeSemicolon();
                return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
              };
              Parser2.prototype.parseEmptyStatement = function() {
                var node = this.createNode();
                this.expect(";");
                return this.finalize(node, new Node.EmptyStatement());
              };
              Parser2.prototype.parseExpressionStatement = function() {
                var node = this.createNode();
                var expr = this.parseExpression();
                this.consumeSemicolon();
                return this.finalize(node, new Node.ExpressionStatement(expr));
              };
              Parser2.prototype.parseIfClause = function() {
                if (this.context.strict && this.matchKeyword("function")) {
                  this.tolerateError(messages_1.Messages.StrictFunction);
                }
                return this.parseStatement();
              };
              Parser2.prototype.parseIfStatement = function() {
                var node = this.createNode();
                var consequent;
                var alternate = null;
                this.expectKeyword("if");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  consequent = this.parseIfClause();
                  if (this.matchKeyword("else")) {
                    this.nextToken();
                    alternate = this.parseIfClause();
                  }
                }
                return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
              };
              Parser2.prototype.parseDoWhileStatement = function() {
                var node = this.createNode();
                this.expectKeyword("do");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                var body = this.parseStatement();
                this.context.inIteration = previousInIteration;
                this.expectKeyword("while");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                } else {
                  this.expect(")");
                  if (this.match(";")) {
                    this.nextToken();
                  }
                }
                return this.finalize(node, new Node.DoWhileStatement(body, test));
              };
              Parser2.prototype.parseWhileStatement = function() {
                var node = this.createNode();
                var body;
                this.expectKeyword("while");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = true;
                  body = this.parseStatement();
                  this.context.inIteration = previousInIteration;
                }
                return this.finalize(node, new Node.WhileStatement(test, body));
              };
              Parser2.prototype.parseForStatement = function() {
                var init = null;
                var test = null;
                var update = null;
                var forIn = true;
                var left, right;
                var node = this.createNode();
                this.expectKeyword("for");
                this.expect("(");
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  if (this.matchKeyword("var")) {
                    init = this.createNode();
                    this.nextToken();
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseVariableDeclarationList({ inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && this.matchKeyword("in")) {
                      var decl = declarations[0];
                      if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                      }
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.nextToken();
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.nextToken();
                      left = init;
                      right = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.expect(";");
                    }
                  } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                    init = this.createNode();
                    var kind = this.nextToken().value;
                    if (!this.context.strict && this.lookahead.value === "in") {
                      init = this.finalize(init, new Node.Identifier(kind));
                      this.nextToken();
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = false;
                      var declarations = this.parseBindingList(kind, { inFor: true });
                      this.context.allowIn = previousAllowIn;
                      if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseExpression();
                        init = null;
                      } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseAssignmentExpression();
                        init = null;
                        forIn = false;
                      } else {
                        this.consumeSemicolon();
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                      }
                    }
                  } else {
                    var initStartToken = this.lookahead;
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    this.context.allowIn = previousAllowIn;
                    if (this.matchKeyword("in")) {
                      if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                      }
                      this.nextToken();
                      this.reinterpretExpressionAsPattern(init);
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else if (this.matchContextualKeyword("of")) {
                      if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                      }
                      this.nextToken();
                      this.reinterpretExpressionAsPattern(init);
                      left = init;
                      right = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      if (this.match(",")) {
                        var initSeq = [init];
                        while (this.match(",")) {
                          this.nextToken();
                          initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                        }
                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                      }
                      this.expect(";");
                    }
                  }
                }
                if (typeof left === "undefined") {
                  if (!this.match(";")) {
                    test = this.parseExpression();
                  }
                  this.expect(";");
                  if (!this.match(")")) {
                    update = this.parseExpression();
                  }
                }
                var body;
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = true;
                  body = this.isolateCoverGrammar(this.parseStatement);
                  this.context.inIteration = previousInIteration;
                }
                return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
              };
              Parser2.prototype.parseContinueStatement = function() {
                var node = this.createNode();
                this.expectKeyword("continue");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  label = id;
                  var key = "$" + id.name;
                  if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.UnknownLabel, id.name);
                  }
                }
                this.consumeSemicolon();
                if (label === null && !this.context.inIteration) {
                  this.throwError(messages_1.Messages.IllegalContinue);
                }
                return this.finalize(node, new Node.ContinueStatement(label));
              };
              Parser2.prototype.parseBreakStatement = function() {
                var node = this.createNode();
                this.expectKeyword("break");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  var key = "$" + id.name;
                  if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.UnknownLabel, id.name);
                  }
                  label = id;
                }
                this.consumeSemicolon();
                if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                  this.throwError(messages_1.Messages.IllegalBreak);
                }
                return this.finalize(node, new Node.BreakStatement(label));
              };
              Parser2.prototype.parseReturnStatement = function() {
                if (!this.context.inFunctionBody) {
                  this.tolerateError(messages_1.Messages.IllegalReturn);
                }
                var node = this.createNode();
                this.expectKeyword("return");
                var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
                var argument = hasArgument ? this.parseExpression() : null;
                this.consumeSemicolon();
                return this.finalize(node, new Node.ReturnStatement(argument));
              };
              Parser2.prototype.parseWithStatement = function() {
                if (this.context.strict) {
                  this.tolerateError(messages_1.Messages.StrictModeWith);
                }
                var node = this.createNode();
                var body;
                this.expectKeyword("with");
                this.expect("(");
                var object = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  body = this.parseStatement();
                }
                return this.finalize(node, new Node.WithStatement(object, body));
              };
              Parser2.prototype.parseSwitchCase = function() {
                var node = this.createNode();
                var test;
                if (this.matchKeyword("default")) {
                  this.nextToken();
                  test = null;
                } else {
                  this.expectKeyword("case");
                  test = this.parseExpression();
                }
                this.expect(":");
                var consequent = [];
                while (true) {
                  if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                    break;
                  }
                  consequent.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.SwitchCase(test, consequent));
              };
              Parser2.prototype.parseSwitchStatement = function() {
                var node = this.createNode();
                this.expectKeyword("switch");
                this.expect("(");
                var discriminant = this.parseExpression();
                this.expect(")");
                var previousInSwitch = this.context.inSwitch;
                this.context.inSwitch = true;
                var cases = [];
                var defaultFound = false;
                this.expect("{");
                while (true) {
                  if (this.match("}")) {
                    break;
                  }
                  var clause = this.parseSwitchCase();
                  if (clause.test === null) {
                    if (defaultFound) {
                      this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                    }
                    defaultFound = true;
                  }
                  cases.push(clause);
                }
                this.expect("}");
                this.context.inSwitch = previousInSwitch;
                return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
              };
              Parser2.prototype.parseLabelledStatement = function() {
                var node = this.createNode();
                var expr = this.parseExpression();
                var statement;
                if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var id = expr;
                  var key = "$" + id.name;
                  if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                  }
                  this.context.labelSet[key] = true;
                  var body = void 0;
                  if (this.matchKeyword("class")) {
                    this.tolerateUnexpectedToken(this.lookahead);
                    body = this.parseClassDeclaration();
                  } else if (this.matchKeyword("function")) {
                    var token = this.lookahead;
                    var declaration = this.parseFunctionDeclaration();
                    if (this.context.strict) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                    } else if (declaration.generator) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                    }
                    body = declaration;
                  } else {
                    body = this.parseStatement();
                  }
                  delete this.context.labelSet[key];
                  statement = new Node.LabeledStatement(id, body);
                } else {
                  this.consumeSemicolon();
                  statement = new Node.ExpressionStatement(expr);
                }
                return this.finalize(node, statement);
              };
              Parser2.prototype.parseThrowStatement = function() {
                var node = this.createNode();
                this.expectKeyword("throw");
                if (this.hasLineTerminator) {
                  this.throwError(messages_1.Messages.NewlineAfterThrow);
                }
                var argument = this.parseExpression();
                this.consumeSemicolon();
                return this.finalize(node, new Node.ThrowStatement(argument));
              };
              Parser2.prototype.parseCatchClause = function() {
                var node = this.createNode();
                this.expectKeyword("catch");
                this.expect("(");
                if (this.match(")")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                var params = [];
                var param = this.parsePattern(params);
                var paramMap = {};
                for (var i = 0; i < params.length; i++) {
                  var key = "$" + params[i].value;
                  if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                    this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                  }
                  paramMap[key] = true;
                }
                if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(param.name)) {
                    this.tolerateError(messages_1.Messages.StrictCatchVariable);
                  }
                }
                this.expect(")");
                var body = this.parseBlock();
                return this.finalize(node, new Node.CatchClause(param, body));
              };
              Parser2.prototype.parseFinallyClause = function() {
                this.expectKeyword("finally");
                return this.parseBlock();
              };
              Parser2.prototype.parseTryStatement = function() {
                var node = this.createNode();
                this.expectKeyword("try");
                var block = this.parseBlock();
                var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                if (!handler && !finalizer) {
                  this.throwError(messages_1.Messages.NoCatchOrFinally);
                }
                return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
              };
              Parser2.prototype.parseDebuggerStatement = function() {
                var node = this.createNode();
                this.expectKeyword("debugger");
                this.consumeSemicolon();
                return this.finalize(node, new Node.DebuggerStatement());
              };
              Parser2.prototype.parseStatement = function() {
                var statement;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    statement = this.parseExpressionStatement();
                    break;
                  case 7:
                    var value = this.lookahead.value;
                    if (value === "{") {
                      statement = this.parseBlock();
                    } else if (value === "(") {
                      statement = this.parseExpressionStatement();
                    } else if (value === ";") {
                      statement = this.parseEmptyStatement();
                    } else {
                      statement = this.parseExpressionStatement();
                    }
                    break;
                  case 3:
                    statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        statement = this.parseBreakStatement();
                        break;
                      case "continue":
                        statement = this.parseContinueStatement();
                        break;
                      case "debugger":
                        statement = this.parseDebuggerStatement();
                        break;
                      case "do":
                        statement = this.parseDoWhileStatement();
                        break;
                      case "for":
                        statement = this.parseForStatement();
                        break;
                      case "function":
                        statement = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        statement = this.parseIfStatement();
                        break;
                      case "return":
                        statement = this.parseReturnStatement();
                        break;
                      case "switch":
                        statement = this.parseSwitchStatement();
                        break;
                      case "throw":
                        statement = this.parseThrowStatement();
                        break;
                      case "try":
                        statement = this.parseTryStatement();
                        break;
                      case "var":
                        statement = this.parseVariableStatement();
                        break;
                      case "while":
                        statement = this.parseWhileStatement();
                        break;
                      case "with":
                        statement = this.parseWithStatement();
                        break;
                      default:
                        statement = this.parseExpressionStatement();
                        break;
                    }
                    break;
                  default:
                    statement = this.throwUnexpectedToken(this.lookahead);
                }
                return statement;
              };
              Parser2.prototype.parseFunctionSourceElements = function() {
                var node = this.createNode();
                this.expect("{");
                var body = this.parseDirectivePrologues();
                var previousLabelSet = this.context.labelSet;
                var previousInIteration = this.context.inIteration;
                var previousInSwitch = this.context.inSwitch;
                var previousInFunctionBody = this.context.inFunctionBody;
                this.context.labelSet = {};
                this.context.inIteration = false;
                this.context.inSwitch = false;
                this.context.inFunctionBody = true;
                while (this.lookahead.type !== 2) {
                  if (this.match("}")) {
                    break;
                  }
                  body.push(this.parseStatementListItem());
                }
                this.expect("}");
                this.context.labelSet = previousLabelSet;
                this.context.inIteration = previousInIteration;
                this.context.inSwitch = previousInSwitch;
                this.context.inFunctionBody = previousInFunctionBody;
                return this.finalize(node, new Node.BlockStatement(body));
              };
              Parser2.prototype.validateParam = function(options, param, name2) {
                var key = "$" + name2;
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(name2)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamName;
                  }
                  if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamDupe;
                  }
                } else if (!options.firstRestricted) {
                  if (this.scanner.isRestrictedWord(name2)) {
                    options.firstRestricted = param;
                    options.message = messages_1.Messages.StrictParamName;
                  } else if (this.scanner.isStrictModeReservedWord(name2)) {
                    options.firstRestricted = param;
                    options.message = messages_1.Messages.StrictReservedWord;
                  } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamDupe;
                  }
                }
                if (typeof Object.defineProperty === "function") {
                  Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
                } else {
                  options.paramSet[key] = true;
                }
              };
              Parser2.prototype.parseRestElement = function(params) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params);
                if (this.match("=")) {
                  this.throwError(messages_1.Messages.DefaultRestParameter);
                }
                if (!this.match(")")) {
                  this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                }
                return this.finalize(node, new Node.RestElement(arg));
              };
              Parser2.prototype.parseFormalParameter = function(options) {
                var params = [];
                var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                for (var i = 0; i < params.length; i++) {
                  this.validateParam(options, params[i], params[i].value);
                }
                options.simple = options.simple && param instanceof Node.Identifier;
                options.params.push(param);
              };
              Parser2.prototype.parseFormalParameters = function(firstRestricted) {
                var options;
                options = {
                  simple: true,
                  params: [],
                  firstRestricted
                };
                this.expect("(");
                if (!this.match(")")) {
                  options.paramSet = {};
                  while (this.lookahead.type !== 2) {
                    this.parseFormalParameter(options);
                    if (this.match(")")) {
                      break;
                    }
                    this.expect(",");
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return {
                  simple: options.simple,
                  params: options.params,
                  stricted: options.stricted,
                  firstRestricted: options.firstRestricted,
                  message: options.message
                };
              };
              Parser2.prototype.matchAsyncFunction = function() {
                var match2 = this.matchContextualKeyword("async");
                if (match2) {
                  var state = this.scanner.saveState();
                  this.scanner.scanComments();
                  var next = this.scanner.lex();
                  this.scanner.restoreState(state);
                  match2 = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                }
                return match2;
              };
              Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                var node = this.createNode();
                var isAsync = this.matchContextualKeyword("async");
                if (isAsync) {
                  this.nextToken();
                }
                this.expectKeyword("function");
                var isGenerator = isAsync ? false : this.match("*");
                if (isGenerator) {
                  this.nextToken();
                }
                var message;
                var id = null;
                var firstRestricted = null;
                if (!identifierIsOptional || !this.match("(")) {
                  var token = this.lookahead;
                  id = this.parseVariableIdentifier();
                  if (this.context.strict) {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                    }
                  } else {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictFunctionName;
                    } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                var previousAllowAwait = this.context.await;
                var previousAllowYield = this.context.allowYield;
                this.context.await = isAsync;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters(firstRestricted);
                var params = formalParameters.params;
                var stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted;
                if (formalParameters.message) {
                  message = formalParameters.message;
                }
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                if (this.context.strict && firstRestricted) {
                  this.throwUnexpectedToken(firstRestricted, message);
                }
                if (this.context.strict && stricted) {
                  this.tolerateUnexpectedToken(stricted, message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                this.context.await = previousAllowAwait;
                this.context.allowYield = previousAllowYield;
                return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
              };
              Parser2.prototype.parseFunctionExpression = function() {
                var node = this.createNode();
                var isAsync = this.matchContextualKeyword("async");
                if (isAsync) {
                  this.nextToken();
                }
                this.expectKeyword("function");
                var isGenerator = isAsync ? false : this.match("*");
                if (isGenerator) {
                  this.nextToken();
                }
                var message;
                var id = null;
                var firstRestricted;
                var previousAllowAwait = this.context.await;
                var previousAllowYield = this.context.allowYield;
                this.context.await = isAsync;
                this.context.allowYield = !isGenerator;
                if (!this.match("(")) {
                  var token = this.lookahead;
                  id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                  if (this.context.strict) {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                    }
                  } else {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictFunctionName;
                    } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                var formalParameters = this.parseFormalParameters(firstRestricted);
                var params = formalParameters.params;
                var stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted;
                if (formalParameters.message) {
                  message = formalParameters.message;
                }
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                if (this.context.strict && firstRestricted) {
                  this.throwUnexpectedToken(firstRestricted, message);
                }
                if (this.context.strict && stricted) {
                  this.tolerateUnexpectedToken(stricted, message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                this.context.await = previousAllowAwait;
                this.context.allowYield = previousAllowYield;
                return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
              };
              Parser2.prototype.parseDirective = function() {
                var token = this.lookahead;
                var node = this.createNode();
                var expr = this.parseExpression();
                var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                this.consumeSemicolon();
                return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
              };
              Parser2.prototype.parseDirectivePrologues = function() {
                var firstRestricted = null;
                var body = [];
                while (true) {
                  var token = this.lookahead;
                  if (token.type !== 8) {
                    break;
                  }
                  var statement = this.parseDirective();
                  body.push(statement);
                  var directive = statement.directive;
                  if (typeof directive !== "string") {
                    break;
                  }
                  if (directive === "use strict") {
                    this.context.strict = true;
                    if (firstRestricted) {
                      this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                    }
                    if (!this.context.allowStrictDirective) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                    }
                  } else {
                    if (!firstRestricted && token.octal) {
                      firstRestricted = token;
                    }
                  }
                }
                return body;
              };
              Parser2.prototype.qualifiedPropertyName = function(token) {
                switch (token.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return true;
                  case 7:
                    return token.value === "[";
                  default:
                    break;
                }
                return false;
              };
              Parser2.prototype.parseGetterMethod = function() {
                var node = this.createNode();
                var isGenerator = false;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                if (formalParameters.params.length > 0) {
                  this.tolerateError(messages_1.Messages.BadGetterArity);
                }
                var method = this.parsePropertyMethod(formalParameters);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              };
              Parser2.prototype.parseSetterMethod = function() {
                var node = this.createNode();
                var isGenerator = false;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                if (formalParameters.params.length !== 1) {
                  this.tolerateError(messages_1.Messages.BadSetterArity);
                } else if (formalParameters.params[0] instanceof Node.RestElement) {
                  this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                }
                var method = this.parsePropertyMethod(formalParameters);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              };
              Parser2.prototype.parseGeneratorMethod = function() {
                var node = this.createNode();
                var isGenerator = true;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var params = this.parseFormalParameters();
                this.context.allowYield = false;
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              };
              Parser2.prototype.isStartOfExpression = function() {
                var start = true;
                var value = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                    break;
                  case 4:
                    start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                    break;
                  default:
                    break;
                }
                return start;
              };
              Parser2.prototype.parseYieldExpression = function() {
                var node = this.createNode();
                this.expectKeyword("yield");
                var argument = null;
                var delegate = false;
                if (!this.hasLineTerminator) {
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = false;
                  delegate = this.match("*");
                  if (delegate) {
                    this.nextToken();
                    argument = this.parseAssignmentExpression();
                  } else if (this.isStartOfExpression()) {
                    argument = this.parseAssignmentExpression();
                  }
                  this.context.allowYield = previousAllowYield;
                }
                return this.finalize(node, new Node.YieldExpression(argument, delegate));
              };
              Parser2.prototype.parseClassElement = function(hasConstructor) {
                var token = this.lookahead;
                var node = this.createNode();
                var kind = "";
                var key = null;
                var value = null;
                var computed = false;
                var method = false;
                var isStatic = false;
                var isAsync = false;
                if (this.match("*")) {
                  this.nextToken();
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  var id = key;
                  if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                    token = this.lookahead;
                    isStatic = true;
                    computed = this.match("[");
                    if (this.match("*")) {
                      this.nextToken();
                    } else {
                      key = this.parseObjectPropertyKey();
                    }
                  }
                  if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                    var punctuator = this.lookahead.value;
                    if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                      isAsync = true;
                      token = this.lookahead;
                      key = this.parseObjectPropertyKey();
                      if (token.type === 3 && token.value === "constructor") {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                      }
                    }
                  }
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token.type === 3) {
                  if (token.value === "get" && lookaheadPropertyKey) {
                    kind = "get";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    this.context.allowYield = false;
                    value = this.parseGetterMethod();
                  } else if (token.value === "set" && lookaheadPropertyKey) {
                    kind = "set";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    value = this.parseSetterMethod();
                  }
                } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                  kind = "init";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseGeneratorMethod();
                  method = true;
                }
                if (!kind && key && this.match("(")) {
                  kind = "init";
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                }
                if (!kind) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                if (kind === "init") {
                  kind = "method";
                }
                if (!computed) {
                  if (isStatic && this.isPropertyKey(key, "prototype")) {
                    this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                  }
                  if (!isStatic && this.isPropertyKey(key, "constructor")) {
                    if (kind !== "method" || !method || value && value.generator) {
                      this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                    }
                    if (hasConstructor.value) {
                      this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                    } else {
                      hasConstructor.value = true;
                    }
                    kind = "constructor";
                  }
                }
                return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
              };
              Parser2.prototype.parseClassElementList = function() {
                var body = [];
                var hasConstructor = { value: false };
                this.expect("{");
                while (!this.match("}")) {
                  if (this.match(";")) {
                    this.nextToken();
                  } else {
                    body.push(this.parseClassElement(hasConstructor));
                  }
                }
                this.expect("}");
                return body;
              };
              Parser2.prototype.parseClassBody = function() {
                var node = this.createNode();
                var elementList = this.parseClassElementList();
                return this.finalize(node, new Node.ClassBody(elementList));
              };
              Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
                var node = this.createNode();
                var previousStrict = this.context.strict;
                this.context.strict = true;
                this.expectKeyword("class");
                var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
                var superClass = null;
                if (this.matchKeyword("extends")) {
                  this.nextToken();
                  superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                }
                var classBody = this.parseClassBody();
                this.context.strict = previousStrict;
                return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
              };
              Parser2.prototype.parseClassExpression = function() {
                var node = this.createNode();
                var previousStrict = this.context.strict;
                this.context.strict = true;
                this.expectKeyword("class");
                var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
                var superClass = null;
                if (this.matchKeyword("extends")) {
                  this.nextToken();
                  superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                }
                var classBody = this.parseClassBody();
                this.context.strict = previousStrict;
                return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
              };
              Parser2.prototype.parseModule = function() {
                this.context.strict = true;
                this.context.isModule = true;
                this.scanner.isModule = true;
                var node = this.createNode();
                var body = this.parseDirectivePrologues();
                while (this.lookahead.type !== 2) {
                  body.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.Module(body));
              };
              Parser2.prototype.parseScript = function() {
                var node = this.createNode();
                var body = this.parseDirectivePrologues();
                while (this.lookahead.type !== 2) {
                  body.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.Script(body));
              };
              Parser2.prototype.parseModuleSpecifier = function() {
                var node = this.createNode();
                if (this.lookahead.type !== 8) {
                  this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                }
                var token = this.nextToken();
                var raw = this.getTokenRaw(token);
                return this.finalize(node, new Node.Literal(token.value, raw));
              };
              Parser2.prototype.parseImportSpecifier = function() {
                var node = this.createNode();
                var imported;
                var local;
                if (this.lookahead.type === 3) {
                  imported = this.parseVariableIdentifier();
                  local = imported;
                  if (this.matchContextualKeyword("as")) {
                    this.nextToken();
                    local = this.parseVariableIdentifier();
                  }
                } else {
                  imported = this.parseIdentifierName();
                  local = imported;
                  if (this.matchContextualKeyword("as")) {
                    this.nextToken();
                    local = this.parseVariableIdentifier();
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                }
                return this.finalize(node, new Node.ImportSpecifier(local, imported));
              };
              Parser2.prototype.parseNamedImports = function() {
                this.expect("{");
                var specifiers = [];
                while (!this.match("}")) {
                  specifiers.push(this.parseImportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                return specifiers;
              };
              Parser2.prototype.parseImportDefaultSpecifier = function() {
                var node = this.createNode();
                var local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportDefaultSpecifier(local));
              };
              Parser2.prototype.parseImportNamespaceSpecifier = function() {
                var node = this.createNode();
                this.expect("*");
                if (!this.matchContextualKeyword("as")) {
                  this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                }
                this.nextToken();
                var local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
              };
              Parser2.prototype.parseImportDeclaration = function() {
                if (this.context.inFunctionBody) {
                  this.throwError(messages_1.Messages.IllegalImportDeclaration);
                }
                var node = this.createNode();
                this.expectKeyword("import");
                var src;
                var specifiers = [];
                if (this.lookahead.type === 8) {
                  src = this.parseModuleSpecifier();
                } else {
                  if (this.match("{")) {
                    specifiers = specifiers.concat(this.parseNamedImports());
                  } else if (this.match("*")) {
                    specifiers.push(this.parseImportNamespaceSpecifier());
                  } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                    specifiers.push(this.parseImportDefaultSpecifier());
                    if (this.match(",")) {
                      this.nextToken();
                      if (this.match("*")) {
                        specifiers.push(this.parseImportNamespaceSpecifier());
                      } else if (this.match("{")) {
                        specifiers = specifiers.concat(this.parseNamedImports());
                      } else {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    }
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                  if (!this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  src = this.parseModuleSpecifier();
                }
                this.consumeSemicolon();
                return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
              };
              Parser2.prototype.parseExportSpecifier = function() {
                var node = this.createNode();
                var local = this.parseIdentifierName();
                var exported = local;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  exported = this.parseIdentifierName();
                }
                return this.finalize(node, new Node.ExportSpecifier(local, exported));
              };
              Parser2.prototype.parseExportDeclaration = function() {
                if (this.context.inFunctionBody) {
                  this.throwError(messages_1.Messages.IllegalExportDeclaration);
                }
                var node = this.createNode();
                this.expectKeyword("export");
                var exportDeclaration;
                if (this.matchKeyword("default")) {
                  this.nextToken();
                  if (this.matchKeyword("function")) {
                    var declaration = this.parseFunctionDeclaration(true);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchKeyword("class")) {
                    var declaration = this.parseClassDeclaration(true);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchContextualKeyword("async")) {
                    var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else {
                    if (this.matchContextualKeyword("from")) {
                      this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                    }
                    var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                    this.consumeSemicolon();
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  }
                } else if (this.match("*")) {
                  this.nextToken();
                  if (!this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  var src = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
                } else if (this.lookahead.type === 4) {
                  var declaration = void 0;
                  switch (this.lookahead.value) {
                    case "let":
                    case "const":
                      declaration = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      declaration = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else if (this.matchAsyncFunction()) {
                  var declaration = this.parseFunctionDeclaration();
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else {
                  var specifiers = [];
                  var source = null;
                  var isExportFromIdentifier = false;
                  this.expect("{");
                  while (!this.match("}")) {
                    isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                    specifiers.push(this.parseExportSpecifier());
                    if (!this.match("}")) {
                      this.expect(",");
                    }
                  }
                  this.expect("}");
                  if (this.matchContextualKeyword("from")) {
                    this.nextToken();
                    source = this.parseModuleSpecifier();
                    this.consumeSemicolon();
                  } else if (isExportFromIdentifier) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  } else {
                    this.consumeSemicolon();
                  }
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
                }
                return exportDeclaration;
              };
              return Parser2;
            }();
            exports3.Parser = Parser;
          },
          /* 9 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            function assert19(condition, message) {
              if (!condition) {
                throw new Error("ASSERT: " + message);
              }
            }
            exports3.assert = assert19;
          },
          /* 10 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var ErrorHandler = function() {
              function ErrorHandler2() {
                this.errors = [];
                this.tolerant = false;
              }
              ErrorHandler2.prototype.recordError = function(error4) {
                this.errors.push(error4);
              };
              ErrorHandler2.prototype.tolerate = function(error4) {
                if (this.tolerant) {
                  this.recordError(error4);
                } else {
                  throw error4;
                }
              };
              ErrorHandler2.prototype.constructError = function(msg, column) {
                var error4 = new Error(msg);
                try {
                  throw error4;
                } catch (base) {
                  if (Object.create && Object.defineProperty) {
                    error4 = Object.create(base);
                    Object.defineProperty(error4, "column", { value: column });
                  }
                }
                return error4;
              };
              ErrorHandler2.prototype.createError = function(index, line, col, description) {
                var msg = "Line " + line + ": " + description;
                var error4 = this.constructError(msg, col);
                error4.index = index;
                error4.lineNumber = line;
                error4.description = description;
                return error4;
              };
              ErrorHandler2.prototype.throwError = function(index, line, col, description) {
                throw this.createError(index, line, col, description);
              };
              ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
                var error4 = this.createError(index, line, col, description);
                if (this.tolerant) {
                  this.recordError(error4);
                } else {
                  throw error4;
                }
              };
              return ErrorHandler2;
            }();
            exports3.ErrorHandler = ErrorHandler;
          },
          /* 11 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.Messages = {
              BadGetterArity: "Getter must not have any formal parameters",
              BadSetterArity: "Setter must have exactly one formal parameter",
              BadSetterRestParameter: "Setter function argument must not be a rest parameter",
              ConstructorIsAsync: "Class constructor may not be an async method",
              ConstructorSpecialMethod: "Class constructor may not be an accessor",
              DeclarationMissingInitializer: "Missing initializer in %0 declaration",
              DefaultRestParameter: "Unexpected token =",
              DuplicateBinding: "Duplicate binding %0",
              DuplicateConstructor: "A class may only have one constructor",
              DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
              ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
              GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
              IllegalBreak: "Illegal break statement",
              IllegalContinue: "Illegal continue statement",
              IllegalExportDeclaration: "Unexpected token",
              IllegalImportDeclaration: "Unexpected token",
              IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
              IllegalReturn: "Illegal return statement",
              InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
              InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
              InvalidLHSInAssignment: "Invalid left-hand side in assignment",
              InvalidLHSInForIn: "Invalid left-hand side in for-in",
              InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
              InvalidModuleSpecifier: "Unexpected token",
              InvalidRegExp: "Invalid regular expression",
              LetInLexicalBinding: "let is disallowed as a lexically bound name",
              MissingFromClause: "Unexpected token",
              MultipleDefaultsInSwitch: "More than one default clause in switch statement",
              NewlineAfterThrow: "Illegal newline after throw",
              NoAsAfterImportNamespace: "Unexpected token",
              NoCatchOrFinally: "Missing catch or finally after try",
              ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
              Redeclaration: "%0 '%1' has already been declared",
              StaticPrototype: "Classes may not have static property named prototype",
              StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
              StrictDelete: "Delete of an unqualified identifier in strict mode.",
              StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
              StrictFunctionName: "Function name may not be eval or arguments in strict mode",
              StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
              StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
              StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
              StrictModeWith: "Strict mode code may not include a with statement",
              StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
              StrictParamDupe: "Strict mode function may not have duplicate parameter names",
              StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
              StrictReservedWord: "Use of future reserved word in strict mode",
              StrictVarName: "Variable name may not be eval or arguments in strict mode",
              TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
              UnexpectedEOS: "Unexpected end of input",
              UnexpectedIdentifier: "Unexpected identifier",
              UnexpectedNumber: "Unexpected number",
              UnexpectedReserved: "Unexpected reserved word",
              UnexpectedString: "Unexpected string",
              UnexpectedTemplate: "Unexpected quasi %0",
              UnexpectedToken: "Unexpected token %0",
              UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
              UnknownLabel: "Undefined label '%0'",
              UnterminatedRegExp: "Invalid regular expression: missing /"
            };
          },
          /* 12 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var assert_1 = __webpack_require__(9);
            var character_1 = __webpack_require__(4);
            var messages_1 = __webpack_require__(11);
            function hexValue(ch) {
              return "0123456789abcdef".indexOf(ch.toLowerCase());
            }
            function octalValue(ch) {
              return "01234567".indexOf(ch);
            }
            var Scanner = function() {
              function Scanner2(code, handler) {
                this.source = code;
                this.errorHandler = handler;
                this.trackComment = false;
                this.isModule = false;
                this.length = code.length;
                this.index = 0;
                this.lineNumber = code.length > 0 ? 1 : 0;
                this.lineStart = 0;
                this.curlyStack = [];
              }
              Scanner2.prototype.saveState = function() {
                return {
                  index: this.index,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart
                };
              };
              Scanner2.prototype.restoreState = function(state) {
                this.index = state.index;
                this.lineNumber = state.lineNumber;
                this.lineStart = state.lineStart;
              };
              Scanner2.prototype.eof = function() {
                return this.index >= this.length;
              };
              Scanner2.prototype.throwUnexpectedToken = function(message) {
                if (message === void 0) {
                  message = messages_1.Messages.UnexpectedTokenIllegal;
                }
                return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              };
              Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                if (message === void 0) {
                  message = messages_1.Messages.UnexpectedTokenIllegal;
                }
                this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              };
              Scanner2.prototype.skipSingleLineComment = function(offset) {
                var comments = [];
                var start, loc;
                if (this.trackComment) {
                  comments = [];
                  start = this.index - offset;
                  loc = {
                    start: {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - offset
                    },
                    end: {}
                  };
                }
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  ++this.index;
                  if (character_1.Character.isLineTerminator(ch)) {
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart - 1
                      };
                      var entry = {
                        multiLine: false,
                        slice: [start + offset, this.index - 1],
                        range: [start, this.index - 1],
                        loc
                      };
                      comments.push(entry);
                    }
                    if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    this.lineStart = this.index;
                    return comments;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: false,
                    slice: [start + offset, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments.push(entry);
                }
                return comments;
              };
              Scanner2.prototype.skipMultiLineComment = function() {
                var comments = [];
                var start, loc;
                if (this.trackComment) {
                  comments = [];
                  start = this.index - 2;
                  loc = {
                    start: {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 2
                    },
                    end: {}
                  };
                }
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isLineTerminator(ch)) {
                    if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    ++this.index;
                    this.lineStart = this.index;
                  } else if (ch === 42) {
                    if (this.source.charCodeAt(this.index + 1) === 47) {
                      this.index += 2;
                      if (this.trackComment) {
                        loc.end = {
                          line: this.lineNumber,
                          column: this.index - this.lineStart
                        };
                        var entry = {
                          multiLine: true,
                          slice: [start + 2, this.index - 2],
                          range: [start, this.index],
                          loc
                        };
                        comments.push(entry);
                      }
                      return comments;
                    }
                    ++this.index;
                  } else {
                    ++this.index;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: true,
                    slice: [start + 2, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments.push(entry);
                }
                this.tolerateUnexpectedToken();
                return comments;
              };
              Scanner2.prototype.scanComments = function() {
                var comments;
                if (this.trackComment) {
                  comments = [];
                }
                var start = this.index === 0;
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isWhiteSpace(ch)) {
                    ++this.index;
                  } else if (character_1.Character.isLineTerminator(ch)) {
                    ++this.index;
                    if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    this.lineStart = this.index;
                    start = true;
                  } else if (ch === 47) {
                    ch = this.source.charCodeAt(this.index + 1);
                    if (ch === 47) {
                      this.index += 2;
                      var comment = this.skipSingleLineComment(2);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                      start = true;
                    } else if (ch === 42) {
                      this.index += 2;
                      var comment = this.skipMultiLineComment();
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else if (start && ch === 45) {
                    if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                      this.index += 3;
                      var comment = this.skipSingleLineComment(3);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else if (ch === 60 && !this.isModule) {
                    if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                      this.index += 4;
                      var comment = this.skipSingleLineComment(4);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                }
                return comments;
              };
              Scanner2.prototype.isFutureReservedWord = function(id) {
                switch (id) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return true;
                  default:
                    return false;
                }
              };
              Scanner2.prototype.isStrictModeReservedWord = function(id) {
                switch (id) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              };
              Scanner2.prototype.isRestrictedWord = function(id) {
                return id === "eval" || id === "arguments";
              };
              Scanner2.prototype.isKeyword = function(id) {
                switch (id.length) {
                  case 2:
                    return id === "if" || id === "in" || id === "do";
                  case 3:
                    return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                  case 4:
                    return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                  case 5:
                    return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                  case 6:
                    return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                  case 7:
                    return id === "default" || id === "finally" || id === "extends";
                  case 8:
                    return id === "function" || id === "continue" || id === "debugger";
                  case 10:
                    return id === "instanceof";
                  default:
                    return false;
                }
              };
              Scanner2.prototype.codePointAt = function(i) {
                var cp = this.source.charCodeAt(i);
                if (cp >= 55296 && cp <= 56319) {
                  var second = this.source.charCodeAt(i + 1);
                  if (second >= 56320 && second <= 57343) {
                    var first3 = cp;
                    cp = (first3 - 55296) * 1024 + second - 56320 + 65536;
                  }
                }
                return cp;
              };
              Scanner2.prototype.scanHexEscape = function(prefix) {
                var len = prefix === "u" ? 4 : 2;
                var code = 0;
                for (var i = 0; i < len; ++i) {
                  if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                    code = code * 16 + hexValue(this.source[this.index++]);
                  } else {
                    return null;
                  }
                }
                return String.fromCharCode(code);
              };
              Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                var ch = this.source[this.index];
                var code = 0;
                if (ch === "}") {
                  this.throwUnexpectedToken();
                }
                while (!this.eof()) {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                    break;
                  }
                  code = code * 16 + hexValue(ch);
                }
                if (code > 1114111 || ch !== "}") {
                  this.throwUnexpectedToken();
                }
                return character_1.Character.fromCodePoint(code);
              };
              Scanner2.prototype.getIdentifier = function() {
                var start = this.index++;
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (ch === 92) {
                    this.index = start;
                    return this.getComplexIdentifier();
                  } else if (ch >= 55296 && ch < 57343) {
                    this.index = start;
                    return this.getComplexIdentifier();
                  }
                  if (character_1.Character.isIdentifierPart(ch)) {
                    ++this.index;
                  } else {
                    break;
                  }
                }
                return this.source.slice(start, this.index);
              };
              Scanner2.prototype.getComplexIdentifier = function() {
                var cp = this.codePointAt(this.index);
                var id = character_1.Character.fromCodePoint(cp);
                this.index += id.length;
                var ch;
                if (cp === 92) {
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id = ch;
                }
                while (!this.eof()) {
                  cp = this.codePointAt(this.index);
                  if (!character_1.Character.isIdentifierPart(cp)) {
                    break;
                  }
                  ch = character_1.Character.fromCodePoint(cp);
                  id += ch;
                  this.index += ch.length;
                  if (cp === 92) {
                    id = id.substr(0, id.length - 1);
                    if (this.source.charCodeAt(this.index) !== 117) {
                      this.throwUnexpectedToken();
                    }
                    ++this.index;
                    if (this.source[this.index] === "{") {
                      ++this.index;
                      ch = this.scanUnicodeCodePointEscape();
                    } else {
                      ch = this.scanHexEscape("u");
                      if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken();
                      }
                    }
                    id += ch;
                  }
                }
                return id;
              };
              Scanner2.prototype.octalToDecimal = function(ch) {
                var octal = ch !== "0";
                var code = octalValue(ch);
                if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  octal = true;
                  code = code * 8 + octalValue(this.source[this.index++]);
                  if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                    code = code * 8 + octalValue(this.source[this.index++]);
                  }
                }
                return {
                  code,
                  octal
                };
              };
              Scanner2.prototype.scanIdentifier = function() {
                var type;
                var start = this.index;
                var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                if (id.length === 1) {
                  type = 3;
                } else if (this.isKeyword(id)) {
                  type = 4;
                } else if (id === "null") {
                  type = 5;
                } else if (id === "true" || id === "false") {
                  type = 1;
                } else {
                  type = 3;
                }
                if (type !== 3 && start + id.length !== this.index) {
                  var restore = this.index;
                  this.index = start;
                  this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                  this.index = restore;
                }
                return {
                  type,
                  value: id,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanPunctuator = function() {
                var start = this.index;
                var str = this.source[this.index];
                switch (str) {
                  case "(":
                  case "{":
                    if (str === "{") {
                      this.curlyStack.push("{");
                    }
                    ++this.index;
                    break;
                  case ".":
                    ++this.index;
                    if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                      this.index += 2;
                      str = "...";
                    }
                    break;
                  case "}":
                    ++this.index;
                    this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    str = this.source.substr(this.index, 4);
                    if (str === ">>>=") {
                      this.index += 4;
                    } else {
                      str = str.substr(0, 3);
                      if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                        this.index += 3;
                      } else {
                        str = str.substr(0, 2);
                        if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                          this.index += 2;
                        } else {
                          str = this.source[this.index];
                          if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                            ++this.index;
                          }
                        }
                      }
                    }
                }
                if (this.index === start) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 7,
                  value: str,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanHexLiteral = function(start) {
                var num = "";
                while (!this.eof()) {
                  if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseInt("0x" + num, 16),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanBinaryLiteral = function(start) {
                var num = "";
                var ch;
                while (!this.eof()) {
                  ch = this.source[this.index];
                  if (ch !== "0" && ch !== "1") {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (!this.eof()) {
                  ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                    this.throwUnexpectedToken();
                  }
                }
                return {
                  type: 6,
                  value: parseInt(num, 2),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
                var num = "";
                var octal = false;
                if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                  octal = true;
                  num = "0" + this.source[this.index++];
                } else {
                  ++this.index;
                }
                while (!this.eof()) {
                  if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (!octal && num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseInt(num, 8),
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.isImplicitOctalLiteral = function() {
                for (var i = this.index + 1; i < this.length; ++i) {
                  var ch = this.source[i];
                  if (ch === "8" || ch === "9") {
                    return false;
                  }
                  if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    return true;
                  }
                }
                return true;
              };
              Scanner2.prototype.scanNumericLiteral = function() {
                var start = this.index;
                var ch = this.source[start];
                assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                var num = "";
                if (ch !== ".") {
                  num = this.source[this.index++];
                  ch = this.source[this.index];
                  if (num === "0") {
                    if (ch === "x" || ch === "X") {
                      ++this.index;
                      return this.scanHexLiteral(start);
                    }
                    if (ch === "b" || ch === "B") {
                      ++this.index;
                      return this.scanBinaryLiteral(start);
                    }
                    if (ch === "o" || ch === "O") {
                      return this.scanOctalLiteral(ch, start);
                    }
                    if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                      if (this.isImplicitOctalLiteral()) {
                        return this.scanOctalLiteral(ch, start);
                      }
                    }
                  }
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                  ch = this.source[this.index];
                }
                if (ch === ".") {
                  num += this.source[this.index++];
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                  ch = this.source[this.index];
                }
                if (ch === "e" || ch === "E") {
                  num += this.source[this.index++];
                  ch = this.source[this.index];
                  if (ch === "+" || ch === "-") {
                    num += this.source[this.index++];
                  }
                  if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      num += this.source[this.index++];
                    }
                  } else {
                    this.throwUnexpectedToken();
                  }
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseFloat(num),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanStringLiteral = function() {
                var start = this.index;
                var quote = this.source[start];
                assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                ++this.index;
                var octal = false;
                var str = "";
                while (!this.eof()) {
                  var ch = this.source[this.index++];
                  if (ch === quote) {
                    quote = "";
                    break;
                  } else if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      switch (ch) {
                        case "u":
                          if (this.source[this.index] === "{") {
                            ++this.index;
                            str += this.scanUnicodeCodePointEscape();
                          } else {
                            var unescaped_1 = this.scanHexEscape(ch);
                            if (unescaped_1 === null) {
                              this.throwUnexpectedToken();
                            }
                            str += unescaped_1;
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          if (unescaped === null) {
                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                          }
                          str += unescaped;
                          break;
                        case "n":
                          str += "\n";
                          break;
                        case "r":
                          str += "\r";
                          break;
                        case "t":
                          str += "	";
                          break;
                        case "b":
                          str += "\b";
                          break;
                        case "f":
                          str += "\f";
                          break;
                        case "v":
                          str += "\v";
                          break;
                        case "8":
                        case "9":
                          str += ch;
                          this.tolerateUnexpectedToken();
                          break;
                        default:
                          if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            var octToDec = this.octalToDecimal(ch);
                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                          } else {
                            str += ch;
                          }
                          break;
                      }
                    } else {
                      ++this.lineNumber;
                      if (ch === "\r" && this.source[this.index] === "\n") {
                        ++this.index;
                      }
                      this.lineStart = this.index;
                    }
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    break;
                  } else {
                    str += ch;
                  }
                }
                if (quote !== "") {
                  this.index = start;
                  this.throwUnexpectedToken();
                }
                return {
                  type: 8,
                  value: str,
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanTemplate = function() {
                var cooked = "";
                var terminated = false;
                var start = this.index;
                var head = this.source[start] === "`";
                var tail = false;
                var rawOffset = 2;
                ++this.index;
                while (!this.eof()) {
                  var ch = this.source[this.index++];
                  if (ch === "`") {
                    rawOffset = 1;
                    tail = true;
                    terminated = true;
                    break;
                  } else if (ch === "$") {
                    if (this.source[this.index] === "{") {
                      this.curlyStack.push("${");
                      ++this.index;
                      terminated = true;
                      break;
                    }
                    cooked += ch;
                  } else if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      switch (ch) {
                        case "n":
                          cooked += "\n";
                          break;
                        case "r":
                          cooked += "\r";
                          break;
                        case "t":
                          cooked += "	";
                          break;
                        case "u":
                          if (this.source[this.index] === "{") {
                            ++this.index;
                            cooked += this.scanUnicodeCodePointEscape();
                          } else {
                            var restore = this.index;
                            var unescaped_2 = this.scanHexEscape(ch);
                            if (unescaped_2 !== null) {
                              cooked += unescaped_2;
                            } else {
                              this.index = restore;
                              cooked += ch;
                            }
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          if (unescaped === null) {
                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                          }
                          cooked += unescaped;
                          break;
                        case "b":
                          cooked += "\b";
                          break;
                        case "f":
                          cooked += "\f";
                          break;
                        case "v":
                          cooked += "\v";
                          break;
                        default:
                          if (ch === "0") {
                            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                              this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                            }
                            cooked += "\0";
                          } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          } else {
                            cooked += ch;
                          }
                          break;
                      }
                    } else {
                      ++this.lineNumber;
                      if (ch === "\r" && this.source[this.index] === "\n") {
                        ++this.index;
                      }
                      this.lineStart = this.index;
                    }
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                    cooked += "\n";
                  } else {
                    cooked += ch;
                  }
                }
                if (!terminated) {
                  this.throwUnexpectedToken();
                }
                if (!head) {
                  this.curlyStack.pop();
                }
                return {
                  type: 10,
                  value: this.source.slice(start + 1, this.index - rawOffset),
                  cooked,
                  head,
                  tail,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.testRegExp = function(pattern, flags) {
                var astralSubstitute = "\uFFFF";
                var tmp = pattern;
                var self = this;
                if (flags.indexOf("u") >= 0) {
                  tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 1114111) {
                      self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                    }
                    if (codePoint <= 65535) {
                      return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                  }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                }
                try {
                  RegExp(tmp);
                } catch (e) {
                  this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(pattern, flags);
                } catch (exception) {
                  return null;
                }
              };
              Scanner2.prototype.scanRegExpBody = function() {
                var ch = this.source[this.index];
                assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
                var str = this.source[this.index++];
                var classMarker = false;
                var terminated = false;
                while (!this.eof()) {
                  ch = this.source[this.index++];
                  str += ch;
                  if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    }
                    str += ch;
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  } else if (classMarker) {
                    if (ch === "]") {
                      classMarker = false;
                    }
                  } else {
                    if (ch === "/") {
                      terminated = true;
                      break;
                    } else if (ch === "[") {
                      classMarker = true;
                    }
                  }
                }
                if (!terminated) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                return str.substr(1, str.length - 2);
              };
              Scanner2.prototype.scanRegExpFlags = function() {
                var str = "";
                var flags = "";
                while (!this.eof()) {
                  var ch = this.source[this.index];
                  if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                    break;
                  }
                  ++this.index;
                  if (ch === "\\" && !this.eof()) {
                    ch = this.source[this.index];
                    if (ch === "u") {
                      ++this.index;
                      var restore = this.index;
                      var char = this.scanHexEscape("u");
                      if (char !== null) {
                        flags += char;
                        for (str += "\\u"; restore < this.index; ++restore) {
                          str += this.source[restore];
                        }
                      } else {
                        this.index = restore;
                        flags += "u";
                        str += "\\u";
                      }
                      this.tolerateUnexpectedToken();
                    } else {
                      str += "\\";
                      this.tolerateUnexpectedToken();
                    }
                  } else {
                    flags += ch;
                    str += ch;
                  }
                }
                return flags;
              };
              Scanner2.prototype.scanRegExp = function() {
                var start = this.index;
                var pattern = this.scanRegExpBody();
                var flags = this.scanRegExpFlags();
                var value = this.testRegExp(pattern, flags);
                return {
                  type: 9,
                  value: "",
                  pattern,
                  flags,
                  regex: value,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.lex = function() {
                if (this.eof()) {
                  return {
                    type: 2,
                    value: "",
                    lineNumber: this.lineNumber,
                    lineStart: this.lineStart,
                    start: this.index,
                    end: this.index
                  };
                }
                var cp = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(cp)) {
                  return this.scanIdentifier();
                }
                if (cp === 40 || cp === 41 || cp === 59) {
                  return this.scanPunctuator();
                }
                if (cp === 39 || cp === 34) {
                  return this.scanStringLiteral();
                }
                if (cp === 46) {
                  if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                    return this.scanNumericLiteral();
                  }
                  return this.scanPunctuator();
                }
                if (character_1.Character.isDecimalDigit(cp)) {
                  return this.scanNumericLiteral();
                }
                if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                  return this.scanTemplate();
                }
                if (cp >= 55296 && cp < 57343) {
                  if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                    return this.scanIdentifier();
                  }
                }
                return this.scanPunctuator();
              };
              return Scanner2;
            }();
            exports3.Scanner = Scanner;
          },
          /* 13 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.TokenName = {};
            exports3.TokenName[
              1
              /* BooleanLiteral */
            ] = "Boolean";
            exports3.TokenName[
              2
              /* EOF */
            ] = "<end>";
            exports3.TokenName[
              3
              /* Identifier */
            ] = "Identifier";
            exports3.TokenName[
              4
              /* Keyword */
            ] = "Keyword";
            exports3.TokenName[
              5
              /* NullLiteral */
            ] = "Null";
            exports3.TokenName[
              6
              /* NumericLiteral */
            ] = "Numeric";
            exports3.TokenName[
              7
              /* Punctuator */
            ] = "Punctuator";
            exports3.TokenName[
              8
              /* StringLiteral */
            ] = "String";
            exports3.TokenName[
              9
              /* RegularExpression */
            ] = "RegularExpression";
            exports3.TokenName[
              10
              /* Template */
            ] = "Template";
          },
          /* 14 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.XHTMLEntities = {
              quot: '"',
              amp: "&",
              apos: "'",
              gt: ">",
              nbsp: "\xA0",
              iexcl: "\xA1",
              cent: "\xA2",
              pound: "\xA3",
              curren: "\xA4",
              yen: "\xA5",
              brvbar: "\xA6",
              sect: "\xA7",
              uml: "\xA8",
              copy: "\xA9",
              ordf: "\xAA",
              laquo: "\xAB",
              not: "\xAC",
              shy: "\xAD",
              reg: "\xAE",
              macr: "\xAF",
              deg: "\xB0",
              plusmn: "\xB1",
              sup2: "\xB2",
              sup3: "\xB3",
              acute: "\xB4",
              micro: "\xB5",
              para: "\xB6",
              middot: "\xB7",
              cedil: "\xB8",
              sup1: "\xB9",
              ordm: "\xBA",
              raquo: "\xBB",
              frac14: "\xBC",
              frac12: "\xBD",
              frac34: "\xBE",
              iquest: "\xBF",
              Agrave: "\xC0",
              Aacute: "\xC1",
              Acirc: "\xC2",
              Atilde: "\xC3",
              Auml: "\xC4",
              Aring: "\xC5",
              AElig: "\xC6",
              Ccedil: "\xC7",
              Egrave: "\xC8",
              Eacute: "\xC9",
              Ecirc: "\xCA",
              Euml: "\xCB",
              Igrave: "\xCC",
              Iacute: "\xCD",
              Icirc: "\xCE",
              Iuml: "\xCF",
              ETH: "\xD0",
              Ntilde: "\xD1",
              Ograve: "\xD2",
              Oacute: "\xD3",
              Ocirc: "\xD4",
              Otilde: "\xD5",
              Ouml: "\xD6",
              times: "\xD7",
              Oslash: "\xD8",
              Ugrave: "\xD9",
              Uacute: "\xDA",
              Ucirc: "\xDB",
              Uuml: "\xDC",
              Yacute: "\xDD",
              THORN: "\xDE",
              szlig: "\xDF",
              agrave: "\xE0",
              aacute: "\xE1",
              acirc: "\xE2",
              atilde: "\xE3",
              auml: "\xE4",
              aring: "\xE5",
              aelig: "\xE6",
              ccedil: "\xE7",
              egrave: "\xE8",
              eacute: "\xE9",
              ecirc: "\xEA",
              euml: "\xEB",
              igrave: "\xEC",
              iacute: "\xED",
              icirc: "\xEE",
              iuml: "\xEF",
              eth: "\xF0",
              ntilde: "\xF1",
              ograve: "\xF2",
              oacute: "\xF3",
              ocirc: "\xF4",
              otilde: "\xF5",
              ouml: "\xF6",
              divide: "\xF7",
              oslash: "\xF8",
              ugrave: "\xF9",
              uacute: "\xFA",
              ucirc: "\xFB",
              uuml: "\xFC",
              yacute: "\xFD",
              thorn: "\xFE",
              yuml: "\xFF",
              OElig: "\u0152",
              oelig: "\u0153",
              Scaron: "\u0160",
              scaron: "\u0161",
              Yuml: "\u0178",
              fnof: "\u0192",
              circ: "\u02C6",
              tilde: "\u02DC",
              Alpha: "\u0391",
              Beta: "\u0392",
              Gamma: "\u0393",
              Delta: "\u0394",
              Epsilon: "\u0395",
              Zeta: "\u0396",
              Eta: "\u0397",
              Theta: "\u0398",
              Iota: "\u0399",
              Kappa: "\u039A",
              Lambda: "\u039B",
              Mu: "\u039C",
              Nu: "\u039D",
              Xi: "\u039E",
              Omicron: "\u039F",
              Pi: "\u03A0",
              Rho: "\u03A1",
              Sigma: "\u03A3",
              Tau: "\u03A4",
              Upsilon: "\u03A5",
              Phi: "\u03A6",
              Chi: "\u03A7",
              Psi: "\u03A8",
              Omega: "\u03A9",
              alpha: "\u03B1",
              beta: "\u03B2",
              gamma: "\u03B3",
              delta: "\u03B4",
              epsilon: "\u03B5",
              zeta: "\u03B6",
              eta: "\u03B7",
              theta: "\u03B8",
              iota: "\u03B9",
              kappa: "\u03BA",
              lambda: "\u03BB",
              mu: "\u03BC",
              nu: "\u03BD",
              xi: "\u03BE",
              omicron: "\u03BF",
              pi: "\u03C0",
              rho: "\u03C1",
              sigmaf: "\u03C2",
              sigma: "\u03C3",
              tau: "\u03C4",
              upsilon: "\u03C5",
              phi: "\u03C6",
              chi: "\u03C7",
              psi: "\u03C8",
              omega: "\u03C9",
              thetasym: "\u03D1",
              upsih: "\u03D2",
              piv: "\u03D6",
              ensp: "\u2002",
              emsp: "\u2003",
              thinsp: "\u2009",
              zwnj: "\u200C",
              zwj: "\u200D",
              lrm: "\u200E",
              rlm: "\u200F",
              ndash: "\u2013",
              mdash: "\u2014",
              lsquo: "\u2018",
              rsquo: "\u2019",
              sbquo: "\u201A",
              ldquo: "\u201C",
              rdquo: "\u201D",
              bdquo: "\u201E",
              dagger: "\u2020",
              Dagger: "\u2021",
              bull: "\u2022",
              hellip: "\u2026",
              permil: "\u2030",
              prime: "\u2032",
              Prime: "\u2033",
              lsaquo: "\u2039",
              rsaquo: "\u203A",
              oline: "\u203E",
              frasl: "\u2044",
              euro: "\u20AC",
              image: "\u2111",
              weierp: "\u2118",
              real: "\u211C",
              trade: "\u2122",
              alefsym: "\u2135",
              larr: "\u2190",
              uarr: "\u2191",
              rarr: "\u2192",
              darr: "\u2193",
              harr: "\u2194",
              crarr: "\u21B5",
              lArr: "\u21D0",
              uArr: "\u21D1",
              rArr: "\u21D2",
              dArr: "\u21D3",
              hArr: "\u21D4",
              forall: "\u2200",
              part: "\u2202",
              exist: "\u2203",
              empty: "\u2205",
              nabla: "\u2207",
              isin: "\u2208",
              notin: "\u2209",
              ni: "\u220B",
              prod: "\u220F",
              sum: "\u2211",
              minus: "\u2212",
              lowast: "\u2217",
              radic: "\u221A",
              prop: "\u221D",
              infin: "\u221E",
              ang: "\u2220",
              and: "\u2227",
              or: "\u2228",
              cap: "\u2229",
              cup: "\u222A",
              int: "\u222B",
              there4: "\u2234",
              sim: "\u223C",
              cong: "\u2245",
              asymp: "\u2248",
              ne: "\u2260",
              equiv: "\u2261",
              le: "\u2264",
              ge: "\u2265",
              sub: "\u2282",
              sup: "\u2283",
              nsub: "\u2284",
              sube: "\u2286",
              supe: "\u2287",
              oplus: "\u2295",
              otimes: "\u2297",
              perp: "\u22A5",
              sdot: "\u22C5",
              lceil: "\u2308",
              rceil: "\u2309",
              lfloor: "\u230A",
              rfloor: "\u230B",
              loz: "\u25CA",
              spades: "\u2660",
              clubs: "\u2663",
              hearts: "\u2665",
              diams: "\u2666",
              lang: "\u27E8",
              rang: "\u27E9"
            };
          },
          /* 15 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var error_handler_1 = __webpack_require__(10);
            var scanner_1 = __webpack_require__(12);
            var token_1 = __webpack_require__(13);
            var Reader = function() {
              function Reader2() {
                this.values = [];
                this.curly = this.paren = -1;
              }
              Reader2.prototype.beforeFunctionExpression = function(t) {
                return [
                  "(",
                  "{",
                  "[",
                  "in",
                  "typeof",
                  "instanceof",
                  "new",
                  "return",
                  "case",
                  "delete",
                  "throw",
                  "void",
                  // assignment operators
                  "=",
                  "+=",
                  "-=",
                  "*=",
                  "**=",
                  "/=",
                  "%=",
                  "<<=",
                  ">>=",
                  ">>>=",
                  "&=",
                  "|=",
                  "^=",
                  ",",
                  // binary/unary operators
                  "+",
                  "-",
                  "*",
                  "**",
                  "/",
                  "%",
                  "++",
                  "--",
                  "<<",
                  ">>",
                  ">>>",
                  "&",
                  "|",
                  "^",
                  "!",
                  "~",
                  "&&",
                  "||",
                  "?",
                  ":",
                  "===",
                  "==",
                  ">=",
                  "<=",
                  "<",
                  ">",
                  "!=",
                  "!=="
                ].indexOf(t) >= 0;
              };
              Reader2.prototype.isRegexStart = function() {
                var previous = this.values[this.values.length - 1];
                var regex = previous !== null;
                switch (previous) {
                  case "this":
                  case "]":
                    regex = false;
                    break;
                  case ")":
                    var keyword = this.values[this.paren - 1];
                    regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                    break;
                  case "}":
                    regex = false;
                    if (this.values[this.curly - 3] === "function") {
                      var check = this.values[this.curly - 4];
                      regex = check ? !this.beforeFunctionExpression(check) : false;
                    } else if (this.values[this.curly - 4] === "function") {
                      var check = this.values[this.curly - 5];
                      regex = check ? !this.beforeFunctionExpression(check) : true;
                    }
                    break;
                  default:
                    break;
                }
                return regex;
              };
              Reader2.prototype.push = function(token) {
                if (token.type === 7 || token.type === 4) {
                  if (token.value === "{") {
                    this.curly = this.values.length;
                  } else if (token.value === "(") {
                    this.paren = this.values.length;
                  }
                  this.values.push(token.value);
                } else {
                  this.values.push(null);
                }
              };
              return Reader2;
            }();
            var Tokenizer = function() {
              function Tokenizer2(code, config) {
                this.errorHandler = new error_handler_1.ErrorHandler();
                this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
                this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
                this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
                this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
                this.buffer = [];
                this.reader = new Reader();
              }
              Tokenizer2.prototype.errors = function() {
                return this.errorHandler.errors;
              };
              Tokenizer2.prototype.getNextToken = function() {
                if (this.buffer.length === 0) {
                  var comments = this.scanner.scanComments();
                  if (this.scanner.trackComment) {
                    for (var i = 0; i < comments.length; ++i) {
                      var e = comments[i];
                      var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                      var comment = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value
                      };
                      if (this.trackRange) {
                        comment.range = e.range;
                      }
                      if (this.trackLoc) {
                        comment.loc = e.loc;
                      }
                      this.buffer.push(comment);
                    }
                  }
                  if (!this.scanner.eof()) {
                    var loc = void 0;
                    if (this.trackLoc) {
                      loc = {
                        start: {
                          line: this.scanner.lineNumber,
                          column: this.scanner.index - this.scanner.lineStart
                        },
                        end: {}
                      };
                    }
                    var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                    var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(token);
                    var entry = {
                      type: token_1.TokenName[token.type],
                      value: this.scanner.source.slice(token.start, token.end)
                    };
                    if (this.trackRange) {
                      entry.range = [token.start, token.end];
                    }
                    if (this.trackLoc) {
                      loc.end = {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      };
                      entry.loc = loc;
                    }
                    if (token.type === 9) {
                      var pattern = token.pattern;
                      var flags = token.flags;
                      entry.regex = { pattern, flags };
                    }
                    this.buffer.push(entry);
                  }
                }
                return this.buffer.shift();
              };
              return Tokenizer2;
            }();
            exports3.Tokenizer = Tokenizer;
          }
          /******/
        ])
      );
    });
  }
});

// ../node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js
var require_util8 = __commonJS({
  "../node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray3(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray3;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError6(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError6;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../node_modules/.pnpm/array-timsort@1.0.3/node_modules/array-timsort/src/index.js
var require_src = __commonJS({
  "../node_modules/.pnpm/array-timsort@1.0.3/node_modules/array-timsort/src/index.js"(exports2, module2) {
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    var results;
    var log10 = (x) => x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
    function alphabeticalCompare(a, b) {
      if (a === b) {
        return 0;
      }
      if (~~a === a && ~~b === b) {
        if (a === 0 || b === 0) {
          return a < b ? -1 : 1;
        }
        if (a < 0 || b < 0) {
          if (b >= 0) {
            return -1;
          }
          if (a >= 0) {
            return 1;
          }
          a = -a;
          b = -b;
        }
        const al = log10(a);
        const bl = log10(b);
        let t = 0;
        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }
        if (a === b) {
          return t;
        }
        return a < b ? -1 : 1;
      }
      const aStr = String(a);
      const bStr = String(b);
      if (aStr === bStr) {
        return 0;
      }
      return aStr < bStr ? -1 : 1;
    }
    function minRunLength(n) {
      let r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare3) {
      let runHi = lo + 1;
      if (runHi === hi) {
        return 1;
      }
      if (compare3(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare3(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }
        reverseRun(array, lo, runHi);
        reverseRun(results, lo, runHi);
      } else {
        while (runHi < hi && compare3(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        const t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare3) {
      if (start === lo) {
        start++;
      }
      for (; start < hi; start++) {
        const pivot = array[start];
        const pivotIndex = results[start];
        let left = lo;
        let right = start;
        while (left < right) {
          const mid = left + right >>> 1;
          if (compare3(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }
        let n = start - left;
        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];
            results[left + 3] = results[left + 2];
          /* falls through */
          case 2:
            array[left + 2] = array[left + 1];
            results[left + 2] = results[left + 1];
          /* falls through */
          case 1:
            array[left + 1] = array[left];
            results[left + 1] = results[left];
            break;
          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              results[left + n] = results[left + n - 1];
              n--;
            }
        }
        array[left] = pivot;
        results[left] = pivotIndex;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare3) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare3(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare3(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare3(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare3(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare3) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare3(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare3(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare3(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare3(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }
      return offset;
    }
    var TimSort = class {
      constructor(array, compare3) {
        this.array = array;
        this.compare = compare3;
        const { length } = array;
        this.length = length;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH ? length >>> 1 : DEFAULT_TMP_STORAGE_LENGTH;
        this.tmp = new Array(this.tmpStorageLength);
        this.tmpIndex = new Array(this.tmpStorageLength);
        this.stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
        this.stackSize = 0;
      }
      /**
       * Push a new run on TimSort's stack.
       *
       * @param {number} runStart - Start index of the run in the original array.
       * @param {number} runLength - Length of the run;
       */
      pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      }
      /**
       * Merge runs on TimSort's stack so that the following holds for all i:
       * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
       * 2) runLength[i - 2] > runLength[i - 1]
       */
      mergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
            if (this.runLength[n - 1] < this.runLength[n + 1]) {
              n--;
            }
          } else if (this.runLength[n] > this.runLength[n + 1]) {
            break;
          }
          this.mergeAt(n);
        }
      }
      /**
       * Merge all runs on TimSort's stack until only one remains.
       */
      forceMergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
          this.mergeAt(n);
        }
      }
      /**
       * Merge the runs on the stack at positions i and i+1. Must be always be called
       * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
       *
       * @param {number} i - Index of the run to merge in TimSort's stack.
       */
      mergeAt(i) {
        const { compare: compare3 } = this;
        const { array } = this;
        let start1 = this.runStart[i];
        let length1 = this.runLength[i];
        const start2 = this.runStart[i + 1];
        let length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;
        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }
        this.stackSize--;
        const k = gallopRight(array[start2], array, start1, length1, 0, compare3);
        start1 += k;
        length1 -= k;
        if (length1 === 0) {
          return;
        }
        length2 = gallopLeft(
          array[start1 + length1 - 1],
          array,
          start2,
          length2,
          length2 - 1,
          compare3
        );
        if (length2 === 0) {
          return;
        }
        if (length1 <= length2) {
          this.mergeLow(start1, length1, start2, length2);
        } else {
          this.mergeHigh(start1, length1, start2, length2);
        }
      }
      /**
       * Merge two adjacent runs in a stable way. The runs must be such that the
       * first element of run1 is bigger than the first element in run2 and the
       * last element of run1 is greater than all the elements in run2.
       * The method should be called when run1.length <= run2.length as it uses
       * TimSort temporary array to store run1. Use mergeHigh if run1.length >
       * run2.length.
       *
       * @param {number} start1 - First element in run1.
       * @param {number} length1 - Length of run1.
       * @param {number} start2 - First element in run2.
       * @param {number} length2 - Length of run2.
       */
      mergeLow(start1, length1, start2, length2) {
        const { compare: compare3 } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
          tmpIndex[i] = results[start1 + i];
        }
        let cursor1 = 0;
        let cursor2 = start2;
        let dest = start1;
        array[dest] = array[cursor2];
        results[dest] = results[cursor2];
        dest++;
        cursor2++;
        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
          return;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count22 = 0;
          let exit = false;
          do {
            if (compare3(array[cursor2], tmp[cursor1]) < 0) {
              array[dest] = array[cursor2];
              results[dest] = results[cursor2];
              dest++;
              cursor2++;
              count22++;
              count1 = 0;
              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor1];
              results[dest] = tmpIndex[cursor1];
              dest++;
              cursor1++;
              count1++;
              count22 = 0;
              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count22) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare3);
            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
                results[dest + i] = tmpIndex[cursor1 + i];
              }
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor2];
            results[dest] = results[cursor2];
            dest++;
            cursor2++;
            if (--length2 === 0) {
              exit = true;
              break;
            }
            count22 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare3);
            if (count22 !== 0) {
              for (i = 0; i < count22; i++) {
                array[dest + i] = array[cursor2 + i];
                results[dest + i] = results[cursor2 + i];
              }
              dest += count22;
              cursor2 += count22;
              length2 -= count22;
              if (length2 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor1];
            results[dest] = tmpIndex[cursor1];
            dest++;
            cursor1++;
            if (--length1 === 1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
        } else if (length1 === 0) {
          throw new Error("mergeLow preconditions were not respected");
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
        }
      }
      /**
       * Merge two adjacent runs in a stable way. The runs must be such that the
       * first element of run1 is bigger than the first element in run2 and the
       * last element of run1 is greater than all the elements in run2.
       * The method should be called when run1.length > run2.length as it uses
       * TimSort temporary array to store run2. Use mergeLow if run1.length <=
       * run2.length.
       *
       * @param {number} start1 - First element in run1.
       * @param {number} length1 - Length of run1.
       * @param {number} start2 - First element in run2.
       * @param {number} length2 - Length of run2.
       */
      mergeHigh(start1, length1, start2, length2) {
        const { compare: compare3 } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
          tmpIndex[i] = results[start2 + i];
        }
        let cursor1 = start1 + length1 - 1;
        let cursor2 = length2 - 1;
        let dest = start2 + length2 - 1;
        let customCursor = 0;
        let customDest = 0;
        array[dest] = array[cursor1];
        results[dest] = results[cursor1];
        dest--;
        cursor1--;
        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
          return;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count22 = 0;
          let exit = false;
          do {
            if (compare3(tmp[cursor2], array[cursor1]) < 0) {
              array[dest] = array[cursor1];
              results[dest] = results[cursor1];
              dest--;
              cursor1--;
              count1++;
              count22 = 0;
              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor2];
              results[dest] = tmpIndex[cursor2];
              dest--;
              cursor2--;
              count22++;
              count1 = 0;
              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count22) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = length1 - gallopRight(
              tmp[cursor2],
              array,
              start1,
              length1,
              length1 - 1,
              compare3
            );
            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
                results[customDest + i] = results[customCursor + i];
              }
              if (length1 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor2];
            results[dest] = tmpIndex[cursor2];
            dest--;
            cursor2--;
            if (--length2 === 1) {
              exit = true;
              break;
            }
            count22 = length2 - gallopLeft(
              array[cursor1],
              tmp,
              0,
              length2,
              length2 - 1,
              compare3
            );
            if (count22 !== 0) {
              dest -= count22;
              cursor2 -= count22;
              length2 -= count22;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count22; i++) {
                array[customDest + i] = tmp[customCursor + i];
                results[customDest + i] = tmpIndex[customCursor + i];
              }
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor1];
            results[dest] = results[cursor1];
            dest--;
            cursor1--;
            if (--length1 === 0) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
        } else if (length2 === 0) {
          throw new Error("mergeHigh preconditions were not respected");
        } else {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
        }
      }
    };
    function sort(array, compare3, lo, hi) {
      if (!Array.isArray(array)) {
        throw new TypeError(
          `The "array" argument must be an array. Received ${array}`
        );
      }
      results = [];
      const { length } = array;
      let i = 0;
      while (i < length) {
        results[i] = i++;
      }
      if (!compare3) {
        compare3 = alphabeticalCompare;
      } else if (typeof compare3 !== "function") {
        hi = lo;
        lo = compare3;
        compare3 = alphabeticalCompare;
      }
      if (!lo) {
        lo = 0;
      }
      if (!hi) {
        hi = length;
      }
      let remaining = hi - lo;
      if (remaining < 2) {
        return results;
      }
      let runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare3);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare3);
        return results;
      }
      const ts = new TimSort(array, compare3);
      const minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare3);
        if (runLength < minRun) {
          let force = remaining;
          if (force > minRun) {
            force = minRun;
          }
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare3);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);
      ts.forceMergeRuns();
      return results;
    }
    module2.exports = {
      sort
    };
  }
});

// ../node_modules/.pnpm/has-own-prop@2.0.0/node_modules/has-own-prop/index.js
var require_has_own_prop = __commonJS({
  "../node_modules/.pnpm/has-own-prop@2.0.0/node_modules/has-own-prop/index.js"(exports2, module2) {
    "use strict";
    var hasOwnProp = Object.prototype.hasOwnProperty;
    module2.exports = (object, property) => hasOwnProp.call(object, property);
  }
});

// ../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/common.js
var require_common = __commonJS({
  "../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/common.js"(exports2, module2) {
    var hasOwnProperty4 = require_has_own_prop();
    var {
      isObject,
      isArray: isArray3,
      isString: isString2,
      isNumber
    } = require_util8();
    var PREFIX_BEFORE = "before";
    var PREFIX_AFTER_PROP = "after-prop";
    var PREFIX_AFTER_COLON = "after-colon";
    var PREFIX_AFTER_VALUE = "after-value";
    var PREFIX_AFTER = "after";
    var PREFIX_BEFORE_ALL = "before-all";
    var PREFIX_AFTER_ALL = "after-all";
    var BRACKET_OPEN = "[";
    var BRACKET_CLOSE = "]";
    var CURLY_BRACKET_OPEN = "{";
    var CURLY_BRACKET_CLOSE = "}";
    var COMMA = ",";
    var EMPTY = "";
    var MINUS = "-";
    var SYMBOL_PREFIXES = [
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER
    ];
    var NON_PROP_SYMBOL_KEYS = [
      PREFIX_BEFORE,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL
    ].map(Symbol.for);
    var COLON = ":";
    var UNDEFINED = void 0;
    var symbol = (prefix, key) => Symbol.for(prefix + COLON + key);
    var define2 = (target, key, value) => Object.defineProperty(target, key, {
      value,
      writable: true,
      configurable: true
    });
    var copy_comments_by_kind = (target, source, target_key, source_key, prefix, remove_source) => {
      const source_prop = symbol(prefix, source_key);
      if (!hasOwnProperty4(source, source_prop)) {
        return;
      }
      const target_prop = target_key === source_key ? source_prop : symbol(prefix, target_key);
      define2(target, target_prop, source[source_prop]);
      if (remove_source) {
        delete source[source_prop];
      }
    };
    var copy_comments = (target, source, target_key, source_key, remove_source) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        copy_comments_by_kind(
          target,
          source,
          target_key,
          source_key,
          prefix,
          remove_source
        );
      });
    };
    var swap_comments = (array, from, to) => {
      if (from === to) {
        return;
      }
      SYMBOL_PREFIXES.forEach((prefix) => {
        const target_prop = symbol(prefix, to);
        if (!hasOwnProperty4(array, target_prop)) {
          copy_comments_by_kind(array, array, to, from, prefix, true);
          return;
        }
        const comments = array[target_prop];
        delete array[target_prop];
        copy_comments_by_kind(array, array, to, from, prefix, true);
        define2(array, symbol(prefix, from), comments);
      });
    };
    var assign_non_prop_comments = (target, source) => {
      NON_PROP_SYMBOL_KEYS.forEach((key) => {
        const comments = source[key];
        if (comments) {
          define2(target, key, comments);
        }
      });
    };
    var assign3 = (target, source, keys3) => {
      keys3.forEach((key) => {
        if (!isString2(key) && !isNumber(key)) {
          return;
        }
        if (!hasOwnProperty4(source, key)) {
          return;
        }
        target[key] = source[key];
        copy_comments(target, source, key, key);
      });
      return target;
    };
    module2.exports = {
      SYMBOL_PREFIXES,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      symbol,
      define: define2,
      copy_comments,
      swap_comments,
      assign_non_prop_comments,
      assign(target, source, keys3) {
        if (!isObject(target)) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        if (!isObject(source)) {
          return target;
        }
        if (keys3 === UNDEFINED) {
          keys3 = Object.keys(source);
          assign_non_prop_comments(target, source);
        } else if (!isArray3(keys3)) {
          throw new TypeError("keys must be array or undefined");
        } else if (keys3.length === 0) {
          assign_non_prop_comments(target, source);
        }
        return assign3(target, source, keys3);
      }
    };
  }
});

// ../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/array.js
var require_array = __commonJS({
  "../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/array.js"(exports2, module2) {
    var { isArray: isArray3 } = require_util8();
    var { sort } = require_src();
    var {
      SYMBOL_PREFIXES,
      UNDEFINED,
      symbol,
      copy_comments,
      swap_comments
    } = require_common();
    var reverse_comments = (array) => {
      const { length } = array;
      let i = 0;
      const max4 = length / 2;
      for (; i < max4; i++) {
        swap_comments(array, i, length - i - 1);
      }
    };
    var move_comment = (target, source, i, offset, remove) => {
      copy_comments(target, source, i + offset, i, remove);
    };
    var move_comments = (target, source, start, count3, offset, remove) => {
      if (offset > 0) {
        let i2 = count3;
        while (i2-- > 0) {
          move_comment(target, source, start + i2, offset, remove);
        }
        return;
      }
      let i = 0;
      while (i < count3) {
        const ii = i++;
        move_comment(target, source, start + ii, offset, remove);
      }
    };
    var remove_comments = (array, key) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        const prop = symbol(prefix, key);
        delete array[prop];
      });
    };
    var get_mapped = (map3, key) => {
      let mapped = key;
      while (mapped in map3) {
        mapped = map3[mapped];
      }
      return mapped;
    };
    var CommentArray = class _CommentArray extends Array {
      // - deleteCount + items.length
      // We should avoid `splice(begin, deleteCount, ...items)`,
      // because `splice(0, undefined)` is not equivalent to `splice(0)`,
      // as well as:
      // - slice
      splice(...args) {
        const { length } = this;
        const ret = super.splice(...args);
        let [begin, deleteCount, ...items] = args;
        if (begin < 0) {
          begin += length;
        }
        if (arguments.length === 1) {
          deleteCount = length - begin;
        } else {
          deleteCount = Math.min(length - begin, deleteCount);
        }
        const {
          length: item_length
        } = items;
        const offset = item_length - deleteCount;
        const start = begin + deleteCount;
        const count3 = length - start;
        move_comments(this, this, start, count3, offset, true);
        return ret;
      }
      slice(...args) {
        const { length } = this;
        const array = super.slice(...args);
        if (!array.length) {
          return new _CommentArray();
        }
        let [begin, before] = args;
        if (before === UNDEFINED) {
          before = length;
        } else if (before < 0) {
          before += length;
        }
        if (begin < 0) {
          begin += length;
        } else if (begin === UNDEFINED) {
          begin = 0;
        }
        move_comments(array, this, begin, before - begin, -begin);
        return array;
      }
      unshift(...items) {
        const { length } = this;
        const ret = super.unshift(...items);
        const {
          length: items_length
        } = items;
        if (items_length > 0) {
          move_comments(this, this, 0, length, items_length, true);
        }
        return ret;
      }
      shift() {
        const ret = super.shift();
        const { length } = this;
        remove_comments(this, 0);
        move_comments(this, this, 1, length, -1, true);
        return ret;
      }
      reverse() {
        super.reverse();
        reverse_comments(this);
        return this;
      }
      pop() {
        const ret = super.pop();
        remove_comments(this, this.length);
        return ret;
      }
      concat(...items) {
        let { length } = this;
        const ret = super.concat(...items);
        if (!items.length) {
          return ret;
        }
        move_comments(ret, this, 0, this.length, 0);
        items.forEach((item) => {
          const prev = length;
          length += isArray3(item) ? item.length : 1;
          if (!(item instanceof _CommentArray)) {
            return;
          }
          move_comments(ret, item, 0, item.length, prev);
        });
        return ret;
      }
      sort(...args) {
        const result = sort(
          this,
          ...args.slice(0, 1)
        );
        const map3 = /* @__PURE__ */ Object.create(null);
        result.forEach((source_index, index) => {
          if (source_index === index) {
            return;
          }
          const real_source_index = get_mapped(map3, source_index);
          if (real_source_index === index) {
            return;
          }
          map3[index] = real_source_index;
          swap_comments(this, index, real_source_index);
        });
        return this;
      }
    };
    module2.exports = {
      CommentArray
    };
  }
});

// ../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/parse.js
var require_parse3 = __commonJS({
  "../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/parse.js"(exports2, module2) {
    var esprima = require_esprima();
    var {
      CommentArray
    } = require_array();
    var {
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      define: define2,
      assign_non_prop_comments
    } = require_common();
    var tokenize = (code) => esprima.tokenize(code, {
      comment: true,
      loc: true
    });
    var previous_hosts = [];
    var comments_host = null;
    var unassigned_comments = null;
    var previous_props = [];
    var last_prop;
    var remove_comments = false;
    var inline = false;
    var tokens = null;
    var last = null;
    var current = null;
    var index;
    var reviver = null;
    var clean5 = () => {
      previous_props.length = previous_hosts.length = 0;
      last = null;
      last_prop = UNDEFINED;
    };
    var free = () => {
      clean5();
      tokens.length = 0;
      unassigned_comments = comments_host = tokens = last = current = reviver = null;
    };
    var symbolFor = (prefix) => Symbol.for(
      last_prop !== UNDEFINED ? prefix + COLON + last_prop : prefix
    );
    var transform2 = (k, v) => reviver ? reviver(k, v) : v;
    var unexpected = () => {
      const error4 = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`);
      Object.assign(error4, current.loc.start);
      throw error4;
    };
    var unexpected_end = () => {
      const error4 = new SyntaxError("Unexpected end of JSON input");
      Object.assign(error4, last ? last.loc.end : {
        line: 1,
        column: 0
      });
      throw error4;
    };
    var next = () => {
      const new_token = tokens[++index];
      inline = current && new_token && current.loc.end.line === new_token.loc.start.line || false;
      last = current;
      current = new_token;
    };
    var type = () => {
      if (!current) {
        unexpected_end();
      }
      return current.type === "Punctuator" ? current.value : current.type;
    };
    var is = (t) => type() === t;
    var expect = (a) => {
      if (!is(a)) {
        unexpected();
      }
    };
    var set_comments_host = (new_host) => {
      previous_hosts.push(comments_host);
      comments_host = new_host;
    };
    var restore_comments_host = () => {
      comments_host = previous_hosts.pop();
    };
    var assign_after_comments = () => {
      if (!unassigned_comments) {
        return;
      }
      const after_comments = [];
      for (const comment of unassigned_comments) {
        if (comment.inline) {
          after_comments.push(comment);
        } else {
          break;
        }
      }
      const { length } = after_comments;
      if (!length) {
        return;
      }
      if (length === unassigned_comments.length) {
        unassigned_comments = null;
      } else {
        unassigned_comments.splice(0, length);
      }
      define2(comments_host, symbolFor(PREFIX_AFTER), after_comments);
    };
    var assign_comments = (prefix) => {
      if (!unassigned_comments) {
        return;
      }
      define2(comments_host, symbolFor(prefix), unassigned_comments);
      unassigned_comments = null;
    };
    var parse_comments = (prefix) => {
      const comments = [];
      while (current && (is("LineComment") || is("BlockComment"))) {
        const comment = {
          ...current,
          inline
        };
        comments.push(comment);
        next();
      }
      if (remove_comments) {
        return;
      }
      if (!comments.length) {
        return;
      }
      if (prefix) {
        define2(comments_host, symbolFor(prefix), comments);
        return;
      }
      unassigned_comments = comments;
    };
    var set_prop = (prop, push) => {
      if (push) {
        previous_props.push(last_prop);
      }
      last_prop = prop;
    };
    var restore_prop = () => {
      last_prop = previous_props.pop();
    };
    var parse_object = () => {
      const obj = {};
      set_comments_host(obj);
      set_prop(UNDEFINED, true);
      let started = false;
      let name2;
      parse_comments();
      while (!is(CURLY_BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(CURLY_BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        expect("String");
        name2 = JSON.parse(current.value);
        set_prop(name2);
        assign_comments(PREFIX_BEFORE);
        next();
        parse_comments(PREFIX_AFTER_PROP);
        expect(COLON);
        next();
        parse_comments(PREFIX_AFTER_COLON);
        obj[name2] = transform2(name2, walk());
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return obj;
    };
    var parse_array = () => {
      const array = new CommentArray();
      set_comments_host(array);
      set_prop(UNDEFINED, true);
      let started = false;
      let i = 0;
      parse_comments();
      while (!is(BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        set_prop(i);
        assign_comments(PREFIX_BEFORE);
        array[i] = transform2(i, walk());
        i++;
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return array;
    };
    function walk() {
      let tt = type();
      if (tt === CURLY_BRACKET_OPEN) {
        next();
        return parse_object();
      }
      if (tt === BRACKET_OPEN) {
        next();
        return parse_array();
      }
      let negative = EMPTY;
      if (tt === MINUS) {
        next();
        tt = type();
        negative = MINUS;
      }
      let v;
      switch (tt) {
        case "String":
        case "Boolean":
        case "Null":
        case "Numeric":
          v = current.value;
          next();
          return JSON.parse(negative + v);
        default:
      }
    }
    var isObject = (subject) => Object(subject) === subject;
    var parse3 = (code, rev, no_comments) => {
      clean5();
      tokens = tokenize(code);
      reviver = rev;
      remove_comments = no_comments;
      if (!tokens.length) {
        unexpected_end();
      }
      index = -1;
      next();
      set_comments_host({});
      parse_comments(PREFIX_BEFORE_ALL);
      let result = walk();
      parse_comments(PREFIX_AFTER_ALL);
      if (current) {
        unexpected();
      }
      if (!no_comments && result !== null) {
        if (!isObject(result)) {
          result = new Object(result);
        }
        assign_non_prop_comments(result, comments_host);
      }
      restore_comments_host();
      result = transform2("", result);
      free();
      return result;
    };
    module2.exports = {
      parse: parse3,
      tokenize
    };
  }
});

// ../node_modules/.pnpm/repeat-string@1.6.1/node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "../node_modules/.pnpm/repeat-string@1.6.1/node_modules/repeat-string/index.js"(exports2, module2) {
    "use strict";
    var res = "";
    var cache5;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1) return str;
      if (num === 2) return str + str;
      var max4 = str.length * num;
      if (cache5 !== str || typeof cache5 === "undefined") {
        cache5 = str;
        res = "";
      } else if (res.length >= max4) {
        return res.substr(0, max4);
      }
      while (max4 > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max4);
      return res;
    }
  }
});

// ../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/stringify.js
var require_stringify = __commonJS({
  "../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/stringify.js"(exports2, module2) {
    var {
      isArray: isArray3,
      isObject,
      isFunction,
      isNumber,
      isString: isString2
    } = require_util8();
    var repeat = require_repeat_string();
    var {
      PREFIX_BEFORE_ALL,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      EMPTY,
      UNDEFINED
    } = require_common();
    var ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var SPACE = " ";
    var LF2 = "\n";
    var STR_NULL = "null";
    var BEFORE = (prop) => `${PREFIX_BEFORE}:${prop}`;
    var AFTER_PROP = (prop) => `${PREFIX_AFTER_PROP}:${prop}`;
    var AFTER_COLON = (prop) => `${PREFIX_AFTER_COLON}:${prop}`;
    var AFTER_VALUE = (prop) => `${PREFIX_AFTER_VALUE}:${prop}`;
    var AFTER = (prop) => `${PREFIX_AFTER}:${prop}`;
    var meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var escape = (string) => {
      ESCAPABLE.lastIndex = 0;
      if (!ESCAPABLE.test(string)) {
        return string;
      }
      return string.replace(ESCAPABLE, (a) => {
        const c = meta[a];
        return typeof c === "string" ? c : a;
      });
    };
    var quote = (string) => `"${escape(string)}"`;
    var comment_stringify = (value, line) => line ? `//${value}` : `/*${value}*/`;
    var process_comments = (host, symbol_tag, deeper_gap, display_block) => {
      const comments = host[Symbol.for(symbol_tag)];
      if (!comments || !comments.length) {
        return EMPTY;
      }
      let is_line_comment = false;
      const str = comments.reduce((prev, {
        inline,
        type,
        value
      }) => {
        const delimiter = inline ? SPACE : LF2 + deeper_gap;
        is_line_comment = type === "LineComment";
        return prev + delimiter + comment_stringify(value, is_line_comment);
      }, EMPTY);
      return display_block || is_line_comment ? str + LF2 + deeper_gap : str;
    };
    var replacer = null;
    var indent = EMPTY;
    var clean5 = () => {
      replacer = null;
      indent = EMPTY;
    };
    var join2 = (one, two, gap) => one ? two ? one + two.trim() + LF2 + gap : one.trimRight() + LF2 + gap : two ? two.trimRight() + LF2 + gap : EMPTY;
    var join_content = (inside, value, gap) => {
      const comment = process_comments(value, PREFIX_BEFORE, gap + indent, true);
      return join2(comment, inside, gap);
    };
    var array_stringify = (value, gap) => {
      const deeper_gap = gap + indent;
      const { length } = value;
      let inside = EMPTY;
      let after_comma = EMPTY;
      for (let i = 0; i < length; i++) {
        if (i !== 0) {
          inside += COMMA;
        }
        const before = join2(
          after_comma,
          process_comments(value, BEFORE(i), deeper_gap),
          deeper_gap
        );
        inside += before || LF2 + deeper_gap;
        inside += stringify4(i, value, deeper_gap) || STR_NULL;
        inside += process_comments(value, AFTER_VALUE(i), deeper_gap);
        after_comma = process_comments(value, AFTER(i), deeper_gap);
      }
      inside += join2(
        after_comma,
        process_comments(value, PREFIX_AFTER, deeper_gap),
        deeper_gap
      );
      return BRACKET_OPEN + join_content(inside, value, gap) + BRACKET_CLOSE;
    };
    var object_stringify = (value, gap) => {
      if (!value) {
        return "null";
      }
      const deeper_gap = gap + indent;
      let inside = EMPTY;
      let after_comma = EMPTY;
      let first3 = true;
      const keys3 = isArray3(replacer) ? replacer : Object.keys(value);
      const iteratee = (key) => {
        const sv = stringify4(key, value, deeper_gap);
        if (sv === UNDEFINED) {
          return;
        }
        if (!first3) {
          inside += COMMA;
        }
        first3 = false;
        const before = join2(
          after_comma,
          process_comments(value, BEFORE(key), deeper_gap),
          deeper_gap
        );
        inside += before || LF2 + deeper_gap;
        inside += quote(key) + process_comments(value, AFTER_PROP(key), deeper_gap) + COLON + process_comments(value, AFTER_COLON(key), deeper_gap) + SPACE + sv + process_comments(value, AFTER_VALUE(key), deeper_gap);
        after_comma = process_comments(value, AFTER(key), deeper_gap);
      };
      keys3.forEach(iteratee);
      inside += join2(
        after_comma,
        process_comments(value, PREFIX_AFTER, deeper_gap),
        deeper_gap
      );
      return CURLY_BRACKET_OPEN + join_content(inside, value, gap) + CURLY_BRACKET_CLOSE;
    };
    function stringify4(key, holder, gap) {
      let value = holder[key];
      if (isObject(value) && isFunction(value.toJSON)) {
        value = value.toJSON(key);
      }
      if (isFunction(replacer)) {
        value = replacer.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return Number.isFinite(value) ? String(value) : STR_NULL;
        case "boolean":
        case "null":
          return String(value);
        // If the type is 'object', we might be dealing with an object or an array or
        // null.
        case "object":
          return isArray3(value) ? array_stringify(value, gap) : object_stringify(value, gap);
        // undefined
        default:
      }
    }
    var get_indent = (space) => isString2(space) ? space : isNumber(space) ? repeat(SPACE, space) : EMPTY;
    var { toString } = Object.prototype;
    var PRIMITIVE_OBJECT_TYPES = [
      "[object Number]",
      "[object String]",
      "[object Boolean]"
    ];
    var is_primitive_object = (subject) => {
      if (typeof subject !== "object") {
        return false;
      }
      const str = toString.call(subject);
      return PRIMITIVE_OBJECT_TYPES.includes(str);
    };
    module2.exports = (value, replacer_, space) => {
      const indent_ = get_indent(space);
      if (!indent_) {
        return JSON.stringify(value, replacer_);
      }
      if (!isFunction(replacer_) && !isArray3(replacer_)) {
        replacer_ = null;
      }
      replacer = replacer_;
      indent = indent_;
      const str = is_primitive_object(value) ? JSON.stringify(value) : stringify4("", { "": value }, EMPTY);
      clean5();
      return isObject(value) ? process_comments(value, PREFIX_BEFORE_ALL, EMPTY).trimLeft() + str + process_comments(value, PREFIX_AFTER_ALL, EMPTY).trimRight() : str;
    };
  }
});

// ../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/index.js
var require_src2 = __commonJS({
  "../node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/index.js"(exports2, module2) {
    var { parse: parse3, tokenize } = require_parse3();
    var stringify4 = require_stringify();
    var { CommentArray } = require_array();
    var { assign: assign3 } = require_common();
    module2.exports = {
      parse: parse3,
      stringify: stringify4,
      tokenize,
      CommentArray,
      assign: assign3
    };
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode2(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar2(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias2;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap2;
    exports2.isNode = isNode2;
    exports2.isPair = isPair2;
    exports2.isScalar = isScalar2;
    exports2.isSeq = isSeq2;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path17) {
      const ctrl = callVisitor(key, node, visitor, path17);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path17, ctrl);
        return visit_(key, ctrl, visitor, path17);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path17 = Object.freeze(path17.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path17);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path17 = Object.freeze(path17.concat(node));
          const ck = visit_("key", node.key, visitor, path17);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path17);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path17) {
      const ctrl = await callVisitor(key, node, visitor, path17);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path17, ctrl);
        return visitAsync_(key, ctrl, visitor, path17);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path17 = Object.freeze(path17.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path17);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path17 = Object.freeze(path17.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path17);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path17);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path17) {
      if (typeof visitor === "function")
        return visitor(key, node, path17);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path17);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path17);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path17);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path17);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path17);
      return void 0;
    }
    function replaceNode(key, path17, node) {
      const parent = path17[path17.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit;
    exports2.visitAsync = visitAsync;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    var escapeChars2 = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars2[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name2 = parts.shift();
        switch (name2) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version3] = parts;
            if (version3 === "1.1" || version3 === "1.2") {
              this.yaml.version = version3;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version3);
              onError(6, `Unsupported YAML version ${version3}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name2}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error4) {
            onError(String(error4));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name2 = `${prefix}${i}`;
        if (!exclude.has(name2))
          return name2;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error4 = new Error("Failed to resolve repeated object (this should not happen)");
              error4.source = source;
              throw error4;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep)
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count: count3, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count3);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node))
                nodes.push(node);
            }
          });
          if (ctx)
            ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this)
            break;
          if (node.anchor === this.source)
            found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count3 = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count3)
            count3 = c;
        }
        return count3;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar2 = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar2.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar2.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar2.PLAIN = "PLAIN";
    Scalar2.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar2.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar2;
    exports2.isScalarValue = isScalarValue;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar2 = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match2 = tags.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) ?? match2[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map3 = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map3.items.push(value);
        return map3;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar2.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar2.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path17, value) {
      let v = value;
      for (let i = path17.length - 1; i >= 0; --i) {
        const k = path17[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path17) => path17 == null || typeof path17 === "object" && !!path17[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path17, value) {
        if (isEmptyPath(path17))
          this.add(value);
        else {
          const [key, ...rest] = path17;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path17) {
        const [key, ...rest] = path17;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path17, keepScalar) {
        const [key, ...rest] = path17;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path17) {
        const [key, ...rest] = path17;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path17, value) {
        const [key, ...rest] = path17;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split2 = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i, indent.length);
          end = i + indent.length + endStep;
          split2 = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split2 = i;
          }
          if (i >= end) {
            if (split2) {
              folds.push(split2);
              end = split2 + endStep;
              split2 = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split2 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i, indent) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar2.Scalar.BLOCK_FOLDED ? false : type === Scalar2.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar2.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent}`);
      return `|${header}
${indent}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar2.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar2.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar2.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar2.Scalar.BLOCK_FOLDED:
          case Scalar2.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar2.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar2.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar2.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringify.js
var require_stringify2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match2 = tags.filter((t) => t.tag === item.tag);
        if (match2.length > 0)
          return match2.find((t) => t.format === item.format) ?? match2[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match2 = tags.filter((t) => t.identify?.(obj));
        if (match2.length > 1) {
          const testMatch = match2.filter((t) => t.test);
          if (testMatch.length > 0)
            match2 = testMatch;
        }
        tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name2 = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
        throw new Error(`Tag not resolved for ${name2} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify4(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify4;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar2 = require_Scalar();
    var stringify4 = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar2.Scalar.BLOCK_FOLDED || key.type === Scalar2.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify4.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify4.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    var node_process = require("process");
    function debug5(logLevel, ...messages2) {
      if (logLevel === "debug")
        console.log(...messages2);
    }
    function warn(logLevel, warning4) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function")
          node_process.emitWarning(warning4);
        else
          console.warn(warning4);
      }
    }
    exports2.debug = debug5;
    exports2.warn = warn;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar2 = require_Scalar();
    var MERGE_KEY = "<<";
    var merge5 = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar2.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge5.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar2.Scalar.PLAIN) && merge5.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge5.tag && tag.default);
    function addMergeToJSMap(ctx, map3, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value))
        for (const it of value.items)
          mergeValue(ctx, map3, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeValue(ctx, map3, it);
      else
        mergeValue(ctx, map3, value);
    }
    function mergeValue(ctx, map3, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map3 instanceof Map) {
          if (!map3.has(key))
            map3.set(key, value2);
        } else if (map3 instanceof Set) {
          map3.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
          Object.defineProperty(map3, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map3;
    }
    exports2.addMergeToJSMap = addMergeToJSMap;
    exports2.isMergeKey = isMergeKey;
    exports2.merge = merge5;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log3 = require_log();
    var merge5 = require_merge();
    var stringify4 = require_stringify2();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map3, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map3, value);
      else if (merge5.isMergeKey(ctx, key))
        merge5.addMergeToJSMap(ctx, map3, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map3 instanceof Map) {
          map3.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map3 instanceof Set) {
          map3.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map3)
            Object.defineProperty(map3, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map3[stringKey] = jsValue;
        }
      }
      return map3;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify4.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log3.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value))
          value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify4 = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify5 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify5(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify4.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify4.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar2 = require_Scalar();
    function findPair2(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap2 = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map3 = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map3.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map3.items.sort(schema.sortMapEntries);
        }
        return map3;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair2(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar2.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair2(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair2(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair2(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map3 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map3, item);
        return map3;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap2;
    exports2.findPair = findPair2;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLMap2 = require_YAMLMap();
    var map3 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap2.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map4, onError) {
        if (!identity.isMap(map4))
          onError("Expected a mapping for this tag");
        return map4;
      },
      createNode: (schema, obj, ctx) => YAMLMap2.YAMLMap.from(schema, obj, ctx)
    };
    exports2.map = map3;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar2 = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq2 = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx2 = asItemIndex(key);
        if (typeof idx2 !== "number")
          return false;
        const del = this.items.splice(idx2, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx2 = asItemIndex(key);
        if (typeof idx2 !== "number")
          return void 0;
        const it = this.items[idx2];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx2 = asItemIndex(key);
        return typeof idx2 === "number" && idx2 < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx2 = asItemIndex(key);
        if (typeof idx2 !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx2];
        if (identity.isScalar(prev) && Scalar2.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx2] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx2 = identity.isScalar(key) ? key.value : key;
      if (idx2 && typeof idx2 === "string")
        idx2 = Number(idx2);
      return typeof idx2 === "number" && Number.isInteger(idx2) && idx2 >= 0 ? idx2 : null;
    }
    exports2.YAMLSeq = YAMLSeq2;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq2 = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq2.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq2.YAMLSeq.from(schema, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar2.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar2.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar2.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format: format4, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format4 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar2.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    var map3 = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar2.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map3.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var node_buffer = require("buffer");
    var Scalar2 = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
          return "";
        const buf = value;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type ?? (type = Scalar2.Scalar.BLOCK_LITERAL);
        if (type !== Scalar2.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar2.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar2 = require_Scalar();
    var YAMLSeq2 = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar2.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq2.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys3 = Object.keys(it);
            if (keys3.length === 1) {
              key = keys3[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys3.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap2 = require_YAMLMap();
    var YAMLSeq2 = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq2.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap2.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap2.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap2.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap2.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap2.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map3 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map3.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map3.set(key, value);
        }
        return map3;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar2.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar2.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar2.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap2 = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap2.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap2.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap2.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap2.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map3, onError) {
        if (identity.isMap(map3)) {
          if (map3.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map3);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map3;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match2 = str.match(timestamp.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match2.map(Number);
        const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match2[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge5 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge5.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge5 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map3.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map3.map,
      merge: merge5.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge5.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge5.merge) ? schemaTags.concat(merge5.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys3 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys3} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge5.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys3 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys3}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var map3 = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge5, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge5);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map3.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports2.Schema = Schema;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify4 = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify4.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify4.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify4.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version3 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version3 = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version: version3 });
        this.setSchema(version3, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path17, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path17, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name2) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name2 || prev.has(name2) ? anchors.findNewAnchor(name2 || "a", prev) : name2;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path17) {
        if (Collection.isEmptyPath(path17)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path17) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path17, keepScalar) {
        if (Collection.isEmptyPath(path17))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path17, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path17) {
        if (Collection.isEmptyPath(path17))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path17) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path17, value) {
        if (Collection.isEmptyPath(path17)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path17), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path17, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version3, options = {}) {
        if (typeof version3 === "number")
          version3 = String(version3);
        let opt;
        switch (version3) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version3;
            else
              this.directives = new directives.Directives({ version: version3 });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version3);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count: count3, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count3);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/errors.js
var require_errors2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name2, pos, code, message) {
        super();
        this.name = name2;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error4) => {
      if (error4.pos[0] === -1)
        return;
      error4.linePos = error4.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error4.linePos[0];
      error4.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count3 = 1;
        const end = error4.linePos[1];
        if (end && end.line === line && end.col > col) {
          count3 = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count3);
        error4.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else if (!found || indicator !== "seq-item-ind")
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap2 = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap2.YAMLMap;
      const map3 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep3, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep3?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep3) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map3.comment)
                map3.comment += "\n" + keyProps.comment;
              else
                map3.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep3 ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep3, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map3.range = [bm.offset, offset, commentEnd ?? offset];
      return map3;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq2 = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq2.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep3 = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep3 + cb;
              sep3 = "";
              break;
            }
            case "newline":
              if (comment)
                sep3 += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap2 = require_YAMLMap();
    var YAMLSeq2 = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap2 = fc.start.source === "{";
      const fcName = isMap2 ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap2.YAMLMap : YAMLSeq2.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep: sep3, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep3?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep3 && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap2 && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap2 && !sep3 && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep3, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep3 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap2 && !props.found && ctx.options.strict) {
              if (sep3)
                for (const st of sep3) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep3, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap2) {
            const map3 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map3.items.push(pair);
          } else {
            const map3 = new YAMLMap2.YAMLMap(ctx.schema);
            map3.flow = true;
            map3.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map3.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map3);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap2 ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name2 = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar2 = require_Scalar();
    var YAMLMap2 = require_YAMLMap();
    var YAMLSeq2 = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap2.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq2.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar2.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar2.Scalar.BLOCK_FOLDED : Scalar2.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value = "";
      let sep3 = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar2.Scalar.BLOCK_LITERAL) {
          value += sep3 + indent.slice(trimIndent) + content;
          sep3 = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep3 === " ")
            sep3 = "\n";
          else if (!prevMoreIndented && sep3 === "\n")
            sep3 = "\n\n";
          value += sep3 + indent.slice(trimIndent) + content;
          sep3 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep3 === "\n")
            value += "\n";
          else
            sep3 = "\n";
        } else {
          value += sep3 + content;
          sep3 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error4 = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n)
            indent = n;
          else if (error4 === -1)
            error4 = offset + i;
        }
      }
      if (error4 !== -1)
        onError(error4, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split2 = source.split(/\n( *)/);
      const first3 = split2[0];
      const m = first3.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first3.slice(m[1].length)] : ["", first3];
      const lines = [line0];
      for (let i = 1; i < split2.length; i += 2)
        lines.push([split2[i], split2[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar2 = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar2.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar2.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar2.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first3, line;
      try {
        first3 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first3 = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match2 = first3.exec(source);
      if (!match2)
        return source;
      let res = match2[1];
      let sep3 = " ";
      let pos = first3.lastIndex;
      line.lastIndex = pos;
      while (match2 = line.exec(source)) {
        if (match2[1] === "") {
          if (sep3 === "\n")
            res += sep3;
          else
            sep3 = "\n";
        } else {
          res += sep3 + match2[1];
          sep3 = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match2 = last.exec(source);
      return res + sep3 + (match2?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar2 = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value, token, onError);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar2.Scalar(res);
      } catch (error4) {
        const msg = error4 instanceof Error ? error4.message : String(error4);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar2.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors2();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning4) => {
          const pos = getErrorPos(source);
          if (warning4)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning4) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning4);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error4 = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error4);
            else
              this.doc.errors.push(error4);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors2();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify4 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep3, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep3)
        for (const st of sep3)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify4;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path17) => {
      let item = cst;
      for (const [field, index] of path17) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path17) => {
      const parent = visit.itemAtPath(cst, path17.slice(0, -1));
      const field = path17[path17.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path17, item, visitor) {
      let ctrl = visitor(item, path17);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path17.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path17);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path17) : ctrl;
    }
    exports2.visit = visit;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar2;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty2(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty2(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty2(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty2(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty2(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty2(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty2(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error4) {
        const token = error4 ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep3;
          if (scalar.end) {
            sep3 = scalar.end;
            sep3.push(this.sourceToken);
            delete scalar.end;
          } else
            sep3 = [this.sourceToken];
          const map3 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep3 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map3;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map3) {
        const it = map3.items[map3.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map3.indent)) {
                const prev = map3.items[map3.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map3.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map3.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map3.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep3 = it.sep;
                  sep3.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep3 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map3.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs6 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map3.items.push({ start, key: fs6, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs6);
              } else {
                Object.assign(it, { key: fs6, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map3);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map3.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs6 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs6, sep: [] });
              else if (it.sep)
                this.stack.push(fs6);
              else
                Object.assign(it, { key: fs6, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep3 = fc.end.splice(1, fc.end.length);
            sep3.push(this.sourceToken);
            const map3 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep3 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map3;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors2();
    var log3 = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser2 = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser2.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument2(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser2.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse3(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument2(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning4) => log3.warn(doc.options.logLevel, warning4));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify4(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse3;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument2;
    exports2.stringify = stringify4;
  }
});

// ../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "../node_modules/.pnpm/yaml@2.8.0/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors2();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar2 = require_Scalar();
    var YAMLMap2 = require_YAMLMap();
    var YAMLSeq2 = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser2 = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar2.Scalar;
    exports2.YAMLMap = YAMLMap2.YAMLMap;
    exports2.YAMLSeq = YAMLSeq2.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser2.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
    exports2.visitAsync = visit.visitAsync;
  }
});

// ../node_modules/.pnpm/callsites@3.1.0/node_modules/callsites/index.js
var require_callsites = __commonJS({
  "../node_modules/.pnpm/callsites@3.1.0/node_modules/callsites/index.js"(exports2, module2) {
    "use strict";
    var callsites = () => {
      const _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = _prepareStackTrace;
      return stack;
    };
    module2.exports = callsites;
    module2.exports.default = callsites;
  }
});

// ../node_modules/.pnpm/parent-module@2.0.0/node_modules/parent-module/index.js
var require_parent_module = __commonJS({
  "../node_modules/.pnpm/parent-module@2.0.0/node_modules/parent-module/index.js"(exports2, module2) {
    "use strict";
    var callsites = require_callsites();
    module2.exports = (filePath) => {
      const stacks = callsites();
      if (!filePath) {
        return stacks[2].getFileName();
      }
      let hasSeenValue = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilePath = stack.getFileName();
        if (typeof parentFilePath !== "string") {
          continue;
        }
        if (parentFilePath === filePath) {
          hasSeenValue = true;
          continue;
        }
        if (parentFilePath === "module.js") {
          continue;
        }
        if (hasSeenValue && parentFilePath !== filePath) {
          return parentFilePath;
        }
      }
    };
  }
});

// ../node_modules/.pnpm/clear-module@4.1.2/node_modules/clear-module/index.js
var require_clear_module = __commonJS({
  "../node_modules/.pnpm/clear-module@4.1.2/node_modules/clear-module/index.js"(exports2, module2) {
    "use strict";
    var path17 = require("path");
    var resolveFrom2 = require_resolve_from();
    var parentModule = require_parent_module();
    var resolve5 = (moduleId) => {
      try {
        return resolveFrom2(path17.dirname(parentModule(__filename)), moduleId);
      } catch (_) {
      }
    };
    var clear = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
      }
      const filePath = resolve5(moduleId);
      if (!filePath) {
        return;
      }
      if (require.cache[filePath] && require.cache[filePath].parent) {
        let i = require.cache[filePath].parent.children.length;
        while (i--) {
          if (require.cache[filePath].parent.children[i].id === filePath) {
            require.cache[filePath].parent.children.splice(i, 1);
          }
        }
      }
      if (require.cache[filePath]) {
        const children = require.cache[filePath].children.map((child) => child.id);
        delete require.cache[filePath];
        for (const id of children) {
          clear(id);
        }
      }
    };
    clear.all = () => {
      const directory = path17.dirname(parentModule(__filename));
      for (const moduleId of Object.keys(require.cache)) {
        delete require.cache[resolveFrom2(directory, moduleId)];
      }
    };
    clear.match = (regex) => {
      for (const moduleId of Object.keys(require.cache)) {
        if (regex.test(moduleId)) {
          clear(moduleId);
        }
      }
    };
    clear.single = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
      }
      delete require.cache[resolve5(moduleId)];
    };
    module2.exports = clear;
  }
});

// ../node_modules/.pnpm/resolve-from@4.0.0/node_modules/resolve-from/index.js
var require_resolve_from2 = __commonJS({
  "../node_modules/.pnpm/resolve-from@4.0.0/node_modules/resolve-from/index.js"(exports2, module2) {
    "use strict";
    var path17 = require("path");
    var Module = require("module");
    var fs6 = require("fs");
    var resolveFrom2 = (fromDir, moduleId, silent) => {
      if (typeof fromDir !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDir = fs6.realpathSync(fromDir);
      } catch (err) {
        if (err.code === "ENOENT") {
          fromDir = path17.resolve(fromDir);
        } else if (silent) {
          return null;
        } else {
          throw err;
        }
      }
      const fromFile = path17.join(fromDir, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (err) {
          return null;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDir, moduleId) => resolveFrom2(fromDir, moduleId);
    module2.exports.silent = (fromDir, moduleId) => resolveFrom2(fromDir, moduleId, true);
  }
});

// ../node_modules/.pnpm/parent-module@1.0.1/node_modules/parent-module/index.js
var require_parent_module2 = __commonJS({
  "../node_modules/.pnpm/parent-module@1.0.1/node_modules/parent-module/index.js"(exports2, module2) {
    "use strict";
    var callsites = require_callsites();
    module2.exports = (filepath) => {
      const stacks = callsites();
      if (!filepath) {
        return stacks[2].getFileName();
      }
      let seenVal = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilepath = stack.getFileName();
        if (typeof parentFilepath !== "string") {
          continue;
        }
        if (parentFilepath === filepath) {
          seenVal = true;
          continue;
        }
        if (parentFilepath === "module.js") {
          continue;
        }
        if (seenVal && parentFilepath !== filepath) {
          return parentFilepath;
        }
      }
    };
  }
});

// ../node_modules/.pnpm/import-fresh@3.3.1/node_modules/import-fresh/index.js
var require_import_fresh = __commonJS({
  "../node_modules/.pnpm/import-fresh@3.3.1/node_modules/import-fresh/index.js"(exports2, module2) {
    "use strict";
    var path17 = require("path");
    var resolveFrom2 = require_resolve_from2();
    var parentModule = require_parent_module2();
    module2.exports = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError("Expected a string");
      }
      const parentPath = parentModule(__filename);
      const cwd = parentPath ? path17.dirname(parentPath) : __dirname;
      const filePath = resolveFrom2(cwd, moduleId);
      const oldModule = require.cache[filePath];
      if (oldModule && oldModule.parent) {
        let i = oldModule.parent.children.length;
        while (i--) {
          if (oldModule.parent.children[i].id === filePath) {
            oldModule.parent.children.splice(i, 1);
          }
        }
      }
      delete require.cache[filePath];
      const parent = require.cache[parentPath];
      return parent === void 0 || parent.require === void 0 ? require(filePath) : parent.require(filePath);
    };
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/utils.js
var require_utils4 = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizePath = exports2.isRootDirectory = exports2.convertSlashes = exports2.cleanPath = void 0;
    var path_1 = require("path");
    function cleanPath(path17) {
      let normalized = (0, path_1.normalize)(path17);
      if (normalized.length > 1 && normalized[normalized.length - 1] === path_1.sep)
        normalized = normalized.substring(0, normalized.length - 1);
      return normalized;
    }
    exports2.cleanPath = cleanPath;
    var SLASHES_REGEX = /[\\/]/g;
    function convertSlashes(path17, separator) {
      return path17.replace(SLASHES_REGEX, separator);
    }
    exports2.convertSlashes = convertSlashes;
    var WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
    function isRootDirectory(path17) {
      return path17 === "/" || WINDOWS_ROOT_DIR_REGEX.test(path17);
    }
    exports2.isRootDirectory = isRootDirectory;
    function normalizePath2(path17, options) {
      const { resolvePaths, normalizePath: normalizePath3, pathSeparator } = options;
      const pathNeedsCleaning = process.platform === "win32" && path17.includes("/") || path17.startsWith(".");
      if (resolvePaths)
        path17 = (0, path_1.resolve)(path17);
      if (normalizePath3 || pathNeedsCleaning)
        path17 = cleanPath(path17);
      if (path17 === ".")
        return "";
      const needsSeperator = path17[path17.length - 1] !== pathSeparator;
      return convertSlashes(needsSeperator ? path17 + pathSeparator : path17, pathSeparator);
    }
    exports2.normalizePath = normalizePath2;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/join-path.js
var require_join_path = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/join-path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = exports2.joinDirectoryPath = exports2.joinPathWithBasePath = void 0;
    var path_1 = require("path");
    var utils_1 = require_utils4();
    function joinPathWithBasePath(filename, directoryPath) {
      return directoryPath + filename;
    }
    exports2.joinPathWithBasePath = joinPathWithBasePath;
    function joinPathWithRelativePath(root, options) {
      return function(filename, directoryPath) {
        const sameRoot = directoryPath.startsWith(root);
        if (sameRoot)
          return directoryPath.replace(root, "") + filename;
        else
          return (0, utils_1.convertSlashes)((0, path_1.relative)(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
      };
    }
    function joinPath(filename) {
      return filename;
    }
    function joinDirectoryPath(filename, directoryPath, separator) {
      return directoryPath + filename + separator;
    }
    exports2.joinDirectoryPath = joinDirectoryPath;
    function build(root, options) {
      const { relativePaths, includeBasePath } = options;
      return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
    }
    exports2.build = build;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/push-directory.js
var require_push_directory = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/push-directory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = void 0;
    function pushDirectoryWithRelativePath(root) {
      return function(directoryPath, paths) {
        paths.push(directoryPath.substring(root.length) || ".");
      };
    }
    function pushDirectoryFilterWithRelativePath(root) {
      return function(directoryPath, paths, filters) {
        const relativePath = directoryPath.substring(root.length) || ".";
        if (filters.every((filter3) => filter3(relativePath, true))) {
          paths.push(relativePath);
        }
      };
    }
    var pushDirectory = (directoryPath, paths) => {
      paths.push(directoryPath || ".");
    };
    var pushDirectoryFilter = (directoryPath, paths, filters) => {
      const path17 = directoryPath || ".";
      if (filters.every((filter3) => filter3(path17, true))) {
        paths.push(path17);
      }
    };
    var empty = () => {
    };
    function build(root, options) {
      const { includeDirs, filters, relativePaths } = options;
      if (!includeDirs)
        return empty;
      if (relativePaths)
        return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
      return filters && filters.length ? pushDirectoryFilter : pushDirectory;
    }
    exports2.build = build;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/push-file.js
var require_push_file = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/push-file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = void 0;
    var pushFileFilterAndCount = (filename, _paths, counts, filters) => {
      if (filters.every((filter3) => filter3(filename, false)))
        counts.files++;
    };
    var pushFileFilter = (filename, paths, _counts, filters) => {
      if (filters.every((filter3) => filter3(filename, false)))
        paths.push(filename);
    };
    var pushFileCount = (_filename, _paths, counts, _filters) => {
      counts.files++;
    };
    var pushFile = (filename, paths) => {
      paths.push(filename);
    };
    var empty = () => {
    };
    function build(options) {
      const { excludeFiles, filters, onlyCounts } = options;
      if (excludeFiles)
        return empty;
      if (filters && filters.length) {
        return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
      } else if (onlyCounts) {
        return pushFileCount;
      } else {
        return pushFile;
      }
    }
    exports2.build = build;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/get-array.js
var require_get_array = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/get-array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = void 0;
    var getArray = (paths) => {
      return paths;
    };
    var getArrayGroup = () => {
      return [""].slice(0, 0);
    };
    function build(options) {
      return options.group ? getArrayGroup : getArray;
    }
    exports2.build = build;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/group-files.js
var require_group_files = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/group-files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = void 0;
    var groupFiles = (groups, directory, files) => {
      groups.push({ directory, files, dir: directory });
    };
    var empty = () => {
    };
    function build(options) {
      return options.group ? groupFiles : empty;
    }
    exports2.build = build;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/resolve-symlink.js
var require_resolve_symlink = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/resolve-symlink.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = void 0;
    var fs_1 = __importDefault(require("fs"));
    var path_1 = require("path");
    var resolveSymlinksAsync = function(path17, state, callback) {
      const { queue, options: { suppressErrors } } = state;
      queue.enqueue();
      fs_1.default.realpath(path17, (error4, resolvedPath) => {
        if (error4)
          return queue.dequeue(suppressErrors ? null : error4, state);
        fs_1.default.stat(resolvedPath, (error5, stat3) => {
          if (error5)
            return queue.dequeue(suppressErrors ? null : error5, state);
          if (stat3.isDirectory() && isRecursive(path17, resolvedPath, state))
            return queue.dequeue(null, state);
          callback(stat3, resolvedPath);
          queue.dequeue(null, state);
        });
      });
    };
    var resolveSymlinks = function(path17, state, callback) {
      const { queue, options: { suppressErrors } } = state;
      queue.enqueue();
      try {
        const resolvedPath = fs_1.default.realpathSync(path17);
        const stat3 = fs_1.default.statSync(resolvedPath);
        if (stat3.isDirectory() && isRecursive(path17, resolvedPath, state))
          return;
        callback(stat3, resolvedPath);
      } catch (e) {
        if (!suppressErrors)
          throw e;
      }
    };
    function build(options, isSynchronous) {
      if (!options.resolveSymlinks || options.excludeSymlinks)
        return null;
      return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
    }
    exports2.build = build;
    function isRecursive(path17, resolved, state) {
      if (state.options.useRealPaths)
        return isRecursiveUsingRealPaths(resolved, state);
      let parent = (0, path_1.dirname)(path17);
      let depth = 1;
      while (parent !== state.root && depth < 2) {
        const resolvedPath = state.symlinks.get(parent);
        const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
        if (isSameRoot)
          depth++;
        else
          parent = (0, path_1.dirname)(parent);
      }
      state.symlinks.set(path17, resolved);
      return depth > 1;
    }
    function isRecursiveUsingRealPaths(resolved, state) {
      return state.visited.includes(resolved + state.options.pathSeparator);
    }
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/invoke-callback.js
var require_invoke_callback = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/invoke-callback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = void 0;
    var onlyCountsSync = (state) => {
      return state.counts;
    };
    var groupsSync = (state) => {
      return state.groups;
    };
    var defaultSync = (state) => {
      return state.paths;
    };
    var limitFilesSync = (state) => {
      return state.paths.slice(0, state.options.maxFiles);
    };
    var onlyCountsAsync = (state, error4, callback) => {
      report(error4, callback, state.counts, state.options.suppressErrors);
      return null;
    };
    var defaultAsync = (state, error4, callback) => {
      report(error4, callback, state.paths, state.options.suppressErrors);
      return null;
    };
    var limitFilesAsync = (state, error4, callback) => {
      report(error4, callback, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
      return null;
    };
    var groupsAsync = (state, error4, callback) => {
      report(error4, callback, state.groups, state.options.suppressErrors);
      return null;
    };
    function report(error4, callback, output, suppressErrors) {
      if (error4 && !suppressErrors)
        callback(error4, output);
      else
        callback(null, output);
    }
    function build(options, isSynchronous) {
      const { onlyCounts, group, maxFiles } = options;
      if (onlyCounts)
        return isSynchronous ? onlyCountsSync : onlyCountsAsync;
      else if (group)
        return isSynchronous ? groupsSync : groupsAsync;
      else if (maxFiles)
        return isSynchronous ? limitFilesSync : limitFilesAsync;
      else
        return isSynchronous ? defaultSync : defaultAsync;
    }
    exports2.build = build;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/walk-directory.js
var require_walk_directory = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/functions/walk-directory.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.build = void 0;
    var fs_1 = __importDefault(require("fs"));
    var readdirOpts = { withFileTypes: true };
    var walkAsync = (state, crawlPath, directoryPath, currentDepth, callback) => {
      state.queue.enqueue();
      if (currentDepth < 0)
        return state.queue.dequeue(null, state);
      state.visited.push(crawlPath);
      state.counts.directories++;
      fs_1.default.readdir(crawlPath || ".", readdirOpts, (error4, entries = []) => {
        callback(entries, directoryPath, currentDepth);
        state.queue.dequeue(state.options.suppressErrors ? null : error4, state);
      });
    };
    var walkSync = (state, crawlPath, directoryPath, currentDepth, callback) => {
      if (currentDepth < 0)
        return;
      state.visited.push(crawlPath);
      state.counts.directories++;
      let entries = [];
      try {
        entries = fs_1.default.readdirSync(crawlPath || ".", readdirOpts);
      } catch (e) {
        if (!state.options.suppressErrors)
          throw e;
      }
      callback(entries, directoryPath, currentDepth);
    };
    function build(isSynchronous) {
      return isSynchronous ? walkSync : walkAsync;
    }
    exports2.build = build;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/queue.js
var require_queue = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Queue = void 0;
    var Queue = class {
      onQueueEmpty;
      count = 0;
      constructor(onQueueEmpty) {
        this.onQueueEmpty = onQueueEmpty;
      }
      enqueue() {
        this.count++;
        return this.count;
      }
      dequeue(error4, output) {
        if (this.onQueueEmpty && (--this.count <= 0 || error4)) {
          this.onQueueEmpty(error4, output);
          if (error4) {
            output.controller.abort();
            this.onQueueEmpty = void 0;
          }
        }
      }
    };
    exports2.Queue = Queue;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/counter.js
var require_counter = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/counter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Counter = void 0;
    var Counter = class {
      _files = 0;
      _directories = 0;
      set files(num) {
        this._files = num;
      }
      get files() {
        return this._files;
      }
      set directories(num) {
        this._directories = num;
      }
      get directories() {
        return this._directories;
      }
      /**
       * @deprecated use `directories` instead
       */
      /* c8 ignore next 3 */
      get dirs() {
        return this._directories;
      }
    };
    exports2.Counter = Counter;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/walker.js
var require_walker = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/walker.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Walker = void 0;
    var path_1 = require("path");
    var utils_1 = require_utils4();
    var joinPath = __importStar(require_join_path());
    var pushDirectory = __importStar(require_push_directory());
    var pushFile = __importStar(require_push_file());
    var getArray = __importStar(require_get_array());
    var groupFiles = __importStar(require_group_files());
    var resolveSymlink = __importStar(require_resolve_symlink());
    var invokeCallback = __importStar(require_invoke_callback());
    var walkDirectory = __importStar(require_walk_directory());
    var queue_1 = require_queue();
    var counter_1 = require_counter();
    var Walker = class {
      root;
      isSynchronous;
      state;
      joinPath;
      pushDirectory;
      pushFile;
      getArray;
      groupFiles;
      resolveSymlink;
      walkDirectory;
      callbackInvoker;
      constructor(root, options, callback) {
        this.isSynchronous = !callback;
        this.callbackInvoker = invokeCallback.build(options, this.isSynchronous);
        this.root = (0, utils_1.normalizePath)(root, options);
        this.state = {
          root: (0, utils_1.isRootDirectory)(this.root) ? this.root : this.root.slice(0, -1),
          // Perf: we explicitly tell the compiler to optimize for String arrays
          paths: [""].slice(0, 0),
          groups: [],
          counts: new counter_1.Counter(),
          options,
          queue: new queue_1.Queue((error4, state) => this.callbackInvoker(state, error4, callback)),
          symlinks: /* @__PURE__ */ new Map(),
          visited: [""].slice(0, 0),
          controller: new AbortController()
        };
        this.joinPath = joinPath.build(this.root, options);
        this.pushDirectory = pushDirectory.build(this.root, options);
        this.pushFile = pushFile.build(options);
        this.getArray = getArray.build(options);
        this.groupFiles = groupFiles.build(options);
        this.resolveSymlink = resolveSymlink.build(options, this.isSynchronous);
        this.walkDirectory = walkDirectory.build(this.isSynchronous);
      }
      start() {
        this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
        this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
        return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
      }
      walk = (entries, directoryPath, depth) => {
        const { paths, options: { filters, resolveSymlinks, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
        if (controller.signal.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles)
          return;
        const files = this.getArray(this.state.paths);
        for (let i = 0; i < entries.length; ++i) {
          const entry = entries[i];
          if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks && !excludeSymlinks) {
            const filename = this.joinPath(entry.name, directoryPath);
            this.pushFile(filename, files, this.state.counts, filters);
          } else if (entry.isDirectory()) {
            let path17 = joinPath.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
            if (exclude && exclude(entry.name, path17))
              continue;
            this.pushDirectory(path17, paths, filters);
            this.walkDirectory(this.state, path17, path17, depth - 1, this.walk);
          } else if (this.resolveSymlink && entry.isSymbolicLink()) {
            let path17 = joinPath.joinPathWithBasePath(entry.name, directoryPath);
            this.resolveSymlink(path17, this.state, (stat3, resolvedPath) => {
              if (stat3.isDirectory()) {
                resolvedPath = (0, utils_1.normalizePath)(resolvedPath, this.state.options);
                if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path17 + pathSeparator))
                  return;
                this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path17 + pathSeparator, depth - 1, this.walk);
              } else {
                resolvedPath = useRealPaths ? resolvedPath : path17;
                const filename = (0, path_1.basename)(resolvedPath);
                const directoryPath2 = (0, utils_1.normalizePath)((0, path_1.dirname)(resolvedPath), this.state.options);
                resolvedPath = this.joinPath(filename, directoryPath2);
                this.pushFile(resolvedPath, files, this.state.counts, filters);
              }
            });
          }
        }
        this.groupFiles(this.state.groups, directoryPath, files);
      };
    };
    exports2.Walker = Walker;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/async.js
var require_async = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callback = exports2.promise = void 0;
    var walker_1 = require_walker();
    function promise(root, options) {
      return new Promise((resolve5, reject) => {
        callback(root, options, (err, output) => {
          if (err)
            return reject(err);
          resolve5(output);
        });
      });
    }
    exports2.promise = promise;
    function callback(root, options, callback2) {
      let walker = new walker_1.Walker(root, options, callback2);
      walker.start();
    }
    exports2.callback = callback;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/sync.js
var require_sync = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/api/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = void 0;
    var walker_1 = require_walker();
    function sync(root, options) {
      const walker = new walker_1.Walker(root, options);
      return walker.start();
    }
    exports2.sync = sync;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/builder/api-builder.js
var require_api_builder = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/builder/api-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APIBuilder = void 0;
    var async_1 = require_async();
    var sync_1 = require_sync();
    var APIBuilder = class {
      root;
      options;
      constructor(root, options) {
        this.root = root;
        this.options = options;
      }
      withPromise() {
        return (0, async_1.promise)(this.root, this.options);
      }
      withCallback(cb) {
        (0, async_1.callback)(this.root, this.options, cb);
      }
      sync() {
        return (0, sync_1.sync)(this.root, this.options);
      }
    };
    exports2.APIBuilder = APIBuilder;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/builder/index.js
var require_builder = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Builder = void 0;
    var path_1 = require("path");
    var api_builder_1 = require_api_builder();
    var pm2 = null;
    try {
      require.resolve("picomatch");
      pm2 = require_picomatch2();
    } catch (_e) {
    }
    var Builder = class {
      globCache = {};
      options = {
        maxDepth: Infinity,
        suppressErrors: true,
        pathSeparator: path_1.sep,
        filters: []
      };
      globFunction;
      constructor(options) {
        this.options = { ...this.options, ...options };
        this.globFunction = this.options.globFunction;
      }
      group() {
        this.options.group = true;
        return this;
      }
      withPathSeparator(separator) {
        this.options.pathSeparator = separator;
        return this;
      }
      withBasePath() {
        this.options.includeBasePath = true;
        return this;
      }
      withRelativePaths() {
        this.options.relativePaths = true;
        return this;
      }
      withDirs() {
        this.options.includeDirs = true;
        return this;
      }
      withMaxDepth(depth) {
        this.options.maxDepth = depth;
        return this;
      }
      withMaxFiles(limit) {
        this.options.maxFiles = limit;
        return this;
      }
      withFullPaths() {
        this.options.resolvePaths = true;
        this.options.includeBasePath = true;
        return this;
      }
      withErrors() {
        this.options.suppressErrors = false;
        return this;
      }
      withSymlinks({ resolvePaths = true } = {}) {
        this.options.resolveSymlinks = true;
        this.options.useRealPaths = resolvePaths;
        return this.withFullPaths();
      }
      withAbortSignal(signal) {
        this.options.signal = signal;
        return this;
      }
      normalize() {
        this.options.normalizePath = true;
        return this;
      }
      filter(predicate) {
        this.options.filters.push(predicate);
        return this;
      }
      onlyDirs() {
        this.options.excludeFiles = true;
        this.options.includeDirs = true;
        return this;
      }
      exclude(predicate) {
        this.options.exclude = predicate;
        return this;
      }
      onlyCounts() {
        this.options.onlyCounts = true;
        return this;
      }
      crawl(root) {
        return new api_builder_1.APIBuilder(root || ".", this.options);
      }
      withGlobFunction(fn) {
        this.globFunction = fn;
        return this;
      }
      /**
       * @deprecated Pass options using the constructor instead:
       * ```ts
       * new fdir(options).crawl("/path/to/root");
       * ```
       * This method will be removed in v7.0
       */
      /* c8 ignore next 4 */
      crawlWithOptions(root, options) {
        this.options = { ...this.options, ...options };
        return new api_builder_1.APIBuilder(root || ".", this.options);
      }
      glob(...patterns) {
        if (this.globFunction) {
          return this.globWithOptions(patterns);
        }
        return this.globWithOptions(patterns, ...[{ dot: true }]);
      }
      globWithOptions(patterns, ...options) {
        const globFn = this.globFunction || pm2;
        if (!globFn) {
          throw new Error("Please specify a glob function to use glob matching.");
        }
        var isMatch = this.globCache[patterns.join("\0")];
        if (!isMatch) {
          isMatch = globFn(patterns, ...options);
          this.globCache[patterns.join("\0")] = isMatch;
        }
        this.options.filters.push((path17) => isMatch(path17));
        return this;
      }
    };
    exports2.Builder = Builder;
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/types.js
var require_types = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/.pnpm/fdir@6.4.6_picomatch@4.0.2/node_modules/fdir/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fdir = void 0;
    var builder_1 = require_builder();
    Object.defineProperty(exports2, "fdir", { enumerable: true, get: function() {
      return builder_1.Builder;
    } });
    __exportStar(require_types(), exports2);
  }
});

// ../node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js
var require_json_buffer = __commonJS({
  "../node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js"(exports2) {
    exports2.stringify = function stringify4(o) {
      if ("undefined" == typeof o) return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON)
        o = o.toJSON();
      if (o && "object" === typeof o) {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first3 = true;
        for (var k in o) {
          var ignore = "function" == typeof o[k] || !array && "undefined" === typeof o[k];
          if (Object.hasOwnProperty.call(o, k) && !ignore) {
            if (!first3)
              s += ",";
            first3 = false;
            if (array) {
              if (o[k] == void 0)
                s += "null";
              else
                s += stringify4(o[k]);
            } else if (o[k] !== void 0) {
              s += stringify4(k) + ":" + stringify4(o[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if ("string" === typeof o) {
        return JSON.stringify(/^:/.test(o) ? ":" + o : o);
      } else if ("undefined" === typeof o) {
        return "null";
      } else
        return JSON.stringify(o);
    };
    exports2.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        if ("string" === typeof value) {
          if (/^:base64:/.test(value))
            return Buffer.from(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  }
});

// ../node_modules/.pnpm/keyv@4.5.4/node_modules/keyv/src/index.js
var require_src3 = __commonJS({
  "../node_modules/.pnpm/keyv@4.5.4/node_modules/keyv/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var JSONB = require_json_buffer();
    var loadStore = (options) => {
      const adapters = {
        redis: "@keyv/redis",
        rediss: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql",
        etcd: "@keyv/etcd",
        offline: "@keyv/offline",
        tiered: "@keyv/tiered"
      };
      if (options.adapter || options.uri) {
        const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
        return new (require(adapters[adapter]))(options);
      }
      return /* @__PURE__ */ new Map();
    };
    var iterableAdapters = [
      "sqlite",
      "postgres",
      "mysql",
      "mongo",
      "redis",
      "tiered"
    ];
    var Keyv = class extends EventEmitter2 {
      constructor(uri, { emitErrors = true, ...options } = {}) {
        super();
        this.opts = {
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse,
          ...typeof uri === "string" ? { uri } : uri,
          ...options
        };
        if (!this.opts.store) {
          const adapterOptions = { ...this.opts };
          this.opts.store = loadStore(adapterOptions);
        }
        if (this.opts.compression) {
          const compression = this.opts.compression;
          this.opts.serialize = compression.serialize.bind(compression);
          this.opts.deserialize = compression.deserialize.bind(compression);
        }
        if (typeof this.opts.store.on === "function" && emitErrors) {
          this.opts.store.on("error", (error4) => this.emit("error", error4));
        }
        this.opts.store.namespace = this.opts.namespace;
        const generateIterator = (iterator) => async function* () {
          for await (const [key, raw] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator) {
            const data = await this.opts.deserialize(raw);
            if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
              continue;
            }
            if (typeof data.expires === "number" && Date.now() > data.expires) {
              this.delete(key);
              continue;
            }
            yield [this._getKeyUnprefix(key), data.value];
          }
        };
        if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) {
          this.iterator = generateIterator(this.opts.store);
        } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) {
          this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
        }
      }
      _checkIterableAdaptar() {
        return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      _getKeyPrefixArray(keys3) {
        return keys3.map((key) => `${this.opts.namespace}:${key}`);
      }
      _getKeyUnprefix(key) {
        return key.split(":").splice(1).join(":");
      }
      get(key, options) {
        const { store } = this.opts;
        const isArray3 = Array.isArray(key);
        const keyPrefixed = isArray3 ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
        if (isArray3 && store.getMany === void 0) {
          const promises3 = [];
          for (const key2 of keyPrefixed) {
            promises3.push(
              Promise.resolve().then(() => store.get(key2)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
                if (data === void 0 || data === null) {
                  return void 0;
                }
                if (typeof data.expires === "number" && Date.now() > data.expires) {
                  return this.delete(key2).then(() => void 0);
                }
                return options && options.raw ? data : data.value;
              })
            );
          }
          return Promise.allSettled(promises3).then((values) => {
            const data = [];
            for (const value of values) {
              data.push(value.value);
            }
            return data;
          });
        }
        return Promise.resolve().then(() => isArray3 ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
          if (data === void 0 || data === null) {
            return void 0;
          }
          if (isArray3) {
            return data.map((row, index) => {
              if (typeof row === "string") {
                row = this.opts.deserialize(row);
              }
              if (row === void 0 || row === null) {
                return void 0;
              }
              if (typeof row.expires === "number" && Date.now() > row.expires) {
                this.delete(key[index]).then(() => void 0);
                return void 0;
              }
              return options && options.raw ? row : row.value;
            });
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            return this.delete(key).then(() => void 0);
          }
          return options && options.raw ? data : data.value;
        });
      }
      set(key, value, ttl) {
        const keyPrefixed = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") {
          ttl = this.opts.ttl;
        }
        if (ttl === 0) {
          ttl = void 0;
        }
        const { store } = this.opts;
        return Promise.resolve().then(() => {
          const expires = typeof ttl === "number" ? Date.now() + ttl : null;
          if (typeof value === "symbol") {
            this.emit("error", "symbol cannot be serialized");
          }
          value = { value, expires };
          return this.opts.serialize(value);
        }).then((value2) => store.set(keyPrefixed, value2, ttl)).then(() => true);
      }
      delete(key) {
        const { store } = this.opts;
        if (Array.isArray(key)) {
          const keyPrefixed2 = this._getKeyPrefixArray(key);
          if (store.deleteMany === void 0) {
            const promises3 = [];
            for (const key2 of keyPrefixed2) {
              promises3.push(store.delete(key2));
            }
            return Promise.allSettled(promises3).then((values) => values.every((x) => x.value === true));
          }
          return Promise.resolve().then(() => store.deleteMany(keyPrefixed2));
        }
        const keyPrefixed = this._getKeyPrefix(key);
        return Promise.resolve().then(() => store.delete(keyPrefixed));
      }
      clear() {
        const { store } = this.opts;
        return Promise.resolve().then(() => store.clear());
      }
      has(key) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store } = this.opts;
        return Promise.resolve().then(async () => {
          if (typeof store.has === "function") {
            return store.has(keyPrefixed);
          }
          const value = await store.get(keyPrefixed);
          return value !== void 0;
        });
      }
      disconnect() {
        const { store } = this.opts;
        if (typeof store.disconnect === "function") {
          return store.disconnect();
        }
      }
    };
    module2.exports = Keyv;
  }
});

// ../node_modules/.pnpm/flatted@3.3.3/node_modules/flatted/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/.pnpm/flatted@3.3.3/node_modules/flatted/cjs/index.js"(exports2) {
    "use strict";
    var { parse: $parse, stringify: $stringify } = JSON;
    var { keys: keys3 } = Object;
    var Primitive = String;
    var primitive = "string";
    var ignore = {};
    var object = "object";
    var noop = (_, value) => value;
    var primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
    var Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;
    var revive = (input, parsed, output, $) => {
      const lazy = [];
      for (let ke = keys3(output), { length } = ke, y = 0; y < length; y++) {
        const k = ke[y];
        const value = output[k];
        if (value instanceof Primitive) {
          const tmp = input[value];
          if (typeof tmp === object && !parsed.has(tmp)) {
            parsed.add(tmp);
            output[k] = ignore;
            lazy.push({ k, a: [input, parsed, tmp, $] });
          } else
            output[k] = $.call(output, k, tmp);
        } else if (output[k] !== ignore)
          output[k] = $.call(output, k, value);
      }
      for (let { length } = lazy, i = 0; i < length; i++) {
        const { k, a } = lazy[i];
        output[k] = $.call(output, k, revive.apply(null, a));
      }
      return output;
    };
    var set = (known, input, value) => {
      const index = Primitive(input.push(value) - 1);
      known.set(value, index);
      return index;
    };
    var parse3 = (text, reviver) => {
      const input = $parse(text, Primitives).map(primitives);
      const value = input[0];
      const $ = reviver || noop;
      const tmp = typeof value === object && value ? revive(input, /* @__PURE__ */ new Set(), value, $) : value;
      return $.call({ "": tmp }, "", tmp);
    };
    exports2.parse = parse3;
    var stringify4 = (value, replacer, space) => {
      const $ = replacer && typeof replacer === object ? (k, v) => k === "" || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;
      const known = /* @__PURE__ */ new Map();
      const input = [];
      const output = [];
      let i = +set(known, input, $.call({ "": value }, "", value));
      let firstRun = !i;
      while (i < input.length) {
        firstRun = true;
        output[i] = $stringify(input[i++], replace, space);
      }
      return "[" + output.join(",") + "]";
      function replace(key, value2) {
        if (firstRun) {
          firstRun = !firstRun;
          return value2;
        }
        const after = $.call(this, key, value2);
        switch (typeof after) {
          case object:
            if (after === null) return after;
          case primitive:
            return known.get(after) || set(known, input, after);
        }
        return after;
      }
    };
    exports2.stringify = stringify4;
    var toJSON = (value) => $parse(stringify4(value));
    exports2.toJSON = toJSON;
    var fromJSON = (value) => parse3($stringify(value));
    exports2.fromJSON = fromJSON;
  }
});

// ../node_modules/.pnpm/flat-cache@5.0.0/node_modules/flat-cache/src/utils.js
var require_utils5 = __commonJS({
  "../node_modules/.pnpm/flat-cache@5.0.0/node_modules/flat-cache/src/utils.js"(exports2, module2) {
    var fs6 = require("node:fs");
    var path17 = require("node:path");
    var flatted = require_cjs();
    function tryParse(filePath, defaultValue) {
      let result;
      try {
        result = readJSON(filePath);
      } catch {
        result = defaultValue;
      }
      return result;
    }
    function readJSON(filePath) {
      return flatted.parse(
        fs6.readFileSync(filePath, {
          encoding: "utf8"
        })
      );
    }
    function writeJSON(filePath, data) {
      fs6.mkdirSync(path17.dirname(filePath), {
        recursive: true
      });
      fs6.writeFileSync(filePath, flatted.stringify(data));
    }
    module2.exports = { tryParse, readJSON, writeJSON };
  }
});

// ../node_modules/.pnpm/flat-cache@5.0.0/node_modules/flat-cache/src/del.js
var require_del = __commonJS({
  "../node_modules/.pnpm/flat-cache@5.0.0/node_modules/flat-cache/src/del.js"(exports2, module2) {
    var fs6 = require("node:fs");
    var path17 = require("node:path");
    function del(targetPath) {
      if (!fs6.existsSync(targetPath)) {
        return false;
      }
      try {
        if (fs6.statSync(targetPath).isDirectory()) {
          for (const file of fs6.readdirSync(targetPath)) {
            const currentPath = path17.join(targetPath, file);
            if (fs6.statSync(currentPath).isFile()) {
              fs6.unlinkSync(currentPath);
            }
          }
          fs6.rmdirSync(targetPath);
        } else {
          fs6.unlinkSync(targetPath);
        }
        return true;
      } catch (error4) {
        console.error(`Error while deleting ${targetPath}: ${error4.message}`);
      }
    }
    module2.exports = { del };
  }
});

// ../node_modules/.pnpm/flat-cache@5.0.0/node_modules/flat-cache/src/cache.js
var require_cache2 = __commonJS({
  "../node_modules/.pnpm/flat-cache@5.0.0/node_modules/flat-cache/src/cache.js"(exports2, module2) {
    var path17 = require("node:path");
    var fs6 = require("node:fs");
    var Keyv = require_src3();
    var { writeJSON, tryParse } = require_utils5();
    var { del } = require_del();
    var cache5 = {
      /**
        * Load a cache identified by the given Id. If the element does not exists, then initialize an empty
        * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted
        * then the cache module directory `./cache` will be used instead
        *
        * @method load
        * @param docId {String} the id of the cache, would also be used as the name of the file cache
        * @param [cacheDir] {String} directory for the cache entry
        */
      load(documentId, cacheDir) {
        const me = this;
        me.keyv = new Keyv();
        me.__visited = {};
        me.__persisted = {};
        me._pathToFile = cacheDir ? path17.resolve(cacheDir, documentId) : path17.resolve(__dirname, "../.cache/", documentId);
        if (fs6.existsSync(me._pathToFile)) {
          me._persisted = tryParse(me._pathToFile, {});
        }
      },
      get _persisted() {
        return this.__persisted;
      },
      set _persisted(value) {
        this.__persisted = value;
      },
      get _visited() {
        return this.__visited;
      },
      set _visited(value) {
        this.__visited = value;
      },
      /**
        * Load the cache from the provided file
        * @method loadFile
        * @param  {String} pathToFile the path to the file containing the info for the cache
        */
      loadFile(pathToFile) {
        const me = this;
        const dir = path17.dirname(pathToFile);
        const fName = path17.basename(pathToFile);
        me.load(fName, dir);
      },
      /**
        * Returns the entire persisted object
        * @method all
        * @returns {*}
        */
      all() {
        return this._persisted;
      },
      keys() {
        return Object.keys(this._persisted);
      },
      /**
        * Sets a key to a given value
        * @method setKey
        * @param key {string} the key to set
        * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify
        */
      setKey(key, value) {
        this._visited[key] = true;
        this._persisted[key] = value;
      },
      /**
        * Remove a given key from the cache
        * @method removeKey
        * @param key {String} the key to remove from the object
        */
      removeKey(key) {
        delete this._visited[key];
        delete this._persisted[key];
      },
      /**
        * Return the value of the provided key
        * @method getKey
        * @param key {String} the name of the key to retrieve
        * @returns {*} the value from the key
        */
      getKey(key) {
        this._visited[key] = true;
        return this._persisted[key];
      },
      /**
        * Remove keys that were not accessed/set since the
        * last time the `prune` method was called.
        * @method _prune
        * @private
        */
      _prune() {
        const me = this;
        const object = {};
        const keys3 = Object.keys(me._visited);
        if (keys3.length === 0) {
          return;
        }
        for (const key of keys3) {
          object[key] = me._persisted[key];
        }
        me._visited = {};
        me._persisted = object;
      },
      /**
        * Save the state of the cache identified by the docId to disk
        * as a JSON structure
        * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files
        * @method save
        */
      save(noPrune) {
        const me = this;
        !noPrune && me._prune();
        writeJSON(me._pathToFile, me._persisted);
      },
      /**
        * Remove the file where the cache is persisted
        * @method removeCacheFile
        * @return {Boolean} true or false if the file was successfully deleted
        */
      removeCacheFile() {
        return del(this._pathToFile);
      },
      /**
        * Destroy the file cache and cache content.
        * @method destroy
        */
      destroy() {
        const me = this;
        me._visited = {};
        me._persisted = {};
        me.removeCacheFile();
      }
    };
    module2.exports = {
      /**
        * Alias for create. Should be considered depreacted. Will be removed in next releases
        *
        * @method load
        * @param docId {String} the id of the cache, would also be used as the name of the file cache
        * @param [cacheDir] {String} directory for the cache entry
        * @returns {cache} cache instance
        */
      load(documentId, cacheDir) {
        return this.create(documentId, cacheDir);
      },
      /**
        * Load a cache identified by the given Id. If the element does not exists, then initialize an empty
        * cache storage.
        *
        * @method create
        * @param docId {String} the id of the cache, would also be used as the name of the file cache
        * @param [cacheDir] {String} directory for the cache entry
        * @returns {cache} cache instance
        */
      create(documentId, cacheDir) {
        const object = Object.create(cache5);
        object.load(documentId, cacheDir);
        return object;
      },
      createFromFile(filePath) {
        const object = Object.create(cache5);
        object.loadFile(filePath);
        return object;
      },
      /**
        * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly
        *
        * @method clearCache
        * @param docId {String} the id of the cache, would also be used as the name of the file cache
        * @param cacheDir {String} the directory where the cache file was written
        * @returns {Boolean} true if the cache folder was deleted. False otherwise
        */
      clearCacheById(documentId, cacheDir) {
        const filePath = cacheDir ? path17.resolve(cacheDir, documentId) : path17.resolve(__dirname, "../.cache/", documentId);
        return del(filePath);
      },
      /**
        * Remove all cache stored in the cache directory
        * @method clearAll
        * @returns {Boolean} true if the cache folder was deleted. False otherwise
        */
      clearAll(cacheDir) {
        const filePath = cacheDir ? path17.resolve(cacheDir) : path17.resolve(__dirname, "../.cache/");
        return del(filePath);
      }
    };
  }
});

// ../node_modules/.pnpm/file-entry-cache@9.1.0/node_modules/file-entry-cache/cache.js
var require_cache3 = __commonJS({
  "../node_modules/.pnpm/file-entry-cache@9.1.0/node_modules/file-entry-cache/cache.js"(exports2, module2) {
    var path17 = require("node:path");
    var crypto2 = require("node:crypto");
    module2.exports = {
      createFromFile(filePath, useChecksum, currentWorkingDir) {
        const fname = path17.basename(filePath);
        const dir = path17.dirname(filePath);
        return this.create(fname, dir, useChecksum, currentWorkingDir);
      },
      create(cacheId, _path, useChecksum, currentWorkingDir) {
        const fs6 = require("node:fs");
        const flatCache = require_cache2();
        const cache5 = flatCache.load(cacheId, _path);
        let normalizedEntries = {};
        const removeNotFoundFiles = function removeNotFoundFiles2() {
          const cachedEntries = cache5.keys();
          for (const fPath of cachedEntries) {
            try {
              let filePath = fPath;
              if (currentWorkingDir) {
                filePath = path17.join(currentWorkingDir, fPath);
              }
              fs6.statSync(filePath);
            } catch (error4) {
              if (error4.code === "ENOENT") {
                cache5.removeKey(fPath);
              }
            }
          }
        };
        removeNotFoundFiles();
        return {
          /**
              * The flat cache storage used to persist the metadata of the `files
              * @type {Object}
              */
          cache: cache5,
          /**
              * To enable relative paths as the key with current working directory
              * @type {string}
              */
          currentWorkingDir: currentWorkingDir ?? void 0,
          /**
              * Given a buffer, calculate md5 hash of its content.
              * @method getHash
              * @param  {Buffer} buffer   buffer to calculate hash on
              * @return {String}          content hash digest
              */
          getHash(buffer) {
            return crypto2.createHash("md5").update(buffer).digest("hex");
          },
          /**
              * Return whether or not a file has changed since last time reconcile was called.
              * @method hasFileChanged
              * @param  {String}  file  the filepath to check
              * @return {Boolean}       wheter or not the file has changed
              */
          hasFileChanged(file) {
            return this.getFileDescriptor(file).changed;
          },
          /**
              * Given an array of file paths it return and object with three arrays:
              *  - changedFiles: Files that changed since previous run
              *  - notChangedFiles: Files that haven't change
              *  - notFoundFiles: Files that were not found, probably deleted
              *
              * @param  {Array} files the files to analyze and compare to the previous seen files
              * @return {[type]}       [description]
              */
          analyzeFiles(files) {
            const me = this;
            files ||= [];
            const res = {
              changedFiles: [],
              notFoundFiles: [],
              notChangedFiles: []
            };
            for (const entry of me.normalizeEntries(files)) {
              if (entry.changed) {
                res.changedFiles.push(entry.key);
                continue;
              }
              if (entry.notFound) {
                res.notFoundFiles.push(entry.key);
                continue;
              }
              res.notChangedFiles.push(entry.key);
            }
            return res;
          },
          getFileDescriptor(file) {
            let fstat;
            try {
              fstat = fs6.statSync(file);
            } catch (error4) {
              this.removeEntry(file);
              return { key: file, notFound: true, err: error4 };
            }
            if (useChecksum) {
              return this._getFileDescriptorUsingChecksum(file);
            }
            return this._getFileDescriptorUsingMtimeAndSize(file, fstat);
          },
          _getFileKey(file) {
            if (this.currentWorkingDir) {
              return file.split(this.currentWorkingDir).pop();
            }
            return file;
          },
          _getFileDescriptorUsingMtimeAndSize(file, fstat) {
            let meta = cache5.getKey(this._getFileKey(file));
            const cacheExists = Boolean(meta);
            const cSize = fstat.size;
            const cTime = fstat.mtime.getTime();
            let isDifferentDate;
            let isDifferentSize;
            if (meta) {
              isDifferentDate = cTime !== meta.mtime;
              isDifferentSize = cSize !== meta.size;
            } else {
              meta = { size: cSize, mtime: cTime };
            }
            const nEntry = normalizedEntries[this._getFileKey(file)] = {
              key: this._getFileKey(file),
              changed: !cacheExists || isDifferentDate || isDifferentSize,
              meta
            };
            return nEntry;
          },
          _getFileDescriptorUsingChecksum(file) {
            let meta = cache5.getKey(this._getFileKey(file));
            const cacheExists = Boolean(meta);
            let contentBuffer;
            try {
              contentBuffer = fs6.readFileSync(file);
            } catch {
              contentBuffer = "";
            }
            let isDifferent = true;
            const hash = this.getHash(contentBuffer);
            if (meta) {
              isDifferent = hash !== meta.hash;
            } else {
              meta = { hash };
            }
            const nEntry = normalizedEntries[this._getFileKey(file)] = {
              key: this._getFileKey(file),
              changed: !cacheExists || isDifferent,
              meta
            };
            return nEntry;
          },
          /**
              * Return the list o the files that changed compared
              * against the ones stored in the cache
              *
              * @method getUpdated
              * @param files {Array} the array of files to compare against the ones in the cache
              * @returns {Array}
              */
          getUpdatedFiles(files) {
            const me = this;
            files ||= [];
            return me.normalizeEntries(files).filter((entry) => entry.changed).map((entry) => entry.key);
          },
          /**
              * Return the list of files
              * @method normalizeEntries
              * @param files
              * @returns {*}
              */
          normalizeEntries(files) {
            files ||= [];
            const me = this;
            const nEntries = files.map((file) => me.getFileDescriptor(file));
            return nEntries;
          },
          /**
              * Remove an entry from the file-entry-cache. Useful to force the file to still be considered
              * modified the next time the process is run
              *
              * @method removeEntry
              * @param entryName
              */
          removeEntry(entryName) {
            delete normalizedEntries[this._getFileKey(entryName)];
            cache5.removeKey(this._getFileKey(entryName));
          },
          /**
              * Delete the cache file from the disk
              * @method deleteCacheFile
              */
          deleteCacheFile() {
            cache5.removeCacheFile();
          },
          /**
              * Remove the cache from the file and clear the memory cache
              */
          destroy() {
            normalizedEntries = {};
            cache5.destroy();
          },
          _getMetaForFileUsingCheckSum(cacheEntry) {
            let filePath = cacheEntry.key;
            if (this.currentWorkingDir) {
              filePath = path17.join(this.currentWorkingDir, filePath);
            }
            const contentBuffer = fs6.readFileSync(filePath);
            const hash = this.getHash(contentBuffer);
            const meta = Object.assign(cacheEntry.meta, { hash });
            delete meta.size;
            delete meta.mtime;
            return meta;
          },
          _getMetaForFileUsingMtimeAndSize(cacheEntry) {
            let filePath = cacheEntry.key;
            if (currentWorkingDir) {
              filePath = path17.join(currentWorkingDir, filePath);
            }
            const stat3 = fs6.statSync(filePath);
            const meta = Object.assign(cacheEntry.meta, {
              size: stat3.size,
              mtime: stat3.mtime.getTime()
            });
            delete meta.hash;
            return meta;
          },
          /**
              * Sync the files and persist them to the cache
              * @method reconcile
              */
          reconcile(noPrune) {
            removeNotFoundFiles();
            noPrune = noPrune === void 0 ? true : noPrune;
            const entries = normalizedEntries;
            const keys3 = Object.keys(entries);
            if (keys3.length === 0) {
              return;
            }
            const me = this;
            for (const entryName of keys3) {
              const cacheEntry = entries[entryName];
              try {
                const meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);
                cache5.setKey(this._getFileKey(entryName), meta);
              } catch (error4) {
                if (error4.code !== "ENOENT") {
                  throw error4;
                }
              }
            }
            cache5.save(noPrune);
          }
        };
      }
    };
  }
});

// src/main.ts
var import_core5 = __toESM(require_core(), 1);
var import_context = __toESM(require_context(), 1);

// src/action.ts
var import_node_path12 = __toESM(require("node:path"), 1);
var import_core4 = __toESM(require_core(), 1);

// src/ActionParams.ts
var import_fs = require("fs");

// src/error.ts
var AppError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function toError(e) {
  if (e instanceof Error) return e;
  if (typeof e === "string") return new Error(e);
  const err = new Error("Unknown error");
  err.cause = e;
  return err;
}

// src/ActionParams.ts
var defaultActionParams = {
  files: "",
  incremental_files_only: "true",
  config: "",
  root: "",
  inline: "warning",
  treat_flagged_words_as_errors: "false",
  strict: "true",
  verbose: "false",
  check_dot_files: "explicit",
  use_cspell_files: "false",
  suggestions: "false",
  report: "all"
};
function applyDefaults(params) {
  const results = { ...defaultActionParams, ...params };
  const alias = results;
  for (const [key, value] of Object.entries(defaultActionParams)) {
    alias[key] = alias[key] || value;
  }
  return results;
}
function validateConfig(params) {
  const config = params.config;
  const success = !config || (0, import_fs.existsSync)(config);
  return !success ? `Configuration file "${config}" not found.` : void 0;
}
function validateRoot(params) {
  const root = params.root;
  const success = !root || (0, import_fs.existsSync)(root);
  return !success ? `Root path does not exist: "${root}"` : void 0;
}
function validateTrueFalse(key) {
  return validateOptions(key, ["true", "false"]);
}
function validateOptions(key, options) {
  return (params) => {
    const value = params[key];
    const success = options.includes(value);
    return !success ? `Invalid ${key} setting, must be one of (${options.join(", ")})` : void 0;
  };
}
function validateActionParams(params, logError2) {
  const validations = [
    validateConfig,
    validateRoot,
    validateOptions("inline", ["error", "warning", "none"]),
    validateTrueFalse("treat_flagged_words_as_errors"),
    validateTrueFalse("strict"),
    validateTrueFalse("incremental_files_only"),
    validateTrueFalse("verbose"),
    validateTrueFalse("use_cspell_files"),
    validateTrueFalse("suggestions"),
    validateOptions("check_dot_files", ["true", "false", "explicit"]),
    validateOptions("report", ["all", "simple", "typos", "flagged"])
  ];
  const success = validations.map((fn) => fn(params)).map((msg) => !msg || (logError2(msg), false)).reduce((a, b) => a && b, true);
  if (!success) {
    throw new AppError("Bad Configuration.");
  }
}

// src/checkDotMap.ts
var checkDotMap = {
  true: true,
  false: false,
  explicit: void 0
};

// src/checkSpelling.ts
var import_node_path11 = __toESM(require("node:path"), 1);
var import_core2 = __toESM(require_core(), 1);

// src/git.ts
var import_node_child_process = require("node:child_process");
var import_node_util = require("node:util");
var execP = (0, import_node_util.promisify)(import_node_child_process.exec);
async function gitListCommits(count3 = 100, _since) {
  const args = ["rev-list", "HEAD", `-${count3}`];
  const cmdResult = await runGit(args);
  return cmdResult.split("\n").map((a) => a.trim()).filter((a) => !!a);
}
async function gitDeepen(count3) {
  const args = ["fetch", `--deepen=${count3}`];
  await runGit(args);
}
async function gitListFiles(sha1, sha2) {
  const SHAs = [sha1, sha2].map(cleanSha).filter((a) => !!a);
  if (!SHAs.length) return [];
  const args = ["diff-tree", "--no-commit-id", "--name-only", "-r", ...SHAs];
  const cmdResult = await runGit(args);
  return cmdResult.split("\n").map((a) => a.trim()).filter((a) => !!a);
}
async function gitRoot() {
  return (await runGit(["rev-parse", "--show-toplevel"])).trim();
}
function cleanSha(sha) {
  if (!sha) return "";
  if (["HEAD"].includes(sha)) return sha;
  const s = sha.trim().replace(/[^a-fA-F0-9]/g, "");
  return s.replace(/^0+$/, "");
}
async function gitListFilesForPullRequest(pr) {
  const event = pr;
  const sha1 = pr?.pull_request?.base?.sha || event?.before;
  const sha2 = event?.after || pr?.pull_request?.head?.sha;
  if (!sha1 || !sha2 || !pr.pull_request) {
    throw new GitError(`Invalid PR event base.sha: ${sha1}, head.sha: ${sha2}`);
  }
  const commitCount = pr.pull_request.commits || 0;
  try {
    await deepenIfNecessary(commitCount + 1);
    return gitListFiles(sha1, sha2);
  } catch (e) {
    throw new GitError(`Error getting files for PR ${pr?.number} from git`, e);
  }
}
async function gitListFilesForPush(push) {
  try {
    const commitCount = push.commits?.length || 0;
    await deepenIfNecessary(commitCount + 1);
    return gitListFiles(push.before, push.after);
  } catch (e) {
    throw new GitError(`Error getting files for Push, (Commit: ${push?.after}) from git`, e);
  }
}
async function deepenIfNecessary(commitCount) {
  const commits = await gitListCommits(commitCount);
  if (commits.length < commitCount) {
    await gitDeepen(commitCount);
  }
}
var GitError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "GitError";
  }
};
async function runGit(args) {
  const { stdout } = await execP(`git ${args.join(" ")}`);
  return stdout;
}

// src/reporter.ts
var import_core = __toESM(require_core(), 1);
var import_command = __toESM(require_command(), 1);
var path = __toESM(require("path"), 1);

// ../node_modules/.pnpm/vscode-uri@3.1.0/node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  "use strict";
  var t = { 975: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i2 = 0, o2 = -1, s2 = 0, h2 = 0; h2 <= t3.length; ++h2) {
        if (h2 < t3.length) r3 = t3.charCodeAt(h2);
        else {
          if (47 === r3) break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o2 === h2 - 1 || 1 === s2) ;
          else if (o2 !== h2 - 1 && 2 === s2) {
            if (n3.length < 2 || 2 !== i2 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a2 = n3.lastIndexOf("/");
                if (a2 !== n3.length - 1) {
                  -1 === a2 ? (n3 = "", i2 = 0) : i2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o2 = h2, s2 = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i2 = 0, o2 = h2, s2 = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i2 = 2);
          } else n3.length > 0 ? n3 += "/" + t3.slice(o2 + 1, h2) : n3 = t3.slice(o2 + 1, h2), i2 = h2 - o2 - 1;
          o2 = h2, s2 = 0;
        } else 46 === r3 && -1 !== s2 ? ++s2 : s2 = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i2 = false, o2 = arguments.length - 1; o2 >= -1 && !i2; o2--) {
        var s2;
        o2 >= 0 ? s2 = arguments[o2] : (void 0 === t3 && (t3 = process.cwd()), s2 = t3), e2(s2), 0 !== s2.length && (n3 = s2 + "/" + n3, i2 = 47 === s2.charCodeAt(0));
      }
      return n3 = r2(n3, !i2), i2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      var n3 = 47 === t3.charCodeAt(0), i2 = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i2 && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length) return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i2 = arguments[r3];
        e2(i2), i2.length > 0 && (void 0 === t3 ? t3 = i2 : t3 += "/" + i2);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3) return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
      for (var i2 = 1; i2 < t3.length && 47 === t3.charCodeAt(i2); ++i2) ;
      for (var o2 = t3.length, s2 = o2 - i2, h2 = 1; h2 < r3.length && 47 === r3.charCodeAt(h2); ++h2) ;
      for (var a2 = r3.length - h2, c2 = s2 < a2 ? s2 : a2, f2 = -1, u2 = 0; u2 <= c2; ++u2) {
        if (u2 === c2) {
          if (a2 > c2) {
            if (47 === r3.charCodeAt(h2 + u2)) return r3.slice(h2 + u2 + 1);
            if (0 === u2) return r3.slice(h2 + u2);
          } else s2 > c2 && (47 === t3.charCodeAt(i2 + u2) ? f2 = u2 : 0 === u2 && (f2 = 0));
          break;
        }
        var l2 = t3.charCodeAt(i2 + u2);
        if (l2 !== r3.charCodeAt(h2 + u2)) break;
        47 === l2 && (f2 = u2);
      }
      var g2 = "";
      for (u2 = i2 + f2 + 1; u2 <= o2; ++u2) u2 !== o2 && 47 !== t3.charCodeAt(u2) || (0 === g2.length ? g2 += ".." : g2 += "/..");
      return g2.length > 0 ? g2 + r3.slice(h2 + f2) : (h2 += f2, 47 === r3.charCodeAt(h2) && ++h2, r3.slice(h2));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i2 = -1, o2 = true, s2 = t3.length - 1; s2 >= 1; --s2) if (47 === (r3 = t3.charCodeAt(s2))) {
        if (!o2) {
          i2 = s2;
          break;
        }
      } else o2 = false;
      return -1 === i2 ? n3 ? "/" : "." : n3 && 1 === i2 ? "//" : t3.slice(0, i2);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i2 = 0, o2 = -1, s2 = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3) return "";
        var h2 = r3.length - 1, a2 = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c2 = t3.charCodeAt(n3);
          if (47 === c2) {
            if (!s2) {
              i2 = n3 + 1;
              break;
            }
          } else -1 === a2 && (s2 = false, a2 = n3 + 1), h2 >= 0 && (c2 === r3.charCodeAt(h2) ? -1 == --h2 && (o2 = n3) : (h2 = -1, o2 = a2));
        }
        return i2 === o2 ? o2 = a2 : -1 === o2 && (o2 = t3.length), t3.slice(i2, o2);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
        if (!s2) {
          i2 = n3 + 1;
          break;
        }
      } else -1 === o2 && (s2 = false, o2 = n3 + 1);
      return -1 === o2 ? "" : t3.slice(i2, o2);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i2 = -1, o2 = true, s2 = 0, h2 = t3.length - 1; h2 >= 0; --h2) {
        var a2 = t3.charCodeAt(h2);
        if (47 !== a2) -1 === i2 && (o2 = false, i2 = h2 + 1), 46 === a2 ? -1 === r3 ? r3 = h2 : 1 !== s2 && (s2 = 1) : -1 !== r3 && (s2 = -1);
        else if (!o2) {
          n3 = h2 + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i2 || 0 === s2 || 1 === s2 && r3 === i2 - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i2);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      }(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length) return r3;
      var n3, i2 = t3.charCodeAt(0), o2 = 47 === i2;
      o2 ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s2 = -1, h2 = 0, a2 = -1, c2 = true, f2 = t3.length - 1, u2 = 0; f2 >= n3; --f2) if (47 !== (i2 = t3.charCodeAt(f2))) -1 === a2 && (c2 = false, a2 = f2 + 1), 46 === i2 ? -1 === s2 ? s2 = f2 : 1 !== u2 && (u2 = 1) : -1 !== s2 && (u2 = -1);
      else if (!c2) {
        h2 = f2 + 1;
        break;
      }
      return -1 === s2 || -1 === a2 || 0 === u2 || 1 === u2 && s2 === a2 - 1 && s2 === h2 + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h2 && o2 ? t3.slice(1, a2) : t3.slice(h2, a2)) : (0 === h2 && o2 ? (r3.name = t3.slice(1, s2), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h2, s2), r3.base = t3.slice(h2, a2)), r3.ext = t3.slice(s2, a2)), h2 > 0 ? r3.dir = t3.slice(0, h2 - 1) : o2 && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i2 = e[n2];
    if (void 0 !== i2) return i2.exports;
    var o2 = e[n2] = { exports: {} };
    return t[n2](o2, o2.exports, r), o2.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  let i;
  if (r.r(n), r.d(n, { URI: () => l, Utils: () => I }), "object" == typeof process) i = "win32" === process.platform;
  else if ("object" == typeof navigator) {
    let t2 = navigator.userAgent;
    i = t2.indexOf("Windows") >= 0;
  }
  const o = /^\w[\w\d+.-]*$/, s = /^\//, h = /^\/\//;
  function a(t2, e2) {
    if (!t2.scheme && e2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t2.authority}", path: "${t2.path}", query: "${t2.query}", fragment: "${t2.fragment}"}`);
    if (t2.scheme && !o.test(t2.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
    if (t2.path) {
      if (t2.authority) {
        if (!s.test(t2.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      } else if (h.test(t2.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
    }
  }
  const c = "", f = "/", u = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  class l {
    static isUri(t2) {
      return t2 instanceof l || !!t2 && "string" == typeof t2.authority && "string" == typeof t2.fragment && "string" == typeof t2.path && "string" == typeof t2.query && "string" == typeof t2.scheme && "string" == typeof t2.fsPath && "function" == typeof t2.with && "function" == typeof t2.toString;
    }
    scheme;
    authority;
    path;
    query;
    fragment;
    constructor(t2, e2, r2, n2, i2, o2 = false) {
      "object" == typeof t2 ? (this.scheme = t2.scheme || c, this.authority = t2.authority || c, this.path = t2.path || c, this.query = t2.query || c, this.fragment = t2.fragment || c) : (this.scheme = /* @__PURE__ */ function(t3, e3) {
        return t3 || e3 ? t3 : "file";
      }(t2, o2), this.authority = e2 || c, this.path = function(t3, e3) {
        switch (t3) {
          case "https":
          case "http":
          case "file":
            e3 ? e3[0] !== f && (e3 = f + e3) : e3 = f;
        }
        return e3;
      }(this.scheme, r2 || c), this.query = n2 || c, this.fragment = i2 || c, a(this, o2));
    }
    get fsPath() {
      return v(this, false);
    }
    with(t2) {
      if (!t2) return this;
      let { scheme: e2, authority: r2, path: n2, query: i2, fragment: o2 } = t2;
      return void 0 === e2 ? e2 = this.scheme : null === e2 && (e2 = c), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = c), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = c), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = c), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = c), e2 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e2, r2, n2, i2, o2);
    }
    static parse(t2, e2 = false) {
      const r2 = u.exec(t2);
      return r2 ? new d(r2[2] || c, w(r2[4] || c), w(r2[5] || c), w(r2[7] || c), w(r2[9] || c), e2) : new d(c, c, c, c, c);
    }
    static file(t2) {
      let e2 = c;
      if (i && (t2 = t2.replace(/\\/g, f)), t2[0] === f && t2[1] === f) {
        const r2 = t2.indexOf(f, 2);
        -1 === r2 ? (e2 = t2.substring(2), t2 = f) : (e2 = t2.substring(2, r2), t2 = t2.substring(r2) || f);
      }
      return new d("file", e2, t2, c, c);
    }
    static from(t2) {
      const e2 = new d(t2.scheme, t2.authority, t2.path, t2.query, t2.fragment);
      return a(e2, true), e2;
    }
    toString(t2 = false) {
      return b(this, t2);
    }
    toJSON() {
      return this;
    }
    static revive(t2) {
      if (t2) {
        if (t2 instanceof l) return t2;
        {
          const e2 = new d(t2);
          return e2._formatted = t2.external, e2._fsPath = t2._sep === g ? t2.fsPath : null, e2;
        }
      }
      return t2;
    }
  }
  const g = i ? 1 : void 0;
  class d extends l {
    _formatted = null;
    _fsPath = null;
    get fsPath() {
      return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
    }
    toString(t2 = false) {
      return t2 ? b(this, true) : (this._formatted || (this._formatted = b(this, false)), this._formatted);
    }
    toJSON() {
      const t2 = { $mid: 1 };
      return this._fsPath && (t2.fsPath = this._fsPath, t2._sep = g), this._formatted && (t2.external = this._formatted), this.path && (t2.path = this.path), this.scheme && (t2.scheme = this.scheme), this.authority && (t2.authority = this.authority), this.query && (t2.query = this.query), this.fragment && (t2.fragment = this.fragment), t2;
    }
  }
  const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
  function m(t2, e2, r2) {
    let n2, i2 = -1;
    for (let o2 = 0; o2 < t2.length; o2++) {
      const s2 = t2.charCodeAt(o2);
      if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e2 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t2.charAt(o2));
      else {
        void 0 === n2 && (n2 = t2.substr(0, o2));
        const e3 = p[s2];
        void 0 !== e3 ? (-1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), n2 += e3) : -1 === i2 && (i2 = o2);
      }
    }
    return -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2))), void 0 !== n2 ? n2 : t2;
  }
  function y(t2) {
    let e2;
    for (let r2 = 0; r2 < t2.length; r2++) {
      const n2 = t2.charCodeAt(r2);
      35 === n2 || 63 === n2 ? (void 0 === e2 && (e2 = t2.substr(0, r2)), e2 += p[n2]) : void 0 !== e2 && (e2 += t2[r2]);
    }
    return void 0 !== e2 ? e2 : t2;
  }
  function v(t2, e2) {
    let r2;
    return r2 = t2.authority && t2.path.length > 1 && "file" === t2.scheme ? `//${t2.authority}${t2.path}` : 47 === t2.path.charCodeAt(0) && (t2.path.charCodeAt(1) >= 65 && t2.path.charCodeAt(1) <= 90 || t2.path.charCodeAt(1) >= 97 && t2.path.charCodeAt(1) <= 122) && 58 === t2.path.charCodeAt(2) ? e2 ? t2.path.substr(1) : t2.path[1].toLowerCase() + t2.path.substr(2) : t2.path, i && (r2 = r2.replace(/\//g, "\\")), r2;
  }
  function b(t2, e2) {
    const r2 = e2 ? y : m;
    let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: a2 } = t2;
    if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += f, n2 += f), o2) {
      let t3 = o2.indexOf("@");
      if (-1 !== t3) {
        const e3 = o2.substr(0, t3);
        o2 = o2.substr(t3 + 1), t3 = e3.lastIndexOf(":"), -1 === t3 ? n2 += r2(e3, false, false) : (n2 += r2(e3.substr(0, t3), false, false), n2 += ":", n2 += r2(e3.substr(t3 + 1), false, true)), n2 += "@";
      }
      o2 = o2.toLowerCase(), t3 = o2.lastIndexOf(":"), -1 === t3 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t3), false, true), n2 += o2.substr(t3));
    }
    if (s2) {
      if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
        const t3 = s2.charCodeAt(1);
        t3 >= 65 && t3 <= 90 && (s2 = `/${String.fromCharCode(t3 + 32)}:${s2.substr(3)}`);
      } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
        const t3 = s2.charCodeAt(0);
        t3 >= 65 && t3 <= 90 && (s2 = `${String.fromCharCode(t3 + 32)}:${s2.substr(2)}`);
      }
      n2 += r2(s2, true, false);
    }
    return h2 && (n2 += "?", n2 += r2(h2, false, false)), a2 && (n2 += "#", n2 += e2 ? a2 : m(a2, false, false)), n2;
  }
  function C(t2) {
    try {
      return decodeURIComponent(t2);
    } catch {
      return t2.length > 3 ? t2.substr(0, 3) + C(t2.substr(3)) : t2;
    }
  }
  const A = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function w(t2) {
    return t2.match(A) ? t2.replace(A, (t3) => C(t3)) : t2;
  }
  var x = r(975);
  const P = x.posix || x, _ = "/";
  var I;
  !function(t2) {
    t2.joinPath = function(t3, ...e2) {
      return t3.with({ path: P.join(t3.path, ...e2) });
    }, t2.resolvePath = function(t3, ...e2) {
      let r2 = t3.path, n2 = false;
      r2[0] !== _ && (r2 = _ + r2, n2 = true);
      let i2 = P.resolve(r2, ...e2);
      return n2 && i2[0] === _ && !t3.authority && (i2 = i2.substring(1)), t3.with({ path: i2 });
    }, t2.dirname = function(t3) {
      if (0 === t3.path.length || t3.path === _) return t3;
      let e2 = P.dirname(t3.path);
      return 1 === e2.length && 46 === e2.charCodeAt(0) && (e2 = ""), t3.with({ path: e2 });
    }, t2.basename = function(t3) {
      return P.basename(t3.path);
    }, t2.extname = function(t3) {
      return P.extname(t3.path);
    };
  }(I || (I = {})), LIB = n;
})();
var { URI, Utils } = LIB;

// src/reporter.ts
var core = { debug: import_core.debug, info: import_core.info, warning: import_core.warning, error: import_core.error };
function nullEmitter(_msg) {
}
var CSpellReporterForGithubAction = class {
  constructor(reportIssueCommand, options, logger = core) {
    this.reportIssueCommand = reportIssueCommand;
    this.options = options;
    this.logger = logger;
    this.verbose = options.verbose;
  }
  issues = [];
  issueCounts = /* @__PURE__ */ new Map();
  result = {
    files: -1,
    filesWithIssues: /* @__PURE__ */ new Set(),
    issues: -1,
    errors: -1,
    cachedFiles: 0
  };
  finished = false;
  verbose;
  _issue(issue, _options) {
    const { issues, issueCounts } = this;
    const uri = issue.uri;
    if (uri) {
      issueCounts.set(uri, (issueCounts.get(uri) || 0) + 1);
    }
    issues.push(issue);
  }
  _info(message, _msgType) {
    this._debug(message);
  }
  _debug(message) {
    nullEmitter(message);
  }
  _progress(progress) {
    if (!this.verbose || !isProgressFileComplete(progress)) {
      return;
    }
    const { issueCounts, logger } = this;
    const issueCount = issueCounts.get(progress.filename) || 0;
    const { fileNum, fileCount, filename, elapsedTimeMs } = progress;
    const issues = issueCount ? ` issues: ${issueCount}` : "";
    const timeMsg = elapsedTimeMs ? `(${elapsedTimeMs.toFixed(2)}ms)` : "-";
    logger.info(`${fileNum}/${fileCount} ${filename}${issues} ${timeMsg}`);
  }
  _error(message, error4) {
    const { logger } = this;
    logger.error(`${message}
        name: ${error4.name}
        msg: ${error4.message}
        stack:
${error4.stack}
        `);
    return;
  }
  _result(result) {
    Object.assign(this.result, result);
    this.finished = true;
    const command = this.reportIssueCommand;
    const errorCommand = this.options.treatFlaggedWordsAsErrors ? "error" : command;
    const cwd = process.cwd();
    this.issues.forEach((item) => {
      const isError6 = item.isFlagged || false;
      const hasPreferred = item.suggestionsEx?.some((s) => s.isPreferred) || false;
      const msgPrefix = isError6 ? "Forbidden word" : hasPreferred ? "Misspelled word" : "Unknown word";
      const suggestions2 = item.suggestionsEx?.map((s) => s.word + (s.isPreferred ? "*" : "")).join(", ") || "";
      const sugMsg = suggestions2 ? ` Suggestions: (${suggestions2})` : "";
      const message = `${msgPrefix} (${item.text})${sugMsg}`;
      const cmd = isError6 ? errorCommand : command;
      if (!["error", "warning"].includes(cmd)) {
        return;
      }
      (0, import_command.issueCommand)(
        cmd,
        {
          file: relative2(cwd, item.uri || ""),
          line: item.row,
          col: item.col
        },
        message
      );
      console.warn(`${relative2(cwd, item.uri || "")}:${item.row}:${item.col} ${message}`);
    });
  }
  reporter = {
    debug: (...args) => this._debug(...args),
    error: (...args) => this._error(...args),
    info: (...args) => this._info(...args),
    issue: (...args) => this._issue(...args),
    progress: (...args) => this._progress(...args),
    result: (...args) => this._result(...args)
  };
};
function isProgressFileComplete(p) {
  return p.type === "ProgressFileComplete";
}
function relative2(cwd, fileUri) {
  const fsPath = URI.parse(fileUri).fsPath;
  return path.relative(cwd, fsPath);
}

// ../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes3 = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes3.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes3,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// ../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require("node:process"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_node_tty = __toESM(require("node:tty"), 1);
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process.default;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min3 = forceColor || 0;
  if (env.TERM === "dumb") {
    return min3;
  }
  if (import_node_process.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min3;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version3 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version3 >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min3;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

// ../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var Chalk = class {
  constructor(options) {
    return chalkFactory(options);
  }
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? "" : string;
  }
  let styler = self[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/helpers/iteratorToIterable.js
function* iteratorToIterable(iterator) {
  try {
    let n;
    while (!(n = iterator.next()).done) {
      yield n.value;
    }
  } catch (e) {
    if (iterator.throw) {
      return iterator.throw(e);
    }
    throw e;
  } finally {
    iterator.return?.();
  }
}
async function* asyncIteratorToAsyncIterable(iterator) {
  try {
    let n;
    while (!(n = await iterator.next()).done) {
      yield n.value;
    }
  } catch (e) {
    if (iterator.throw) {
      return iterator.throw(e);
    }
    throw e;
  } finally {
    iterator.return?.();
  }
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/helpers/util.js
function toPipeFn(syncFn, asyncFn) {
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}
function isAsyncIterable(i) {
  return typeof i[Symbol.asyncIterator] === "function";
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/helpers/toArray.js
function toArray(i) {
  return isAsyncIterable(i) ? toArrayAsync(i) : toArraySync(i);
}
function toArraySync(iter) {
  return [...iter];
}
async function toArrayAsync(iter) {
  const collection = [];
  for await (const i of iter) {
    collection.push(i);
  }
  return collection;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/helpers/toAsyncIterable.js
async function* mergeAsyncIterables(iter, ...rest) {
  for await (const i of [iter, ...rest]) {
    yield* i;
  }
}
var toAsyncIterable = mergeAsyncIterables;

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  opAppend: () => opAppend,
  opAppendAsync: () => opAppendAsync,
  opAppendSync: () => opAppendSync,
  opAwaitAsync: () => opAwaitAsync,
  opBuffer: () => opBuffer,
  opBufferAsync: () => opBufferAsync,
  opBufferSync: () => opBufferSync,
  opCombineAsync: () => opCombineAsync,
  opCombineSync: () => opCombineSync,
  opConcatMap: () => opConcatMap,
  opConcatMapAsync: () => opConcatMapAsync,
  opConcatMapSync: () => opConcatMapSync,
  opFilter: () => opFilter,
  opFilterAsync: () => opFilterAsync,
  opFilterSync: () => opFilterSync,
  opFirst: () => opFirst,
  opFirstAsync: () => opFirstAsync,
  opFirstSync: () => opFirstSync,
  opFlatten: () => opFlatten,
  opFlattenAsync: () => opFlattenAsync,
  opFlattenSync: () => opFlattenSync,
  opJoinStrings: () => opJoinStrings,
  opJoinStringsAsync: () => opJoinStringsAsync,
  opJoinStringsSync: () => opJoinStringsSync,
  opLast: () => opLast,
  opLastAsync: () => opLastAsync,
  opLastSync: () => opLastSync,
  opMap: () => opMap,
  opMapAsync: () => opMapAsync,
  opMapSync: () => opMapSync,
  opReduceAsync: () => opReduceAsync,
  opReduceSync: () => opReduceSync,
  opSkip: () => opSkip,
  opSkipAsync: () => opSkipAsync,
  opSkipSync: () => opSkipSync,
  opTake: () => opTake,
  opTakeAsync: () => opTakeAsync,
  opTakeSync: () => opTakeSync,
  opTap: () => opTap,
  opTapAsync: () => opTapAsync,
  opTapSync: () => opTapSync,
  opUnique: () => opUnique,
  opUniqueAsync: () => opUniqueAsync,
  opUniqueSync: () => opUniqueSync
});

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/append.js
function opAppendAsync(...iterablesToAppend) {
  async function* fnAppend(iter) {
    yield* iter;
    for (const i of iterablesToAppend) {
      yield* i;
    }
  }
  return fnAppend;
}
function opAppendSync(...iterablesToAppend) {
  function* fnAppend(iter) {
    yield* iter;
    for (const i of iterablesToAppend) {
      yield* i;
    }
  }
  return fnAppend;
}
function opAppend(...iterablesToAppend) {
  function _(i) {
    return isAsyncIterable(i) ? opAppendAsync(...iterablesToAppend)(i) : opAppendSync(...iterablesToAppend)(i);
  }
  return _;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/await.js
async function* _asyncAwait(iter) {
  for await (const v of iter) {
    yield v;
  }
}
function opAwaitAsync() {
  return _asyncAwait;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/buffer.js
function opBufferAsync(size) {
  async function* fnBuffer(iter) {
    let buffer = [];
    for await (const v of iter) {
      buffer.push(v);
      if (buffer.length >= size) {
        yield buffer;
        buffer = [];
      }
    }
    if (buffer.length > 0) {
      yield buffer;
    }
  }
  return fnBuffer;
}
function opBufferSync(size) {
  function* fnBuffer(iter) {
    let buffer = [];
    for (const v of iter) {
      buffer.push(v);
      if (buffer.length >= size) {
        yield buffer;
        buffer = [];
      }
    }
    if (buffer.length > 0) {
      yield buffer;
    }
  }
  return fnBuffer;
}
function opBuffer(size) {
  const asyncFn = opBufferAsync(size);
  const syncFn = opBufferSync(size);
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/combine.js
function opCombineAsync(...fns) {
  function combine4(iter) {
    for (const fn of fns) {
      iter = fn(iter);
    }
    return iter;
  }
  return combine4;
}
function opCombineSync(...fns) {
  function combine4(iter) {
    for (const fn of fns) {
      iter = fn(iter);
    }
    return iter;
  }
  return combine4;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/concatMap.js
function opConcatMapAsync(mapFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      yield* mapFn(v);
    }
  }
  return fn;
}
function opConcatMapSync(mapFn) {
  function fnConcatMapSync(iterable) {
    function opConcatMapIterator() {
      const iter = iterable[Symbol.iterator]();
      let resultsIter = void 0;
      function nextConcatMap() {
        while (true) {
          if (resultsIter) {
            const { done: done2, value: value2 } = resultsIter.next();
            if (!done2) {
              return { value: value2 };
            }
            resultsIter = void 0;
          }
          const { done, value } = iter.next();
          if (done) {
            return { done, value: void 0 };
          }
          resultsIter = mapFn(value)[Symbol.iterator]();
        }
      }
      return {
        next: nextConcatMap
      };
    }
    return {
      [Symbol.iterator]: opConcatMapIterator
    };
  }
  return fnConcatMapSync;
}
var opConcatMap = (fn) => toPipeFn(opConcatMapSync(fn), opConcatMapAsync(fn));

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/filter.js
function opFilterAsync(filterFn) {
  async function* genFilter(iter) {
    for await (const v of iter) {
      const pass = await filterFn(v);
      if (pass)
        yield v;
    }
  }
  return genFilter;
}
function opFilterSync(filterFn) {
  function opFilterIterable(iterable) {
    function opFilterIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpFilter() {
        while (true) {
          const { done, value } = iter.next();
          if (done)
            return { done, value: void 0 };
          if (filterFn(value))
            return { value };
        }
      }
      return {
        next: nextOpFilter
      };
    }
    return {
      [Symbol.iterator]: opFilterIterator
    };
  }
  return opFilterIterable;
}
function opFilter(fn) {
  const asyncFn = opFilterAsync(fn);
  const syncFn = opFilterSync(fn);
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/first.js
function opFirstAsync(firstFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      const pass = await firstFn(v);
      if (pass) {
        yield v;
        break;
      }
    }
  }
  return fn;
}
function opFirstSync(firstFn) {
  function* fn(iter) {
    for (const v of iter) {
      if (firstFn(v)) {
        yield v;
        break;
      }
    }
  }
  return fn;
}
function opFirst(fn) {
  const asyncFn = opFirstAsync(fn);
  const syncFn = opFirstSync(fn);
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/flatten.js
function opFlattenAsync() {
  async function* fn(iter) {
    for await (const v of iter) {
      yield* v;
    }
  }
  return fn;
}
function opFlattenSync() {
  function* fn(iter) {
    for (const v of iter) {
      yield* v;
    }
  }
  return fn;
}
var opFlatten = () => toPipeFn(opFlattenSync(), opFlattenAsync());

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/joinStrings.js
function opJoinStringsAsync(joinCharacter = ",") {
  async function* fn(iter) {
    for await (const v of iter) {
      const a = await toArray(v);
      yield a.join(joinCharacter);
    }
  }
  return fn;
}
function opJoinStringsSync(joinCharacter = ",") {
  function* fn(iter) {
    for (const v of iter) {
      const a = toArray(v);
      yield a.join(joinCharacter);
    }
  }
  return fn;
}
var opJoinStrings = (joinCharacter) => toPipeFn(opJoinStringsSync(joinCharacter), opJoinStringsAsync(joinCharacter));

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/last.js
var symNotFound = Symbol("LastNotFound");
function opLastAsync(lastFn) {
  async function* fn(iter) {
    let last = symNotFound;
    for await (const v of iter) {
      const pass = await lastFn(v);
      if (pass) {
        last = v;
      }
    }
    if (last !== symNotFound)
      yield last;
  }
  return fn;
}
function opLastSync(lastFn) {
  function* fn(iter) {
    let last = symNotFound;
    for (const v of iter) {
      if (lastFn(v)) {
        last = v;
      }
    }
    if (last !== symNotFound)
      yield last;
  }
  return fn;
}
function opLast(fn) {
  const asyncFn = opLastAsync(fn);
  const syncFn = opLastSync(fn);
  function _(i) {
    return isAsyncIterable(i) ? asyncFn(i) : syncFn(i);
  }
  return _;
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/map.js
function opMapAsync(mapFn) {
  async function* genMap(iter) {
    for await (const v of iter) {
      yield mapFn(v);
    }
  }
  return genMap;
}
function opMapSync(mapFn) {
  function opMapIterable(iterable) {
    function opMapIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpMap() {
        const { done, value } = iter.next();
        if (done)
          return { done, value: void 0 };
        return { value: mapFn(value) };
      }
      return {
        next: nextOpMap
      };
    }
    return {
      [Symbol.iterator]: opMapIterator
    };
  }
  return opMapIterable;
}
var opMap = (fn) => toPipeFn(opMapSync(fn), opMapAsync(fn));

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/reduce.js
function opReduceAsync(reduceFn, initialValue) {
  async function* reduce3(head, tail) {
    for await (const v of tail) {
      head = reduceFn(head, v);
    }
    yield head;
  }
  async function* fn(iter) {
    const ht = initialValue === void 0 ? await headTailAsync(iter) : { head: await initialValue, tail: iter };
    if (!ht)
      return;
    yield* reduce3(ht.head, ht.tail);
  }
  return fn;
}
function opReduceSync(reduceFn, initialValue) {
  function* reduce3(head, tail) {
    for (const v of tail) {
      head = reduceFn(head, v);
    }
    yield head;
  }
  function* fn(iter) {
    const ht = initialValue === void 0 ? headTail(iter) : { head: initialValue, tail: iter };
    if (!ht)
      return;
    yield* reduce3(ht.head, ht.tail);
  }
  return fn;
}
function headTail(iter) {
  const iterator = iter[Symbol.iterator]();
  const first3 = iterator.next();
  if (first3.done)
    return void 0;
  return { head: first3.value, tail: iteratorToIterable(iterator) };
}
async function headTailAsync(iter) {
  const iterator = isIterable(iter) ? iter[Symbol.iterator]() : iter[Symbol.asyncIterator]();
  const first3 = await iterator.next();
  if (first3.done)
    return void 0;
  return { head: first3.value, tail: asyncIteratorToAsyncIterable(iterator) };
}
function isIterable(i) {
  return typeof i[Symbol.iterator] === "function";
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/skip.js
function opSkipAsync(count3) {
  async function* fn(iter) {
    for await (const v of iter) {
      if (count3 > 0) {
        --count3;
        continue;
      }
      yield v;
    }
  }
  return fn;
}
function opSkipSync(count3) {
  function* fn(iter) {
    for (const v of iter) {
      if (count3 > 0) {
        --count3;
        continue;
      }
      yield v;
    }
  }
  return fn;
}
var opSkip = (count3) => toPipeFn(opSkipSync(count3), opSkipAsync(count3));

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/take.js
function opTakeAsync(count3) {
  async function* fn(iter) {
    if (count3 <= 0)
      return;
    for await (const v of iter) {
      yield v;
      if (--count3 <= 0)
        return;
    }
  }
  return fn;
}
function opTakeSync(count3) {
  function* fn(iter) {
    if (count3 <= 0)
      return;
    for (const v of iter) {
      yield v;
      if (--count3 <= 0)
        return;
    }
  }
  return fn;
}
var opTake = (count3) => toPipeFn(opTakeSync(count3), opTakeAsync(count3));

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/tap.js
function opTapAsync(tapFn) {
  async function* fn(iter) {
    for await (const v of iter) {
      tapFn(v);
      yield v;
    }
  }
  return fn;
}
function opTapSync(tapFn) {
  function* fn(iter) {
    for (const v of iter) {
      tapFn(v);
      yield v;
    }
  }
  return fn;
}
var opTap = (fn) => toPipeFn(opTapSync(fn), opTapAsync(fn));

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/operators/unique.js
function opUniqueAsync(k) {
  function fnK(k2) {
    async function* fn2(iter) {
      const s = /* @__PURE__ */ new Set();
      for await (const v of iter) {
        const kk = k2(v);
        if (s.has(kk))
          continue;
        s.add(kk);
        yield v;
      }
    }
    return fn2;
  }
  async function* fn(iter) {
    const s = /* @__PURE__ */ new Set();
    for await (const v of iter) {
      if (s.has(v))
        continue;
      s.add(v);
      yield v;
    }
  }
  return k ? fnK(k) : fn;
}
function opUniqueSync(k) {
  function fnK(key) {
    function* fn2(iter) {
      const s = /* @__PURE__ */ new Set();
      for (const v of iter) {
        const kk = key(v);
        if (s.has(kk))
          continue;
        s.add(kk);
        yield v;
      }
    }
    return fn2;
  }
  function* fn(iter) {
    const s = /* @__PURE__ */ new Set();
    for (const v of iter) {
      if (s.has(v))
        continue;
      s.add(v);
      yield v;
    }
  }
  return k ? fnK(k) : fn;
}
var opUnique = (getKey) => toPipeFn(opUniqueSync(getKey), opUniqueAsync(getKey));

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/pipe.js
function pipeAsync(i, ...fns) {
  const iter = toAsyncIterable(i);
  return opCombineAsync(...fns)(iter);
}
function pipeSync(i, ...fns) {
  return opCombineSync(...fns)(i);
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/reduce.js
function reduceSync(iter, reduceFn, initialValue) {
  const i = initialValue === void 0 ? pipeSync(iter, opReduceSync(reduceFn)) : pipeSync(iter, opReduceSync(reduceFn, initialValue));
  return [...i][0];
}

// ../node_modules/.pnpm/@cspell+cspell-pipe@9.1.5/node_modules/@cspell/cspell-pipe/dist/index.js
var operators = operators_exports;

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/errors.js
var import_node_util2 = require("node:util");
var allowStringOrUndefined = {
  string: true,
  undefined: true
};
function isError(e) {
  if (e instanceof Error)
    return true;
  if (!e || typeof e !== "object")
    return false;
  const ex = e;
  return typeof ex.name == "string" && typeof ex.message == "string" && typeof ex.stack in allowStringOrUndefined;
}
function toError2(e, errorFactory = UnknownError) {
  if (isError(e))
    return e;
  return new errorFactory(e);
}
var UnknownError = class extends Error {
  cause;
  constructor(cause) {
    super((0, import_node_util2.format)(cause));
    this.cause = cause;
  }
};
function catchPromiseError(p, handler) {
  if (p === void 0)
    return void 0;
  return _catchPromiseError(p, handler);
}
async function _catchPromiseError(p, handler) {
  try {
    return await p;
  } catch (e) {
    return handler(e);
  }
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/events/events.js
var EventEmitter = class {
  name;
  #listeners = /* @__PURE__ */ new Set();
  constructor(name2) {
    this.name = name2;
  }
  /**
   * The event listeners can subscribe to.
   */
  on = (listener) => {
    this.#listeners.add(listener);
    return {
      dispose: () => {
        this.#listeners.delete(listener);
      }
    };
  };
  /**
   * Notify all subscribers of the {@link EventEmitter.on event}. Failure
   * of one or more listener will not fail this function call.
   *
   * @param data The event object.
   */
  fire(event) {
    let errors;
    for (const listener of this.#listeners) {
      try {
        listener(event);
      } catch (e) {
        errors = errors ?? [];
        errors.push(toError2(e));
      }
    }
    return errors;
  }
  /**
   * Dispose this object and free resources.
   */
  dispose = () => {
    this.#listeners.clear();
  };
};
var ClearCacheEvent = class _ClearCacheEvent extends EventEmitter {
  constructor() {
    super(_ClearCacheEvent.eventName);
  }
  static eventName = "clear-cache";
};
var clearCacheEvent = new ClearCacheEvent();
function onClearCache(listener) {
  return clearCacheEvent.on(listener);
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/AutoCache.js
var CACHE_SIZE = 100;
var Cache01 = class {
  maxSize;
  hits = 0;
  misses = 0;
  swaps = 0;
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
};
var Cache01Map = class extends Cache01 {
  count = 0;
  cache0 = /* @__PURE__ */ new Map();
  cache1 = /* @__PURE__ */ new Map();
  constructor(maxSize) {
    super(maxSize);
  }
  get(key) {
    const cache0 = this.cache0;
    const cache1 = this.cache1;
    let found = cache0.get(key);
    if (found !== void 0) {
      ++this.hits;
      return found;
    }
    found = cache1.get(key);
    if (found !== void 0) {
      ++this.hits;
      ++this.count;
      cache0.set(key, found);
      return found;
    }
    ++this.misses;
    return void 0;
  }
  set(key, value) {
    if (this.count >= this.maxSize) {
      const c = this.cache1;
      this.cache1 = this.cache0;
      this.cache0 = c;
      c.clear();
      this.swaps++;
      this.count = 0;
    }
    ++this.count;
    this.cache0.set(key, value);
    return this;
  }
};
function createCache01(size) {
  return new Cache01Map(size);
}
function autoCache(fn, size = CACHE_SIZE) {
  const cache5 = createCache01(size);
  const ac = get;
  ac.hits = 0;
  ac.misses = 0;
  ac.swaps = 0;
  function get(k) {
    const f = cache5.get(k);
    if (f !== void 0) {
      ++ac.hits;
      return f;
    }
    const r = fn(k);
    cache5.set(k, r);
    ac.swaps = cache5.swaps;
    ++ac.misses;
    return r;
  }
  return ac;
}
function extractStats(ac) {
  const { hits, misses, swaps } = ac;
  return { hits, misses, swaps };
}

// ../node_modules/.pnpm/cspell-trie-lib@9.1.5/node_modules/cspell-trie-lib/dist/index.js
var import_node_assert = __toESM(require("node:assert"), 1);
var import_node_os2 = require("node:os");

// ../node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/util/util.js
function* toIterableIterator(i) {
  yield* i;
}

// ../node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/operators/operatorsBase.js
function* filter(i, fnFilter) {
  for (const v of i) {
    if (fnFilter(v)) {
      yield v;
    }
  }
}
function* skip(i, n) {
  let a = 0;
  for (const t of i) {
    if (a >= n) {
      yield t;
    }
    a += 1;
  }
}
function* take(i, n) {
  let a = 0;
  if (n) {
    for (const t of i) {
      if (a >= n) {
        break;
      }
      yield t;
      a += 1;
    }
  }
}
function* concat(i, j) {
  yield* i;
  yield* j;
}
function* concatMap(i, fn) {
  for (const t of i) {
    yield* fn(t);
  }
}
function* combine(i, j, fnMap) {
  const jit = j[Symbol.iterator]();
  for (const r of i) {
    const s = jit.next().value;
    yield fnMap(r, s);
  }
}
function map(i, fnMap) {
  function* fn(i2, fnMap2) {
    for (const v of i2) {
      yield fnMap2(v);
    }
  }
  return fn(i, fnMap);
}
function* scan(i, fnReduce, initValue) {
  let index = 0;
  if (initValue === void 0) {
    index = 1;
    const iter = i[Symbol.iterator]();
    let r = iter.next();
    if (!r.done)
      yield r.value;
    initValue = r.value;
    i = makeIterable(iter);
  }
  let prevValue = initValue;
  for (const t of i) {
    const nextValue = fnReduce(prevValue, t, index);
    yield nextValue;
    prevValue = nextValue;
    index += 1;
  }
}
function all(i, fn) {
  for (const t of i) {
    if (!fn(t)) {
      return false;
    }
  }
  return true;
}
function any(i, fn) {
  for (const t of i) {
    if (fn(t)) {
      return true;
    }
  }
  return false;
}
function count(i) {
  return reduce(i, (p) => p + 1, 0);
}
function first(i, fn, defaultValue) {
  fn = fn || (() => true);
  for (const t of i) {
    if (fn(t)) {
      return t;
    }
  }
  return defaultValue;
}
function forEach(i, fn) {
  let index = 0;
  for (const t of i) {
    fn(t, index);
    index += 1;
  }
}
function max(i, selector = (t) => t) {
  return reduce(i, (p, c) => selector(c) > selector(p) ? c : p, void 0);
}
function min(i, selector = (t) => t) {
  return reduce(i, (p, c) => selector(c) < selector(p) ? c : p, void 0);
}
function reduce(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === void 0) {
    index = 1;
    const r = iter.next();
    initialValue = r.value;
  }
  let prevValue = initialValue;
  for (const t of iter) {
    const nextValue = fnReduce(prevValue, t, index);
    prevValue = nextValue;
    index += 1;
  }
  return prevValue;
}
async function reduceAsync(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === void 0) {
    index = 1;
    const r = iter.next();
    initialValue = r.value;
  }
  let previousValue = await initialValue;
  for (const p of iter) {
    const t = await p;
    const nextValue = await fnReduce(previousValue, t, index);
    previousValue = nextValue;
    index += 1;
  }
  return previousValue;
}
function makeIterable(i) {
  function* fromIterator(i2) {
    for (let r = i2.next(); !r.done; r = i2.next()) {
      yield r.value;
    }
  }
  function* fromIterable(i2) {
    yield* i2;
  }
  return isIterable2(i) ? isIterableIterator(i) ? i : fromIterable(i) : fromIterator(i);
}
function isIterable2(i) {
  return !!i[Symbol.iterator];
}
function isIterableIterator(i) {
  return typeof i.next == "function";
}

// ../node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/operators/operators.js
function filter2(fnFilter) {
  return (i) => filter(i, fnFilter);
}
function skip2(n) {
  return (i) => skip(i, n);
}
function take2(n) {
  return (i) => take(i, n);
}
function concat2(j) {
  return (i) => concat(i, j);
}
function concatMap2(fn) {
  return (i) => concatMap(i, fn);
}
function combine2(fnMap, j) {
  return (i) => combine(i, j, fnMap);
}
function map2(fnMap) {
  return (i) => map(i, fnMap);
}
function scan2(fnReduce, initValue) {
  return (i) => scan(i, fnReduce, initValue);
}
function all2(fn) {
  return (i) => all(i, fn);
}
function any2(fn) {
  return (i) => any(i, fn);
}
function count2() {
  return (i) => count(i);
}
function first2(fn, defaultValue) {
  return (i) => first(i, fn, defaultValue);
}
function forEach2(fn) {
  return (i) => forEach(i, fn);
}
function max2(selector) {
  return (i) => max(i, selector);
}
function min2(selector) {
  return (i) => min(i, selector);
}
function reduce2(fnReduce, initialValue) {
  return (i) => reduce(i, fnReduce, initialValue);
}
function reduceAsync2(fnReduceAsync, initialValue) {
  return (i) => reduceAsync(i, fnReduceAsync, initialValue);
}
function pipe(...fns) {
  return (i) => {
    for (const fn of fns) {
      i = fn ? fn(i) : i;
    }
    return i;
  };
}

// ../node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/ImplSequence.js
var ImplSequence = class _ImplSequence {
  i;
  _iterator;
  constructor(i) {
    this.i = i;
  }
  get iter() {
    return typeof this.i === "function" ? this.i() : this.i;
  }
  get iterator() {
    if (!this._iterator) {
      this._iterator = this.iter[Symbol.iterator]();
    }
    return this._iterator;
  }
  inject(fn) {
    const iter = this.i;
    return () => fn(typeof iter === "function" ? iter() : iter);
  }
  chain(fn) {
    return new _ImplSequence(this.inject(fn));
  }
  [Symbol.iterator]() {
    return this.iter[Symbol.iterator]();
  }
  next() {
    return this.iterator.next();
  }
  //// Filters
  filter(fnFilter) {
    return this.chain(filter2(fnFilter));
  }
  skip(n) {
    return this.chain(skip2(n));
  }
  take(n) {
    return this.chain(take2(n));
  }
  //// Extenders
  concat(j) {
    return this.chain(concat2(j));
  }
  concatMap(fn) {
    return this.chain(concatMap2(fn));
  }
  //// Mappers
  combine(fn, j) {
    return this.chain(combine2(fn, j));
  }
  map(fn) {
    return this.chain(map2(fn));
  }
  scan(fnReduce, initValue) {
    return this.chain(scan2(fnReduce, initValue));
  }
  pipe(...fns) {
    if (!fns.length)
      return this;
    return this.chain(pipe.apply(null, fns));
  }
  // Reducers
  all(fnFilter) {
    return all2(fnFilter)(this.iter);
  }
  any(fnFilter) {
    return any2(fnFilter)(this.iter);
  }
  count() {
    return count2()(this.iter);
  }
  first(fnFilter, defaultValue) {
    return first2(fnFilter, defaultValue)(this.iter);
  }
  forEach(fn) {
    return forEach2(fn)(this.iter);
  }
  max(fnSelector) {
    return max2(fnSelector)(this.iter);
  }
  min(fnSelector) {
    return min2(fnSelector)(this.iter);
  }
  reduce(fnReduce, initValue) {
    return reduce2(fnReduce, initValue)(this.iter);
  }
  reduceAsync(fnReduceAsync, initialValue) {
    return reduceAsync2(fnReduceAsync, initialValue)(this.iter);
  }
  reduceToSequence(fnReduce, initialValue) {
    return this.chain(reduce2(fnReduce, initialValue));
  }
  //// Cast
  toArray() {
    return [...this.iter];
  }
  toIterable() {
    return toIterableIterator(this.iter);
  }
};

// ../node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/GenSequence.js
function genSequence(i) {
  return new ImplSequence(i);
}

// ../node_modules/.pnpm/cspell-trie-lib@9.1.5/node_modules/cspell-trie-lib/dist/index.js
var SymEmpty = Symbol("memorizeLastCall");
function memorizeLastCall(fn) {
  let lastP = void 0;
  let lastR = SymEmpty;
  function calc(p) {
    if (lastR !== SymEmpty && lastP === p) return lastR;
    lastP = p;
    lastR = fn(p);
    return lastR;
  }
  return calc;
}
var defaultLegacyMinCompoundLength$3 = 3;
var _defaultFindOptions$1 = {
  matchCase: false,
  compoundMode: "compound",
  legacyMinCompoundLength: defaultLegacyMinCompoundLength$3
};
Object.freeze(_defaultFindOptions$1);
var arrayCompoundModes$1 = [
  "none",
  "compound",
  "legacy"
];
var knownCompoundModes$1 = new Map(arrayCompoundModes$1.map((a) => [a, a]));
var notFound = {
  found: false,
  compoundUsed: false,
  caseMatched: false,
  forbidden: void 0
};
Object.freeze(notFound);
function findWordNode$1(root, word, options) {
  return _findWordNode$1(root, word, options);
}
function findWord$1(root, word, options) {
  if (root.find) {
    const found$1 = root.find(word, options?.matchCase || false);
    if (found$1) {
      if (options?.checkForbidden && found$1.forbidden === void 0) found$1.forbidden = isForbiddenWord$1(root, word, root.forbidPrefix);
      return found$1;
    }
    if (!root.hasCompoundWords) return notFound;
  }
  const { found, compoundUsed, caseMatched, forbidden } = _findWordNode$1(root, word, options);
  const result = {
    found,
    compoundUsed,
    caseMatched,
    forbidden
  };
  if (options?.checkForbidden && forbidden === void 0) result.forbidden = isForbiddenWord$1(root, word, root.forbidPrefix);
  return result;
}
function _findWordNode$1(root, word, options) {
  const trieInfo = root.info;
  const matchCase3 = options?.matchCase || false;
  const compoundMode = knownCompoundModes$1.get(options?.compoundMode) || _defaultFindOptions$1.compoundMode;
  const compoundPrefix = compoundMode === "compound" ? trieInfo.compoundCharacter ?? root.compoundFix : "";
  const ignoreCasePrefix = matchCase3 ? "" : trieInfo.stripCaseAndAccentsPrefix ?? root.caseInsensitivePrefix;
  const mustCheckForbidden = options?.checkForbidden === true;
  const checkForbidden = options?.checkForbidden ?? true;
  function __findCompound() {
    const f = findCompoundWord$1(root, word, compoundPrefix, ignoreCasePrefix);
    if (f.found !== false && (mustCheckForbidden || f.compoundUsed && checkForbidden)) {
      const r = !f.caseMatched ? walk$2(root, root.caseInsensitivePrefix) : root;
      f.forbidden = isForbiddenWord$1(r, word, root.forbidPrefix);
    }
    return f;
  }
  function __findExact() {
    const n = root.getNode ? root.getNode(word) : walk$2(root, word);
    const isFound = isEndOfWordNode$1(n);
    const result = {
      found: isFound && word,
      compoundUsed: false,
      forbidden: checkForbidden ? isForbiddenWord$1(root, word, root.forbidPrefix) : void 0,
      node: n,
      caseMatched: true
    };
    return result;
  }
  switch (compoundMode) {
    case "none":
      return matchCase3 ? __findExact() : __findCompound();
    case "compound":
      return __findCompound();
    case "legacy":
      return findLegacyCompound$1(root, word, options);
  }
}
function findLegacyCompound$1(root, word, options) {
  const roots = [root];
  if (!options?.matchCase) roots.push(walk$2(root, root.caseInsensitivePrefix));
  return findLegacyCompoundNode$1(roots, word, options?.legacyMinCompoundLength || defaultLegacyMinCompoundLength$3);
}
function findCompoundNode$1(root, word, compoundCharacter, ignoreCasePrefix) {
  const stack = [{
    n: root,
    compoundPrefix: ignoreCasePrefix,
    cr: void 0,
    caseMatched: true
  }];
  const compoundPrefix = compoundCharacter || ignoreCasePrefix;
  const possibleCompoundPrefix = ignoreCasePrefix && compoundCharacter ? ignoreCasePrefix + compoundCharacter : "";
  const nw = word.normalize();
  const w = [...nw];
  function determineRoot(s) {
    const prefix = s.compoundPrefix;
    let r = root;
    let i$1;
    for (i$1 = 0; i$1 < prefix.length && r; ++i$1) r = r.get(prefix[i$1]);
    const caseMatched$1 = s.caseMatched && prefix[0] !== ignoreCasePrefix;
    return {
      n: s.n,
      compoundPrefix: prefix === compoundPrefix ? possibleCompoundPrefix : "",
      cr: r,
      caseMatched: caseMatched$1
    };
  }
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = h && n?.get(h) || void 0;
    if (c && i < word.length) {
      caseMatched = s.caseMatched;
      stack[i] = {
        n: c,
        compoundPrefix,
        cr: void 0,
        caseMatched
      };
    } else if (!c || !c.eow) {
      node = node || c;
      while (--i > 0) {
        const s$1 = stack[i];
        if (!s$1.compoundPrefix || !s$1.n?.hasChildren()) continue;
        if (s$1.n.get(compoundCharacter)) break;
      }
      if (i >= 0 && stack[i].compoundPrefix) {
        compoundUsed = i > 0;
        const r = determineRoot(stack[i]);
        stack[i] = r;
        if (!r.cr) break;
        if (!i && !r.caseMatched && nw !== nw.toLowerCase()) break;
      } else break;
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  const found = i === word.length && word || false;
  const result = {
    found,
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
  return result;
}
function findCompoundWord$1(root, word, compoundCharacter, ignoreCasePrefix) {
  const { found, compoundUsed, node, caseMatched } = findCompoundNode$1(root, word, compoundCharacter, ignoreCasePrefix);
  if (!node || !node.eow) return {
    found: false,
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
  return {
    found,
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
}
function findWordExact$1(root, word) {
  const r = root;
  if (r?.findExact) return r.findExact(word);
  return isEndOfWordNode$1(walk$2(root, word));
}
function isEndOfWordNode$1(n) {
  return !!n?.eow;
}
function walk$2(root, word) {
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = n.get(h);
  }
  return n;
}
function findLegacyCompoundNode$1(roots, word, minCompoundLength) {
  const root = roots[0];
  const numRoots = roots.length;
  const stack = [{
    n: root,
    usedRoots: 1,
    subLength: 0,
    isCompound: false,
    cr: void 0,
    caseMatched: true
  }];
  const w = word;
  const wLen = w.length;
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = n?.get(h);
    if (c && i < wLen) stack[i] = {
      n: c,
      usedRoots: 0,
      subLength: s.subLength + 1,
      isCompound: s.isCompound,
      cr: void 0,
      caseMatched: s.caseMatched
    };
    else if (!c || !c.eow || c.eow && s.subLength < minCompoundLength - 1) {
      while (--i > 0) {
        const s$1 = stack[i];
        if (s$1.usedRoots < numRoots && s$1.n?.eow && (s$1.subLength >= minCompoundLength || !s$1.subLength) && wLen - i >= minCompoundLength) break;
      }
      if (i > 0 || stack[i].usedRoots < numRoots) {
        compoundUsed = i > 0;
        const s$1 = stack[i];
        s$1.cr = roots[s$1.usedRoots++];
        s$1.subLength = 0;
        s$1.isCompound = compoundUsed;
        s$1.caseMatched = s$1.caseMatched && s$1.usedRoots <= 1;
      } else break;
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  function extractWord() {
    if (!word || i < word.length) return false;
    const letters = [];
    let subLen = 0;
    for (let j = 0; j < i; ++j) {
      const { subLength } = stack[j];
      if (subLength < subLen) letters.push("+");
      letters.push(word[j]);
      subLen = subLength;
    }
    return letters.join("");
  }
  const found = extractWord();
  const result = {
    found,
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
  return result;
}
function isForbiddenWord$1(root, word, forbiddenPrefix) {
  const r = root;
  if (r?.isForbidden) return r.isForbidden(word);
  return findWordExact$1(root?.get(forbiddenPrefix), word);
}
var createFindOptions$1 = memorizeLastCall(_createFindOptions$1);
function _createFindOptions$1(options) {
  if (!options) return _defaultFindOptions$1;
  const d = _defaultFindOptions$1;
  return {
    matchCase: options.matchCase ?? d.matchCase,
    compoundMode: options.compoundMode ?? d.compoundMode,
    legacyMinCompoundLength: options.legacyMinCompoundLength ?? d.legacyMinCompoundLength,
    checkForbidden: options.checkForbidden ?? d.checkForbidden
  };
}
var JOIN_SEPARATOR = "+";
var WORD_SEPARATOR = " ";
var CompoundWordsMethod = /* @__PURE__ */ function(CompoundWordsMethod$1) {
  CompoundWordsMethod$1[CompoundWordsMethod$1["NONE"] = 0] = "NONE";
  CompoundWordsMethod$1[CompoundWordsMethod$1["SEPARATE_WORDS"] = 1] = "SEPARATE_WORDS";
  CompoundWordsMethod$1[CompoundWordsMethod$1["JOIN_WORDS"] = 2] = "JOIN_WORDS";
  return CompoundWordsMethod$1;
}({});
function* compoundWalker$1(root, compoundingMethod) {
  const empty = Object.freeze([]);
  const roots = {
    [CompoundWordsMethod.NONE]: empty,
    [CompoundWordsMethod.JOIN_WORDS]: [[JOIN_SEPARATOR, root]],
    [CompoundWordsMethod.SEPARATE_WORDS]: [[WORD_SEPARATOR, root]]
  };
  const rc = roots[compoundingMethod].length ? roots[compoundingMethod] : void 0;
  function children(n) {
    if (n.hasChildren()) {
      const entries = n.entries();
      const c = Array.isArray(entries) ? entries : [...entries];
      return n.eow && rc ? [...c, ...rc] : c;
    }
    if (n.eow) return roots[compoundingMethod];
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = {
    t: "",
    c: children(root),
    ci: 0
  };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length) {
      const [char, node] = s.c[s.ci++];
      const text = baseText + char;
      const goDeeper = yield {
        text,
        node,
        depth
      };
      if (goDeeper ?? true) {
        depth++;
        baseText = text;
        stack[depth] = {
          t: text,
          c: children(node),
          ci: 0
        };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function* nodeWalker$1(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  stack[depth] = {
    t: "",
    n: root,
    c: Array.isArray(entries) ? entries : [...entries],
    ci: 0
  };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const idx$1 = s.ci++;
      const [char, node] = s.c[idx$1];
      const text = baseText + char;
      const goDeeper = yield {
        text,
        node,
        depth
      };
      if (goDeeper !== false) {
        depth++;
        baseText = text;
        const s$1 = stack[depth];
        const entries$1 = node.entries();
        const c = Array.isArray(entries$1) ? entries$1 : [...entries$1];
        if (s$1) {
          s$1.t = text;
          s$1.n = node;
          s$1.c = c;
          s$1.ci = 0;
        } else stack[depth] = {
          t: text,
          n: node,
          c,
          ci: 0
        };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function walker$1(root, compoundingMethod = CompoundWordsMethod.NONE) {
  return compoundingMethod === CompoundWordsMethod.NONE ? nodeWalker$1(root) : compoundWalker$1(root, compoundingMethod);
}
function walkerWords$1(root) {
  return walkerWordsITrie(root);
}
function* walkerWordsITrie(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  const c = Array.isArray(entries) ? entries : [...entries];
  stack[depth] = {
    t: "",
    n: root,
    c,
    ci: 0
  };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const [char, node] = s.c[s.ci++];
      if (!node) continue;
      const text = baseText + char;
      if (node.eow) yield text;
      depth++;
      baseText = text;
      const entries$1 = node.entries();
      const c$1 = Array.isArray(entries$1) ? entries$1 : [...entries$1];
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node;
        s.c = c$1;
        s.ci = 0;
      } else stack[depth] = {
        t: text,
        n: node,
        c: c$1,
        ci: 0
      };
      s = stack[depth];
    }
    depth -= 1;
  }
}
function iteratorTrieWords$1(node) {
  return walkerWords$1(node);
}
function findNode$1(node, word) {
  for (let i = 0; i < word.length; ++i) {
    const n = node.get(word[i]);
    if (!n) return void 0;
    node = n;
  }
  return node;
}
function countWords$1(root) {
  const visited = /* @__PURE__ */ new Map();
  function walk$3(n) {
    const nestedCount = visited.get(n.id);
    if (nestedCount !== void 0) return nestedCount;
    let cnt = n.eow ? 1 : 0;
    visited.set(n, cnt);
    for (const c of n.values()) cnt += walk$3(c);
    visited.set(n, cnt);
    return cnt;
  }
  return walk$3(root);
}
function trieRootToITrieRoot(root) {
  return ImplITrieRoot.toITrieNode(root);
}
var EmptyKeys$2 = Object.freeze([]);
var EmptyValues = Object.freeze([]);
var EmptyEntries$2 = Object.freeze([]);
var ImplITrieNode = class ImplITrieNode2 {
  id;
  _keys;
  constructor(node) {
    this.node = node;
    this.id = node;
  }
  /** flag End of Word */
  get eow() {
    return !!this.node.f;
  }
  /** number of children */
  get size() {
    if (!this.node.c) return 0;
    return this.keys().length;
  }
  /** get keys to children */
  keys() {
    if (this._keys) return this._keys;
    const keys3 = this.node.c ? Object.keys(this.node.c) : EmptyKeys$2;
    this._keys = keys3;
    return keys3;
  }
  /** get the child nodes */
  values() {
    return !this.node.c ? EmptyValues : Object.values(this.node.c).map((n) => ImplITrieNode2.toITrieNode(n));
  }
  entries() {
    return !this.node.c ? EmptyEntries$2 : Object.entries(this.node.c).map(([k, n]) => [k, ImplITrieNode2.toITrieNode(n)]);
  }
  /** get child ITrieNode */
  get(char) {
    const n = this.node.c?.[char];
    if (!n) return void 0;
    return ImplITrieNode2.toITrieNode(n);
  }
  getNode(chars) {
    return this.findNode(chars);
  }
  has(char) {
    const c = this.node.c;
    return c && char in c || false;
  }
  child(keyIdx) {
    const char = this.keys()[keyIdx];
    const n = char && this.get(char);
    if (!n) throw new Error("Index out of range.");
    return n;
  }
  hasChildren() {
    return !!this.node.c;
  }
  #findTrieNode(word) {
    let node = this.node;
    for (const char of word) {
      if (!node) return void 0;
      node = node.c?.[char];
    }
    return node;
  }
  findNode(word) {
    const node = this.#findTrieNode(word);
    return node && ImplITrieNode2.toITrieNode(node);
  }
  findExact(word) {
    const node = this.#findTrieNode(word);
    return !!node && !!node.f;
  }
  static toITrieNode(node) {
    return new this(node);
  }
};
var ImplITrieRoot = class extends ImplITrieNode {
  info;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(root) {
    super(root);
    this.root = root;
    const { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, isCaseAware } = root;
    this.info = {
      stripCaseAndAccentsPrefix,
      compoundCharacter,
      forbiddenWordPrefix,
      isCaseAware
    };
    this.hasForbiddenWords = !!root.c[forbiddenWordPrefix];
    this.hasCompoundWords = !!root.c[compoundCharacter];
    this.hasNonStrictWords = !!root.c[stripCaseAndAccentsPrefix];
  }
  get eow() {
    return false;
  }
  resolveId(id) {
    const n = id;
    return new ImplITrieNode(n);
  }
  get forbidPrefix() {
    return this.root.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.root.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.root.stripCaseAndAccentsPrefix;
  }
  static toITrieNode(node) {
    return new this(node);
  }
};
var walkerWords = _walkerWords;
function* _walkerWords(root) {
  const empty = [];
  function children(n) {
    if (n.c) return Object.keys(n.c);
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = {
    t: "",
    n: root.c,
    c: children(root),
    ci: 0
  };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const char = s.c[s.ci++];
      const node = s.n[char];
      const text = baseText + char;
      if (node.f) yield text;
      depth++;
      baseText = text;
      const c = children(node);
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node.c;
        s.c = c;
        s.ci = 0;
      } else stack[depth] = {
        t: text,
        n: node.c,
        c,
        ci: 0
      };
      s = stack[depth];
    }
    depth -= 1;
  }
}
var defaultGenSuggestionOptions = {
  compoundMethod: CompoundWordsMethod.NONE,
  ignoreCase: true,
  changeLimit: 5
};
var defaultSuggestionOptions = {
  ...defaultGenSuggestionOptions,
  numSuggestions: 8,
  includeTies: true,
  timeout: 5e3
};
var keyMapOfGenSuggestionOptionsStrict = {
  changeLimit: "changeLimit",
  compoundMethod: "compoundMethod",
  ignoreCase: "ignoreCase",
  compoundSeparator: "compoundSeparator"
};
var keyMapOfSuggestionOptionsStrict = {
  ...keyMapOfGenSuggestionOptionsStrict,
  filter: "filter",
  includeTies: "includeTies",
  numSuggestions: "numSuggestions",
  timeout: "timeout",
  weightMap: "weightMap"
};
function createSuggestionOptions(...opts) {
  const options = { ...defaultSuggestionOptions };
  const keys3 = Object.keys(keyMapOfSuggestionOptionsStrict);
  for (const opt of opts) for (const key of keys3) assign(options, opt, key);
  return options;
}
function assign(dest, src, k) {
  dest[k] = src[k] ?? dest[k];
}
var PairingHeap = class {
  _heap;
  _size = 0;
  constructor(compare$3) {
    this.compare = compare$3;
  }
  /** Add an item to the heap. */
  add(v) {
    this._heap = insert$1(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  /** take an item from the heap. */
  dequeue() {
    const n = this.next();
    if (n.done) return void 0;
    return n.value;
  }
  /** Add items to the heap */
  append(i) {
    for (const v of i) this.add(v);
    return this;
  }
  /** get the next value */
  next() {
    if (!this._heap) return {
      value: void 0,
      done: true
    };
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead(this.compare, this._heap);
    return { value };
  }
  /** peek at the next value without removing it. */
  peek() {
    return this._heap?.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  /** alias of `size` */
  get length() {
    return this._size;
  }
  /** number of entries in the heap. */
  get size() {
    return this._size;
  }
};
function removeHead(compare$3, heap) {
  if (!heap || !heap.c) return void 0;
  return mergeSiblings(compare$3, heap.c);
}
function insert$1(compare$3, heap, v) {
  const n = {
    v,
    s: void 0,
    c: void 0
  };
  if (!heap || compare$3(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge(compare$3, a, b) {
  if (compare$3(a.v, b.v) <= 0) {
    a.s = void 0;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = void 0;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings(compare$3, n) {
  if (!n.s) return n;
  const s = n.s;
  const ss = s.s;
  const m = merge(compare$3, n, s);
  return ss ? merge(compare$3, m, mergeSiblings(compare$3, ss)) : m;
}
var DEFAULT_COMPOUNDED_WORD_SEPARATOR = "\u2219";
var opCosts = {
  baseCost: 100,
  swapCost: 75,
  duplicateLetterCost: 80,
  compound: 1,
  visuallySimilar: 1,
  firstLetterBias: 5,
  wordBreak: 99,
  wordLengthCostFactor: 0.5
};
var intl = new Intl.Collator("en", { sensitivity: "base" });
var compare$2 = intl.compare;
var visualLetterGroups = [
  forms("\u01CE\xE0\xE5\xC4\xC0A\xE3\xE2\xE1\u01DF\u1EB7\u1EAF\u1EA5\u0100\u0101\u0103\u0105a\xE4\xE6\u0250\u0251\u03B1\u0430\u1FB3") + "\u1FB3",
  forms("Bb\u1E03\u0432\u044A\u044C"),
  forms("\u010B\u010C\u010Dc\u0109\xE7C\xC7\u0107\u010A\u0421\u0441\u03C2"),
  forms("\u1E0E\u1E0B\u1E0F\u1E11\u010F\u0111\u1E0DDd"),
  forms("\u0113\xEB\xC8\xCA\xCB\u1EC1\xE9\xE8\u1EBF\u1EC7\u0115eE\u0112\u0117\u0119\u011B\xEA\u0259\u025B\u0451\u0401\u0435\u0292"),
  forms("f\u1E1FF\uFB00"),
  forms("\u0121\u0120\u011E\u01E7\u011D\u0123Gg\u0263"),
  forms("\u0127\u0126\u0125\u1E25Hh\u1E24\u021F\u043D"),
  forms("I\u012F\xEF\u0130\xCE\xCD\u012Bi\xCC\xEC\xED\xEE\u0131\u026A\u0268\u0457\u038A\u0399"),
  forms("jJ\u0135"),
  forms("\u0137Kk\u03BA\u043A\u045C"),
  forms("\u1E37\u0142\u013E\u013CLl\u013A\u1E36\u03AF\u03B9"),
  forms("M\u1E43\u1E41m"),
  forms("n\u0146\xD1N\u1E47\u0148\u0147\xF1\u0144\u014B\u045D\u0438\u0439"),
  forms("\xD2O\xF8\u022D\u014C\u014D\u0151\u1ECFo\xD6\xF2\u0231\u022F\xF3\xF4\xF5\xF6\u01A1\u0254\u03CC\u03B4\u043E"),
  forms("P\u1E57p\u0440\u0420\u03C1"),
  forms("Qq"),
  forms("\u0159R\u1E5Br\u0155\u0157\u0453\u0433\u044F"),
  forms("\u1E63\u0161\u0218\u1E62sS\u0160\u1E61\u015E\u015D\u015B\u0219\u0283\u03A3"),
  forms("t\u021B\u021A\u0165T\u1E6D\u1E6C\u1E6B"),
  forms("\xDC\xFC\xFB\u016A\u01B0\u016F\u016B\u0171\xFA\xDB\u016D\xD9\xF9u\u0173U"),
  forms("Vv\u03BD"),
  forms("\u0175wW\u1E83\u1E85\u1E81\u03C9\u0448"),
  forms("xX\u0445"),
  forms("\xFF\xFDY\u0177y\xDD\u1EF3\u0423\u045E\u0443"),
  forms("Z\u1E93\u017E\u017D\u017C\u017B\u017Az")
];
function forms(letters) {
  const n = letters.normalize("NFC").replaceAll(/\p{M}/gu, "");
  const na = n.normalize("NFD").replaceAll(/\p{M}/gu, "");
  const s = new Set(n + n.toLowerCase() + n.toUpperCase() + na + na.toLowerCase() + na.toUpperCase());
  return [...s].join("");
}
var visualLetterMaskMap = calcVisualLetterMasks(visualLetterGroups);
function calcVisualLetterMasks(groups) {
  const map3 = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < groups.length; ++i) {
    const m = 1 << i;
    const g = groups[i];
    for (const c of g) map3[c] = (map3[c] || 0) | m;
  }
  return map3;
}
var matchPossibleWordSeparators = /[+∙•・●]/g;
function createWeightMap(...defs) {
  const map3 = _createWeightMap();
  addDefsToWeightMap(map3, defs);
  return map3;
}
function addDefToWeightMap(map3, ...defs) {
  return addDefsToWeightMap(map3, defs);
}
function addAdjustment(map3, ...adjustments) {
  for (const adj of adjustments) map3.adjustments.set(adj.id, adj);
  return map3;
}
function addDefsToWeightMap(map3, defs) {
  function addSet(set, def) {
    addSetToTrieCost(map3.insDel, set, def.insDel, def.penalty);
    addSetToTrieTrieCost(map3.replace, set, def.replace, def.penalty);
    addSetToTrieTrieCost(map3.swap, set, def.swap, def.penalty);
  }
  for (const _def of defs) {
    const def = normalizeDef(_def);
    const mapSets = splitMap$1(def);
    mapSets.forEach((s) => addSet(s, def));
  }
  return map3;
}
function _createWeightMap() {
  return {
    insDel: {},
    replace: {},
    swap: {},
    adjustments: /* @__PURE__ */ new Map()
  };
}
function lowest(a, b) {
  if (a === void 0) return b;
  if (b === void 0) return a;
  return a <= b ? a : b;
}
function highest(a, b) {
  if (a === void 0) return b;
  if (b === void 0) return a;
  return a >= b ? a : b;
}
function normalize(s) {
  const f = /* @__PURE__ */ new Set([s]);
  f.add(s.normalize("NFC"));
  f.add(s.normalize("NFD"));
  return f;
}
function* splitMapSubstringsIterable(map3) {
  let seq = "";
  let mode = 0;
  for (const char of map3) {
    if (mode && char === ")") {
      yield* normalize(seq);
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield* normalize(char);
  }
}
function splitMapSubstrings(map3) {
  return [...splitMapSubstringsIterable(map3)];
}
function splitMap$1(def) {
  const { map: map3 } = def;
  const sets = map3.split("|");
  return sets.map(splitMapSubstrings).filter((s) => s.length > 0);
}
function addToTrieCost(trie, str, cost, penalties) {
  if (!str) return;
  let t = trie;
  for (const c of str) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  t.c = lowest(t.c, cost);
  t.p = highest(t.p, penalties);
}
function addToTrieTrieCost(trie, left, right, cost, penalties) {
  let t = trie;
  for (const c of left) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  const trieCost = t.t = t.t || /* @__PURE__ */ Object.create(null);
  addToTrieCost(trieCost, right, cost, penalties);
}
function addSetToTrieCost(trie, set, cost, penalties) {
  if (cost === void 0) return;
  for (const str of set) addToTrieCost(trie, str, cost, penalties);
}
function addSetToTrieTrieCost(trie, set, cost, penalties) {
  if (cost === void 0) return;
  for (const left of set) for (const right of set) {
    if (left === right) continue;
    addToTrieTrieCost(trie, left, right, cost, penalties);
  }
}
function* searchTrieNodes(trie, str, i) {
  const len = str.length;
  for (let n = trie.n; i < len && n; ) {
    const t = n[str[i]];
    if (!t) return;
    ++i;
    yield {
      i,
      t
    };
    n = t.n;
  }
}
function* findTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const { c, p } = n.t;
    if (c !== void 0) yield {
      i: n.i,
      c,
      p: p || 0
    };
  }
}
function* findTrieTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const t = n.t.t;
    if (t !== void 0) yield {
      i: n.i,
      t
    };
  }
}
function createWeightCostCalculator(weightMap) {
  return new _WeightCostCalculator(weightMap);
}
var _WeightCostCalculator = class {
  constructor(weightMap) {
    this.weightMap = weightMap;
  }
  *calcInsDelCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieCostPrefixes(this.weightMap.insDel, a, ai)) yield {
      a,
      b,
      ai: del.i,
      bi,
      c: c + del.c,
      p: p + del.p
    };
    for (const ins of findTrieCostPrefixes(this.weightMap.insDel, b, bi)) yield {
      a,
      b,
      ai,
      bi: ins.i,
      c: c + ins.c,
      p: p + ins.p
    };
  }
  *calcReplaceCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieTrieCostPrefixes(this.weightMap.replace, a, ai)) for (const ins of findTrieCostPrefixes(del.t, b, bi)) yield {
      a,
      b,
      ai: del.i,
      bi: ins.i,
      c: c + ins.c,
      p: p + ins.p
    };
  }
  *calcSwapCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    const swap = this.weightMap.swap;
    for (const left of findTrieTrieCostPrefixes(swap, a, ai)) for (const right of findTrieCostPrefixes(left.t, a, left.i)) {
      const sw = a.slice(left.i, right.i) + a.slice(ai, left.i);
      if (b.slice(bi).startsWith(sw)) {
        const len = sw.length;
        yield {
          a,
          b,
          ai: ai + len,
          bi: bi + len,
          c: c + right.c,
          p: p + right.p
        };
      }
    }
  }
  calcAdjustment(word) {
    let penalty = 0;
    for (const adj of this.weightMap.adjustments.values()) if (adj.regexp.global) for (const _m of word.matchAll(adj.regexp)) penalty += adj.penalty;
    else if (adj.regexp.test(word)) penalty += adj.penalty;
    return penalty;
  }
};
function normalizeDef(def) {
  const { map: map3, ...rest } = def;
  return {
    ...rest,
    map: normalizeMap(map3)
  };
}
function normalizeMap(map3) {
  return map3.replaceAll(matchPossibleWordSeparators, DEFAULT_COMPOUNDED_WORD_SEPARATOR);
}
function distanceAStarWeighted(wordA, wordB, map3, cost = 100) {
  const calc = createWeightCostCalculator(map3);
  const best = _distanceAStarWeightedEx(wordA, wordB, calc, cost);
  const penalty = calc.calcAdjustment(wordB);
  return best.c + best.p + penalty;
}
function _distanceAStarWeightedEx(wordA, wordB, map3, cost = 100) {
  const a = "^" + wordA + "$";
  const b = "^" + wordB + "$";
  const aN = a.length;
  const bN = b.length;
  const candidates = new CandidatePool(aN, bN);
  candidates.add({
    ai: 0,
    bi: 0,
    c: 0,
    p: 0,
    f: void 0
  });
  function opSub(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN && bi < bN) {
      const cc = a[ai] === b[bi] ? c : c + cost;
      candidates.add({
        ai: ai + 1,
        bi: bi + 1,
        c: cc,
        p,
        f: n
      });
    }
  }
  function opIns(n) {
    const { ai, bi, c, p } = n;
    if (bi < bN) candidates.add({
      ai,
      bi: bi + 1,
      c: c + cost,
      p,
      f: n
    });
  }
  function opDel(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN) candidates.add({
      ai: ai + 1,
      bi,
      c: c + cost,
      p,
      f: n
    });
  }
  function opSwap(n) {
    const { ai, bi, c, p } = n;
    if (a[ai] === b[bi + 1] && a[ai + 1] === b[bi]) candidates.add({
      ai: ai + 2,
      bi: bi + 2,
      c: c + cost,
      p,
      f: n
    });
  }
  function opMap$1(n) {
    const { ai, bi, c, p } = n;
    const pos = {
      a,
      b,
      ai,
      bi,
      c,
      p
    };
    const costCalculations = [
      map3.calcInsDelCosts(pos),
      map3.calcSwapCosts(pos),
      map3.calcReplaceCosts(pos)
    ];
    costCalculations.forEach((iter) => {
      for (const nn of iter) candidates.add({
        ...nn,
        f: n
      });
    });
  }
  let best;
  while (best = candidates.next()) {
    if (best.ai === aN && best.bi === bN) break;
    opSwap(best);
    opIns(best);
    opDel(best);
    opMap$1(best);
    opSub(best);
  }
  (0, import_node_assert.default)(best);
  return best;
}
var CandidatePool = class {
  pool = new PairingHeap(compare$1);
  grid = [];
  constructor(aN, bN) {
    this.aN = aN;
    this.bN = bN;
  }
  next() {
    let n;
    while (n = this.pool.dequeue()) if (!n.d) return n;
    return void 0;
  }
  add(n) {
    const i = idx(n.ai, n.bi, this.bN);
    const g = this.grid[i];
    if (!g) {
      this.grid[i] = n;
      this.pool.add(n);
      return;
    }
    if (g.c <= n.c) return;
    g.d = true;
    this.grid[i] = n;
    this.pool.add(n);
  }
};
function idx(r, c, cols) {
  return r * cols + c;
}
function compare$1(a, b) {
  return a.c - b.c || b.ai + b.bi - a.ai - a.bi;
}
var initialRow = [...".".repeat(50)].map((_, i) => i);
Object.freeze(initialRow);
var defaultCost = 100;
function editDistanceWeighted(wordA, wordB, weights, editCost = defaultCost) {
  return distanceAStarWeighted(wordA, wordB, weights, editCost);
}
function startTimer() {
  const start = performance.now();
  return () => performance.now() - start;
}
function createPerfTimer() {
  const timer = startTimer();
  const active = /* @__PURE__ */ new Map();
  const events = [{
    name: "start",
    at: 0
  }];
  function updateEvent(event, atTime = timer()) {
    const elapsed = atTime - event.at;
    event.elapsed = (event.elapsed || 0) + elapsed;
    return elapsed;
  }
  function start(name2) {
    const event = createEvent(name2 || "start");
    events.push(event);
    name2 && active.set(name2, event);
    return () => updateEvent(event);
  }
  function stop(name2) {
    const knownEvent = name2 && active.get(name2);
    if (knownEvent) return updateEvent(knownEvent);
    return mark(name2 || "stop");
  }
  function createEvent(name2) {
    return {
      name: name2,
      at: timer()
    };
  }
  function mark(name2) {
    const event = createEvent(name2);
    events.push(event);
    return event.at;
  }
  function formatReport() {
    const lineElements = [
      {
        name: "Event Name",
        at: "Time",
        elapsed: "Elapsed"
      },
      {
        name: "----------",
        at: "----",
        elapsed: "-------"
      },
      ...mapEvents()
    ];
    function mapEvents() {
      const stack = [];
      return events.map((e) => {
        for (let s = stack.pop(); s; s = stack.pop()) if (s >= e.at + (e.elapsed || 0)) {
          stack.push(s);
          break;
        }
        const d = stack.length;
        if (e.elapsed) stack.push(e.at + e.elapsed);
        return {
          name: "| ".repeat(d) + (e.name || "").replaceAll("	", "  "),
          at: `${t(e.at)}`,
          elapsed: e.elapsed ? `${t(e.elapsed)}` : "--"
        };
      });
    }
    function t(ms) {
      return ms.toFixed(3) + "ms";
    }
    function m(v, s) {
      return Math.max(v, s.length);
    }
    const lengths = lineElements.reduce((a, b) => ({
      name: m(a.name, b.name),
      at: m(a.at, b.at),
      elapsed: m(a.elapsed, b.elapsed)
    }), {
      name: 0,
      at: 0,
      elapsed: 0
    });
    const lines = lineElements.map((e) => `${e.at.padStart(lengths.at)}  ${e.name.padEnd(lengths.name)}  ${e.elapsed.padStart(lengths.elapsed)}`);
    return lines.join("\n");
  }
  function measureFn(name2, fn) {
    const s = start(name2);
    const v = fn();
    s();
    return v;
  }
  async function measureAsyncFn(name2, fn) {
    const s = start(name2);
    const v = await fn();
    s();
    return v;
  }
  function report(reporter = console.log) {
    reporter(formatReport());
  }
  return {
    start,
    stop,
    mark,
    elapsed: timer,
    report,
    formatReport,
    measureFn,
    measureAsyncFn
  };
}
var globalPerfTimer = void 0;
function getGlobalPerfTimer() {
  const timer = globalPerfTimer || createPerfTimer();
  globalPerfTimer = timer;
  return timer;
}
function isDefined$1(a) {
  return a !== void 0;
}
function cleanCopy(t) {
  const r = { ...t };
  return clean$1(r);
}
function clean$1(t) {
  for (const prop in t) if (t[prop] === void 0) delete t[prop];
  return t;
}
function unique(a) {
  return [...new Set(a)];
}
function regexQuote(text) {
  return text.replaceAll(/([[\]\-+(){},|*.\\])/g, "\\$1");
}
function replaceAllFactory(match2, replaceWithText) {
  const r = RegExp(regexQuote(match2), "g");
  return (text) => text.replace(r, replaceWithText);
}
var defaultMaxNumberSuggestions = 10;
var BASE_COST = 100;
var MAX_NUM_CHANGES = 5;
var MAX_COST_SCALE = 0.5;
var MAX_ALLOWED_COST_SCALE = 1.03 * MAX_COST_SCALE;
var collator = new Intl.Collator();
var regexSeparator = new RegExp(`[${regexQuote(WORD_SEPARATOR)}]`, "g");
var wordLengthCost = [
  0,
  50,
  25,
  5,
  0
];
var EXTRA_WORD_COST = 5;
var DEFAULT_COLLECTOR_TIMEOUT = 1e3;
var symStopProcessing = Symbol("Collector Stop Processing");
function compSuggestionResults(a, b) {
  const aPref = a.isPreferred && -1 || 0;
  const bPref = b.isPreferred && -1 || 0;
  return aPref - bPref || a.cost - b.cost || a.word.length - b.word.length || collator.compare(a.word, b.word);
}
var defaultSuggestionCollectorOptions = Object.freeze({
  numSuggestions: defaultMaxNumberSuggestions,
  filter: () => true,
  changeLimit: MAX_NUM_CHANGES,
  includeTies: false,
  ignoreCase: true,
  timeout: DEFAULT_COLLECTOR_TIMEOUT,
  weightMap: void 0,
  compoundSeparator: "",
  compoundMethod: void 0
});
function suggestionCollector(wordToMatch, options) {
  const { filter: filter3 = () => true, changeLimit = MAX_NUM_CHANGES, includeTies = false, ignoreCase: ignoreCase2 = true, timeout = DEFAULT_COLLECTOR_TIMEOUT, weightMap, compoundSeparator = defaultSuggestionCollectorOptions.compoundSeparator } = options;
  const numSuggestions = Math.max(options.numSuggestions, 0) || 0;
  const numSugToHold = weightMap ? numSuggestions * 2 : numSuggestions;
  const sugs = /* @__PURE__ */ new Map();
  let maxCost = BASE_COST * Math.min(wordToMatch.length * MAX_ALLOWED_COST_SCALE, changeLimit);
  const useSeparator = compoundSeparator || (weightMap ? DEFAULT_COMPOUNDED_WORD_SEPARATOR : defaultSuggestionCollectorOptions.compoundSeparator);
  const fnCleanWord = !useSeparator || useSeparator === compoundSeparator ? (w) => w : replaceAllFactory(useSeparator, "");
  if (useSeparator && weightMap) addDefToWeightMap(weightMap, {
    map: useSeparator,
    insDel: 50
  });
  const genSuggestionOptions = clean$1({
    changeLimit,
    ignoreCase: ignoreCase2,
    compoundMethod: options.compoundMethod,
    compoundSeparator: useSeparator
  });
  let timeRemaining = timeout;
  function dropMax() {
    if (sugs.size < 2 || !numSuggestions) {
      sugs.clear();
      return;
    }
    const sorted = [...sugs.values()].sort(compSuggestionResults);
    let i = numSugToHold - 1;
    maxCost = sorted[i].cost;
    for (; i < sorted.length && sorted[i].cost <= maxCost; ++i) ;
    for (; i < sorted.length; ++i) sugs.delete(sorted[i].word);
  }
  function adjustCost(sug) {
    if (sug.isPreferred) return sug;
    const words = sug.word.split(regexSeparator);
    const extraCost = words.map((w) => wordLengthCost[w.length] || 0).reduce((a, b) => a + b, 0) + (words.length - 1) * EXTRA_WORD_COST;
    return {
      word: sug.word,
      cost: sug.cost + extraCost
    };
  }
  function collectSuggestion(suggestion) {
    const { word, cost, isPreferred } = adjustCost(suggestion);
    if (cost <= maxCost && filter3(suggestion.word, cost)) {
      const known = sugs.get(word);
      if (known) {
        known.cost = Math.min(known.cost, cost);
        known.isPreferred = known.isPreferred || isPreferred;
      } else {
        sugs.set(word, {
          word,
          cost,
          isPreferred
        });
        if (cost < maxCost && sugs.size > numSugToHold) dropMax();
      }
    }
    return maxCost;
  }
  function collect2(src, timeout$1, filter$1) {
    let stop = false;
    timeout$1 = timeout$1 ?? timeRemaining;
    timeout$1 = Math.min(timeout$1, timeRemaining);
    if (timeout$1 < 0) return;
    const timer = startTimer();
    let ir;
    while (!(ir = src.next(stop || maxCost)).done) {
      if (timer() > timeout$1) stop = symStopProcessing;
      const { value } = ir;
      if (!value) continue;
      if (isSuggestionResult(value)) {
        if (!filter$1 || filter$1(value.word, value.cost)) collectSuggestion(value);
        continue;
      }
    }
    timeRemaining -= timer();
  }
  function cleanCompoundResult(sr) {
    const { word, cost } = sr;
    const cWord = fnCleanWord(word);
    if (cWord !== word) return {
      word: cWord,
      cost,
      compoundWord: word,
      isPreferred: void 0
    };
    return { ...sr };
  }
  function suggestions2() {
    if (numSuggestions < 1 || !sugs.size) return [];
    const NF = "NFD";
    const nWordToMatch = wordToMatch.normalize(NF);
    const rawValues = [...sugs.values()];
    const values = weightMap ? rawValues.map(({ word, cost, isPreferred }) => ({
      word,
      cost: isPreferred ? cost : editDistanceWeighted(nWordToMatch, word.normalize(NF), weightMap, 110),
      isPreferred
    })) : rawValues;
    const sorted = values.sort(compSuggestionResults).map(cleanCompoundResult);
    let i = Math.min(sorted.length, numSuggestions) - 1;
    const limit = includeTies ? sorted.length : Math.min(sorted.length, numSuggestions);
    const iCost = sorted[i].cost;
    const maxCost$1 = Math.min(iCost, weightMap ? changeLimit * BASE_COST - 1 : iCost);
    for (i = 1; i < limit && sorted[i].cost <= maxCost$1; ++i) ;
    sorted.length = i;
    return sorted;
  }
  const collector = {
    collect: collect2,
    add: function(suggestion) {
      collectSuggestion(suggestion);
      return this;
    },
    get suggestions() {
      return suggestions2();
    },
    get maxCost() {
      return maxCost;
    },
    get word() {
      return wordToMatch;
    },
    get maxNumSuggestions() {
      return numSuggestions;
    },
    get changeLimit() {
      return changeLimit;
    },
    includesTies: includeTies,
    ignoreCase: ignoreCase2,
    symbolStopProcessing: symStopProcessing,
    genSuggestionOptions
  };
  return collector;
}
function impersonateCollector(collector, word) {
  const r = Object.create(collector);
  Object.defineProperty(r, "word", {
    value: word,
    writable: false
  });
  return r;
}
function isSuggestionResult(s) {
  const r = s;
  return !!r && typeof r === "object" && r?.cost !== void 0 && r.word != void 0;
}
function comparePath(a, b) {
  return a.c / (a.i + 1) - b.c / (b.i + 1) + (b.i - a.i);
}
function suggestAStar(trie, word, options = {}) {
  const opts = createSuggestionOptions(options);
  const collector = suggestionCollector(word, opts);
  collector.collect(getSuggestionsAStar(trie, word, opts));
  return collector.suggestions;
}
function* getSuggestionsAStar(trie, srcWord, options = {}) {
  const { compoundMethod, changeLimit, ignoreCase: ignoreCase2, weightMap } = createSuggestionOptions(options);
  const visMap = visualLetterMaskMap;
  const root = trie.getRoot();
  const rootIgnoreCase = ignoreCase2 && root.get(root.info.stripCaseAndAccentsPrefix) || void 0;
  const pathHeap = new PairingHeap(comparePath);
  const resultHeap = new PairingHeap(compareSuggestion);
  const rootPNode = {
    n: root,
    i: 0,
    c: 0,
    s: "",
    p: void 0,
    t: createCostTrie()
  };
  const BC = opCosts.baseCost;
  const VC = opCosts.visuallySimilar;
  const DL = opCosts.duplicateLetterCost;
  const wordSeparator = compoundMethod === CompoundWordsMethod.JOIN_WORDS ? JOIN_SEPARATOR : WORD_SEPARATOR;
  const sc = specialChars(trie.info);
  const comp = trie.info.compoundCharacter;
  const compRoot = root.get(comp);
  const compRootIgnoreCase = rootIgnoreCase && rootIgnoreCase.get(comp);
  const emitted = /* @__PURE__ */ Object.create(null);
  const srcLetters = [...srcWord];
  let limit = BC * Math.min(srcLetters.length * opCosts.wordLengthCostFactor, changeLimit);
  pathHeap.add(rootPNode);
  if (rootIgnoreCase) pathHeap.add({
    n: rootIgnoreCase,
    i: 0,
    c: 0,
    s: "",
    p: void 0,
    t: createCostTrie()
  });
  let best = pathHeap.dequeue();
  let maxSize = pathHeap.size;
  let suggestionsGenerated = 0;
  let nodesProcessed = 0;
  let nodesProcessedLimit = 1e3;
  let minGen = 1;
  while (best) {
    if (++nodesProcessed > nodesProcessedLimit) {
      nodesProcessedLimit += 1e3;
      if (suggestionsGenerated < minGen) break;
      minGen += suggestionsGenerated;
    }
    if (best.c > limit) {
      best = pathHeap.dequeue();
      maxSize = Math.max(maxSize, pathHeap.size);
      continue;
    }
    processPath2(best);
    for (const sug of resultHeap) {
      ++suggestionsGenerated;
      if (sug.cost > limit) continue;
      if (sug.word in emitted && emitted[sug.word] <= sug.cost) continue;
      const action2 = yield sug;
      emitted[sug.word] = sug.cost;
      if (typeof action2 === "number") limit = Math.min(action2, limit);
      if (typeof action2 === "symbol") return;
    }
    best = pathHeap.dequeue();
    maxSize = Math.max(maxSize, pathHeap.size);
  }
  return;
  function compareSuggestion(a, b) {
    const pa = a.isPreferred && 1 || 0;
    const pb = b.isPreferred && 1 || 0;
    return pb - pa || a.cost - b.cost || Math.abs(a.word.charCodeAt(0) - srcWord.charCodeAt(0)) - Math.abs(b.word.charCodeAt(0) - srcWord.charCodeAt(0));
  }
  function processPath2(p) {
    const len = srcLetters.length;
    if (p.n.eow && p.i === len) {
      const word = pNodeToWord(p);
      const result = {
        word,
        cost: p.c
      };
      resultHeap.add(result);
    }
    calcEdges(p);
  }
  function calcEdges(p) {
    const { n, i, t } = p;
    const s = srcLetters[i];
    const sg = visMap[s] || 0;
    const cost0 = p.c;
    const cost = cost0 + BC + (i ? 0 : opCosts.firstLetterBias);
    const costVis = cost0 + VC;
    const costLegacyCompound = cost0 + opCosts.wordBreak;
    const costCompound = cost0 + opCosts.compound;
    if (s) {
      const m = n.get(s);
      if (m) storePath(t, m, i + 1, cost0, s, p, "=", s);
      if (weightMap) processWeightMapEdges(p, weightMap);
      const ns = srcLetters[i + 1];
      if (s == ns && m) storePath(t, m, i + 2, cost0 + DL, s, p, "dd", s);
      storePath(t, n, i + 1, cost, "", p, "d", "");
      for (const [ss, node] of n.entries()) {
        if (node.id === m?.id || ss in sc) continue;
        const g = visMap[ss] || 0;
        const c = sg & g ? costVis : cost;
        storePath(t, node, i + 1, c, ss, p, "r", ss);
      }
      if (n.eow && i && compoundMethod) storePath(t, root, i, costLegacyCompound, wordSeparator, p, "L", wordSeparator);
      if (ns) {
        const n1 = n.get(ns);
        const n2 = n1?.get(s);
        if (n2) {
          const ss = ns + s;
          storePath(t, n2, i + 2, cost0 + opCosts.swapCost, ss, p, "s", ss);
        }
      }
    }
    if (compRoot && costCompound <= limit && n.get(comp)) {
      if (compRootIgnoreCase) storePath(t, compRootIgnoreCase, i, costCompound, "", p, "~+", "~+");
      storePath(t, compRoot, i, costCompound, "", p, "+", "+");
    }
    if (cost <= limit) for (const [char, node] of n.entries()) {
      if (char in sc) continue;
      storePath(t, node, i, cost, char, p, "i", char);
    }
  }
  function processWeightMapEdges(p, weightMap$1) {
    delLetters(p, weightMap$1, srcLetters, storePath);
    insLetters(p, weightMap$1, srcLetters, storePath);
    repLetters(p, weightMap$1, srcLetters, storePath);
    return;
  }
  function storePath(t, n, i, c, s, p, a, ss) {
    const tt = getCostTrie(t, ss);
    const curr = tt.c[i];
    if (curr <= c || c > limit) return void 0;
    tt.c[i] = c;
    pathHeap.add({
      n,
      i,
      c,
      s,
      p,
      t: tt,
      a
    });
  }
}
function delLetters(pNode, weightMap, letters, storePath) {
  const { t, n } = pNode;
  const trie = weightMap.insDel;
  let ii = pNode.i;
  const cost0 = pNode.c - pNode.i;
  const len = letters.length;
  for (let nn = trie.n; ii < len && nn; ) {
    const tt = nn[letters[ii]];
    if (!tt) return;
    ++ii;
    if (tt.c !== void 0) storePath(t, n, ii, cost0 + tt.c, "", pNode, "d", "");
    nn = tt.n;
  }
}
function insLetters(p, weightMap, _letters, storePath) {
  const { t, i, c, n } = p;
  const cost0 = c;
  searchTrieCostNodesMatchingTrie2(weightMap.insDel, n, (s, tc, n$1) => {
    if (tc.c !== void 0) storePath(t, n$1, i, cost0 + tc.c, s, p, "i", s);
  });
}
function repLetters(pNode, weightMap, letters, storePath) {
  const node = pNode.n;
  const pt = pNode.t;
  const cost0 = pNode.c;
  const len = letters.length;
  const trie = weightMap.replace;
  let i = pNode.i;
  for (let n = trie.n; i < len && n; ) {
    const t = n[letters[i]];
    if (!t) return;
    ++i;
    const tInsert = t.t;
    if (tInsert) searchTrieCostNodesMatchingTrie2(tInsert, node, (s, tt, n$1) => {
      const c = tt.c;
      if (c === void 0) return;
      storePath(pt, n$1, i, cost0 + c + (tt.p || 0), s, pNode, "r", s);
    });
    n = t.n;
  }
}
function createCostTrie() {
  return {
    c: [],
    t: /* @__PURE__ */ Object.create(null)
  };
}
function getCostTrie(t, s) {
  if (s.length == 1) return t.t[s] ??= createCostTrie();
  if (!s) return t;
  let tt = t;
  for (const c of s) tt = tt.t[c] ??= createCostTrie();
  return tt;
}
function pNodeToWord(p) {
  const parts = [];
  let n = p;
  while (n) {
    parts.push(n.s);
    n = n.p;
  }
  parts.reverse();
  return parts.join("");
}
function specialChars(options) {
  const charSet = /* @__PURE__ */ Object.create(null);
  for (const c of Object.values(options)) if (typeof c === "string") charSet[c] = true;
  return charSet;
}
function searchTrieCostNodesMatchingTrie2(trie, node, emit, s = "") {
  const n = trie.n;
  if (!n) return;
  for (const [key, c] of node.entries()) {
    const t = n[key];
    if (!t) continue;
    const pfx = s + key;
    emit(pfx, t, c);
    if (t.n) searchTrieCostNodesMatchingTrie2(t, c, emit, pfx);
  }
}
var COMPOUND_FIX = "+";
var OPTIONAL_COMPOUND_FIX = "*";
var CASE_INSENSITIVE_PREFIX = "~";
var FORBID_PREFIX = "!";
var LINE_COMMENT = "#";
var IDENTITY_PREFIX = "=";
var defaultTrieInfo = Object.freeze({
  compoundCharacter: COMPOUND_FIX,
  forbiddenWordPrefix: FORBID_PREFIX,
  stripCaseAndAccentsPrefix: CASE_INSENSITIVE_PREFIX,
  isCaseAware: true,
  hasForbiddenWords: false,
  hasCompoundWords: false,
  hasNonStrictWords: false
});
function mergeDefaults(value, defaultValue) {
  const result = { ...defaultValue };
  if (value) {
    for (const [k, v] of Object.entries(value)) if (k in result) result[k] = v ?? result[k];
  }
  return result;
}
function mergeOptionalWithDefaults(...options) {
  return options.reduce((acc, opt) => mergeDefaults(opt, acc), defaultTrieInfo);
}
function expandCharacterSet(line, rangeChar = "-") {
  const charSet = /* @__PURE__ */ new Set();
  let mode = 0;
  let prev = "";
  for (const char of line) {
    if (mode) {
      expandRange(prev, char).forEach((a) => charSet.add(a));
      mode = 0;
    }
    if (char === rangeChar && prev) {
      mode = 1;
      continue;
    }
    charSet.add(char);
    prev = char;
  }
  if (mode) charSet.add(rangeChar);
  return charSet;
}
function expandRange(a, b) {
  const values = [];
  const end = b.codePointAt(0);
  const begin = a.codePointAt(0);
  if (!(begin && end)) return values;
  for (let i = begin; i <= end; ++i) values.push(String.fromCodePoint(i));
  return values;
}
function caseForms(letter, locale) {
  const forms$1 = /* @__PURE__ */ new Set([letter]);
  function tryCases(s) {
    forms$1.add(s.toLocaleLowerCase(locale));
    forms$1.add(s.toLocaleUpperCase(locale));
  }
  tryCases(letter);
  [...forms$1].forEach(tryCases);
  return [...forms$1].filter((a) => !!a);
}
function accentForms(letter) {
  const forms$1 = /* @__PURE__ */ new Set([
    letter,
    letter.normalize("NFC"),
    letter.normalize("NFD")
  ]);
  return forms$1;
}
function stripAccents(characters) {
  return characters.normalize("NFD").replaceAll(/\p{M}/gu, "");
}
function stripNonAccents(characters) {
  return characters.normalize("NFD").replaceAll(/[^\p{M}]/gu, "");
}
function isValidUtf16Character(char) {
  const len = char.length;
  const code = char.charCodeAt(0) & 64512;
  const valid = len === 1 && (code & 63488) !== 55296 || len === 2 && (code & 64512) === 55296 && (char.charCodeAt(1) & 64512) === 56320;
  return valid;
}
function assertValidUtf16Character(char) {
  if (!isValidUtf16Character(char)) {
    const len = char.length;
    const codes$1 = toCharCodes(char.slice(0, 2)).map((c) => "0x" + ("0000" + c.toString(16)).slice(-4));
    let message;
    if (len == 1) message = `Invalid utf16 character, lone surrogate: ${codes$1[0]}`;
    else if (len == 2) message = `Invalid utf16 character, not a valid surrogate pair: [${codes$1.join(", ")}]`;
    else message = `Invalid utf16 character, must be a single character, found: ${len}`;
    throw new Error(message);
  }
}
function toCharCodes(s) {
  const values = [];
  for (let i = 0; i < s.length; ++i) values.push(s.charCodeAt(i));
  return values;
}
function encodeUtf8N_BE(code) {
  if (code < 128) return code;
  if (code < 2048) return 49280 | (code & 1984) << 2 | code & 63;
  if (code < 65536) return 14712960 | (code & 61440) << 4 | (code & 4032) << 2 | code & 63;
  return 4034953344 + ((code & 1835008) << 6 | (code & 258048) << 4 | (code & 4032) << 2 | code & 63);
}
var Utf8Accumulator = class Utf8Accumulator2 {
  remaining = 0;
  value = 0;
  decode(byte) {
    let remaining = this.remaining;
    if (byte & -256) return this.reset();
    if ((byte & 128) === 0) {
      if (remaining) return this.reset();
      return byte;
    }
    if (remaining) {
      if ((byte & 192) !== 128) return this.reset();
      let value = this.value;
      value = value << 6 | byte & 63;
      this.value = value;
      remaining -= 1;
      this.remaining = remaining;
      return remaining ? void 0 : value;
    }
    if ((byte & 224) === 192) {
      this.value = byte & 31;
      this.remaining = 1;
      return void 0;
    }
    if ((byte & 240) === 224) {
      this.value = byte & 15;
      this.remaining = 2;
      return void 0;
    }
    if ((byte & 248) === 240) {
      this.value = byte & 7;
      this.remaining = 3;
      return void 0;
    }
    return this.reset();
  }
  reset() {
    this.remaining = 0;
    this.value = 0;
    return 65533;
  }
  clone(into = new Utf8Accumulator2()) {
    into.remaining = this.remaining;
    into.value = this.value;
    return into;
  }
  static isMultiByte(v) {
    return (v & 128) !== 0;
  }
  static isSingleByte(v) {
    return (v & 128) === 0;
  }
  static create() {
    return new this();
  }
};
function encodeTextToUtf8Into(text, into, offset = 0) {
  let i = offset;
  const len = text.length;
  for (let j = 0; j < len; j++) {
    let code = text.charCodeAt(j);
    code = (code & 63488) === 55296 ? text.codePointAt(j++) || 0 : code;
    if (code < 128) {
      into[i++] = code;
      continue;
    }
    if (code < 2048) {
      const u$1 = 49280 | (code & 1984) << 2 | code & 63;
      into[i++] = u$1 >>> 8;
      into[i++] = u$1 & 255;
      continue;
    }
    if (code < 65536) {
      const u$1 = 14712960 | (code & 61440) << 4 | (code & 4032) << 2 | code & 63;
      into[i++] = u$1 >>> 16;
      into[i++] = u$1 >>> 8 & 255;
      into[i++] = u$1 & 255;
      continue;
    }
    const u = 4034953344 | ((code & 1835008) << 6 | (code & 258048) << 4 | (code & 4032) << 2 | code & 63);
    into[i++] = u >>> 24 & 255;
    into[i++] = u >>> 16 & 255;
    into[i++] = u >>> 8 & 255;
    into[i++] = u & 255;
  }
  return i - offset;
}
function encodeTextToUtf8(text) {
  const array = new Array(text.length);
  const len = encodeTextToUtf8Into(text, array);
  array.length !== len && (array.length = len);
  return array;
}
var emptySeq = [0];
Object.freeze(emptySeq);
var CharIndex = class {
  #charToUtf8SeqMap;
  #lastWord = "";
  #lastWordSeq = [];
  #multiByteChars;
  constructor(charIndex) {
    this.charIndex = charIndex;
    this.#charToUtf8SeqMap = buildCharIndexSequenceMap(charIndex);
    this.#multiByteChars = [...this.#charToUtf8SeqMap.values()].some((c) => c.length > 1);
  }
  getCharUtf8Seq(c) {
    const found = this.#charToUtf8SeqMap.get(c);
    if (found) return found;
    const s = encodeTextToUtf8(c);
    this.#charToUtf8SeqMap.set(c, s);
    return s;
  }
  wordToUtf8Seq(word) {
    if (this.#lastWord === word) return this.#lastWordSeq;
    const seq = encodeTextToUtf8(word);
    this.#lastWord = word;
    this.#lastWordSeq = seq;
    return seq;
  }
  indexContainsMultiByteChars() {
    return this.#multiByteChars;
  }
  get size() {
    return this.charIndex.length;
  }
  toJSON() {
    return { charIndex: this.charIndex };
  }
};
function buildCharIndexSequenceMap(charIndex) {
  const map3 = /* @__PURE__ */ new Map();
  for (const key of charIndex) map3.set(key, encodeTextToUtf8(key));
  return map3;
}
var CharIndexBuilder = class {
  charIndex = [];
  charIndexMap = /* @__PURE__ */ new Map();
  charIndexSeqMap = /* @__PURE__ */ new Map();
  #mapIdxToSeq = /* @__PURE__ */ new Map();
  constructor() {
    this.getUtf8Value("");
  }
  getUtf8Value(c) {
    const found = this.charIndexMap.get(c);
    if (found !== void 0) return found;
    const nc = c.normalize("NFC");
    this.charIndex.push(nc);
    const utf8 = encodeUtf8N_BE(nc.codePointAt(0) || 0);
    this.charIndexMap.set(c, utf8);
    this.charIndexMap.set(nc, utf8);
    this.charIndexMap.set(c.normalize("NFD"), utf8);
    return utf8;
  }
  utf8ValueToUtf8Seq(idx$1) {
    const found = this.#mapIdxToSeq.get(idx$1);
    if (found !== void 0) return found;
    const seq = splitUtf8(idx$1);
    this.#mapIdxToSeq.set(idx$1, seq);
    return seq;
  }
  charToUtf8Seq(c) {
    const idx$1 = this.getUtf8Value(c);
    return this.utf8ValueToUtf8Seq(idx$1);
  }
  wordToUtf8Seq(word) {
    const seq = new Array(word.length);
    let i = 0;
    for (const c of word) {
      const idx$1 = this.getUtf8Value(c);
      const cSep = this.utf8ValueToUtf8Seq(idx$1);
      if (typeof cSep === "number") {
        seq[i++] = cSep;
        continue;
      }
      for (const cIdx of cSep) seq[i++] = cIdx;
    }
    if (seq.length !== i) seq.length = i;
    return seq;
  }
  get size() {
    return this.charIndex.length;
  }
  build() {
    return new CharIndex(this.charIndex);
  }
};
function splitUtf8(utf8) {
  if (utf8 <= 255) return [utf8];
  if (utf8 <= 65535) return [utf8 >> 8 & 255, utf8 & 255];
  if (utf8 <= 16777215) return [
    utf8 >> 16 & 255,
    utf8 >> 8 & 255,
    utf8 & 255
  ];
  return [
    utf8 >> 24 & 255,
    utf8 >> 16 & 255,
    utf8 >> 8 & 255,
    utf8 & 255
  ].filter((v) => v);
}
function extractInfo(info5) {
  const { NodeMaskEOW, NodeMaskChildCharIndex, NodeChildRefShift } = info5;
  return {
    NodeMaskEOW,
    NodeMaskChildCharIndex,
    NodeChildRefShift
  };
}
var FastTrieBlobInternals = class {
  NodeMaskEOW;
  NodeMaskChildCharIndex;
  NodeChildRefShift;
  isIndexDecoderNeeded;
  info;
  constructor(nodes, charIndex, maskInfo, info5) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    const { NodeMaskEOW, NodeMaskChildCharIndex, NodeChildRefShift } = maskInfo;
    this.NodeMaskEOW = NodeMaskEOW;
    this.NodeMaskChildCharIndex = NodeMaskChildCharIndex;
    this.NodeChildRefShift = NodeChildRefShift;
    this.isIndexDecoderNeeded = charIndex.indexContainsMultiByteChars();
    this.info = mergeOptionalWithDefaults(info5);
  }
};
var FastTrieBlobInternalsAndMethods = class extends FastTrieBlobInternals {
  nodeFindNode;
  nodeFindExact;
  nodeGetChild;
  isForbidden;
  findExact;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(nodes, charIndex, maskInfo, info5, trieMethods) {
    super(nodes, charIndex, maskInfo, info5);
    this.nodeFindExact = trieMethods.nodeFindExact;
    this.nodeGetChild = trieMethods.nodeGetChild;
    this.isForbidden = trieMethods.isForbidden;
    this.findExact = trieMethods.findExact;
    this.nodeFindNode = trieMethods.nodeFindNode;
    this.hasForbiddenWords = trieMethods.hasForbiddenWords;
    this.hasCompoundWords = trieMethods.hasCompoundWords;
    this.hasNonStrictWords = trieMethods.hasNonStrictWords;
  }
};
function sortNodes(nodes, mask) {
  if (Object.isFrozen(nodes)) {
    assertSorted(nodes, mask);
    return nodes;
  }
  for (let i = 0; i < nodes.length; ++i) {
    let node = nodes[i];
    if (node.length > 2) {
      const isFrozen = Object.isFrozen(node);
      node = isFrozen ? Uint32Array.from(node) : node;
      const nodeInfo = node[0];
      node[0] = 0;
      node.sort((a, b) => !a ? -1 : !b ? 1 : (a & mask) - (b & mask));
      node[0] = nodeInfo;
      if (isFrozen) {
        nodes[i] = node;
        Object.freeze(node);
      }
    }
  }
  Object.freeze(nodes);
  return nodes;
}
function assertSorted(nodes, mask) {
  for (let i = 0; i < nodes.length; ++i) {
    const node = nodes[i];
    if (node.length > 2) {
      let last = -1;
      for (let j = 1; j < node.length; ++j) {
        const n = node[j] & mask;
        if (n < last) throw new Error(`Node ${i} is not sorted. ${last} > ${n}`);
        last = n;
      }
    }
  }
}
var EmptyKeys$1 = Object.freeze([]);
var EmptyNodes$1 = Object.freeze([]);
var EmptyEntries$1 = Object.freeze([]);
var FastTrieBlobINode = class FastTrieBlobINode2 {
  id;
  node;
  eow;
  _keys;
  _count;
  _size;
  _chained;
  _nodesEntries;
  _entries;
  _values;
  charToIdx;
  constructor(trie, nodeIdx) {
    this.trie = trie;
    this.nodeIdx = nodeIdx;
    const node = trie.nodes[nodeIdx];
    this.node = node;
    this.eow = !!(node[0] & trie.NodeMaskEOW);
    this._count = node.length - 1;
    this.id = nodeIdx;
    this.findExact = (word) => trie.nodeFindExact(nodeIdx, word);
  }
  /** get keys to children */
  keys() {
    if (this._keys) return this._keys;
    if (!this._count) return EmptyKeys$1;
    this._keys = this.getNodesEntries().map(([key]) => key);
    return this._keys;
  }
  values() {
    if (!this._count) return EmptyNodes$1;
    if (this._values) return this._values;
    this._values = this.entries().map(([, value]) => value);
    return this._values;
  }
  entries() {
    if (this._entries) return this._entries;
    if (!this._count) return EmptyEntries$1;
    const entries = this.getNodesEntries();
    this._entries = entries.map(([key, value]) => [key, new FastTrieBlobINode2(this.trie, value)]);
    return this._entries;
  }
  /** get child ITrieNode */
  get(char) {
    const idx$1 = this.trie.nodeGetChild(this.id, char);
    if (idx$1 === void 0) return void 0;
    return new FastTrieBlobINode2(this.trie, idx$1);
  }
  getNode(chars) {
    const idx$1 = this.trie.nodeFindNode(this.id, chars);
    if (idx$1 === void 0) return void 0;
    return new FastTrieBlobINode2(this.trie, idx$1);
  }
  has(char) {
    const idx$1 = this.trie.nodeGetChild(this.id, char);
    return idx$1 !== void 0;
  }
  hasChildren() {
    return this._count > 0;
  }
  child(keyIdx) {
    if (!this._values && !this.containsChainedIndexes()) {
      const n = this.node[keyIdx + 1];
      const nodeIdx = n >>> this.trie.NodeChildRefShift;
      return new FastTrieBlobINode2(this.trie, nodeIdx);
    }
    return this.values()[keyIdx];
  }
  getCharToIdxMap() {
    const m = this.charToIdx;
    if (m) return m;
    const map3 = /* @__PURE__ */ Object.create(null);
    const keys3 = this.keys();
    for (let i = 0; i < keys3.length; ++i) map3[keys3[i]] = i;
    this.charToIdx = map3;
    return map3;
  }
  findExact(word) {
    return this.trie.nodeFindExact(this.id, word);
  }
  isForbidden(word) {
    const n = this.trie.nodeGetChild(this.id, this.trie.info.forbiddenWordPrefix);
    if (n === void 0) return false;
    return this.trie.nodeFindExact(n, word);
  }
  findCaseInsensitive(word) {
    const n = this.trie.nodeGetChild(this.id, this.trie.info.stripCaseAndAccentsPrefix);
    if (n === void 0) return false;
    return this.trie.nodeFindExact(n, word);
  }
  containsChainedIndexes() {
    if (this._chained !== void 0) return this._chained;
    if (!this._count || !this.trie.isIndexDecoderNeeded) {
      this._chained = false;
      return false;
    }
    let found = false;
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const len = this._count;
    const node = this.node;
    for (let i = 1; i <= len && !found; ++i) {
      const entry = node[i];
      const codePoint = entry & NodeMaskChildCharIndex;
      found = Utf8Accumulator.isMultiByte(codePoint);
    }
    this._chained = !!found;
    return this._chained;
  }
  getNodesEntries() {
    if (this._nodesEntries) return this._nodesEntries;
    if (!this.containsChainedIndexes()) {
      const entries = Array(this._count);
      const nodes = this.node;
      const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
      const RefShift = this.trie.NodeChildRefShift;
      for (let i = 0; i < this._count; ++i) {
        const entry = nodes[i + 1];
        const codePoint = entry & NodeMaskChildCharIndex;
        entries[i] = [String.fromCodePoint(codePoint), entry >>> RefShift];
      }
      this._nodesEntries = entries;
      return entries;
    }
    this._nodesEntries = this.walkChainedIndexes();
    return this._nodesEntries;
  }
  walkChainedIndexes() {
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.trie.NodeChildRefShift;
    const nodes = this.trie.nodes;
    const acc = Utf8Accumulator.create();
    const stack = [{
      n: this.node,
      c: 1,
      acc
    }];
    let depth = 0;
    const entries = Array(this._count);
    let eIdx = 0;
    while (depth >= 0) {
      const s = stack[depth];
      const { n: node, c: off } = s;
      if (off >= node.length) {
        --depth;
        continue;
      }
      ++s.c;
      const entry = node[off];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc$1 = s.acc.clone();
      const codePoint = acc$1.decode(charIdx);
      if (codePoint !== void 0) {
        const char = String.fromCodePoint(codePoint);
        const nodeIdx = entry >>> NodeChildRefShift;
        entries[eIdx++] = [char, nodeIdx];
        continue;
      }
      const idx$1 = entry >>> NodeChildRefShift;
      const ss = stack[++depth];
      if (ss) {
        ss.n = nodes[idx$1];
        ss.c = 1;
        ss.acc = acc$1;
      } else stack[depth] = {
        n: nodes[idx$1],
        c: 1,
        acc: acc$1
      };
    }
    return entries;
  }
  get size() {
    if (this._size === void 0) {
      if (!this.containsChainedIndexes()) {
        this._size = this._count;
        return this._size;
      }
      this._size = this.getNodesEntries().length;
    }
    return this._size;
  }
};
var FastTrieBlobIRoot = class extends FastTrieBlobINode {
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(trie, nodeIdx) {
    super(trie, nodeIdx);
    this.hasForbiddenWords = trie.hasForbiddenWords;
    this.hasCompoundWords = trie.hasCompoundWords;
    this.hasNonStrictWords = trie.hasNonStrictWords;
  }
  resolveId(id) {
    return new FastTrieBlobINode(this.trie, id);
  }
  find(word, strict) {
    let found = this.findExact(word);
    if (found) return {
      found: word,
      compoundUsed: false,
      caseMatched: true
    };
    if (strict) return void 0;
    found = this.findCaseInsensitive(word);
    return found ? {
      found: word,
      compoundUsed: false,
      caseMatched: false
    } : void 0;
  }
  get info() {
    return this.trie.info;
  }
  get forbidPrefix() {
    return this.trie.info.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.trie.info.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.trie.info.stripCaseAndAccentsPrefix;
  }
};
var TrieBlobInternals = class {
  NodeMaskEOW;
  NodeMaskNumChildren;
  NodeMaskChildCharIndex;
  NodeChildRefShift;
  isIndexDecoderNeeded;
  nodeFindExact;
  isForbidden;
  findExact;
  nodeGetChild;
  nodeFindNode;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(nodes, charIndex, maskInfo, methods) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    const { NodeMaskEOW, NodeMaskChildCharIndex, NodeMaskNumChildren, NodeChildRefShift } = maskInfo;
    this.NodeMaskEOW = NodeMaskEOW;
    this.NodeMaskNumChildren = NodeMaskNumChildren;
    this.NodeMaskChildCharIndex = NodeMaskChildCharIndex;
    this.NodeChildRefShift = NodeChildRefShift;
    this.isIndexDecoderNeeded = charIndex.indexContainsMultiByteChars();
    this.nodeFindExact = methods.nodeFindExact;
    this.isForbidden = methods.isForbidden;
    this.findExact = methods.findExact;
    this.nodeGetChild = methods.nodeGetChild;
    this.nodeFindNode = methods.nodeFindNode;
    this.hasForbiddenWords = methods.hasForbiddenWords;
    this.hasCompoundWords = methods.hasCompoundWords;
    this.hasNonStrictWords = methods.hasNonStrictWords;
  }
};
var EmptyKeys = Object.freeze([]);
var EmptyNodes = Object.freeze([]);
var EmptyEntries = Object.freeze([]);
var TrieBlobINode = class TrieBlobINode2 {
  id;
  node;
  eow;
  _keys;
  _count;
  _size;
  _chained;
  _nodesEntries;
  _entries;
  _values;
  charToIdx;
  constructor(trie, nodeIdx) {
    this.trie = trie;
    this.nodeIdx = nodeIdx;
    const node = trie.nodes[nodeIdx];
    this.node = node;
    this.eow = !!(node & trie.NodeMaskEOW);
    this._count = node & trie.NodeMaskNumChildren;
    this.id = nodeIdx;
  }
  /** get keys to children */
  keys() {
    if (this._keys) return this._keys;
    if (!this._count) return EmptyKeys;
    this._keys = this.getNodesEntries().map(([key]) => key);
    return this._keys;
  }
  values() {
    if (!this._count) return EmptyNodes;
    if (this._values) return this._values;
    this._values = this.entries().map(([, value]) => value);
    return this._values;
  }
  entries() {
    if (this._entries) return this._entries;
    if (!this._count) return EmptyEntries;
    const entries = this.getNodesEntries();
    this._entries = entries.map(([key, value]) => [key, new TrieBlobINode2(this.trie, value)]);
    return this._entries;
  }
  /** get child ITrieNode */
  get(char) {
    return this.#getChildNode(char);
  }
  has(char) {
    return this.trie.nodeGetChild(this.nodeIdx, char) !== void 0;
  }
  hasChildren() {
    return this._count > 0;
  }
  child(keyIdx) {
    if (!this._values && !this.containsChainedIndexes()) {
      const n = this.trie.nodes[this.nodeIdx + keyIdx + 1];
      const nodeIdx = n >>> this.trie.NodeChildRefShift;
      return new TrieBlobINode2(this.trie, nodeIdx);
    }
    return this.values()[keyIdx];
  }
  #getChildNodeIdx(char) {
    return this.trie.nodeGetChild(this.nodeIdx, char);
  }
  #getChildNode(char) {
    if (this.charToIdx) {
      const keyIdx = this.charToIdx[char];
      if (keyIdx === void 0) return void 0;
      return this.child(keyIdx);
    }
    const idx$1 = this.#getChildNodeIdx(char);
    if (idx$1 === void 0) return void 0;
    return new TrieBlobINode2(this.trie, idx$1);
  }
  getCharToIdxMap() {
    const m = this.charToIdx;
    if (m) return m;
    const map3 = /* @__PURE__ */ Object.create(null);
    const keys3 = this.keys();
    for (let i = 0; i < keys3.length; ++i) map3[keys3[i]] = i;
    this.charToIdx = map3;
    return map3;
  }
  getNode(word) {
    const n = this.trie.nodeFindNode(this.nodeIdx, word);
    return n === void 0 ? void 0 : new TrieBlobINode2(this.trie, n);
  }
  findExact(word) {
    return this.trie.nodeFindExact(this.nodeIdx, word);
  }
  containsChainedIndexes() {
    if (this._chained !== void 0) return this._chained;
    if (!this._count || !this.trie.isIndexDecoderNeeded) {
      this._chained = false;
      return false;
    }
    let found = false;
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const offset = this.nodeIdx + 1;
    const nodes = this.trie.nodes;
    const len = this._count;
    for (let i = 0; i < len && !found; ++i) {
      const entry = nodes[i + offset];
      const charIdx = entry & NodeMaskChildCharIndex;
      found = Utf8Accumulator.isMultiByte(charIdx);
    }
    this._chained = !!found;
    return this._chained;
  }
  getNodesEntries() {
    if (this._nodesEntries) return this._nodesEntries;
    if (!this.containsChainedIndexes()) {
      const entries = Array(this._count);
      const nodes = this.trie.nodes;
      const offset = this.nodeIdx + 1;
      const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
      const RefShift = this.trie.NodeChildRefShift;
      for (let i = 0; i < this._count; ++i) {
        const entry = nodes[offset + i];
        const codePoint = entry & NodeMaskChildCharIndex;
        entries[i] = [String.fromCodePoint(codePoint), entry >>> RefShift];
      }
      this._nodesEntries = entries;
      return entries;
    }
    this._nodesEntries = this.walkChainedIndexes();
    return this._nodesEntries;
  }
  walkChainedIndexes() {
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.trie.NodeChildRefShift;
    const NodeMaskNumChildren = this.trie.NodeMaskNumChildren;
    const nodes = this.trie.nodes;
    const acc = Utf8Accumulator.create();
    const stack = [{
      nodeIdx: this.nodeIdx + 1,
      lastIdx: this.nodeIdx + this._count,
      acc
    }];
    let depth = 0;
    const entries = Array(this._count);
    let eIdx = 0;
    while (depth >= 0) {
      const s = stack[depth];
      const { nodeIdx, lastIdx } = s;
      if (nodeIdx > lastIdx) {
        --depth;
        continue;
      }
      ++s.nodeIdx;
      const entry = nodes[nodeIdx];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc$1 = s.acc.clone();
      const codePoint = acc$1.decode(charIdx);
      if (codePoint !== void 0) {
        const char = String.fromCodePoint(codePoint);
        const nodeIdx$1 = entry >>> NodeChildRefShift;
        entries[eIdx++] = [char, nodeIdx$1];
        continue;
      }
      const idx$1 = entry >>> NodeChildRefShift;
      const lIdx = idx$1 + (nodes[idx$1] & NodeMaskNumChildren);
      const ss = stack[++depth];
      if (ss) {
        ss.nodeIdx = idx$1 + 1;
        ss.lastIdx = lIdx;
        ss.acc = acc$1;
      } else stack[depth] = {
        nodeIdx: idx$1 + 1,
        lastIdx: lIdx,
        acc: acc$1
      };
    }
    return entries;
  }
  get size() {
    if (this._size === void 0) {
      if (!this.containsChainedIndexes()) {
        this._size = this._count;
        return this._size;
      }
      this._size = this.getNodesEntries().length;
    }
    return this._size;
  }
};
var TrieBlobIRoot = class extends TrieBlobINode {
  find;
  isForbidden;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(trie, nodeIdx, info5, methods) {
    super(trie, nodeIdx);
    this.info = info5;
    this.find = methods.find;
    this.isForbidden = trie.isForbidden;
    this.hasForbiddenWords = trie.hasForbiddenWords;
    this.hasCompoundWords = trie.hasCompoundWords;
    this.hasNonStrictWords = trie.hasNonStrictWords;
  }
  resolveId(id) {
    return new TrieBlobINode(this.trie, id);
  }
  get forbidPrefix() {
    return this.info.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.info.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.info.stripCaseAndAccentsPrefix;
  }
};
var NodeHeaderNumChildrenBits = 8;
var NodeHeaderNumChildrenShift = 0;
var HEADER_SIZE_UINT32 = 8;
var HEADER_SIZE = HEADER_SIZE_UINT32 * 4;
var HEADER_OFFSET = 0;
var HEADER_OFFSET_SIG = HEADER_OFFSET;
var HEADER_OFFSET_ENDIAN = HEADER_OFFSET_SIG + 8;
var HEADER_OFFSET_VERSION = HEADER_OFFSET_ENDIAN + 4;
var HEADER_OFFSET_NODES = HEADER_OFFSET_VERSION + 4;
var HEADER_OFFSET_NODES_LEN = HEADER_OFFSET_NODES + 4;
var HEADER_OFFSET_CHAR_INDEX = HEADER_OFFSET_NODES_LEN + 4;
var HEADER_OFFSET_CHAR_INDEX_LEN = HEADER_OFFSET_CHAR_INDEX + 4;
var HEADER = {
  header: HEADER_OFFSET,
  sig: HEADER_OFFSET_SIG,
  version: HEADER_OFFSET_VERSION,
  endian: HEADER_OFFSET_ENDIAN,
  nodes: HEADER_OFFSET_NODES,
  nodesLen: HEADER_OFFSET_NODES_LEN,
  charIndex: HEADER_OFFSET_CHAR_INDEX,
  charIndexLen: HEADER_OFFSET_CHAR_INDEX_LEN
};
var headerSig = "TrieBlob";
var version = "00.01.00";
var endianSig = 67305985;
var TrieBlob = class TrieBlob2 {
  info;
  #forbidIdx;
  #compoundIdx;
  #nonStrictIdx;
  #size;
  #iTrieRoot;
  /** the nodes data in 8 bits */
  #nodes8;
  #beAdj = (0, import_node_os2.endianness)() === "BE" ? 3 : 0;
  wordToCharacters = (word) => [...word];
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(nodes, charIndex, info5) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    trieBlobSort(nodes);
    this.info = mergeOptionalWithDefaults(info5);
    this.#nodes8 = new Uint8Array(nodes.buffer, nodes.byteOffset + this.#beAdj);
    this.#forbidIdx = this._lookupNode(0, this.info.forbiddenWordPrefix);
    this.#compoundIdx = this._lookupNode(0, this.info.compoundCharacter);
    this.#nonStrictIdx = this._lookupNode(0, this.info.stripCaseAndAccentsPrefix);
    this.hasForbiddenWords = !!this.#forbidIdx;
    this.hasCompoundWords = !!this.#compoundIdx;
    this.hasNonStrictWords = !!this.#nonStrictIdx;
  }
  wordToUtf8Seq(word) {
    return this.charIndex.wordToUtf8Seq(word);
  }
  letterToNodeCharIndexSequence(letter) {
    return this.charIndex.getCharUtf8Seq(letter);
  }
  has(word) {
    return this.#hasWord(0, word);
  }
  isForbiddenWord(word) {
    return !!this.#forbidIdx && this.#hasWord(this.#forbidIdx, word);
  }
  /**
  * Try to find the word in the trie. The word must be normalized.
  * If `strict` is `true` the case and accents must match.
  * Compound words are supported assuming that the compound character is in the trie.
  *
  * @param word - the word to find (normalized)
  * @param strict - if `true` the case and accents must match.
  */
  find(word, strict) {
    if (!this.hasCompoundWords) {
      const found = this.#hasWord(0, word);
      if (found) return {
        found: word,
        compoundUsed: false,
        caseMatched: true
      };
      if (strict || !this.#nonStrictIdx) return {
        found: false,
        compoundUsed: false,
        caseMatched: false
      };
      return {
        found: this.#hasWord(this.#nonStrictIdx, word) && word,
        compoundUsed: false,
        caseMatched: false
      };
    }
    return void 0;
  }
  getRoot() {
    return this.#iTrieRoot ??= this._getRoot();
  }
  _getRoot() {
    const trieData = new TrieBlobInternals(this.nodes, this.charIndex, {
      NodeMaskEOW: TrieBlob2.NodeMaskEOW,
      NodeMaskNumChildren: TrieBlob2.NodeMaskNumChildren,
      NodeMaskChildCharIndex: TrieBlob2.NodeMaskChildCharIndex,
      NodeChildRefShift: TrieBlob2.NodeChildRefShift
    }, {
      nodeFindExact: (idx$1, word) => this.#hasWord(idx$1, word),
      nodeGetChild: (idx$1, letter) => this._lookupNode(idx$1, letter),
      nodeFindNode: (idx$1, word) => this.#findNode(idx$1, word),
      isForbidden: (word) => this.isForbiddenWord(word),
      findExact: (word) => this.has(word),
      hasCompoundWords: this.hasCompoundWords,
      hasForbiddenWords: this.hasForbiddenWords,
      hasNonStrictWords: this.hasNonStrictWords
    });
    return new TrieBlobIRoot(trieData, 0, this.info, { find: (word, strict) => this.find(word, strict) });
  }
  getNode(prefix) {
    return findNode$1(this.getRoot(), prefix);
  }
  /**
  * Check if the word is in the trie starting at the given node index.
  */
  #hasWord(nodeIdx, word) {
    const nodeIdxFound = this.#findNode(nodeIdx, word);
    if (!nodeIdxFound) return false;
    const node = this.nodes[nodeIdxFound];
    const m = TrieBlob2.NodeMaskEOW;
    return (node & m) === m;
  }
  #findNode(nodeIdx, word) {
    const wordIndexes = this.wordToUtf8Seq(word);
    return this.#lookupNode(nodeIdx, wordIndexes);
  }
  /**
  * Find the node index for the given Utf8 character sequence.
  * @param nodeIdx - node index to start the search
  * @param seq - the byte sequence of the character to look for
  * @returns
  */
  #lookupNode(nodeIdx, seq) {
    const NodeMaskNumChildren = TrieBlob2.NodeMaskNumChildren;
    const NodeChildRefShift = TrieBlob2.NodeChildRefShift;
    const nodes = this.nodes;
    const nodes8 = this.#nodes8;
    const wordIndexes = seq;
    const len = wordIndexes.length;
    let node = nodes[nodeIdx];
    for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = wordIndexes[p];
      const count3 = node & NodeMaskNumChildren;
      const idx4 = nodeIdx << 2;
      if (count3 > 15) {
        const pEnd = idx4 + (count3 << 2);
        let i$1 = idx4 + 4;
        let j = pEnd;
        while (j - i$1 >= 4) {
          const m = i$1 + j >> 1 & -4;
          if (nodes8[m] < letterIdx) i$1 = m + 4;
          else j = m;
        }
        if (i$1 > pEnd || nodes8[i$1] !== letterIdx) return void 0;
        nodeIdx = nodes[i$1 >> 2] >>> NodeChildRefShift;
        continue;
      }
      let i = idx4 + count3 * 4;
      for (; i > idx4; i -= 4) if (nodes8[i] === letterIdx) break;
      if (i <= idx4) return void 0;
      nodeIdx = nodes[i >> 2] >>> NodeChildRefShift;
    }
    return nodeIdx;
  }
  /**
  * Find the node index for the given character.
  * @param nodeIdx - node index to start the search
  * @param char - character to look for
  * @returns
  */
  _lookupNode(nodeIdx, char) {
    const indexSeq = this.letterToNodeCharIndexSequence(char);
    const currNodeIdx = this.#lookupNode(nodeIdx, indexSeq);
    return currNodeIdx;
  }
  *words() {
    const NodeMaskNumChildren = TrieBlob2.NodeMaskNumChildren;
    const NodeMaskEOW = TrieBlob2.NodeMaskEOW;
    const NodeMaskChildCharIndex = TrieBlob2.NodeMaskChildCharIndex;
    const NodeChildRefShift = TrieBlob2.NodeChildRefShift;
    const nodes = this.nodes;
    const stack = [{
      nodeIdx: 0,
      pos: 0,
      word: "",
      acc: Utf8Accumulator.create()
    }];
    let depth = 0;
    while (depth >= 0) {
      const { nodeIdx, pos, word, acc } = stack[depth];
      const node = nodes[nodeIdx];
      if (!pos && node & NodeMaskEOW) yield word;
      const len = node & NodeMaskNumChildren;
      if (pos >= len) {
        --depth;
        continue;
      }
      const nextPos = ++stack[depth].pos;
      const entry = nodes[nodeIdx + nextPos];
      const nAcc = acc.clone();
      const codePoint = nAcc.decode(entry & NodeMaskChildCharIndex);
      const letter = codePoint && String.fromCodePoint(codePoint) || "";
      ++depth;
      stack[depth] = {
        nodeIdx: entry >>> NodeChildRefShift,
        pos: 0,
        word: word + letter,
        acc: nAcc
      };
    }
  }
  get size() {
    if (this.#size) return this.#size;
    const NodeMaskNumChildren = TrieBlob2.NodeMaskNumChildren;
    const nodes = this.nodes;
    let p = 0;
    let count3 = 0;
    while (p < nodes.length) {
      ++count3;
      p += (nodes[p] & NodeMaskNumChildren) + 1;
    }
    this.#size = count3;
    return count3;
  }
  toJSON() {
    return {
      options: this.info,
      nodes: nodesToJson(this.nodes),
      charIndex: this.charIndex
    };
  }
  encodeBin() {
    const charIndex = Buffer.from(this.charIndex.charIndex.join("\n"));
    const charIndexLen = charIndex.byteLength + 3 & -4;
    const nodeOffset = HEADER_SIZE + charIndexLen;
    const size = nodeOffset + this.nodes.length * 4;
    const useLittle = isLittleEndian();
    const buffer$1 = Buffer.alloc(size);
    const header = new DataView(buffer$1.buffer);
    const nodeData = new Uint8Array(this.nodes.buffer);
    buffer$1.write(headerSig, HEADER.sig, "utf8");
    buffer$1.write(version, HEADER.version, "utf8");
    header.setUint32(HEADER.endian, endianSig, useLittle);
    header.setUint32(HEADER.nodes, nodeOffset, useLittle);
    header.setUint32(HEADER.nodesLen, this.nodes.length, useLittle);
    header.setUint32(HEADER.charIndex, HEADER_SIZE, useLittle);
    header.setUint32(HEADER.charIndexLen, charIndex.length, useLittle);
    buffer$1.set(charIndex, HEADER_SIZE);
    buffer$1.set(nodeData, nodeOffset);
    return buffer$1;
  }
  static decodeBin(blob) {
    if (!checkSig(blob)) throw new ErrorDecodeTrieBlob("Invalid TrieBlob Header");
    const header = new DataView(blob.buffer);
    const useLittle = isLittleEndian();
    if (header.getUint32(HEADER.endian, useLittle) !== endianSig) throw new ErrorDecodeTrieBlob("Invalid TrieBlob Header");
    const offsetNodes = header.getUint32(HEADER.nodes, useLittle);
    const lenNodes = header.getUint32(HEADER.nodesLen, useLittle);
    const offsetCharIndex = header.getUint32(HEADER.charIndex, useLittle);
    const lenCharIndex = header.getUint32(HEADER.charIndexLen, useLittle);
    const charIndex = Buffer.from(blob.subarray(offsetCharIndex, offsetCharIndex + lenCharIndex)).toString("utf8").split("\n");
    const nodes = new Uint32Array(blob.buffer, offsetNodes, lenNodes);
    const trieBlob = new TrieBlob2(nodes, new CharIndex(charIndex), defaultTrieInfo);
    return trieBlob;
  }
  static NodeMaskEOW = 256;
  static NodeMaskNumChildren = (1 << NodeHeaderNumChildrenBits) - 1 & 65535;
  static NodeMaskNumChildrenShift = NodeHeaderNumChildrenShift;
  static NodeChildRefShift = 8;
  /**
  * Only 8 bits are reserved for the character index.
  * The max index is {@link TrieBlob.SpecialCharIndexMask} - 1.
  * Node chaining is used to reference higher character indexes.
  * - @see {@link TrieBlob.SpecialCharIndexMask}
  * - @see {@link TrieBlob.MaxCharIndex}
  */
  static NodeMaskChildCharIndex = 255;
  static nodesView(trie) {
    return new Uint32Array(trie.nodes);
  }
};
function isLittleEndian() {
  const buf = new Uint8Array([
    1,
    2,
    3,
    4
  ]);
  const view = new DataView(buf.buffer);
  return view.getUint32(0, true) === 67305985;
}
function checkSig(blob) {
  if (blob.length < HEADER_SIZE) return false;
  const buf = Buffer.from(blob, 0, 8);
  if (buf.toString("utf8", 0, 8) !== headerSig) return false;
  return true;
}
var ErrorDecodeTrieBlob = class extends Error {
  constructor(message) {
    super(message);
  }
};
function nodesToJson(nodes) {
  function nodeElement(offset$1) {
    const node = nodes[offset$1];
    const numChildren = node & TrieBlob.NodeMaskNumChildren;
    const eow = !!(node & TrieBlob.NodeMaskEOW);
    const children = [];
    for (let i = 1; i <= numChildren; ++i) children.push({
      c: ("00" + (nodes[offset$1 + i] & TrieBlob.NodeMaskChildCharIndex).toString(16)).slice(-2),
      o: nodes[offset$1 + i] >>> TrieBlob.NodeChildRefShift
    });
    return {
      id: offset$1,
      eow,
      n: offset$1 + numChildren + 1,
      c: children
    };
  }
  const elements = [];
  let offset = 0;
  while (offset < nodes.length) {
    const e = nodeElement(offset);
    elements.push(e);
    offset = e.n;
  }
  return elements;
}
function trieBlobSort(data) {
  const MaskNumChildren = TrieBlob.NodeMaskNumChildren;
  const MaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
  const limit = data.length;
  let idx$1 = 0;
  let node = data[0];
  let nc = node & MaskNumChildren;
  for (; idx$1 < limit; idx$1 += nc + 1, node = data[idx$1], nc = node & MaskNumChildren) {
    if (!nc) continue;
    const start = idx$1 + 1;
    const end = start + nc;
    let last = 0;
    let i = start;
    for (; i < end; ++i) {
      const cIdx = data[i] & MaskChildCharIndex;
      if (last >= cIdx) break;
      last = cIdx;
    }
    if (i === end) continue;
    const sorted = data.slice(start, end).sort((a, b) => (a & MaskChildCharIndex) - (b & MaskChildCharIndex));
    sorted.forEach((v, i$1) => data[start + i$1] = v);
  }
}
var FastTrieBlob = class FastTrieBlob2 {
  _readonly = false;
  #forbidIdx;
  #compoundIdx;
  #nonStrictIdx;
  _iTrieRoot;
  wordToCharacters;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(nodes, _charIndex, bitMasksInfo, info5) {
    this.nodes = nodes;
    this._charIndex = _charIndex;
    this.bitMasksInfo = bitMasksInfo;
    this.info = info5;
    this.wordToCharacters = (word) => [...word];
    this.#forbidIdx = this.#searchNodeForChar(0, this.info.forbiddenWordPrefix) || 0;
    this.#compoundIdx = this.#searchNodeForChar(0, this.info.compoundCharacter) || 0;
    this.#nonStrictIdx = this.#searchNodeForChar(0, this.info.stripCaseAndAccentsPrefix) || 0;
    this.hasForbiddenWords = !!this.#forbidIdx;
    this.hasCompoundWords = !!this.#compoundIdx;
    this.hasNonStrictWords = !!this.#nonStrictIdx;
  }
  wordToUtf8Seq(word) {
    return this._charIndex.wordToUtf8Seq(word);
  }
  letterToUtf8Seq(letter) {
    return this._charIndex.getCharUtf8Seq(letter);
  }
  has(word) {
    return this.#has(0, word);
  }
  hasCaseInsensitive(word) {
    if (!this.#nonStrictIdx) return false;
    return this.#has(this.#nonStrictIdx, word);
  }
  #has(nodeIdx, word) {
    return this.#hasSorted(nodeIdx, word);
  }
  #hasSorted(nodeIdx, word) {
    const charIndexes = this.wordToUtf8Seq(word);
    const found = this.#lookupNode(nodeIdx, charIndexes);
    if (found === void 0) return false;
    const node = this.nodes[found];
    return !!(node[0] & this.bitMasksInfo.NodeMaskEOW);
  }
  /**
  * Find the node index for the given Utf8 character sequence.
  * @param nodeIdx - node index to start the search
  * @param seq - the byte sequence of the character to look for
  * @returns
  */
  #lookupNode(nodeIdx, seq) {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const nodes = this.nodes;
    const len = seq.length;
    let node = nodes[nodeIdx];
    for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = seq[p];
      const count3 = node.length;
      if (count3 < 2) return void 0;
      let i = 1;
      let j = count3 - 1;
      let c = -1;
      while (i < j) {
        const m = i + j >> 1;
        c = node[m] & NodeMaskChildCharIndex;
        if (c < letterIdx) i = m + 1;
        else j = m;
      }
      if (i >= count3 || (node[i] & NodeMaskChildCharIndex) !== letterIdx) return void 0;
      nodeIdx = node[i] >>> NodeChildRefShift;
      if (!nodeIdx) return void 0;
    }
    return nodeIdx;
  }
  *words() {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const nodes = this.nodes;
    const accumulator = Utf8Accumulator.create();
    const stack = [{
      nodeIdx: 0,
      pos: 0,
      word: "",
      accumulator
    }];
    let depth = 0;
    while (depth >= 0) {
      const { nodeIdx, pos, word, accumulator: accumulator$1 } = stack[depth];
      const node = nodes[nodeIdx];
      if (!pos && node[0] & NodeMaskEOW) yield word;
      if (pos >= node.length - 1) {
        --depth;
        continue;
      }
      const nextPos = ++stack[depth].pos;
      const entry = node[nextPos];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc = accumulator$1.clone();
      const codePoint = acc.decode(charIdx);
      const letter = codePoint && String.fromCodePoint(codePoint) || "";
      ++depth;
      stack[depth] = {
        nodeIdx: entry >>> NodeChildRefShift,
        pos: 0,
        word: word + letter,
        accumulator: acc
      };
    }
  }
  toTrieBlob() {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const nodes = this.nodes;
    function calcNodeToIndex(nodes$1) {
      let offset$1 = 0;
      const idx$1 = Array(nodes$1.length + 1);
      for (let i = 0; i < nodes$1.length; ++i) {
        idx$1[i] = offset$1;
        offset$1 += nodes$1[i].length;
      }
      idx$1[nodes$1.length] = offset$1;
      return idx$1;
    }
    const nodeToIndex = calcNodeToIndex(nodes);
    const nodeElementCount = nodeToIndex[nodeToIndex.length - 1];
    const binNodes = new Uint32Array(nodeElementCount);
    const lenShift = TrieBlob.NodeMaskNumChildrenShift;
    const refShift = TrieBlob.NodeChildRefShift;
    let offset = 0;
    for (let i = 0; i < nodes.length; ++i) {
      const node = nodes[i];
      binNodes[offset++] = node.length - 1 << lenShift | node[0];
      for (let j = 1; j < node.length; ++j) {
        const v = node[j];
        const nodeRef = v >>> NodeChildRefShift;
        const charIndex = v & NodeMaskChildCharIndex;
        binNodes[offset++] = nodeToIndex[nodeRef] << refShift | charIndex;
      }
    }
    return new TrieBlob(binNodes, this._charIndex, this.info);
  }
  isReadonly() {
    return this._readonly;
  }
  freeze() {
    this._readonly = true;
    return this;
  }
  toJSON() {
    return {
      info: this.info,
      nodes: nodesToJSON(this.nodes)
    };
  }
  static create(data) {
    return new FastTrieBlob2(data.nodes, data.charIndex, extractInfo(data), data.info);
  }
  static toITrieNodeRoot(trie) {
    return new FastTrieBlobIRoot(new FastTrieBlobInternalsAndMethods(trie.nodes, trie._charIndex, trie.bitMasksInfo, trie.info, {
      nodeFindNode: (idx$1, word) => trie.#lookupNode(idx$1, trie.wordToUtf8Seq(word)),
      nodeFindExact: (idx$1, word) => trie.#has(idx$1, word),
      nodeGetChild: (idx$1, letter) => trie.#searchNodeForChar(idx$1, letter),
      isForbidden: (word) => trie.isForbiddenWord(word),
      findExact: (word) => trie.has(word),
      hasForbiddenWords: trie.hasForbiddenWords,
      hasCompoundWords: trie.hasCompoundWords,
      hasNonStrictWords: trie.hasNonStrictWords
    }), 0);
  }
  static NodeMaskEOW = TrieBlob.NodeMaskEOW;
  static NodeChildRefShift = TrieBlob.NodeChildRefShift;
  static NodeMaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
  static DefaultBitMaskInfo = {
    NodeMaskEOW: FastTrieBlob2.NodeMaskEOW,
    NodeMaskChildCharIndex: FastTrieBlob2.NodeMaskChildCharIndex,
    NodeChildRefShift: FastTrieBlob2.NodeChildRefShift
  };
  get iTrieRoot() {
    return this._iTrieRoot ??= FastTrieBlob2.toITrieNodeRoot(this);
  }
  getRoot() {
    return this.iTrieRoot;
  }
  getNode(prefix) {
    return findNode$1(this.getRoot(), prefix);
  }
  isForbiddenWord(word) {
    return !!this.#forbidIdx && this.#has(this.#forbidIdx, word);
  }
  nodeInfo(nodeIndex, accumulator) {
    const acc = accumulator ?? Utf8Accumulator.create();
    const n = this.nodes[nodeIndex];
    const eow = !!(n[0] & this.bitMasksInfo.NodeMaskEOW);
    const children = [];
    children.length = n.length - 1;
    for (let p = 1; p < n.length; ++p) {
      const v = n[p];
      const cIdx = v & this.bitMasksInfo.NodeMaskChildCharIndex;
      const a = acc.clone();
      const codePoint = a.decode(cIdx);
      const c = codePoint !== void 0 ? String.fromCodePoint(codePoint) : "\u220E";
      const i = v >>> this.bitMasksInfo.NodeChildRefShift;
      children[p] = {
        c,
        i,
        cIdx
      };
    }
    return {
      eow,
      children
    };
  }
  /** number of nodes */
  get size() {
    return this.nodes.length;
  }
  /** Search from nodeIdx for the node index representing the character. */
  #searchNodeForChar(nodeIdx, char) {
    const charIndexes = this.letterToUtf8Seq(char);
    return this.#lookupNode(nodeIdx, charIndexes);
  }
  get charIndex() {
    return [...this._charIndex.charIndex];
  }
  static fromTrieBlob(trie) {
    const bitMasksInfo = {
      NodeMaskEOW: TrieBlob.NodeMaskEOW,
      NodeMaskChildCharIndex: TrieBlob.NodeMaskChildCharIndex,
      NodeChildRefShift: TrieBlob.NodeChildRefShift
    };
    const trieNodesBin = TrieBlob.nodesView(trie);
    const nodeOffsets = [];
    for (let offset = 0; offset < trieNodesBin.length; offset += (trieNodesBin[offset] & TrieBlob.NodeMaskNumChildren) + 1) nodeOffsets.push(offset);
    const offsetToNodeIndex = new Map(nodeOffsets.map((offset, i) => [offset, i]));
    const nodes = Array.from({ length: nodeOffsets.length });
    for (let i = 0; i < nodes.length; ++i) {
      const offset = nodeOffsets[i];
      const n = trieNodesBin[offset];
      const eow = n & TrieBlob.NodeMaskEOW;
      const count3 = n & TrieBlob.NodeMaskNumChildren;
      const node = new Uint32Array(count3 + 1);
      node[0] = eow;
      nodes[i] = node;
      for (let j = 1; j <= count3; ++j) {
        const n$1 = trieNodesBin[offset + j];
        const charIndex = n$1 & TrieBlob.NodeMaskChildCharIndex;
        const nodeIndex = n$1 >>> TrieBlob.NodeChildRefShift;
        const idx$1 = offsetToNodeIndex.get(nodeIndex);
        if (idx$1 === void 0) throw new Error(`Invalid node index ${nodeIndex}`);
        node[j] = idx$1 << TrieBlob.NodeChildRefShift | charIndex;
      }
    }
    return new FastTrieBlob2(sortNodes(nodes, TrieBlob.NodeMaskChildCharIndex), trie.charIndex, bitMasksInfo, trie.info);
  }
  static isFastTrieBlob(obj) {
    return obj instanceof FastTrieBlob2;
  }
};
function nodesToJSON(nodes) {
  const mapNodeToAcc = /* @__PURE__ */ new Map();
  function mapNode(node, i) {
    if (node.length === 1) return {
      i,
      w: !!(node[0] & TrieBlob.NodeMaskEOW) && 1 || 0
    };
    const acc = mapNodeToAcc.get(node) || Utf8Accumulator.create();
    function mapChild(n) {
      const index = n >>> TrieBlob.NodeChildRefShift;
      const seq = n & TrieBlob.NodeMaskChildCharIndex;
      const cAcc = acc.clone();
      const codePoint = cAcc.decode(seq);
      if (codePoint === void 0) mapNodeToAcc.set(nodes[index], cAcc);
      return {
        i: index,
        c: codePoint && String.fromCodePoint(codePoint) || void 0,
        s: seq.toString(16).padStart(2, "0")
      };
    }
    return {
      i,
      w: !!(node[0] & TrieBlob.NodeMaskEOW) && 1 || 0,
      c: [...node.slice(1)].map(mapChild)
    };
  }
  return nodes.map((n, i) => mapNode(n, i));
}
function resolveMap(map3, key, resolve5) {
  const r = map3.get(key);
  if (r !== void 0) return r;
  const v = resolve5(key);
  map3.set(key, v);
  return v;
}
var FastTrieBlobBuilder = class FastTrieBlobBuilder2 {
  charIndex = new CharIndexBuilder();
  nodes;
  _readonly = false;
  IdxEOW;
  _cursor;
  _options;
  wordToCharacters = (word) => [...word];
  bitMasksInfo;
  constructor(options, bitMasksInfo = FastTrieBlobBuilder2.DefaultBitMaskInfo) {
    this._options = mergeOptionalWithDefaults(options);
    this.bitMasksInfo = bitMasksInfo;
    this.nodes = [[0], Object.freeze([FastTrieBlobBuilder2.NodeMaskEOW])];
    this.IdxEOW = 1;
  }
  setOptions(options) {
    this._options = mergeOptionalWithDefaults(this.options, options);
    return this.options;
  }
  get options() {
    return this._options;
  }
  wordToUtf8Seq(word) {
    return this.charIndex.wordToUtf8Seq(word);
  }
  letterToUtf8Seq(letter) {
    return this.charIndex.charToUtf8Seq(letter);
  }
  insert(word) {
    this.#assertNotReadonly();
    if (typeof word === "string") return this._insert(word);
    const words = word;
    for (const w of words) this._insert(w);
    return this;
  }
  getCursor() {
    this.#assertNotReadonly();
    this._cursor ??= this.createCursor();
    return this._cursor;
  }
  createCursor() {
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const LetterMask = this.bitMasksInfo.NodeMaskChildCharIndex;
    const refNodes = [0, 1];
    function childPos(node, letterIdx) {
      for (let i = 1; i < node.length; ++i) if ((node[i] & LetterMask) === letterIdx) return i;
      return 0;
    }
    (0, import_node_assert.default)(this.nodes.length === 2);
    const eow = 1;
    const eowShifted = eow << NodeChildRefShift;
    const nodes = this.nodes;
    const stack = [{
      nodeIdx: 0,
      pos: 0,
      pDepth: -1
    }];
    let nodeIdx = 0;
    let depth = 0;
    const insertChar = (char) => {
      if (!nodes[nodeIdx]) refNodes.push(nodeIdx);
      const pDepth = depth;
      const utf8Seq = this.letterToUtf8Seq(char);
      for (let i = 0; i < utf8Seq.length; ++i) insertCharIndexes(utf8Seq[i], pDepth);
    };
    const insertCharIndexes = (seq, pDepth) => {
      if (nodes[nodeIdx] && Object.isFrozen(nodes[nodeIdx])) {
        nodeIdx = nodes.push([...nodes[nodeIdx]]) - 1;
        const { pos: pos$1, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos$1] = pNode[pos$1] & LetterMask | nodeIdx << NodeChildRefShift;
      }
      const node = nodes[nodeIdx] || [0];
      nodes[nodeIdx] = node;
      const hasIdx = childPos(node, seq);
      const childIdx = hasIdx ? node[hasIdx] >>> NodeChildRefShift : nodes.length;
      const pos = hasIdx || node.push(childIdx << NodeChildRefShift | seq) - 1;
      ++depth;
      const s = stack[depth];
      if (s) {
        s.nodeIdx = nodeIdx;
        s.pos = pos;
        s.pDepth = pDepth;
      } else stack[depth] = {
        nodeIdx,
        pos,
        pDepth
      };
      nodeIdx = childIdx;
    };
    const markEOW = () => {
      if (nodeIdx === eow) return;
      const node = nodes[nodeIdx];
      if (!node) {
        const { pos, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos] = pNode[pos] & LetterMask | eowShifted;
      } else {
        nodes[nodeIdx] = node;
        node[0] |= NodeMaskEOW;
      }
      nodeIdx = eow;
    };
    const reference = (refId) => {
      const refNodeIdx = refNodes[refId];
      (0, import_node_assert.default)(refNodeIdx !== void 0);
      (0, import_node_assert.default)(nodes[nodeIdx] === void 0);
      (0, import_node_assert.default)(nodes[refNodeIdx]);
      Object.freeze(nodes[refNodeIdx]);
      const s = stack[depth];
      nodeIdx = s.nodeIdx;
      const pos = s.pos;
      const node = nodes[nodeIdx];
      node[pos] = refNodeIdx << NodeChildRefShift | node[pos] & LetterMask;
    };
    const backStep = (num) => {
      if (!num) return;
      (0, import_node_assert.default)(num <= depth && num > 0);
      for (let n = num; n > 0; --n) depth = stack[depth].pDepth;
      nodeIdx = stack[depth + 1].nodeIdx;
    };
    const c = {
      insertChar,
      markEOW,
      reference,
      backStep
    };
    return c;
  }
  _insert(word) {
    word = word.trim();
    if (!word) return this;
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const IdxEOW = this.IdxEOW;
    const nodes = this.nodes;
    const utf8Seq = this.wordToUtf8Seq(word);
    const len = utf8Seq.length;
    let nodeIdx = 0;
    for (let p = 0; p < len; ++p) {
      const seq = utf8Seq[p];
      const node = nodes[nodeIdx];
      const count3 = node.length;
      let i = count3 - 1;
      for (; i > 0; --i) if ((node[i] & NodeMaskChildCharIndex) === seq) break;
      if (i > 0) {
        nodeIdx = node[i] >>> NodeChildRefShift;
        if (nodeIdx === 1 && p < len - 1) {
          nodeIdx = this.nodes.push([NodeMaskEOW]) - 1;
          node[i] = nodeIdx << NodeChildRefShift | seq;
        }
        continue;
      }
      nodeIdx = p < len - 1 ? this.nodes.push([0]) - 1 : IdxEOW;
      node.push(nodeIdx << NodeChildRefShift | seq);
    }
    if (nodeIdx > 1) {
      const node = nodes[nodeIdx];
      node[0] |= NodeMaskEOW;
    }
    return this;
  }
  has(word) {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const nodes = this.nodes;
    const charIndexes = this.wordToUtf8Seq(word);
    const len = charIndexes.length;
    let nodeIdx = 0;
    let node = nodes[nodeIdx];
    for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = charIndexes[p];
      const count3 = node.length;
      let i = count3 - 1;
      for (; i > 0; --i) if ((node[i] & NodeMaskChildCharIndex) === letterIdx) break;
      if (i < 1) return false;
      nodeIdx = node[i] >>> NodeChildRefShift;
    }
    return !!(node[0] & NodeMaskEOW);
  }
  isReadonly() {
    return this._readonly;
  }
  freeze() {
    this._readonly = true;
    return this;
  }
  build() {
    this._cursor = void 0;
    this._readonly = true;
    this.freeze();
    return FastTrieBlob.create(new FastTrieBlobInternals(sortNodes(this.nodes.map((n) => Uint32Array.from(n)), this.bitMasksInfo.NodeMaskChildCharIndex), this.charIndex.build(), this.bitMasksInfo, this.options));
  }
  toJSON() {
    return {
      options: this.options,
      nodes: nodesToJSON(this.nodes.map((n) => Uint32Array.from(n)))
    };
  }
  #assertNotReadonly() {
    (0, import_node_assert.default)(!this.isReadonly(), "FastTrieBlobBuilder is readonly");
  }
  static fromWordList(words, options) {
    const ft = new FastTrieBlobBuilder2(options);
    return ft.insert(words).build();
  }
  static fromTrieRoot(root) {
    const bitMasksInfo = FastTrieBlobBuilder2.DefaultBitMaskInfo;
    const NodeChildRefShift = bitMasksInfo.NodeChildRefShift;
    const NodeCharIndexMask = bitMasksInfo.NodeMaskChildCharIndex;
    const NodeMaskEOW = bitMasksInfo.NodeMaskEOW;
    const tf2 = new FastTrieBlobBuilder2(void 0, bitMasksInfo);
    const IdxEOW = tf2.IdxEOW;
    const known = /* @__PURE__ */ new Map([[root, 0]]);
    function resolveNode(n) {
      if (n.f && !n.c) return IdxEOW;
      const node = [n.f ? NodeMaskEOW : 0];
      return tf2.nodes.push(node) - 1;
    }
    function walk$3(n) {
      const found = known.get(n);
      if (found) return found;
      const nodeIdx = resolveMap(known, n, resolveNode);
      const node = tf2.nodes[nodeIdx];
      if (!n.c) return nodeIdx;
      const children = Object.entries(n.c);
      for (let p = 0; p < children.length; ++p) {
        const [char, childNode] = children[p];
        addCharToNode(node, char, childNode);
      }
      return nodeIdx;
    }
    function resolveChild(node, charIndex) {
      let i = 1;
      for (i = 1; i < node.length && (node[i] & NodeCharIndexMask) !== charIndex; ++i) ;
      return i;
    }
    function addCharToNode(node, char, n) {
      const indexSeq = tf2.letterToUtf8Seq(char);
      assertValidUtf16Character(char);
      for (const idx$1 of indexSeq.slice(0, -1)) {
        const pos = resolveChild(node, idx$1);
        if (pos < node.length) node = tf2.nodes[node[pos] >>> NodeChildRefShift];
        else {
          const next = [0];
          const nodeIdx = tf2.nodes.push(next) - 1;
          node[pos] = nodeIdx << NodeChildRefShift | idx$1;
          node = next;
        }
      }
      const letterIdx = indexSeq[indexSeq.length - 1];
      const i = node.push(letterIdx) - 1;
      node[i] = walk$3(n) << NodeChildRefShift | letterIdx;
    }
    walk$3(root);
    return tf2.build();
  }
  static NodeMaskEOW = TrieBlob.NodeMaskEOW;
  static NodeChildRefShift = TrieBlob.NodeChildRefShift;
  static NodeMaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
  static DefaultBitMaskInfo = {
    NodeMaskEOW: FastTrieBlobBuilder2.NodeMaskEOW,
    NodeMaskChildCharIndex: FastTrieBlobBuilder2.NodeMaskChildCharIndex,
    NodeChildRefShift: FastTrieBlobBuilder2.NodeChildRefShift
  };
};
function clean(t) {
  const copy = { ...t };
  for (const key of Object.keys(copy)) if (copy[key] === void 0) delete copy[key];
  return copy;
}
var defaultLegacyMinCompoundLength$2 = 3;
var ITrieImpl = class ITrieImpl2 {
  _info;
  root;
  count;
  weightMap;
  #optionsCompound = this.createFindOptions({ compoundMode: "compound" });
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(data, numNodes) {
    this.data = data;
    this.numNodes = numNodes;
    this.root = data.getRoot();
    this._info = mergeOptionalWithDefaults(data.info);
    this.hasForbiddenWords = data.hasForbiddenWords;
    this.hasCompoundWords = data.hasCompoundWords;
    this.hasNonStrictWords = data.hasNonStrictWords;
  }
  /**
  * Number of words in the Trie, the first call to this method might be expensive.
  * Use `size` to get the number of nodes.
  */
  numWords() {
    this.count ??= countWords$1(this.root);
    return this.count;
  }
  isNumWordsKnown() {
    return this.count !== void 0;
  }
  get size() {
    return this.data.size;
  }
  get info() {
    return this._info;
  }
  get isCaseAware() {
    return this.info.isCaseAware ?? true;
  }
  /**
  * @param text - text to find in the Trie
  */
  find(text) {
    return findWordNode$1(this.data.getRoot(), text, this.#optionsCompound).node;
  }
  has(word, minLegacyCompoundLength) {
    if (this.hasWord(word, false)) return true;
    if (minLegacyCompoundLength) {
      const f = this.findWord(word, { useLegacyWordCompounds: minLegacyCompoundLength });
      return !!f.found;
    }
    return false;
  }
  /**
  * Determine if a word is in the dictionary.
  * @param word - the exact word to search for - must be normalized.
  * @param caseSensitive - false means also searching a dictionary where the words were normalized to lower case and accents removed.
  * @returns true if the word was found and is not forbidden.
  */
  hasWord(word, caseSensitive) {
    const f = this.findWord(word, {
      caseSensitive,
      checkForbidden: false
    });
    return !!f.found;
  }
  findWord(word, options) {
    if (options?.useLegacyWordCompounds) {
      const len = options.useLegacyWordCompounds !== true ? options.useLegacyWordCompounds : defaultLegacyMinCompoundLength$2;
      const findOptions = this.createFindOptions({
        legacyMinCompoundLength: len,
        matchCase: options.caseSensitive || false
      });
      return findLegacyCompound$1(this.root, word, findOptions);
    }
    return findWord$1(this.root, word, {
      matchCase: options?.caseSensitive,
      checkForbidden: options?.checkForbidden
    });
  }
  /**
  * Determine if a word is in the forbidden word list.
  * @param word the word to lookup.
  */
  isForbiddenWord(word) {
    return this.hasForbiddenWords && isForbiddenWord$1(this.root, word, this.info.forbiddenWordPrefix);
  }
  /**
  * Provides an ordered sequence of words with the prefix of text.
  */
  completeWord(text) {
    const n = this.find(text);
    const compoundChar = this.info.compoundCharacter;
    const subNodes = pipeSync(n ? iteratorTrieWords$1(n) : [], opFilterSync((w) => w[w.length - 1] !== compoundChar), opMapSync((suffix) => text + suffix));
    return pipeSync(n && n.eow ? [text] : [], opAppendSync(subNodes));
  }
  /**
  * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
  * @param text - the text to search for
  * @param maxNumSuggestions - the maximum number of suggestions to return.
  * @param compoundMethod - Use to control splitting words.
  * @param numChanges - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
  *                      the lower the value, the faster results are returned. Values less than 4 are best.
  */
  suggest(text, options) {
    return this.suggestWithCost(text, options).map((a) => a.word);
  }
  /**
  * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
  * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
  */
  suggestWithCost(text, options) {
    const sep3 = options.compoundSeparator;
    const weightMap = options.weightMap || this.weightMap;
    const adjWord = sep3 ? replaceAllFactory(sep3, "") : (a) => a;
    const optFilter = options.filter;
    const filter3 = optFilter ? (word, cost) => {
      const w = adjWord(word);
      return !this.isForbiddenWord(w) && optFilter(w, cost);
    } : (word) => !this.isForbiddenWord(adjWord(word));
    const opts = {
      ...options,
      filter: filter3,
      weightMap
    };
    return suggestAStar(this.data, text, opts);
  }
  /**
  * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
  * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
  * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
  */
  genSuggestions(collector, compoundMethod) {
    const filter3 = (word) => !this.isForbiddenWord(word);
    const options = createSuggestionOptions(clean({
      compoundMethod,
      ...collector.genSuggestionOptions
    }));
    const suggestions2 = getSuggestionsAStar(this.data, collector.word, options);
    collector.collect(suggestions2, void 0, filter3);
  }
  /**
  * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
  */
  words() {
    return iteratorTrieWords$1(this.root);
  }
  /**
  * Allows iteration over the entire tree.
  * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
  */
  iterate() {
    return walker$1(this.root);
  }
  static create(words, info5) {
    const builder = new FastTrieBlobBuilder(info5);
    builder.insert(words);
    const root = builder.build();
    return new ITrieImpl2(root, void 0);
  }
  createFindOptions(options) {
    const findOptions = createFindOptions$1(options);
    return findOptions;
  }
};
function buildITrieFromWords(words, info5 = {}) {
  const builder = new FastTrieBlobBuilder(info5);
  builder.insert(words);
  const ft = builder.build();
  return new ITrieImpl(ft.size > 1e3 ? ft.toTrieBlob() : ft);
}
var FLAG_WORD = 1;
function insert(word, root = {}) {
  const text = [...word];
  let node = root;
  for (let i = 0; i < text.length; ++i) {
    const head = text[i];
    const c = node.c || /* @__PURE__ */ Object.create(null);
    node.c = c;
    node = c[head] || {};
    c[head] = node;
  }
  node.f = (node.f || 0) | FLAG_WORD;
  return root;
}
function iteratorTrieWords(node) {
  return walkerWords(node);
}
function createTrieRoot(options) {
  const fullOptions = mergeOptionalWithDefaults(options);
  return {
    ...fullOptions,
    c: /* @__PURE__ */ Object.create(null)
  };
}
function createTrieRootFromList(words, options) {
  const root = createTrieRoot(options);
  for (const word of words) if (word.length) insert(word, root);
  return root;
}
function countNodes(root) {
  const seen = /* @__PURE__ */ new Set();
  function walk$3(n) {
    if (seen.has(n)) return;
    seen.add(n);
    if (n.c) Object.values(n.c).forEach((n$1) => walk$3(n$1));
  }
  walk$3(root);
  return seen.size;
}
function checkCircular(root) {
  const seen = /* @__PURE__ */ new Set();
  const inStack = /* @__PURE__ */ new Set();
  function walk$3(n) {
    if (seen.has(n)) return {
      isCircular: false,
      allSeen: true
    };
    if (inStack.has(n)) {
      const stack = [...inStack, n];
      const word = trieStackToWord(stack);
      const pos = stack.indexOf(n);
      return {
        isCircular: true,
        allSeen: false,
        ref: {
          stack,
          word,
          pos
        }
      };
    }
    inStack.add(n);
    let r = {
      isCircular: false,
      allSeen: true
    };
    if (n.c) r = Object.values(n.c).reduce((acc, n$1) => {
      if (acc.isCircular) return acc;
      const r$1 = walk$3(n$1);
      r$1.allSeen = r$1.allSeen && acc.allSeen;
      return r$1;
    }, r);
    if (r.allSeen) seen.add(n);
    inStack.delete(n);
    return r;
  }
  return walk$3(root);
}
function reverseMapTrieNode(node) {
  return node.c && new Map(Object.entries(node.c).map(([c, n]) => [n, c]));
}
function trieStackToWord(stack) {
  let word = "";
  let lastMap = reverseMapTrieNode(stack[0]);
  for (let i = 1; i < stack.length; ++i) {
    const n = stack[i];
    const char = lastMap?.get(n);
    if (char) word += char;
    lastMap = reverseMapTrieNode(n);
  }
  return word;
}
function isCircular(root) {
  return checkCircular(root).isCircular;
}
function trieNodeToRoot(node, options) {
  const newOptions = mergeOptionalWithDefaults(options);
  return {
    ...newOptions,
    c: node.c || /* @__PURE__ */ Object.create(null)
  };
}
function consolidate(root) {
  let count3 = 0;
  const signatures = /* @__PURE__ */ new Map();
  const cached = /* @__PURE__ */ new Map();
  const knownMap = /* @__PURE__ */ new Map();
  if (isCircular(root)) throw new Error("Trie is circular.");
  function signature$1(n) {
    const isWord = n.f ? "*" : "";
    const ref = n.c ? JSON.stringify(Object.entries(n.c).map(([k, n$1]) => [k, cached.get(n$1)])) : "";
    return isWord + ref;
  }
  function findEow(n) {
    if (n.f && !n.c) return n;
    let r;
    if (n.c) for (const c of Object.values(n.c)) {
      r = findEow(c);
      if (r) break;
    }
    return r;
  }
  function compareMaps(a, b) {
    for (const e of a) if (b[e[0]] !== e[1]) return false;
    return a.length === b.size;
  }
  function deepCopy(n) {
    const k = knownMap.get(n);
    if (k) return k;
    const orig = n;
    if (n.c) {
      const children = Object.entries(n.c).map((c) => [c[0], deepCopy(c[1])]);
      if (!compareMaps(children, n.c)) n = {
        f: n.f,
        c: Object.fromEntries(children)
      };
    }
    const sig = signature$1(n);
    const ref = signatures.get(sig);
    if (ref) {
      knownMap.set(orig, ref);
      return ref;
    }
    Object.freeze(n);
    signatures.set(sig, n);
    cached.set(n, count3++);
    knownMap.set(orig, n);
    return n;
  }
  function process6(n) {
    if (cached.has(n)) return n;
    if (Object.isFrozen(n)) return knownMap.get(n) || deepCopy(n);
    if (n.c) {
      const children = Object.entries(n.c).sort((a, b) => a[0] < b[0] ? -1 : 1).map(([k, n$1]) => [k, process6(n$1)]);
      n.c = Object.fromEntries(children);
    }
    const sig = signature$1(n);
    const ref = signatures.get(sig);
    if (ref) return ref;
    signatures.set(sig, n);
    cached.set(n, count3++);
    return n;
  }
  const eow = findEow(root) || {
    f: FLAG_WORD,
    c: void 0
  };
  signatures.set(signature$1(eow), eow);
  cached.set(eow, count3++);
  return trieNodeToRoot(process6(root), root);
}
var defaultLegacyMinCompoundLength$1 = 3;
var _defaultFindOptions = {
  matchCase: false,
  compoundMode: "compound",
  forbidPrefix: FORBID_PREFIX,
  compoundFix: COMPOUND_FIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  legacyMinCompoundLength: defaultLegacyMinCompoundLength$1
};
var arrayCompoundModes = [
  "none",
  "compound",
  "legacy"
];
var knownCompoundModes = new Map(arrayCompoundModes.map((a) => [a, a]));
function findWordExact(root, word) {
  return isEndOfWordNode(walk$1(root, word));
}
function isEndOfWordNode(n) {
  return n?.f === FLAG_WORD;
}
function walk$1(root, word) {
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = n.c?.[h];
  }
  return n;
}
var createFindOptions = memorizeLastCall(_createFindOptions);
function _createFindOptions(options) {
  return mergeDefaults(options, _defaultFindOptions);
}
var TrieNodeTrie = class TrieNodeTrie2 {
  _iTrieRoot;
  info;
  _size;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(root) {
    this.root = root;
    this.info = mergeOptionalWithDefaults(root);
    this.hasForbiddenWords = !!root.c[root.forbiddenWordPrefix];
    this.hasCompoundWords = !!root.c[root.compoundCharacter];
    this.hasNonStrictWords = !!root.c[root.stripCaseAndAccentsPrefix];
  }
  wordToCharacters = (word) => [...word];
  get iTrieRoot() {
    return this._iTrieRoot || (this._iTrieRoot = trieRootToITrieRoot(this.root));
  }
  getRoot() {
    return this.iTrieRoot;
  }
  getNode(prefix) {
    return findNode$1(this.getRoot(), prefix);
  }
  words() {
    return iteratorTrieWords(this.root);
  }
  has(word) {
    return findWordExact(this.root, word);
  }
  isForbiddenWord(word) {
    return findWordExact(this.root.c[this.root.forbiddenWordPrefix], word);
  }
  get size() {
    return this._size ??= countNodes(this.root);
  }
  static createFromWords(words, options) {
    const root = createTrieRootFromList(words, options);
    return new TrieNodeTrie2(root);
  }
  static createFromWordsAndConsolidate(words, options) {
    const root = createTrieRootFromList(words, options);
    return new TrieNodeTrie2(consolidate(root));
  }
};
var EOW$3 = "*";
var DATA$4 = EOW$3;
function* toIterableIterator$1(iter) {
  yield* iter;
}
function importTrie$5(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator$1(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg$2 = /^TrieXv1\nbase=(\d+)$/;
    if (!headerReg$2.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg$2, "$1"), 10);
  }
  function readHeader(iter$1) {
    const headerRows = [];
    while (true) {
      const next = iter$1.next();
      if (next.done) break;
      const line = next.value.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$4) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const regNotEscapedCommas = /(^|[^\\]),/g;
  const regUnescapeCommas = /__COMMA__/g;
  const regUnescape = /[\\](.)/g;
  const flagsWord = { f: FLAG_WORD };
  function splitLine$1(line) {
    const pattern = "$1__COMMA__";
    return line.replaceAll(regNotEscapedCommas, pattern).split(regUnescapeCommas).map((a) => a.replaceAll(regUnescape, "$1"));
  }
  function decodeLine$1(line, nodes) {
    const isWord = line[0] === EOW$3;
    line = isWord ? line.slice(1) : line;
    const flags = isWord ? flagsWord : {};
    const children = splitLine$1(line).filter((a) => !!a).map((a) => [a[0], Number.parseInt(a.slice(1) || "0", radix)]).map(([k, i]) => [k, nodes[i]]);
    const cNode = children.length ? { c: Object.fromEntries(children) } : {};
    return {
      ...cNode,
      ...flags
    };
  }
  readHeader(iter);
  const n = genSequence([DATA$4]).concat(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { lines, nodes } = acc;
    const root = decodeLine$1(line, nodes);
    nodes[lines] = root;
    return {
      lines: lines + 1,
      root,
      nodes
    };
  }, {
    lines: 0,
    nodes: [],
    root: {}
  });
  return trieNodeToRoot(n.root, { isCaseAware: false });
}
var EOW$2 = "*";
var DATA$3 = "__DATA__";
function* toIterableIterator2(iter) {
  yield* iter;
}
function importTrie$4(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator2(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg$2 = /^TrieXv2\nbase=(\d+)$/;
    if (!headerReg$2.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg$2, "$1"), 10);
  }
  function readHeader(iter$1) {
    const headerRows = [];
    while (true) {
      const next = iter$1.next();
      if (next.done) break;
      const line = next.value.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$3) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  function parseLine(line, base) {
    const isWord = line[1] === EOW$2;
    const refOffset = isWord ? 2 : 1;
    const refs = line.slice(refOffset).split(",").filter((a) => !!a).map((r) => Number.parseInt(r, base));
    return {
      letter: line[0],
      isWord,
      refs
    };
  }
  const flagsWord = { f: FLAG_WORD };
  function decodeLine$1(line, nodes) {
    const { letter, isWord, refs } = parseLine(line, radix);
    const flags = isWord ? flagsWord : {};
    const children = refs.map((r) => nodes[r]).sort((a, b) => a.s < b.s ? -1 : 1).map((n$1) => [n$1.s, n$1]);
    const cNode = children.length ? { c: Object.fromEntries(children) } : {};
    return {
      s: letter,
      ...cNode,
      ...flags
    };
  }
  readHeader(iter);
  const n = genSequence(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { nodes } = acc;
    const root = decodeLine$1(line, nodes);
    nodes.push(root);
    return {
      root,
      nodes
    };
  }, {
    nodes: [],
    root: {
      s: "",
      c: /* @__PURE__ */ Object.create(null)
    }
  });
  return trieNodeToRoot(n.root, { isCaseAware: false });
}
var EOW = "$";
var BACK = "<";
var EOL = "\n";
var LF = "\r";
var REF = "#";
var REF_REL = "@";
var EOR = ";";
var ESCAPE = "\\";
var REF_INDEX_BEGIN = "[";
var REF_INDEX_END = "]";
var INLINE_DATA_COMMENT_LINE = "/";
var specialCharacters$1 = stringToCharSet$2([
  EOW,
  BACK,
  EOL,
  REF,
  REF_REL,
  EOR,
  ESCAPE,
  LF,
  REF_INDEX_BEGIN,
  REF_INDEX_END,
  INLINE_DATA_COMMENT_LINE,
  ..."0123456789",
  ..."`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|"
].join(""));
var SPECIAL_CHARACTERS_MAP = [
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
];
var specialCharacterMap$2 = stringToCharMap(SPECIAL_CHARACTERS_MAP);
var characterMap$1 = stringToCharMap(SPECIAL_CHARACTERS_MAP.map((a) => [a[1], a[0]]));
var specialPrefix$1 = stringToCharSet$2("~!");
var DATA$2 = "__DATA__";
function importTrie$3(linesX) {
  linesX = typeof linesX === "string" ? linesX.split(/^/m) : linesX;
  let radix = 10;
  const comment = /^\s*#/;
  const iter = tapIterable(pipeSync(linesX, opConcatMapSync((a) => a.split(/^/m))));
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg$2 = /^TrieXv[34]\nbase=(\d+)$/;
    if (!headerReg$2.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg$2, "$1"), 10);
  }
  function readHeader(iter$1) {
    const headerRows = [];
    for (const value of iter$1) {
      const line = value.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$2) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  readHeader(iter);
  const root = parseStream$1(radix, iter);
  return root;
}
var numbersSet = stringToCharSet$2("0123456789");
function parseStream$1(radix, iter) {
  const eow = Object.freeze({ f: 1 });
  let refIndex = [];
  const root = trieNodeToRoot({}, {});
  function parseReference(acc, s) {
    const isIndexRef = s === REF_REL;
    let ref = "";
    function parser2(acc$1, s$1) {
      if (s$1 === EOR || radix === 10 && !(s$1 in numbersSet)) {
        const { root: root$1, nodes: nodes$1, stack } = acc$1;
        const r = Number.parseInt(ref, radix);
        const top = stack[stack.length - 1];
        const p = stack[stack.length - 2].node;
        const n = isIndexRef ? refIndex[r] : r;
        p.c && (p.c[top.s] = nodes$1[n]);
        const rr = {
          root: root$1,
          nodes: nodes$1,
          stack,
          parser: void 0
        };
        return s$1 === EOR ? rr : parserMain(rr, s$1);
      }
      ref = ref + s$1;
      return acc$1;
    }
    const { nodes } = acc;
    nodes.pop();
    return {
      ...acc,
      nodes,
      parser: parser2
    };
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser2 = function(acc$1, s) {
      if (prev) {
        s = characterMap$1[prev + s] || s;
        return parseCharacter({
          ...acc$1,
          parser: void 0
        }, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc$1;
      }
      return parseCharacter({
        ...acc$1,
        parser: void 0
      }, s);
    };
    return {
      ...acc,
      parser: parser2
    };
  }
  function parseComment(acc, s) {
    const endOfComment = s;
    let isEscaped = false;
    function parser2(acc$1, s$1) {
      if (isEscaped) {
        isEscaped = false;
        return acc$1;
      }
      if (s$1 === ESCAPE) {
        isEscaped = true;
        return acc$1;
      }
      if (s$1 === endOfComment) return {
        ...acc$1,
        parser: void 0
      };
      return acc$1;
    }
    return {
      ...acc,
      parser: parser2
    };
  }
  function parseCharacter(acc, s) {
    const parser2 = void 0;
    const { root: root$1, nodes, stack } = acc;
    const top = stack[stack.length - 1];
    const node = top.node;
    const c = node.c ?? /* @__PURE__ */ Object.create(null);
    const n = {
      f: void 0,
      c: void 0,
      n: nodes.length
    };
    c[s] = n;
    node.c = c;
    stack.push({
      node: n,
      s
    });
    nodes.push(n);
    return {
      root: root$1,
      nodes,
      stack,
      parser: parser2
    };
  }
  function parseEOW(acc, _) {
    const parser2 = parseBack;
    const { root: root$1, nodes, stack } = acc;
    const top = stack[stack.length - 1];
    const node = top.node;
    node.f = FLAG_WORD;
    if (!node.c) {
      top.node = eow;
      const p = stack[stack.length - 2].node;
      p.c && (p.c[top.s] = eow);
      nodes.pop();
    }
    stack.pop();
    return {
      root: root$1,
      nodes,
      stack,
      parser: parser2
    };
  }
  const charactersBack = stringToCharSet$2(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) return parserMain({
      ...acc,
      parser: void 0
    }, s);
    let n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    const { stack } = acc;
    while (n-- > 0) stack.pop();
    return {
      ...acc,
      parser: parseBack
    };
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers3 = createStringLookupMap([
    [EOW, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [REF_REL, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore],
    [INLINE_DATA_COMMENT_LINE, parseComment]
  ]);
  function parserMain(acc, s) {
    const parser2 = acc.parser ?? parsers3[s] ?? parseCharacter;
    return parser2(acc, s);
  }
  const charsetSpaces = stringToCharSet$2(" \r\n	");
  function parseReferenceIndex(acc, s) {
    let json = "";
    function parserStart(acc$1, s$1) {
      if (s$1 === REF_INDEX_BEGIN) {
        json = json + s$1;
        return {
          ...acc$1,
          parser: parser2
        };
      }
      if (s$1 in charsetSpaces) return acc$1;
      return parserMain({
        ...acc$1,
        parser: void 0
      }, s$1);
    }
    function parser2(acc$1, s$1) {
      json = json + s$1;
      if (s$1 === REF_INDEX_END) {
        refIndex = json.replaceAll(/[\s[\]]/g, "").split(",").map((n) => Number.parseInt(n, radix));
        return {
          ...acc$1,
          parser: void 0
        };
      }
      return acc$1;
    }
    return parserStart({
      ...acc,
      parser: parserStart
    }, s);
  }
  reduceSync(pipeSync(iter, opConcatMapSync((a) => [...a])), parserMain, {
    nodes: [root],
    root,
    stack: [{
      node: root,
      s: ""
    }],
    parser: parseReferenceIndex
  });
  return root;
}
function stringToCharSet$2(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) set[values[i]] = true;
  return set;
}
function stringToCharMap(values) {
  return createStringLookupMap(values);
}
function createStringLookupMap(values) {
  const map3 = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) map3[values[i][0]] = values[i][1];
  return map3;
}
function tapIterable(iterable) {
  let lastValue;
  let iter;
  function getNext() {
    if (lastValue && lastValue.done) return { ...lastValue };
    iter = iter || iterable[Symbol.iterator]();
    lastValue = iter.next();
    return lastValue;
  }
  function* iterableFn() {
    let next;
    while (!(next = getNext()).done) yield next.value;
  }
  return { [Symbol.iterator]: iterableFn };
}
var EOW$1 = Object.freeze({
  f: 1,
  k: true
});
var compare = new Intl.Collator().compare;
var specialCharacterMap$1 = /* @__PURE__ */ new Map([
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
]);
var characterMap = new Map([...specialCharacterMap$1].map((a) => [a[1], a[0]]));
var DATA$1 = "__DATA__";
function importTrieV3WithBuilder(builder, srcLines) {
  const timer = getGlobalPerfTimer();
  const timerStart = timer.start("importTrieV3");
  const dataLines = typeof srcLines === "string" ? srcLines.split("\n") : Array.isArray(srcLines) ? srcLines : [...srcLines];
  let radix = 16;
  const comment = /^\s*#/;
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg$2 = /^TrieXv3\nbase=(\d+)$/;
    if (!headerReg$2.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg$2, "$1"), 10);
  }
  function findStartOfData(data) {
    for (let i = 0; i < data.length; ++i) {
      const line = data[i];
      if (line.includes(DATA$1)) return i;
    }
    return -1;
  }
  function readHeader(data) {
    const headerRows = [];
    for (const hLine of data) {
      const line = hLine.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$1) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const startOfData = findStartOfData(dataLines);
  if (startOfData < 0) throw new Error("Unknown file format");
  readHeader(dataLines.slice(0, startOfData));
  const cursor = builder.getCursor();
  let node = {
    cursor,
    parser: void 0
  };
  const parser2 = parseStream(radix);
  const timerParse = timer.start("importTrieV3.parse");
  for (let i = startOfData + 1; i < dataLines.length; ++i) {
    const line = dataLines[i];
    for (const c of line) node = parser2(node, c);
  }
  timerParse();
  timerStart();
  return builder.build();
}
function parseStream(radix) {
  function parseReference(acc, _) {
    let ref = "";
    function parser2(acc$1, s) {
      if (s === EOR) {
        const { cursor } = acc$1;
        const r = Number.parseInt(ref, radix);
        cursor.reference(r + 1);
        acc$1.parser = void 0;
        return acc$1;
      }
      ref = ref + s;
      return acc$1;
    }
    acc.parser = parser2;
    return acc;
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser2 = function(acc$1, s) {
      if (prev) {
        s = characterMap.get(prev + s) || s;
        acc$1.parser = void 0;
        return parseCharacter(acc$1, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc$1;
      }
      acc$1.parser = void 0;
      return parseCharacter(acc$1, s);
    };
    acc.parser = parser2;
    return acc;
  }
  function parseCharacter(acc, s) {
    acc.cursor.insertChar(s);
    acc.parser = void 0;
    return acc;
  }
  function parseEOW(acc, _) {
    acc.parser = parseBack;
    acc.cursor.markEOW();
    acc.cursor.backStep(1);
    return acc;
  }
  const charactersBack = stringToCharSet$1(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) {
      acc.parser = void 0;
      return parserMain(acc, s);
    }
    const n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    acc.cursor.backStep(n);
    acc.parser = parseBack;
    return acc;
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers3 = /* @__PURE__ */ new Map([
    [EOW, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore]
  ]);
  function parserMain(acc, s) {
    const parser2 = acc.parser ?? parsers3.get(s) ?? parseCharacter;
    return parser2(acc, s);
  }
  return parserMain;
}
function stringToCharSet$1(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) set[values[i]] = true;
  return set;
}
function importTrieV3AsFastTrieBlob(srcLines) {
  return importTrieV3WithBuilder(new FastTrieBlobBuilder(), srcLines);
}
function decodeTrieData(raw) {
  return decodeStringFormat(typeof raw === "string" ? raw : raw.toString("utf8"));
}
function decodeStringFormat(data) {
  return importTrie$2(data);
}
var deserializers$1 = [
  (data) => new TrieNodeTrie(importTrie$5(data)),
  (data) => new TrieNodeTrie(importTrie$5(data)),
  (data) => new TrieNodeTrie(importTrie$4(data)),
  (data) => importTrieV3AsFastTrieBlob(data),
  (data) => new TrieNodeTrie(importTrie$3(data))
];
var headerReg$1 = /^\s*TrieXv(\d+)/m;
function importTrie$2(input) {
  const lines = Array.isArray(input) ? input : typeof input === "string" ? input.split("\n") : [...input];
  function parseHeaderRows(headerRows) {
    for (let i = 0; i < headerRows.length; ++i) {
      const match2 = headerRows[i].match(headerReg$1);
      if (match2) return Number.parseInt(match2[1], 10);
    }
    throw new Error("Unknown file format");
  }
  function readHeader(iter) {
    const headerRows = [];
    for (const entry of iter) {
      const line = entry.trim();
      headerRows.push(line);
      if (line === DATA$4 || line === DATA$3) break;
    }
    return headerRows;
  }
  const headerLines = readHeader(lines);
  const version$12 = parseHeaderRows(headerLines);
  const method = deserializers$1[version$12];
  if (!method) throw new Error(`Unsupported version: ${version$12}`);
  return method(lines);
}
function decodeTrie(raw) {
  const data = decodeTrieData(raw);
  return new ITrieImpl(data);
}
var specialCharacters = stringToCharSet([
  EOW,
  BACK,
  EOL,
  REF,
  EOR,
  ESCAPE,
  LF,
  "0123456789",
  "`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|"
].join(""));
var specialPrefix = stringToCharSet("~!");
function stringToCharSet(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) set[values[i]] = true;
  return set;
}
var codes = [
  ["af", "Afrikaans"],
  [
    "af-NA",
    "Afrikaans",
    "Namibia"
  ],
  [
    "af-ZA",
    "Afrikaans",
    "South Africa"
  ],
  ["ak", "Akan"],
  [
    "ak-GH",
    "Akan",
    "Ghana"
  ],
  ["am", "Amharic"],
  [
    "am-ET",
    "Amharic",
    "Ethiopia"
  ],
  ["ar", "Arabic"],
  ["ar-1", "Arabic"],
  [
    "ar-AE",
    "Arabic",
    "United Arab Emirates"
  ],
  [
    "ar-BH",
    "Arabic",
    "Bahrain"
  ],
  [
    "ar-DJ",
    "Arabic",
    "Djibouti"
  ],
  [
    "ar-DZ",
    "Arabic",
    "Algeria"
  ],
  [
    "ar-EG",
    "Arabic",
    "Egypt"
  ],
  ["ar-EH", "Arabic"],
  [
    "ar-ER",
    "Arabic",
    "Eritrea"
  ],
  [
    "ar-IL",
    "Arabic",
    "Israel"
  ],
  [
    "ar-IQ",
    "Arabic",
    "Iraq"
  ],
  [
    "ar-JO",
    "Arabic",
    "Jordan"
  ],
  [
    "ar-KM",
    "Arabic",
    "Comoros"
  ],
  [
    "ar-KW",
    "Arabic",
    "Kuwait"
  ],
  [
    "ar-LB",
    "Arabic",
    "Lebanon"
  ],
  [
    "ar-LY",
    "Arabic",
    "Libya"
  ],
  [
    "ar-MA",
    "Arabic",
    "Morocco"
  ],
  [
    "ar-MR",
    "Arabic",
    "Mauritania"
  ],
  [
    "ar-OM",
    "Arabic",
    "Oman"
  ],
  ["ar-PS", "Arabic"],
  [
    "ar-QA",
    "Arabic",
    "Qatar"
  ],
  [
    "ar-SA",
    "Arabic",
    "Saudi Arabia"
  ],
  [
    "ar-SD",
    "Arabic",
    "Sudan"
  ],
  [
    "ar-SO",
    "Arabic",
    "Somalia"
  ],
  ["ar-SS", "Arabic"],
  [
    "ar-SY",
    "Arabic",
    "Syria"
  ],
  [
    "ar-TD",
    "Arabic",
    "Chad"
  ],
  [
    "ar-TN",
    "Arabic",
    "Tunisia"
  ],
  [
    "ar-YE",
    "Arabic",
    "Yemen"
  ],
  ["as", "Assamese"],
  [
    "as-IN",
    "Assamese",
    "India"
  ],
  ["az", "Azerbaijani"],
  [
    "az-AZ",
    "Azerbaijani",
    "Azerbaijan"
  ],
  ["be", "Belarusian"],
  [
    "be-BY",
    "Belarusian",
    "Belarus"
  ],
  ["bg", "Bulgarian"],
  [
    "bg-BG",
    "Bulgarian",
    "Bulgaria"
  ],
  ["bm", "Bambara"],
  [
    "bm-ML",
    "Bambara",
    "Mali"
  ],
  ["bn", "Bengali"],
  [
    "bn-BD",
    "Bengali",
    "Bangladesh"
  ],
  [
    "bn-IN",
    "Bengali",
    "India"
  ],
  ["bo", "Tibetan"],
  [
    "bo-CN",
    "Tibetan",
    "China"
  ],
  [
    "bo-IN",
    "Tibetan",
    "India"
  ],
  ["br", "Breton"],
  [
    "br-FR",
    "Breton",
    "France"
  ],
  ["bs", "Bosnian"],
  [
    "bs-BA",
    "Bosnian",
    "Bosnia and Herzegovina"
  ],
  ["ca", "Catalan"],
  [
    "ca-AD",
    "Catalan",
    "Andorra"
  ],
  [
    "ca-ES",
    "Catalan",
    "Spain"
  ],
  [
    "ca-FR",
    "Catalan",
    "France"
  ],
  [
    "ca-IT",
    "Catalan",
    "Italy"
  ],
  ["ce", "Chechen"],
  [
    "ce-RU",
    "Chechen",
    "Russia"
  ],
  ["cs", "Czech"],
  [
    "cs-CZ",
    "Czech",
    "Czech Republic"
  ],
  ["cu", "Old Slavonic"],
  [
    "cu-RU",
    "Old Slavonic",
    "Russia"
  ],
  ["cy", "Welsh"],
  [
    "cy-GB",
    "Welsh",
    "United Kingdom"
  ],
  ["da", "Danish"],
  [
    "da-DK",
    "Danish",
    "Denmark"
  ],
  [
    "da-GL",
    "Danish",
    "Greenland"
  ],
  ["de", "German"],
  [
    "de-AT",
    "German",
    "Austria"
  ],
  [
    "de-BE",
    "German",
    "Belgium"
  ],
  [
    "de-CH",
    "German",
    "Switzerland"
  ],
  [
    "de-DE",
    "German",
    "Germany"
  ],
  [
    "de-IT",
    "German",
    "Italy"
  ],
  [
    "de-LI",
    "German",
    "Liechtenstein"
  ],
  [
    "de-LU",
    "German",
    "Luxembourg"
  ],
  ["dz", "Dzongkha"],
  [
    "dz-BT",
    "Dzongkha",
    "Bhutan"
  ],
  ["ee", "Ewe"],
  [
    "ee-GH",
    "Ewe",
    "Ghana"
  ],
  [
    "ee-TG",
    "Ewe",
    "Togo"
  ],
  [
    "el",
    "Greek",
    "Modern (1453-)"
  ],
  [
    "el-CY",
    "Greek",
    "Cyprus"
  ],
  [
    "el-GR",
    "Greek",
    "Greece"
  ],
  ["en", "English"],
  [
    "en-AG",
    "English",
    "Antigua and Barbuda"
  ],
  [
    "en-AI",
    "English",
    "Anguilla"
  ],
  [
    "en-AS",
    "English",
    "American Samoa"
  ],
  [
    "en-AT",
    "English",
    "Austria"
  ],
  [
    "en-AU",
    "English",
    "Australia"
  ],
  [
    "en-BB",
    "English",
    "Barbados"
  ],
  [
    "en-BE",
    "English",
    "Belgium"
  ],
  [
    "en-BI",
    "English",
    "Burundi"
  ],
  [
    "en-BM",
    "English",
    "Bermuda"
  ],
  [
    "en-BS",
    "English",
    "Bahamas"
  ],
  [
    "en-BW",
    "English",
    "Botswana"
  ],
  [
    "en-BZ",
    "English",
    "Belize"
  ],
  [
    "en-CA",
    "English",
    "Canada"
  ],
  [
    "en-CC",
    "English",
    "Cocos (Keeling) Islands"
  ],
  [
    "en-CH",
    "English",
    "Switzerland"
  ],
  [
    "en-CK",
    "English",
    "Cook Islands"
  ],
  [
    "en-CM",
    "English",
    "Cameroon"
  ],
  [
    "en-CX",
    "English",
    "Christmas Island"
  ],
  [
    "en-CY",
    "English",
    "Cyprus"
  ],
  [
    "en-DE",
    "English",
    "Germany"
  ],
  ["en-DG", "English"],
  [
    "en-DK",
    "English",
    "Denmark"
  ],
  [
    "en-DM",
    "English",
    "Dominica"
  ],
  [
    "en-ER",
    "English",
    "Eritrea"
  ],
  [
    "en-FI",
    "English",
    "Finland"
  ],
  [
    "en-FJ",
    "English",
    "Fiji"
  ],
  [
    "en-FK",
    "English",
    "Falkland Islands (Islas Malvinas)"
  ],
  [
    "en-FM",
    "English",
    "Micronesia"
  ],
  [
    "en-GB",
    "English",
    "United Kingdom"
  ],
  [
    "en-GD",
    "English",
    "Grenada"
  ],
  [
    "en-GG",
    "English",
    "Guernsey"
  ],
  [
    "en-GH",
    "English",
    "Ghana"
  ],
  [
    "en-GI",
    "English",
    "Gibraltar"
  ],
  [
    "en-GM",
    "English",
    "Gambia"
  ],
  [
    "en-GU",
    "English",
    "Guam"
  ],
  [
    "en-GY",
    "English",
    "Guyana"
  ],
  [
    "en-HK",
    "English",
    "Hong Kong"
  ],
  [
    "en-IE",
    "English",
    "Ireland"
  ],
  [
    "en-IL",
    "English",
    "Israel"
  ],
  [
    "en-IM",
    "English",
    "Isle of Man"
  ],
  [
    "en-IN",
    "English",
    "India"
  ],
  [
    "en-IO",
    "English",
    "British Indian Ocean Territory"
  ],
  [
    "en-JE",
    "English",
    "Jersey"
  ],
  [
    "en-JM",
    "English",
    "Jamaica"
  ],
  [
    "en-KE",
    "English",
    "Kenya"
  ],
  [
    "en-KI",
    "English",
    "Kiribati"
  ],
  [
    "en-KN",
    "English",
    "Saint Kitts and Nevis"
  ],
  [
    "en-KY",
    "English",
    "Cayman Islands"
  ],
  [
    "en-LC",
    "English",
    "Saint Lucia"
  ],
  [
    "en-LR",
    "English",
    "Liberia"
  ],
  [
    "en-LS",
    "English",
    "Lesotho"
  ],
  [
    "en-MG",
    "English",
    "Madagascar"
  ],
  [
    "en-MH",
    "English",
    "Marshall Islands"
  ],
  [
    "en-MO",
    "English",
    "Macau"
  ],
  [
    "en-MP",
    "English",
    "Northern Mariana Islands"
  ],
  [
    "en-MS",
    "English",
    "Montserrat"
  ],
  [
    "en-MT",
    "English",
    "Malta"
  ],
  [
    "en-MU",
    "English",
    "Mauritius"
  ],
  [
    "en-MW",
    "English",
    "Malawi"
  ],
  [
    "en-MY",
    "English",
    "Malaysia"
  ],
  [
    "en-NA",
    "English",
    "Namibia"
  ],
  [
    "en-NF",
    "English",
    "Norfolk Island"
  ],
  [
    "en-NG",
    "English",
    "Nigeria"
  ],
  [
    "en-NL",
    "English",
    "Netherlands"
  ],
  [
    "en-NR",
    "English",
    "Nauru"
  ],
  [
    "en-NU",
    "English",
    "Niue"
  ],
  [
    "en-NZ",
    "English",
    "New Zealand"
  ],
  [
    "en-PG",
    "English",
    "Papua New Guinea"
  ],
  [
    "en-PH",
    "English",
    "Philippines"
  ],
  [
    "en-PK",
    "English",
    "Pakistan"
  ],
  [
    "en-PN",
    "English",
    "Pitcairn Islands"
  ],
  [
    "en-PR",
    "English",
    "Puerto Rico"
  ],
  [
    "en-PW",
    "English",
    "Palau"
  ],
  [
    "en-RW",
    "English",
    "Rwanda"
  ],
  [
    "en-SB",
    "English",
    "Solomon Islands"
  ],
  [
    "en-SC",
    "English",
    "Seychelles"
  ],
  [
    "en-SD",
    "English",
    "Sudan"
  ],
  [
    "en-SE",
    "English",
    "Sweden"
  ],
  [
    "en-SG",
    "English",
    "Singapore"
  ],
  [
    "en-SH",
    "English",
    "Saint Helena"
  ],
  [
    "en-SI",
    "English",
    "Slovenia"
  ],
  [
    "en-SL",
    "English",
    "Sierra Leone"
  ],
  ["en-SS", "English"],
  ["en-SX", "English"],
  [
    "en-SZ",
    "English",
    "Swaziland"
  ],
  [
    "en-TC",
    "English",
    "Turks and Caicos Islands"
  ],
  [
    "en-TK",
    "English",
    "Tokelau"
  ],
  [
    "en-TO",
    "English",
    "Tonga"
  ],
  [
    "en-TT",
    "English",
    "Trinidad and Tobago"
  ],
  [
    "en-TV",
    "English",
    "Tuvalu"
  ],
  [
    "en-TZ",
    "English",
    "Tanzania"
  ],
  [
    "en-UG",
    "English",
    "Uganda"
  ],
  [
    "en-UM",
    "English",
    "Baker Island"
  ],
  [
    "en-US",
    "English",
    "United States"
  ],
  [
    "en-VC",
    "English",
    "Saint Vincent and the Grenadines"
  ],
  [
    "en-VG",
    "English",
    "British Virgin Islands"
  ],
  [
    "en-VI",
    "English",
    "U.S. Virgin Islands"
  ],
  [
    "en-VU",
    "English",
    "Vanuatu"
  ],
  [
    "en-WS",
    "English",
    "Samoa"
  ],
  [
    "en-ZA",
    "English",
    "South Africa"
  ],
  [
    "en-ZM",
    "English",
    "Zambia"
  ],
  [
    "en-ZW",
    "English",
    "Zimbabwe"
  ],
  ["eo", "Esperanto"],
  ["es", "Spanish"],
  [
    "es-AR",
    "Spanish",
    "Argentina"
  ],
  [
    "es-BO",
    "Spanish",
    "Bolivia"
  ],
  [
    "es-BR",
    "Spanish",
    "Brazil"
  ],
  [
    "es-BZ",
    "Spanish",
    "Belize"
  ],
  [
    "es-CL",
    "Spanish",
    "Chile"
  ],
  [
    "es-CO",
    "Spanish",
    "Colombia"
  ],
  [
    "es-CR",
    "Spanish",
    "Costa Rica"
  ],
  [
    "es-CU",
    "Spanish",
    "Cuba"
  ],
  [
    "es-DO",
    "Spanish",
    "Dominican Republic"
  ],
  ["es-EA", "Spanish"],
  [
    "es-EC",
    "Spanish",
    "Ecuador"
  ],
  [
    "es-ES",
    "Spanish",
    "Spain"
  ],
  [
    "es-GQ",
    "Spanish",
    "Equatorial Guinea"
  ],
  [
    "es-GT",
    "Spanish",
    "Guatemala"
  ],
  [
    "es-HN",
    "Spanish",
    "Honduras"
  ],
  ["es-IC", "Spanish"],
  [
    "es-MX",
    "Spanish",
    "Mexico"
  ],
  [
    "es-NI",
    "Spanish",
    "Nicaragua"
  ],
  [
    "es-PA",
    "Spanish",
    "Panama"
  ],
  [
    "es-PE",
    "Spanish",
    "Peru"
  ],
  [
    "es-PH",
    "Spanish",
    "Philippines"
  ],
  [
    "es-PR",
    "Spanish",
    "Puerto Rico"
  ],
  [
    "es-PY",
    "Spanish",
    "Paraguay"
  ],
  [
    "es-SV",
    "Spanish",
    "El Salvador"
  ],
  [
    "es-US",
    "Spanish",
    "United States"
  ],
  [
    "es-UY",
    "Spanish",
    "Uruguay"
  ],
  [
    "es-VE",
    "Spanish",
    "Venezuela"
  ],
  ["et", "Estonian"],
  [
    "et-EE",
    "Estonian",
    "Estonia"
  ],
  ["eu", "Basque"],
  [
    "eu-ES",
    "Basque",
    "Spain"
  ],
  ["fa", "Persian"],
  [
    "fa-AF",
    "Persian",
    "Afghanistan"
  ],
  [
    "fa-IR",
    "Persian",
    "Iran"
  ],
  ["ff", "Fulah"],
  [
    "ff-CM",
    "Fulah",
    "Cameroon"
  ],
  [
    "ff-GN",
    "Fulah",
    "Guinea"
  ],
  [
    "ff-MR",
    "Fulah",
    "Mauritania"
  ],
  [
    "ff-SN",
    "Fulah",
    "Senegal"
  ],
  ["fi", "Finnish"],
  [
    "fi-FI",
    "Finnish",
    "Finland"
  ],
  ["fo", "Faroese"],
  [
    "fo-DK",
    "Faroese",
    "Denmark"
  ],
  [
    "fo-FO",
    "Faroese",
    "Faroe Islands"
  ],
  ["fr", "French"],
  [
    "fr-BE",
    "French",
    "Belgium"
  ],
  [
    "fr-BF",
    "French",
    "Burkina Faso"
  ],
  [
    "fr-BI",
    "French",
    "Burundi"
  ],
  [
    "fr-BJ",
    "French",
    "Benin"
  ],
  ["fr-BL", "French"],
  [
    "fr-CA",
    "French",
    "Canada"
  ],
  [
    "fr-CD",
    "French",
    "Congo"
  ],
  [
    "fr-CF",
    "French",
    "Central African Republic"
  ],
  [
    "fr-CG",
    "French",
    "Congo"
  ],
  [
    "fr-CH",
    "French",
    "Switzerland"
  ],
  ["fr-CI", "French, Cote d'Ivoire (Ivory Coast)"],
  [
    "fr-CM",
    "French",
    "Cameroon"
  ],
  [
    "fr-DJ",
    "French",
    "Djibouti"
  ],
  [
    "fr-DZ",
    "French",
    "Algeria"
  ],
  [
    "fr-FR",
    "French",
    "France"
  ],
  [
    "fr-GA",
    "French",
    "Gabon"
  ],
  [
    "fr-GF",
    "French",
    "French Guiana"
  ],
  [
    "fr-GN",
    "French",
    "Guinea"
  ],
  [
    "fr-GP",
    "French",
    "Saint Barthelemy"
  ],
  [
    "fr-GQ",
    "French",
    "Equatorial Guinea"
  ],
  [
    "fr-HT",
    "French",
    "Haiti"
  ],
  [
    "fr-KM",
    "French",
    "Comoros"
  ],
  [
    "fr-LU",
    "French",
    "Luxembourg"
  ],
  [
    "fr-MA",
    "French",
    "Morocco"
  ],
  [
    "fr-MC",
    "French",
    "Monaco"
  ],
  ["fr-MF", "French"],
  [
    "fr-MG",
    "French",
    "Madagascar"
  ],
  [
    "fr-ML",
    "French",
    "Mali"
  ],
  [
    "fr-MQ",
    "French",
    "Martinique"
  ],
  [
    "fr-MR",
    "French",
    "Mauritania"
  ],
  [
    "fr-MU",
    "French",
    "Mauritius"
  ],
  [
    "fr-NC",
    "French",
    "New Caledonia"
  ],
  [
    "fr-NE",
    "French",
    "Niger"
  ],
  [
    "fr-PF",
    "French",
    "French Polynesia"
  ],
  [
    "fr-PM",
    "French",
    "Saint Pierre and Miquelon"
  ],
  [
    "fr-RE",
    "French",
    "Reunion"
  ],
  [
    "fr-RW",
    "French",
    "Rwanda"
  ],
  [
    "fr-SC",
    "French",
    "Seychelles"
  ],
  [
    "fr-SN",
    "French",
    "Senegal"
  ],
  [
    "fr-SY",
    "French",
    "Syria"
  ],
  [
    "fr-TD",
    "French",
    "Chad"
  ],
  [
    "fr-TG",
    "French",
    "Togo"
  ],
  [
    "fr-TN",
    "French",
    "Tunisia"
  ],
  [
    "fr-VU",
    "French",
    "Vanuatu"
  ],
  [
    "fr-WF",
    "French",
    "Wallis and Futuna"
  ],
  [
    "fr-YT",
    "French",
    "Mayotte"
  ],
  ["fy", "Western Frisian"],
  [
    "fy-NL",
    "Western Frisian",
    "Netherlands"
  ],
  ["ga", "Irish"],
  [
    "ga-IE",
    "Irish",
    "Ireland"
  ],
  ["gd", "Gaelic"],
  [
    "gd-GB",
    "Gaelic",
    "United Kingdom"
  ],
  ["gl", "Galician"],
  [
    "gl-ES",
    "Galician",
    "Spain"
  ],
  ["gu", "Gujarati"],
  [
    "gu-IN",
    "Gujarati",
    "India"
  ],
  ["gv", "Manx"],
  [
    "gv-IM",
    "Manx",
    "Isle of Man"
  ],
  ["ha", "Hausa"],
  [
    "ha-GH",
    "Hausa",
    "Ghana"
  ],
  [
    "ha-NE",
    "Hausa",
    "Niger"
  ],
  [
    "ha-NG",
    "Hausa",
    "Nigeria"
  ],
  ["he", "Hebrew"],
  [
    "he-IL",
    "Hebrew",
    "Israel"
  ],
  ["hi", "Hindi"],
  [
    "hi-IN",
    "Hindi",
    "India"
  ],
  ["hr", "Croatian"],
  [
    "hr-BA",
    "Croatian",
    "Bosnia and Herzegovina"
  ],
  [
    "hr-HR",
    "Croatian",
    "Croatia"
  ],
  ["hu", "Hungarian"],
  [
    "hu-HU",
    "Hungarian",
    "Hungary"
  ],
  ["hy", "Armenian"],
  [
    "hy-AM",
    "Armenian",
    "Armenia"
  ],
  ["id", "Indonesian"],
  [
    "id-ID",
    "Indonesian",
    "Indonesia"
  ],
  ["ig", "Igbo"],
  [
    "ig-NG",
    "Igbo",
    "Nigeria"
  ],
  ["ii", "Sichuan Yi"],
  [
    "ii-CN",
    "Sichuan Yi",
    "China"
  ],
  ["is", "Icelandic"],
  [
    "is-IS",
    "Icelandic",
    "Iceland"
  ],
  ["it", "Italian"],
  [
    "it-CH",
    "Italian",
    "Switzerland"
  ],
  [
    "it-IT",
    "Italian",
    "Italy"
  ],
  [
    "it-SM",
    "Italian",
    "San Marino"
  ],
  [
    "it-VA",
    "Italian",
    "Vatican City"
  ],
  ["ja", "Japanese"],
  [
    "ja-JP",
    "Japanese",
    "Japan"
  ],
  ["ka", "Georgian"],
  [
    "ka-GE",
    "Georgian",
    "Georgia"
  ],
  ["ki", "Kikuyu"],
  [
    "ki-KE",
    "Kikuyu",
    "Kenya"
  ],
  ["kk", "Kazakh"],
  [
    "kk-KZ",
    "Kazakh",
    "Kazakhstan"
  ],
  ["kl", "Kalaallisut"],
  [
    "kl-GL",
    "Kalaallisut",
    "Greenland"
  ],
  ["km", "Central Khmer"],
  [
    "km-KH",
    "Central Khmer",
    "Cambodia"
  ],
  ["kn", "Kannada"],
  [
    "kn-IN",
    "Kannada",
    "India"
  ],
  ["ko", "Korean"],
  [
    "ko-KP",
    "Korean",
    "Korea"
  ],
  [
    "ko-KR",
    "Korean",
    "Korea"
  ],
  ["ks", "Kashmiri"],
  [
    "ks-IN",
    "Kashmiri",
    "India"
  ],
  ["kw", "Cornish"],
  [
    "kw-GB",
    "Cornish",
    "United Kingdom"
  ],
  ["ky", "Kirghiz"],
  [
    "ky-KG",
    "Kirghiz",
    "Kyrgyzstan"
  ],
  ["lb", "Luxembourgish"],
  [
    "lb-LU",
    "Luxembourgish",
    "Luxembourg"
  ],
  ["lg", "Ganda"],
  [
    "lg-UG",
    "Ganda",
    "Uganda"
  ],
  ["ln", "Lingala"],
  [
    "ln-AO",
    "Lingala",
    "Angola"
  ],
  [
    "ln-CD",
    "Lingala",
    "Congo"
  ],
  [
    "ln-CF",
    "Lingala",
    "Central African Republic"
  ],
  [
    "ln-CG",
    "Lingala",
    "Congo"
  ],
  ["lo", "Lao"],
  [
    "lo-LA",
    "Lao",
    "Laos"
  ],
  ["lt", "Lithuanian"],
  [
    "lt-LT",
    "Lithuanian",
    "Lithuania"
  ],
  ["lu", "Luba-Katanga"],
  [
    "lu-CD",
    "Luba-Katanga",
    "Congo"
  ],
  ["lv", "Latvian"],
  [
    "lv-LV",
    "Latvian",
    "Latvia"
  ],
  ["mg", "Malagasy"],
  [
    "mg-MG",
    "Malagasy",
    "Madagascar"
  ],
  ["mk", "Macedonian"],
  [
    "mk-MK",
    "Macedonian",
    "Macedonia"
  ],
  ["ml", "Malayalam"],
  [
    "ml-IN",
    "Malayalam",
    "India"
  ],
  ["mn", "Mongolian"],
  [
    "mn-MN",
    "Mongolian",
    "Mongolia"
  ],
  ["mr", "Marathi"],
  [
    "mr-IN",
    "Marathi",
    "India"
  ],
  ["ms", "Malay"],
  [
    "ms-BN",
    "Malay",
    "Brunei"
  ],
  [
    "ms-MY",
    "Malay",
    "Malaysia"
  ],
  [
    "ms-SG",
    "Malay",
    "Singapore"
  ],
  ["mt", "Maltese"],
  [
    "mt-MT",
    "Maltese",
    "Malta"
  ],
  ["my", "Burmese"],
  [
    "my-MM",
    "Burmese",
    "Myanmar (Burma)"
  ],
  ["nb", "Bokm\xE5l Norwegian"],
  [
    "nb-NO",
    "Bokm\xE5l Norwegian",
    "Norway"
  ],
  [
    "nb-SJ",
    "Bokm\xE5l Norwegian",
    "Svalbard"
  ],
  ["nd", "Ndebele, North"],
  [
    "nd-ZW",
    "Ndebele, North",
    "Zimbabwe"
  ],
  ["ne", "Nepali"],
  [
    "ne-IN",
    "Nepali",
    "India"
  ],
  [
    "ne-NP",
    "Nepali",
    "Nepal"
  ],
  ["nl", "Dutch"],
  [
    "nl-AW",
    "Dutch",
    "Aruba"
  ],
  [
    "nl-BE",
    "Dutch",
    "Belgium"
  ],
  ["nl-BQ", "Dutch"],
  ["nl-CW", "Dutch"],
  [
    "nl-NL",
    "Dutch",
    "Netherlands"
  ],
  [
    "nl-SR",
    "Dutch",
    "Suriname"
  ],
  ["nl-SX", "Dutch"],
  ["nn", "Norwegian Nynorsk"],
  [
    "nn-NO",
    "Norwegian Nynorsk",
    "Norway"
  ],
  ["om", "Oromo"],
  [
    "om-ET",
    "Oromo",
    "Ethiopia"
  ],
  [
    "om-KE",
    "Oromo",
    "Kenya"
  ],
  ["or", "Oriya"],
  [
    "or-IN",
    "Oriya",
    "India"
  ],
  ["os", "Ossetian"],
  [
    "os-GE",
    "Ossetian",
    "Georgia"
  ],
  [
    "os-RU",
    "Ossetian",
    "Russia"
  ],
  ["pa", "Panjabi"],
  [
    "pa-IN",
    "Panjabi",
    "India"
  ],
  [
    "pa-PK",
    "Panjabi",
    "Pakistan"
  ],
  ["pl", "Polish"],
  [
    "pl-PL",
    "Polish",
    "Poland"
  ],
  ["ps", "Pushto"],
  [
    "ps-AF",
    "Pushto",
    "Afghanistan"
  ],
  ["pt", "Portuguese"],
  [
    "pt-AO",
    "Portuguese",
    "Angola"
  ],
  [
    "pt-BR",
    "Portuguese",
    "Brazil"
  ],
  [
    "pt-CH",
    "Portuguese",
    "Switzerland"
  ],
  [
    "pt-CV",
    "Portuguese",
    "Cape Verde"
  ],
  [
    "pt-GQ",
    "Portuguese",
    "Equatorial Guinea"
  ],
  [
    "pt-GW",
    "Portuguese",
    "Guinea-Bissau"
  ],
  [
    "pt-LU",
    "Portuguese",
    "Luxembourg"
  ],
  [
    "pt-MO",
    "Portuguese",
    "Macau"
  ],
  [
    "pt-MZ",
    "Portuguese",
    "Mozambique"
  ],
  [
    "pt-PT",
    "Portuguese",
    "Portugal"
  ],
  [
    "pt-ST",
    "Portuguese",
    "Sao Tome and Principe"
  ],
  [
    "pt-TL",
    "Portuguese",
    "Timor-Leste (East Timor)"
  ],
  ["qu", "Quechua"],
  [
    "qu-BO",
    "Quechua",
    "Bolivia"
  ],
  [
    "qu-EC",
    "Quechua",
    "Ecuador"
  ],
  [
    "qu-PE",
    "Quechua",
    "Peru"
  ],
  ["rm", "Romansh"],
  [
    "rm-CH",
    "Romansh",
    "Switzerland"
  ],
  ["rn", "Rundi"],
  [
    "rn-BI",
    "Rundi",
    "Burundi"
  ],
  ["ro", "Romanian"],
  [
    "ro-MD",
    "Romanian",
    "Moldova"
  ],
  [
    "ro-RO",
    "Romanian",
    "Romania"
  ],
  ["ru", "Russian"],
  [
    "ru-BY",
    "Russian",
    "Belarus"
  ],
  [
    "ru-KG",
    "Russian",
    "Kyrgyzstan"
  ],
  [
    "ru-KZ",
    "Russian",
    "Kazakhstan"
  ],
  [
    "ru-MD",
    "Russian",
    "Moldova"
  ],
  [
    "ru-RU",
    "Russian",
    "Russia"
  ],
  [
    "ru-UA",
    "Russian",
    "Ukraine"
  ],
  ["rw", "Kinyarwanda"],
  [
    "rw-RW",
    "Kinyarwanda",
    "Rwanda"
  ],
  ["se", "Northern Sami"],
  [
    "se-FI",
    "Northern Sami",
    "Finland"
  ],
  [
    "se-NO",
    "Northern Sami",
    "Norway"
  ],
  [
    "se-SE",
    "Northern Sami",
    "Sweden"
  ],
  ["sg", "Sango"],
  [
    "sg-CF",
    "Sango",
    "Central African Republic"
  ],
  ["si", "Sinhala"],
  [
    "si-LK",
    "Sinhala",
    "Sri Lanka"
  ],
  ["sk", "Slovak"],
  [
    "sk-SK",
    "Slovak",
    "Slovakia"
  ],
  ["sl", "Slovenian"],
  [
    "sl-SI",
    "Slovenian",
    "Slovenia"
  ],
  ["sn", "Shona"],
  [
    "sn-ZW",
    "Shona",
    "Zimbabwe"
  ],
  ["so", "Somali"],
  [
    "so-DJ",
    "Somali",
    "Djibouti"
  ],
  [
    "so-ET",
    "Somali",
    "Ethiopia"
  ],
  [
    "so-KE",
    "Somali",
    "Kenya"
  ],
  [
    "so-SO",
    "Somali",
    "Somalia"
  ],
  ["sq", "Albanian"],
  [
    "sq-AL",
    "Albanian",
    "Albania"
  ],
  [
    "sq-MK",
    "Albanian",
    "Macedonia"
  ],
  ["sq-XK", "Albanian"],
  ["sr", "Serbian"],
  [
    "sr-BA",
    "Serbian",
    "Bosnia and Herzegovina"
  ],
  [
    "sr-ME",
    "Serbian",
    "Montenegro"
  ],
  [
    "sr-RS",
    "Serbian",
    "Serbia"
  ],
  ["sr-XK", "Serbian"],
  ["sv", "Swedish"],
  [
    "sv-AX",
    "Swedish",
    "Aland"
  ],
  [
    "sv-FI",
    "Swedish",
    "Finland"
  ],
  [
    "sv-SE",
    "Swedish",
    "Sweden"
  ],
  ["sw", "Swahili"],
  [
    "sw-CD",
    "Swahili",
    "Congo"
  ],
  [
    "sw-KE",
    "Swahili",
    "Kenya"
  ],
  [
    "sw-TZ",
    "Swahili",
    "Tanzania"
  ],
  [
    "sw-UG",
    "Swahili",
    "Uganda"
  ],
  ["ta", "Tamil"],
  [
    "ta-IN",
    "Tamil",
    "India"
  ],
  [
    "ta-LK",
    "Tamil",
    "Sri Lanka"
  ],
  [
    "ta-MY",
    "Tamil",
    "Malaysia"
  ],
  [
    "ta-SG",
    "Tamil",
    "Singapore"
  ],
  ["te", "Telugu"],
  [
    "te-IN",
    "Telugu",
    "India"
  ],
  ["th", "Thai"],
  [
    "th-TH",
    "Thai",
    "Thailand"
  ],
  ["ti", "Tigrinya"],
  [
    "ti-ER",
    "Tigrinya",
    "Eritrea"
  ],
  [
    "ti-ET",
    "Tigrinya",
    "Ethiopia"
  ],
  ["tk", "Turkmen"],
  [
    "tk-TM",
    "Turkmen",
    "Turkmenistan"
  ],
  ["to", "Tonga (Tonga Islands)"],
  [
    "to-TO",
    "Tonga (Tonga Islands)",
    "Tonga"
  ],
  ["tr", "Turkish"],
  [
    "tr-CY",
    "Turkish",
    "Cyprus"
  ],
  [
    "tr-TR",
    "Turkish",
    "Turkey"
  ],
  ["ug", "Uighur"],
  [
    "ug-CN",
    "Uighur",
    "China"
  ],
  ["uk", "Ukrainian"],
  [
    "uk-UA",
    "Ukrainian",
    "Ukraine"
  ],
  ["ur", "Urdu"],
  [
    "ur-IN",
    "Urdu",
    "India"
  ],
  [
    "ur-PK",
    "Urdu",
    "Pakistan"
  ],
  ["uz", "Uzbek"],
  [
    "uz-AF",
    "Uzbek",
    "Afghanistan"
  ],
  [
    "uz-UZ",
    "Uzbek",
    "Uzbekistan"
  ],
  ["vi", "Vietnamese"],
  [
    "vi-VN",
    "Vietnamese",
    "Vietnam"
  ],
  ["vo", "Volap\xFCk"],
  ["yi", "Yiddish"],
  ["yi-1", "Yiddish"],
  ["yo", "Yoruba"],
  [
    "yo-BJ",
    "Yoruba",
    "Benin"
  ],
  [
    "yo-NG",
    "Yoruba",
    "Nigeria"
  ],
  ["zh", "Chinese"],
  [
    "zh-CN",
    "Chinese",
    "China"
  ],
  [
    "zh-HK",
    "Chinese",
    "Hong Kong"
  ],
  [
    "zh-MO",
    "Chinese",
    "Macau"
  ],
  [
    "zh-SG",
    "Chinese",
    "Singapore"
  ],
  [
    "zh-TW",
    "Chinese",
    "China"
  ],
  ["zu", "Zulu"],
  [
    "zu-ZA",
    "Zulu",
    "South Africa"
  ]
];
var codesByLocale;
var Locale = class {
  _raw;
  _locale;
  constructor(locale) {
    this._raw = locale;
    this._locale = normalizeLocale(locale);
  }
  get locale() {
    return this._locale;
  }
  localInfo() {
    return lookupLocaleInfo(this._locale);
  }
  isValid() {
    return isStandardLocale(this._locale);
  }
  toJSON() {
    return this.locale;
  }
  toString() {
    return this.locale;
  }
};
var regExTwoLetter = /^[a-z]{2}$/i;
var regExLocaleWithCountry = /^([a-z]{2})[_-]?([a-z]{2,3})$/i;
var regExValidLocale = /^([a-z]{2})(?:-([A-Z]{2,3}))?$/;
function normalizeLocale(locale) {
  locale = locale.trim();
  if (regExTwoLetter.test(locale)) return locale.toLowerCase();
  const m = locale.match(regExLocaleWithCountry);
  if (!m) return locale;
  const lang = m[1].toLowerCase();
  const variant = m[2].toUpperCase();
  return `${lang}-${variant}`;
}
function isStandardLocale(locale) {
  return regExValidLocale.test(locale);
}
function lookupLocaleInfo(locale) {
  codesByLocale = codesByLocale || buildLocaleLookup();
  return codesByLocale.get(locale);
}
function buildLocaleLookup() {
  const info5 = codes.map(([locale, language, country]) => ({
    locale,
    language,
    country
  }));
  return new Map(info5.map((i) => [i.locale, i]));
}
function createLocale(locale) {
  return new Locale(locale);
}
function parseLocale(locales) {
  locales = typeof locales === "string" ? locales.split(",") : locales;
  return locales.map(createLocale);
}
var defaultEditCosts = {
  accentCosts: 1,
  baseCost: 100,
  capsCosts: 1,
  firstLetterPenalty: 4,
  nonAlphabetCosts: 110
};
var defaultHunspellCosts = {
  ...defaultEditCosts,
  ioConvertCost: 30,
  keyboardCost: 99,
  mapCost: 25,
  replaceCosts: 75,
  tryCharCost: 100
};
function mapHunspellCosts(costs = {}) {
  return {
    ...defaultHunspellCosts,
    ...cleanCopy(costs)
  };
}
function mapEditCosts(costs = {}) {
  return {
    ...defaultEditCosts,
    ...cleanCopy(costs)
  };
}
function joinLetters(letters) {
  const v = [...letters];
  return v.map((a) => a.length > 1 || !a.length ? `(${a})` : a).join("");
}
function parseAlphabet(cs, locale, editCost) {
  const { cost, penalty } = cs;
  const characters = expandCharacterSet(cs.characters);
  const charForms = [...pipeSync(characters, opMapSync((c) => caseForms(c, locale).sort()))];
  const alphabet = joinLetters([...pipeSync(charForms, opFlattenSync(), opMapSync((letter) => accentForms(letter)), opFlattenSync(), opUniqueSync())].sort());
  const sugAlpha = clean$1({
    map: alphabet,
    replace: cost,
    insDel: cost,
    swap: cost,
    penalty
  });
  return [
    sugAlpha,
    parseAlphabetCaps(cs.characters, locale, editCost),
    ...calcCostsForAccentedLetters(alphabet, locale, editCost)
  ];
}
function parseAlphabetCaps(alphabet, locale, editCost) {
  const characters = expandCharacterSet(alphabet);
  const charForms = [...pipeSync(characters, opMapSync((c) => caseForms(c, locale).sort()))];
  const caps = charForms.map((a) => joinLetters(a)).join("|");
  const sugCaps = {
    map: caps,
    replace: editCost.capsCosts
  };
  return sugCaps;
}
function calcFirstCharacterReplaceDefs(alphabets, editCost) {
  return alphabets.map((cs) => calcFirstCharacterReplace(cs, editCost));
}
function calcFirstCharacterReplace(cs, editCost) {
  const mapOfFirstLetters = [...pipeSync(expandCharacterSet(cs.characters), opUniqueSync(), opMapSync((letter) => `(^${letter})`))].sort().join("") + "(^)";
  const penalty = editCost.firstLetterPenalty;
  const cost = cs.cost - penalty;
  return {
    map: mapOfFirstLetters,
    replace: cost,
    penalty: penalty * 2
  };
}
function parseAccents(cs, _editCost) {
  const { cost, penalty } = cs;
  const accents = joinLetters([...pipeSync(expandCharacterSet(cs.characters), opMapSync((char) => stripNonAccents(char)))]);
  if (!accents) return void 0;
  return clean$1({
    map: accents,
    replace: cost,
    insDel: cost,
    penalty
  });
}
function calcCostsForAccentedLetters(simpleMap, locale, costs) {
  const charactersWithAccents = [...pipeSync(splitMap(simpleMap), opMapSync((char) => caseForms(char, locale)), opFlattenSync(), opMapSync((char) => [...accentForms(char)]), opFilterSync((forms$1) => forms$1.length > 1))];
  const characters = pipeSync(charactersWithAccents, opMapSync((forms$1) => /* @__PURE__ */ new Set([...forms$1, ...forms$1.map((char) => stripAccents(char))])), opMapSync((forms$1) => [...forms$1].sort()), opFilterSync((forms$1) => forms$1.length > 1), opMapSync(joinLetters), opUniqueSync());
  const replaceAccentMap = [...characters].join("|");
  const cost = costs.accentCosts;
  const costToReplaceAccent = !replaceAccentMap ? [] : [{
    map: replaceAccentMap,
    replace: cost
  }];
  const normalizeMap$1 = charactersWithAccents.map((a) => a.sort()).map(joinLetters).join("|");
  const costToNormalizeAccent = !normalizeMap$1 ? [] : [{
    map: normalizeMap$1,
    replace: 0
  }];
  return [...costToReplaceAccent, ...costToNormalizeAccent];
}
function* splitMap(map3) {
  let seq = "";
  let mode = 0;
  for (const char of map3) {
    if (mode && char === ")") {
      yield seq;
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield char;
  }
}
function hunspellInformationToSuggestionCostDef(hunInfo, locales) {
  const costs = calcCosts(hunInfo.costs, locales);
  const operations = [
    affKey,
    affKeyCaps,
    affMap,
    affMapAccents,
    affMapCaps,
    affNoTry,
    affRepConv,
    affTry,
    affTryAccents,
    affTryFirstCharacterReplace
  ];
  function parseAff(aff, costs$1) {
    const regSupportedAff = /^(?:MAP|KEY|TRY|NO-TRY|ICONV|OCONV|REP)\s/;
    const rejectAff = /^(?:MAP|KEY|TRY|ICONV|OCONV|REP)\s+\d+$/;
    const lines = aff.split("\n").map((a) => a.replace(/#.*/, "")).map((a) => a.trim()).filter((a) => regSupportedAff.test(a)).filter((a) => !rejectAff.test(a));
    const defs = pipeSync(lines, opMapSync((line) => pipeSync(operations, opMapSync((fn) => fn(line, costs$1)), opMapSync(asArrayOf), opFlattenSync())), opFlattenSync(), opFilterSync(isDefined$1));
    return [...defs];
  }
  return parseAff(hunInfo.aff, costs);
}
function calcCosts(costs = {}, locale) {
  const useLocale = locale?.length ? locale.map((loc) => loc.locale) : void 0;
  const hunCosts = mapHunspellCosts(costs);
  const c = {
    ...hunCosts,
    locale: useLocale
  };
  return c;
}
var regExpMap = /^(?:MAP)\s+(\S+)$/;
function affMap(line, costs) {
  const m = line.match(regExpMap);
  if (!m) return void 0;
  const map3 = m[1];
  const cost = costs.mapCost;
  return {
    map: map3,
    replace: cost,
    swap: cost
  };
}
var regExpTry = /^(?:TRY)\s+(\S+)$/;
function affTry(line, costs) {
  const m = line.match(regExpTry);
  if (!m) return void 0;
  const cost = costs.tryCharCost;
  const tryChars = m[1];
  const characters = tryChars;
  return parseAlphabet({
    characters,
    cost
  }, costs.locale, costs);
}
function affTryFirstCharacterReplace(line, costs) {
  const m = line.match(regExpTry);
  if (!m) return void 0;
  const characters = m[1];
  const cost = costs.tryCharCost;
  return calcFirstCharacterReplace({
    characters,
    cost
  }, costs);
}
var regExpNoTry = /^NO-TRY\s+(\S+)$/;
function affNoTry(line, costs) {
  const m = line.match(regExpNoTry);
  if (!m) return void 0;
  const map3 = m[1];
  return {
    map: map3,
    insDel: Math.max(costs.nonAlphabetCosts - costs.tryCharCost, 0),
    penalty: costs.nonAlphabetCosts + costs.tryCharCost
  };
}
var regExpRepConv = /^(?:REP|(?:I|O)CONV)\s+(\S+)\s+(\S+)$/;
function affRepConv(line, costs) {
  const m = line.match(regExpRepConv);
  if (!m) return void 0;
  const cost = line.startsWith("REP") ? costs.replaceCosts : costs.ioConvertCost;
  const from = m[1];
  let into = m[2];
  into = into.replace(/^0$/, "");
  if (from.startsWith("^") && !into.startsWith("^")) into = "^" + into;
  if (from.endsWith("$") && !into.endsWith("$")) into = into + "$";
  return {
    map: joinLetters([from, into]),
    replace: cost
  };
}
var regExpKey = /^(?:KEY)\s+(\S+)$/;
function affKey(line, costs) {
  const m = line.match(regExpKey);
  if (!m) return void 0;
  const kbd = m[1];
  const pairs = [...splitMap(kbd)].map(reducer((p, v) => ({
    a: p.b,
    b: v
  }), {
    a: "|",
    b: "|"
  })).filter((ab) => ab.a !== "|" && ab.b !== "|").map(({ a, b }) => joinLetters([a, b]));
  const pairsUpper = pairs.map((p) => p.toLocaleUpperCase(costs.locale));
  const map3 = unique([...pairs, ...pairsUpper]).join("|");
  const cost = costs.keyboardCost;
  return {
    map: map3,
    replace: cost,
    swap: cost
  };
}
function affKeyCaps(line, costs) {
  const m = line.match(regExpKey);
  if (!m) return void 0;
  return parseCaps(m[1], costs);
}
function affMapCaps(line, costs) {
  const m = line.match(regExpMap);
  if (!m) return void 0;
  return parseCaps(m[1], costs);
}
function affTryAccents(line, costs) {
  const m = line.match(regExpTry);
  if (!m) return void 0;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function affMapAccents(line, costs) {
  const m = line.match(regExpMap);
  if (!m) return void 0;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function parseCaps(value, costs) {
  const locale = costs.locale;
  const letters = [...splitMap(value)].filter((a) => a !== "|");
  const withCases = letters.map((s) => caseForms(s, locale)).filter((forms$1) => forms$1.length > 1).map(joinLetters);
  const map3 = unique(withCases).join("|");
  const cost = costs.capsCosts;
  if (!map3) return void 0;
  return {
    map: map3,
    replace: cost
  };
}
function reducer(fn, initialVal) {
  let acc = initialVal;
  return (val, i) => acc = fn(acc, val, i);
}
function asArrayOf(v) {
  return Array.isArray(v) ? v : [v];
}
function mapDictionaryInformation(dictInfo) {
  const _locale = dictInfo.locale;
  const locale = _locale ? parseLocale(_locale).filter((loc) => loc.isValid()) : void 0;
  const locales = locale?.map((loc) => loc.locale);
  const costs = mapEditCosts(dictInfo.costs);
  const defsEC = dictInfo.suggestionEditCosts || [];
  const defsHI = dictInfo.hunspellInformation ? hunspellInformationToSuggestionCostDef(dictInfo.hunspellInformation, locale) : [];
  return [
    ...defsEC,
    ...processAlphabet(dictInfo.alphabet, locales, costs),
    ...processAccents(dictInfo.accents, costs),
    ...defsHI
  ];
}
function processAlphabet(alphabet, locale, editCost) {
  const csAlphabet = toCharSets(alphabet, "a-zA-Z", editCost.baseCost);
  return [...pipeSync(csAlphabet, opMapSync((cs) => parseAlphabet(cs, locale, editCost)), opFlattenSync()), ...calcFirstCharacterReplaceDefs(csAlphabet, editCost)];
}
function toCharSets(cs, defaultValue, cost, penalty) {
  cs = cs ?? defaultValue;
  if (!cs) return [];
  if (typeof cs === "string") cs = [{
    characters: cs,
    cost
  }];
  if (penalty !== void 0) cs.forEach((cs$1) => cs$1.penalty = penalty);
  return cs;
}
function processAccents(accents, editCost) {
  const cs = toCharSets(accents, "\u0300-\u0341", editCost.accentCosts);
  return cs.map((cs$1) => parseAccents(cs$1, editCost)).filter(isDefined$1);
}
function mapDictionaryInformationToAdjustment(dictInfo) {
  if (!dictInfo.adjustments) return [];
  return dictInfo.adjustments.map(mapAdjustment);
}
function mapAdjustment(adj) {
  const { id, regexp, penalty } = adj;
  return {
    id,
    regexp: new RegExp(regexp),
    penalty
  };
}
var defaultDefs = [{
  map: "1234567890-.",
  insDel: 1,
  penalty: 200
}];
var defaultAdjustments = [
  {
    id: "compound-case-change",
    regexp: /\p{Ll}∙\p{Lu}/gu,
    penalty: 1e3
  },
  {
    id: "short-compounds-1",
    regexp: /^[^∙]{0,2}(?=∙)|∙[^∙]{0,2}(?=∙|$)/gm,
    penalty: 100
  },
  {
    id: "short-compounds-3",
    regexp: /^[^∙]{3}(?=∙)|∙[^∙]{3}(?=∙|$)/gm,
    penalty: 50
  }
];
function mapDictionaryInformationToWeightMap(dictInfo) {
  const defs = [...mapDictionaryInformation(dictInfo), ...defaultDefs];
  const adjustments = mapDictionaryInformationToAdjustment(dictInfo);
  const map3 = createWeightMap(...defs);
  addAdjustment(map3, ...defaultAdjustments, ...adjustments);
  return map3;
}
var baseCost = opCosts.baseCost;
var swapCost = opCosts.swapCost;
var postSwapCost = swapCost - baseCost;
var mapSubCost = opCosts.visuallySimilar;
var maxCostScale = opCosts.wordLengthCostFactor;
var SymbolFrozenNode = Symbol();
var normalizeWord = (text) => text.normalize();
var normalizeWordForCaseInsensitive = (text) => {
  const t = text.toLowerCase();
  return [t, t.normalize("NFD").replaceAll(/\p{M}/gu, "")];
};
var RegExpSplit = /[\s,;]/g;
var _defaultOptions = {
  commentCharacter: LINE_COMMENT,
  optionalCompoundCharacter: OPTIONAL_COMPOUND_FIX,
  compoundCharacter: COMPOUND_FIX,
  forbiddenPrefix: FORBID_PREFIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  keepExactPrefix: IDENTITY_PREFIX,
  stripCaseAndAccents: true,
  stripCaseAndAccentsKeepDuplicate: false,
  stripCaseAndAccentsOnForbidden: false,
  split: false,
  splitKeepBoth: false,
  splitSeparator: RegExpSplit,
  keepOptionalCompoundCharacter: false
};
var defaultParseDictionaryOptions = Object.freeze(_defaultOptions);
var cSpellToolDirective = "cspell-dictionary:";
function createDictionaryLineParserMapper(options) {
  const _options = options || _defaultOptions;
  const { commentCharacter = _defaultOptions.commentCharacter, optionalCompoundCharacter: optionalCompound = _defaultOptions.optionalCompoundCharacter, compoundCharacter: compound = _defaultOptions.compoundCharacter, caseInsensitivePrefix: ignoreCase2 = _defaultOptions.caseInsensitivePrefix, forbiddenPrefix: forbidden = _defaultOptions.forbiddenPrefix, keepExactPrefix: keepCase = _defaultOptions.keepExactPrefix, splitSeparator = _defaultOptions.splitSeparator, splitKeepBoth = _defaultOptions.splitKeepBoth, stripCaseAndAccentsKeepDuplicate = _defaultOptions.stripCaseAndAccentsKeepDuplicate, stripCaseAndAccentsOnForbidden = _defaultOptions.stripCaseAndAccentsOnForbidden, keepOptionalCompoundCharacter = _defaultOptions.keepOptionalCompoundCharacter } = _options;
  let { stripCaseAndAccents = _defaultOptions.stripCaseAndAccents, split: split2 = _defaultOptions.split } = _options;
  function isString2(line) {
    return typeof line === "string";
  }
  function trim(line) {
    return line.trim();
  }
  function removeComments(line) {
    const idx$1 = line.indexOf(commentCharacter);
    if (idx$1 < 0) return line;
    const idxDirective = line.indexOf(cSpellToolDirective, idx$1);
    if (idxDirective >= 0) {
      const flags = line.slice(idxDirective).split(/[\s,;]/g).map((s) => s.trim()).filter((a) => !!a);
      for (const flag of flags) switch (flag) {
        case "split": {
          split2 = true;
          break;
        }
        case "no-split": {
          split2 = false;
          break;
        }
        case "no-generate-alternatives": {
          stripCaseAndAccents = false;
          break;
        }
        case "generate-alternatives": {
          stripCaseAndAccents = true;
          break;
        }
      }
    }
    return line.slice(0, idx$1).trim();
  }
  function filterEmptyLines(line) {
    return !!line;
  }
  function* mapOptionalPrefix(line) {
    if (line[0] === optionalCompound) {
      const t = line.slice(1);
      yield t;
      yield compound + t;
    } else yield line;
  }
  function* mapOptionalSuffix(line) {
    if (line.slice(-1) === optionalCompound) {
      const t = line.slice(0, -1);
      yield t;
      yield t + compound;
    } else yield line;
  }
  const doNotNormalizePrefix = /* @__PURE__ */ Object.create(null);
  [
    ignoreCase2,
    keepCase,
    '"'
  ].forEach((prefix) => doNotNormalizePrefix[prefix] = true);
  if (!stripCaseAndAccentsOnForbidden) doNotNormalizePrefix[forbidden] = true;
  function removeDoublePrefix(w) {
    return w.startsWith(ignoreCase2 + ignoreCase2) ? w.slice(1) : w;
  }
  function stripKeepCasePrefixAndQuotes(word) {
    word = word.replaceAll(/"(.*?)"/g, "$1");
    return word[0] === keepCase ? word.slice(1) : word;
  }
  function _normalize(word) {
    return normalizeWord(stripKeepCasePrefixAndQuotes(word));
  }
  function* mapNormalize(word) {
    const nWord = _normalize(word);
    const forms$1 = /* @__PURE__ */ new Set();
    forms$1.add(nWord);
    if (stripCaseAndAccents && !(word[0] in doNotNormalizePrefix)) for (const n of normalizeWordForCaseInsensitive(nWord)) (stripCaseAndAccentsKeepDuplicate || n !== nWord) && forms$1.add(ignoreCase2 + n);
    yield* forms$1;
  }
  function* splitWords2(lines) {
    for (const line of lines) {
      if (split2) {
        const lineEscaped = line.includes('"') ? line.replaceAll(/".*?"/g, (quoted) => " " + quoted.replaceAll(/(\s)/g, "\\$1") + " ") : line;
        const words = splitLine(lineEscaped, splitSeparator);
        yield* words.map((escaped) => escaped.replaceAll("\\", ""));
        if (!splitKeepBoth) continue;
      }
      yield line;
    }
  }
  function* splitLines(paragraphs) {
    for (const paragraph of paragraphs) yield* paragraph.split("\n");
  }
  const mapCompounds = keepOptionalCompoundCharacter ? [] : [opConcatMapSync(mapOptionalPrefix), opConcatMapSync(mapOptionalSuffix)];
  const processLines = opCombineSync(opFilterSync(isString2), splitLines, opMapSync(removeComments), splitWords2, opMapSync(trim), opFilterSync(filterEmptyLines), ...mapCompounds, opConcatMapSync(mapNormalize), opMapSync(removeDoublePrefix));
  return processLines;
}
function parseDictionaryLines(lines, options) {
  return createDictionaryLineParserMapper(options)(typeof lines === "string" ? [lines] : lines);
}
var RegExpToEncode = /\\([\s,;])/g;
var RegExpDecode = /<<(%[\da-f]{2})>>/gi;
function encodeLine(line) {
  return line.replaceAll(RegExpToEncode, (_, v) => "<<" + encodeURIComponent(v) + ">>");
}
function decodeLine(line) {
  return line.replaceAll(RegExpDecode, (_, v) => "\\" + decodeURIComponent(v));
}
function splitLine(line, regExp) {
  return encodeLine(line).split(regExp).map((line$1) => decodeLine(line$1));
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/text.js
var regExAllUpper = /^(?:\p{Lu}\p{M}?)+$/u;
var regExAccents = /\p{M}/gu;
function isUpperCase(word) {
  return !!regExAllUpper.test(word);
}
function ucFirst(word) {
  return word.slice(0, 1).toUpperCase() + word.slice(1);
}
function removeAccents(text) {
  return text.normalize("NFD").replaceAll(regExAccents, "");
}
function removeUnboundAccents(text) {
  return text.replaceAll(regExAccents, "");
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryMethods.js
var defaultNumSuggestions = 10;
function wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase2) {
  const forms2 = /* @__PURE__ */ new Set();
  word = word.normalize("NFC");
  const wordLc = word.toLowerCase();
  if (ignoreCase2) {
    if (isDictionaryCaseSensitive) {
      forms2.add(wordLc);
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  } else {
    if (isDictionaryCaseSensitive) {
      forms2.add(word);
      forms2.add(wordLc);
      if (isUpperCase(word)) {
        forms2.add(ucFirst(wordLc));
      }
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  }
  return forms2;
}
function wordSuggestForms(word) {
  word = word.normalize("NFC");
  const forms2 = /* @__PURE__ */ new Set([word]);
  const wordLc = word.toLowerCase();
  forms2.add(wordLc);
  return forms2;
}
var DEFAULT_HAS_OPTIONS = Object.freeze({});
function hasOptionToSearchOption(opt) {
  return canonicalSearchOptions(!opt ? DEFAULT_HAS_OPTIONS : opt);
}
var canonicalSearchOptionsMap = /* @__PURE__ */ new Map();
var knownCanonicalOptions = /* @__PURE__ */ new WeakMap();
function canonicalSearchOptions(opt) {
  const known = knownCanonicalOptions.get(opt);
  if (known)
    return known;
  const { ignoreCase: ignoreCase2, useCompounds } = opt;
  const foundLevel1Map = canonicalSearchOptionsMap.get(ignoreCase2);
  const useLevel1Map = foundLevel1Map || /* @__PURE__ */ new Map();
  if (!foundLevel1Map) {
    canonicalSearchOptionsMap.set(ignoreCase2, useLevel1Map);
  }
  const foundCanOpts = useLevel1Map.get(useCompounds);
  const canOpts = foundCanOpts || Object.freeze({ ignoreCase: ignoreCase2, useCompounds });
  if (!foundCanOpts) {
    useLevel1Map.set(useCompounds, canOpts);
  }
  knownCanonicalOptions.set(opt, canOpts);
  return canOpts;
}
function createWeightMapFromDictionaryInformation(di) {
  return di ? mapDictionaryInformationToWeightMap(di) : void 0;
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/CachingDictionary.js
var dictionaryCounter = 0;
var DefaultAutoCacheSize = 1e3;
var logRequests = false;
var log = [];
var startTime = performance.now();
var CachedDict = class {
  dict;
  options;
  name;
  id = ++dictionaryCounter;
  constructor(dict, options) {
    this.dict = dict;
    this.options = options;
    this.name = dict.name;
  }
  #has = autoCache((word) => this.dict.has(word, this.options), DefaultAutoCacheSize);
  has = logRequests ? (word) => {
    const time = performance.now() - startTime;
    const value = this.#has(word);
    log.push({ time, method: "has", word, value });
    return value;
  } : this.#has;
  isNoSuggestWord = autoCache((word) => this.dict.isNoSuggestWord(word, this.options), DefaultAutoCacheSize);
  isForbidden = autoCache((word) => this.dict.isForbidden(word), DefaultAutoCacheSize);
  getPreferredSuggestions = autoCache((word) => this.dict.getPreferredSuggestions?.(word), DefaultAutoCacheSize);
  suggest = (word, suggestOptions) => this.dict.suggest(word, suggestOptions);
  stats() {
    return {
      name: this.name,
      id: this.id,
      has: extractStats(this.#has),
      isNoSuggestWord: extractStats(this.isNoSuggestWord),
      isForbidden: extractStats(this.isForbidden),
      getPreferredSuggestions: extractStats(this.getPreferredSuggestions)
    };
  }
};
var knownDicts = /* @__PURE__ */ new Map();
function createCachingDictionary(dict, options) {
  options = canonicalSearchOptions(options);
  let knownOptions = knownDicts.get(options);
  if (!knownOptions) {
    knownOptions = /* @__PURE__ */ new WeakMap();
    knownDicts.set(options, knownOptions);
  }
  const known = knownOptions.get(dict);
  if (known)
    return known;
  const cached = new CachedDict(dict, options);
  knownOptions.set(dict, cached);
  return cached;
}
function enableLogging(enabled = !logRequests) {
  logRequests = enabled;
}
function getLog() {
  return log;
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/AutoResolve.js
function autoResolveWeak(map3, key, resolve5) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve5(key);
  map3.set(key, value);
  return value;
}
var AutoResolveWeakCache = class {
  map = /* @__PURE__ */ new WeakMap();
  get(k, resolve5) {
    return resolve5 ? autoResolveWeak(this.map, k, resolve5) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
};
function createAutoResolveWeakCache() {
  return new AutoResolveWeakCache();
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/util.js
function isDefined(v) {
  return v !== void 0;
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
var import_node_url = require("node:url");

// ../node_modules/.pnpm/fast-equals@5.2.2/node_modules/fast-equals/dist/esm/index.mjs
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular2(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    var cache5 = state.cache;
    var cachedA = cache5.get(a);
    var cachedB = cache5.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache5.set(a, b);
    cache5.set(b, a);
    var result = areItemsEqual(a, b, state);
    cache5.delete(a);
    cache5.delete(b);
    return result;
  };
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = Object.hasOwn || function(object, property) {
  return hasOwnProperty.call(object, property);
};
function sameValueZeroEqual(a, b) {
  return a === b || !a && !b && a !== a && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var keys = Object.keys;
function areArraysEqual(a, b, state) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areFunctionsEqual(a, b) {
  return a === b;
}
function areMapsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.entries();
  var aResult;
  var bResult;
  var index = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.entries();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      var aEntry = aResult.value;
      var bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a, b, state) {
  var properties = keys(a);
  var index = properties.length;
  if (keys(b).length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  var properties = getStrictProperties(a);
  var index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  var property;
  var descriptorA;
  var descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.values();
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.values();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var URL_TAG = "[object URL]";
var isArray = Array.isArray;
var isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var assign2 = Object.assign;
var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a) {
  var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areErrorsEqual2 = _a.areErrorsEqual, areFunctionsEqual2 = _a.areFunctionsEqual, areMapsEqual2 = _a.areMapsEqual, areNumbersEqual2 = _a.areNumbersEqual, areObjectsEqual2 = _a.areObjectsEqual, arePrimitiveWrappersEqual2 = _a.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, areTypedArraysEqual2 = _a.areTypedArraysEqual, areUrlsEqual2 = _a.areUrlsEqual;
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    var type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a, b, state);
      }
      return false;
    }
    var constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (isTypedArray != null && isTypedArray(a)) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    var tag = getTag(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig(_a) {
  var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;
  var config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,
    areUrlsEqual
  };
  if (createCustomConfig) {
    config = assign2({}, config, createCustomConfig(config));
  }
  if (circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual);
    var areMapsEqual$1 = createIsCircular(config.areMapsEqual);
    var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
    var areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign2({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare3) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare3(a, b, state);
  };
}
function createIsEqual(_a) {
  var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;
  if (createState) {
    return function isEqual(a, b) {
      var _a2 = createState(), _b = _a2.cache, cache5 = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta = _a2.meta;
      return comparator(a, b, {
        cache: cache5,
        equals,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  }
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function isEqual(a, b) {
    return comparator(a, b, state);
  };
}
var deepEqual = createCustomEqual();
var strictDeepEqual = createCustomEqual({ strict: true });
var circularDeepEqual = createCustomEqual({ circular: true });
var strictCircularDeepEqual = createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictShallowEqual = createCustomEqual({
  strict: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var circularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictCircularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: true
});
function createCustomEqual(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;
  var config = createEqualityComparatorConfig(options);
  var comparator = createEqualityComparator(config);
  var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/simpleCache.js
var SimpleWeakCache = class {
  size;
  L0 = /* @__PURE__ */ new WeakMap();
  L1 = /* @__PURE__ */ new WeakMap();
  L2 = /* @__PURE__ */ new WeakMap();
  sizeL0 = 0;
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.sizeL0 >= this.size) {
      this.rotate();
    }
    this.sizeL0 += 1;
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = /* @__PURE__ */ new WeakMap();
    this.sizeL0 = 0;
  }
};
var AutoWeakCache = class extends SimpleWeakCache {
  factory;
  constructor(factory, size) {
    super(size);
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== void 0)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
};
var SimpleCache = class {
  size;
  L0 = /* @__PURE__ */ new Map();
  L1 = /* @__PURE__ */ new Map();
  L2 = /* @__PURE__ */ new Map();
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = /* @__PURE__ */ new Map();
  }
};

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionary.js
var defaultOptions = Object.freeze({
  weightMap: void 0
});

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/clean.js
function clean2(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === void 0) {
      delete r[key];
    }
  }
  return r;
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/regexHelper.js
function escapeRegEx(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/repMap.js
function createMapper(repMap, ignoreCharset) {
  if (!repMap && !ignoreCharset)
    return (a) => a;
  repMap = repMap || [];
  const charsetMap = charsetToRepMapRegEx(ignoreCharset);
  if (charsetMap) {
    repMap = [...repMap, ...charsetMap];
  }
  const filteredMap = repMap.filter(([match2, _]) => !!match2);
  if (!filteredMap.length) {
    return (a) => a;
  }
  const regEx = createMapperRegExp(repMap);
  const values = repMap.filter(([match2, _]) => !!match2).map(([_, into]) => into);
  function resolve5(m, ...matches) {
    const index = matches.findIndex((a) => !!a);
    return 0 <= index && index < values.length ? values[index] : m;
  }
  return function(s) {
    return s.replace(regEx, resolve5);
  };
}
function charsetToRepMapRegEx(charset, replaceWith = "") {
  if (!charset)
    return void 0;
  return charset.split("|").map((chars) => `[${chars.replaceAll(/[\][\\]/g, "\\$&")}]`).map((map3) => [map3, replaceWith]);
}
function charsetToRepMap(charset, replaceWith = "") {
  if (!charset)
    return void 0;
  return charset.split("|").flatMap((chars) => [...expandCharacterSet(chars)]).map((char) => [char, replaceWith]);
}
function expandReplaceMap(repMap) {
  return repMap.flatMap(([from, replaceWith]) => from.split("|").map((w) => [w, replaceWith]));
}
function createMapperRegExp(repMap) {
  const filteredMap = repMap.filter(([match2, _]) => !!match2);
  if (!filteredMap.length) {
    return /$^/;
  }
  const regExStr = filteredMap.map(([from, _]) => from).map((s) => {
    try {
      const r = /\(/.test(s) ? s.replaceAll(/\((?=.*\))/g, "(?:").replaceAll("(?:?", "(?") : s;
      new RegExp(r);
      s = r;
    } catch {
      return escapeRegEx(s);
    }
    return s;
  }).map((s) => `(${s})`).join("|");
  const regEx = new RegExp(regExStr, "g");
  return regEx;
}
function createRepMapper(repMap, ignoreCharset) {
  if (!repMap && !ignoreCharset)
    return (word) => [word];
  const trie = createTrie(repMap, ignoreCharset);
  return (word) => {
    const edits = calcAllEdits(trie, word);
    return applyEdits(word, edits);
  };
}
function applyEdits(word, edits) {
  if (!edits.length)
    return [word];
  const letterEdits = [];
  for (let i = 0; i < word.length; ++i) {
    letterEdits[i] = { edits: [{ b: i, e: i + 1, r: word[i] }], suffixes: [] };
  }
  letterEdits[word.length] = { edits: [], suffixes: [""] };
  for (const edit of edits) {
    const le = letterEdits[edit.b];
    le.edits.push(edit);
  }
  for (let i = word.length - 1; i >= 0; --i) {
    const le = letterEdits[i];
    const sfx = le.suffixes;
    for (const edit of le.edits) {
      const pfx = edit.r;
      const nSfx = letterEdits[edit.e].suffixes;
      for (const s of nSfx) {
        sfx.push(pfx + s);
      }
    }
  }
  const results = new Set(letterEdits[0].suffixes);
  return [...results];
}
function calcAllEdits(root, word) {
  const edits = [];
  function walk(node, b, e) {
    if (node.rep) {
      node.rep.forEach((r) => edits.push({ b, e, r }));
    }
    if (e === word.length || !node.children)
      return;
    const n = node.children[word[e]];
    if (!n)
      return;
    walk(n, b, e + 1);
  }
  for (let i = 0; i < word.length; ++i) {
    walk(root, i, i);
  }
  return edits;
}
function createTrie(repMap, ignoreCharset) {
  const combined = [repMap, charsetToRepMap(ignoreCharset)].filter(isDefined).flat();
  const expanded = expandReplaceMap(combined);
  const trieRoot = /* @__PURE__ */ Object.create(null);
  expanded.forEach(([match2, replaceWith]) => addToTrie(trieRoot, match2, replaceWith));
  return trieRoot;
}
function addToTrie(node, match2, replaceWith) {
  while (match2) {
    const children = node.children || (node.children = /* @__PURE__ */ Object.create(null));
    const k = match2[0];
    const childNode = children[k] || (children[k] = /* @__PURE__ */ Object.create(null));
    node = childNode;
    match2 = match2.slice(1);
  }
  const s = new Set(node.rep || []);
  s.add(replaceWith);
  node.rep = [...s];
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/defaults.js
var ignoreCase = true;
var isForbiddenIgnoreCaseAndAccents = false;

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryFromTrie.js
var SpellingDictionaryFromTrie = class {
  trie;
  name;
  options;
  source;
  _size = 0;
  knownWords = /* @__PURE__ */ new Set();
  unknownWords = /* @__PURE__ */ new Set();
  mapWord;
  remapWord;
  type = "SpellingDictionaryFromTrie";
  isDictionaryCaseSensitive;
  containsNoSuggestWords;
  #ignoreForbiddenWords = false;
  #findWordOptionsCaseSensitive = { caseSensitive: true };
  #findWordOptionsNotCaseSensitive = { caseSensitive: false };
  weightMap;
  constructor(trie, name2, options, source = "from trie", size) {
    this.trie = trie;
    this.name = name2;
    this.options = options;
    this.source = source;
    this.mapWord = createMapper(options.repMap, options.dictionaryInformation?.ignore);
    this.remapWord = createRepMapper(options.repMap, options.dictionaryInformation?.ignore);
    this.isDictionaryCaseSensitive = options.caseSensitive ?? trie.isCaseAware;
    this.containsNoSuggestWords = options.noSuggest || false;
    this._size = size || 0;
    this.weightMap = options.weightMap || createWeightMapFromDictionaryInformation(options.dictionaryInformation);
    this.#ignoreForbiddenWords = !!options.ignoreForbiddenWords;
    if (this.#ignoreForbiddenWords) {
      this.#findWordOptionsCaseSensitive.checkForbidden = true;
      this.#findWordOptionsNotCaseSensitive.checkForbidden = true;
    }
  }
  get size() {
    if (!this._size) {
      const i = this.trie.iterate();
      let deeper = true;
      let size = 0;
      for (let r = i.next(); !r.done; r = i.next(deeper)) {
        size += 1;
        deeper = r.value.text.length < 5;
      }
      this._size = size;
    }
    return this._size;
  }
  has(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2);
    return r && !r.forbidden && !!r.found || false;
  }
  find(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2);
    const { forbidden = this.#isForbidden(word) } = r || {};
    if (this.#ignoreForbiddenWords && forbidden) {
      return void 0;
    }
    if (!r && !forbidden)
      return void 0;
    const { found = forbidden ? word : false } = r || {};
    const noSuggest = found !== false && this.containsNoSuggestWords;
    return { found, forbidden, noSuggest };
  }
  resolveOptions(hasOptions) {
    const { useCompounds = this.options.useCompounds, ignoreCase: ignoreCase2 = ignoreCase } = hasOptionToSearchOption(hasOptions);
    return { useCompounds, ignoreCase: ignoreCase2 };
  }
  _find = (word, useCompounds, ignoreCase2) => this.findAnyForm(word, useCompounds, ignoreCase2);
  findAnyForm(word, useCompounds, ignoreCase2) {
    const outerForms = outerWordForms(word, this.remapWord || ((word2) => [this.mapWord(word2)]));
    for (const form of outerForms) {
      const r = this._findAnyForm(form, useCompounds, ignoreCase2);
      if (r)
        return r;
    }
    return void 0;
  }
  _findAnyForm(mWord, useCompounds, ignoreCase2) {
    const opts = ignoreCase2 ? this.#findWordOptionsNotCaseSensitive : this.#findWordOptionsCaseSensitive;
    const findResult = this.trie.findWord(mWord, opts);
    if (findResult.found !== false) {
      return findResult;
    }
    const forms2 = wordSearchForms(mWord, this.isDictionaryCaseSensitive, ignoreCase2);
    for (const w of forms2) {
      const findResult2 = this.trie.findWord(w, opts);
      if (findResult2.found !== false) {
        return findResult2;
      }
    }
    if (useCompounds) {
      const optsUseCompounds = { ...opts, useLegacyWordCompounds: useCompounds };
      for (const w of forms2) {
        const findResult2 = this.trie.findWord(w, optsUseCompounds);
        if (findResult2.found !== false) {
          return findResult2;
        }
      }
    }
    return void 0;
  }
  isNoSuggestWord(word, options) {
    return this.containsNoSuggestWords ? this.has(word, options) : false;
  }
  isForbidden(word, _ignoreCaseAndAccents) {
    return this.#ignoreForbiddenWords ? false : this.#isForbidden(word, _ignoreCaseAndAccents);
  }
  #isForbidden(word, _ignoreCaseAndAccents) {
    return this.trie.isForbiddenWord(word);
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, includeTies, ignoreCase: ignoreCase2, timeout } = suggestOptions;
    function filter3(_word) {
      return true;
    }
    const collector = suggestionCollector(word, clean2({
      numSuggestions,
      filter: filter3,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout,
      weightMap: this.weightMap
    }));
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions.map((r) => ({ ...r, word: r.word }));
  }
  genSuggestions(collector, suggestOptions) {
    if (this.options.noSuggest)
      return;
    const _compoundMethod = suggestOptions.compoundMethod ?? (this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : CompoundWordsMethod.NONE);
    for (const w of wordSuggestForms(collector.word)) {
      this.trie.genSuggestions(impersonateCollector(collector, w), _compoundMethod);
    }
  }
  getErrors() {
    return [];
  }
};
function createSpellingDictionaryFromTrieFile(data, name2, source, options) {
  const trie = decodeTrie(data);
  return new SpellingDictionaryFromTrie(trie, name2, options, source);
}
function* outerWordForms(word, mapWord) {
  const sent = /* @__PURE__ */ new Set();
  let w = word;
  const ww = w;
  yield w;
  sent.add(w);
  w = word.normalize("NFC");
  if (w !== ww) {
    yield w;
    sent.add(w);
  }
  w = word.normalize("NFD");
  if (w !== ww && !sent.has(w)) {
    yield w;
    sent.add(w);
  }
  for (const f of sent) {
    for (const m of mapWord(f)) {
      if (m !== ww && !sent.has(m)) {
        yield m;
        sent.add(m);
      }
    }
  }
  return;
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
var cachedDictionaries = new AutoWeakCache(_createSpellingDictionary, 64);
var maxSetSize = 3;
var cachedParamsByWordList = new SimpleCache(64);
function createSpellingDictionary(wordList, name2, source, options) {
  const params = [wordList, name2, source.toString(), options];
  if (!Array.isArray(wordList)) {
    return _createSpellingDictionary(params);
  }
  const cached = cachedParamsByWordList.get(name2) || /* @__PURE__ */ new Set();
  for (const cachedParams of cached) {
    if (deepEqual(params, cachedParams)) {
      return cachedDictionaries.get(cachedParams);
    }
  }
  if (cached.size > maxSetSize)
    cached.clear();
  cached.add(params);
  cachedParamsByWordList.set(name2, cached);
  return cachedDictionaries.get(params);
}
function _createSpellingDictionary(params) {
  const [wordList, name2, source, options] = params;
  const parseOptions = { stripCaseAndAccents: options?.supportNonStrictSearches ?? true };
  const words = parseDictionaryLines(wordList, parseOptions);
  const trie = buildITrieFromWords(words);
  const opts = { ...options || defaultOptions };
  if (opts.weightMap === void 0 && opts.dictionaryInformation) {
    opts.weightMap = createWeightMapFromDictionaryInformation(opts.dictionaryInformation);
  }
  return new SpellingDictionaryFromTrie(trie, name2, opts, source);
}
function createFailedToLoadDictionary(name2, sourceUrl, error4, options) {
  const sourceHref = typeof sourceUrl === "string" ? sourceUrl : sourceUrl.href;
  const source = sourceHref.startsWith("file:") ? (0, import_node_url.fileURLToPath)(sourceUrl) : sourceHref;
  options = options || {};
  return {
    name: name2,
    source,
    type: "error",
    containsNoSuggestWords: false,
    has: () => false,
    find: () => void 0,
    isNoSuggestWord: () => false,
    isForbidden: () => false,
    suggest: () => [],
    mapWord: (a) => a,
    genSuggestions: () => {
      return;
    },
    size: 0,
    options,
    isDictionaryCaseSensitive: false,
    getErrors: () => [error4]
  };
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/util/textMappers.js
function* mapperRemoveCaseAndAccents(words) {
  for (const word of words) {
    const lc = word.toLowerCase();
    yield lc;
    const woAccents = removeAccents(lc);
    if (lc !== woAccents)
      yield woAccents;
  }
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
var import_node_assert2 = __toESM(require("node:assert"), 1);

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/util.js
function normalizeTyposDefValue(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return value;
  const unique2 = [...new Set(value)];
  return unique2.length > 1 ? unique2 : unique2.length === 1 ? unique2[0] : false;
}
function mergeDefEntry(targetDef, key, value) {
  const curValue = targetDef[key];
  if (!curValue) {
    targetDef[key] = normalizeTyposDefValue(value);
    return targetDef;
  }
  if (!value)
    return targetDef;
  const newValue = Array.isArray(curValue) ? curValue : [curValue];
  if (Array.isArray(value)) {
    newValue.push(...value);
  } else {
    newValue.push(value);
  }
  targetDef[key] = normalizeTyposDefValue(newValue);
  return targetDef;
}
function mergeDef(targetDef, fromDef) {
  for (const key of Object.keys(fromDef)) {
    mergeDefEntry(targetDef, key, fromDef[key]);
  }
  return targetDef;
}
function appendToDef(def, entry) {
  if (!entry)
    return def;
  if (typeof entry === "string") {
    if (!def[entry]) {
      def[entry] = false;
    }
    return def;
  }
  if (Array.isArray(entry)) {
    const [key, ...sugs] = entry.map((s2) => s2.trim());
    if (!key)
      return def;
    const s = sugs.map((s2) => s2.trim()).filter((s2) => !!s2);
    return mergeDefEntry(def, key, s);
  }
  return mergeDef(def, entry);
}
function createTyposDef(entries) {
  const def = /* @__PURE__ */ Object.create(null);
  if (!entries)
    return def;
  for (const [key, value] of entries) {
    def[key] = isDefined2(value) ? value : false;
  }
  return def;
}
function extractAllSuggestions(typosDef) {
  const allSugs = pipeSync(Object.values(typosDef), opFilterSync(hasSuggestions), opConcatMapSync((v) => Array.isArray(v) ? v : [v]));
  return new Set(allSugs);
}
function extractIgnoreValues(typosDef, ignorePrefix) {
  const pfxLen = ignorePrefix.length;
  return new Set(Object.keys(typosDef).filter((k) => k.startsWith(ignorePrefix)).map((k) => k.slice(pfxLen)));
}
function isDefined2(v) {
  return v !== void 0 && v !== null;
}
function isString(v) {
  return typeof v === "string";
}
function isArray2(v) {
  return Array.isArray(v);
}
function hasSuggestions(v) {
  return isString(v) || isArray2(v);
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
function assertString(v) {
  (0, import_node_assert2.default)(typeof v === "string", "A string was expected.");
  return true;
}
var suggestionsSeparator = /[,]/;
var typoSuggestionsSeparator = /:|->/;
var typoEntrySeparator = /[\n;]/;
function normalize2(s) {
  return s.normalize();
}
function trimAndFilter(lines) {
  return lines.map((s) => s.trim()).filter((s) => !!s).map(normalize2);
}
function cleanSugs(rawSugs) {
  const sugs = trimAndFilter(rawSugs);
  return sugs.length === 1 ? sugs[0] : sugs.length ? sugs : false;
}
function splitSuggestionsValue(value) {
  return cleanSugs(value.split(suggestionsSeparator));
}
function sanitizeIntoTypoDef(dirtyDef) {
  if (!dirtyDef || typeof dirtyDef !== "object")
    return void 0;
  const def = createTyposDef();
  for (const [rawKey, value] of Object.entries(dirtyDef)) {
    const key = normalize2(rawKey.trim());
    if (!key)
      continue;
    if (typeof value === "string") {
      def[key] = splitSuggestionsValue(value);
      continue;
    }
    if (Array.isArray(value)) {
      const sugs = cleanSugs(value.filter(assertString));
      def[key] = sugs;
      continue;
    }
    (0, import_node_assert2.default)(value === false, "Unexpected suggestion type.");
    def[key] = false;
  }
  return def;
}
function processEntriesToTyposDef(entries) {
  const def = isIterable3(entries) ? reduceToTyposDef(entries) : entries;
  const result = sanitizeIntoTypoDef(def);
  (0, import_node_assert2.default)(result);
  return result;
}
function reduceToTyposDef(entries) {
  const def = createTyposDef();
  for (const entry of entries) {
    appendToDef(def, parseTyposLine(entry));
  }
  return def;
}
function parseTyposLine(line) {
  if (!line)
    return void 0;
  if (typeof line === "string") {
    const def = createTyposDef();
    for (const subEntry of splitIntoLines(line)) {
      const [left, right] = splitEntry(subEntry);
      const typo = left.trim();
      if (!right)
        return typo;
      const sugs = splitSuggestionsValue(right);
      def[typo] = sugs;
    }
    return def;
  }
  if (Array.isArray(line)) {
    const [key, ...sugs] = line.filter(assertString).map((s) => s.trim());
    if (!key)
      return void 0;
    return [key, ...sugs];
  }
  return sanitizeIntoTypoDef(line);
}
function splitIntoLines(content) {
  return trimAndFilter(normalize2(content).split(typoEntrySeparator));
}
function splitEntry(line) {
  return line.split(typoSuggestionsSeparator, 2);
}
function isIterable3(v) {
  return Symbol.iterator in v;
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/TyposDictionary.js
var TyposDictionaryImpl = class {
  name;
  source;
  typosDef;
  containsNoSuggestWords;
  options = {};
  type = "typos";
  size;
  ignoreWords;
  /**
   * Note: ignoreWordsLower is only suggestions with the case and accents removed.
   * The logic is that if someone explicity ignored an upper case version, it does not
   * mean that the lower case version is ok.
   */
  suggestions;
  suggestionsLower;
  explicitIgnoreWords;
  constructor(name2, source, typosDef, ignoreList) {
    this.name = name2;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.explicitIgnoreWords = extractIgnoreValues(typosDef, "!");
    this.suggestions = extractAllSuggestions(typosDef);
    this.ignoreWords = new Set(pipeSync(this.explicitIgnoreWords, opAppendSync(ignoreList || [])));
    this.suggestionsLower = new Set(pipeSync(this.suggestions, mapperRemoveCaseAndAccents));
    this.containsNoSuggestWords = this.ignoreWords.size > 0;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    const result = this._findForms(word, options?.ignoreCase ?? ignoreCase);
    if (result === false)
      return void 0;
    const { found, ignore } = result;
    return { found, forbidden: !ignore, noSuggest: ignore };
  }
  _findForms(word, ignoreCaseAndAccents) {
    const lcWord = word.toLowerCase();
    if (this.ignoreWords.has(word)) {
      return { found: word, ignore: true };
    }
    if (this.suggestions.has(word)) {
      return false;
    }
    if (ignoreCaseAndAccents) {
      if (this.suggestionsLower.has(lcWord)) {
        return false;
      }
      if (this.ignoreWords.has(lcWord)) {
        return { found: lcWord, ignore: true };
      }
    }
    if (word in this.typosDef)
      return { found: word, ignore: false };
    if (lcWord in this.typosDef)
      return { found: lcWord, ignore: false };
    return false;
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const found = this._findForms(word, ignoreCaseAndAccents);
    return found !== false && !found.ignore;
  }
  isNoSuggestWord(word, options) {
    const result = this.find(word, options);
    return result?.noSuggest ?? false;
  }
  /**
   * Determine if the word can appear in a list of suggestions.
   * @param word - word
   * @param ignoreCaseAndAccents - ignore case.
   * @returns true if a word is suggested, otherwise false.
   */
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    const lcWord = word.toLowerCase();
    return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (this.ignoreWords.has(word))
      return [];
    if (!(word in this.typosDef))
      return void 0;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  mapWord(word) {
    return word;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache = createAutoResolveWeakCache();
function createTyposDictionary(entries, name2, source) {
  return createCache.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new TyposDictionaryImpl(name2, source, def);
  });
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/FlagWordsDictionary.js
var FlagWordsDictionaryTrie = class extends SpellingDictionaryFromTrie {
  name;
  source;
  containsNoSuggestWords = false;
  options = {};
  constructor(trie, name2, source) {
    super(trie, name2, defaultOptions, source);
    this.name = name2;
    this.source = source;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  find(word, hasOptions) {
    const f = super.find(word, hasOptions);
    if (!f || !f.forbidden)
      return void 0;
    return f;
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  isDictionaryCaseSensitive = true;
};
var FlagWordsDictionary = class {
  name;
  source;
  dictTypos;
  dictTrie;
  containsNoSuggestWords = false;
  options = {};
  type = "flag-words";
  constructor(name2, source, dictTypos, dictTrie) {
    this.name = name2;
    this.source = source;
    this.dictTypos = dictTypos;
    this.dictTrie = dictTrie;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param word - the word
   * @param options - options
   * @returns always false
   */
  has(word, options) {
    return this.dictTypos.has(word, options) || this.dictTrie?.has(word, options) || false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    const findTypos = this.dictTypos.find(word, options);
    if (findTypos)
      return findTypos;
    const ignoreCase2 = options?.ignoreCase ?? ignoreCase;
    if (this.dictTypos.isSuggestedWord(word, ignoreCase2))
      return void 0;
    return this.dictTrie?.find(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const findResult = this.find(word, { ignoreCase: ignoreCaseAndAccents });
    return findResult?.forbidden || false;
  }
  isNoSuggestWord(word, options) {
    return this.dictTrie?.isNoSuggestWord(word, options) || this.dictTypos.isNoSuggestWord(word, options);
  }
  suggest(word, suggestOptions = {}) {
    return this.dictTypos.suggest(word, suggestOptions);
  }
  getPreferredSuggestions(word) {
    return this.dictTypos.getPreferredSuggestions(word);
  }
  genSuggestions() {
    return;
  }
  mapWord(word) {
    return word;
  }
  get size() {
    return this.dictTypos.size + (this.dictTrie?.size || 0);
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache2 = createAutoResolveWeakCache();
function createFlagWordsDictionary(wordList, name2, source) {
  return createCache2.get(wordList, () => {
    const testSpecialCharacters = /[~*+]/;
    const { t: specialWords, f: typoWords } = bisect(parseDictionaryLines(wordList, { stripCaseAndAccents: false }), (line) => testSpecialCharacters.test(line));
    const trieDict = specialWords.size ? buildTrieDict(specialWords, name2, source) : void 0;
    const typosDict = createTyposDictionary(typoWords, name2, source);
    if (!trieDict)
      return typosDict;
    return new FlagWordsDictionary(name2, source, typosDict, trieDict);
  });
}
var regExpCleanIgnore = /^(!!)+/;
function buildTrieDict(words, name2, source) {
  const trie = buildITrieFromWords(pipeSync(words, opMapSync((w) => "!" + w), opMapSync((w) => w.replace(regExpCleanIgnore, ""))));
  return new FlagWordsDictionaryTrie(trie, name2, source);
}
function bisect(values, predicate) {
  const t = /* @__PURE__ */ new Set();
  const f = /* @__PURE__ */ new Set();
  for (const v of values) {
    if (predicate(v)) {
      t.add(v);
    } else {
      f.add(v);
    }
  }
  return { t, f };
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/IgnoreWordsDictionary.js
var NormalizeForm = "NFC";
var IgnoreWordsDictionary = class {
  name;
  source;
  dict;
  dictNonStrict;
  containsNoSuggestWords = true;
  options = {};
  type = "ignore";
  constructor(name2, source, words) {
    this.name = name2;
    this.source = source;
    this.dict = new Set(words);
    this.dictNonStrict = new Set(pipeSync(this.dict, opFilterSync((w) => w.startsWith("~")), opMapSync((w) => w.slice(1))));
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(word, options) {
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return true;
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return true;
    const ignoreCase2 = options?.ignoreCase ?? ignoreCase;
    return ignoreCase2 && (this.dictNonStrict.has(nWord) || this.dictNonStrict.has(lcWord));
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return { found: lcWord, forbidden: false, noSuggest: true };
    const ignoreCase2 = options?.ignoreCase ?? ignoreCase;
    if (!ignoreCase2)
      return void 0;
    if (this.dictNonStrict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    return this.dictNonStrict.has(lcWord) && { found: lcWord, forbidden: false, noSuggest: true } || void 0;
  }
  isForbidden(_word, _ignoreCase) {
    return false;
  }
  isNoSuggestWord(word, options) {
    return this.has(word, options);
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  mapWord(word) {
    return word;
  }
  get size() {
    return this.dict.size;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache3 = createAutoResolveWeakCache();
function createIgnoreWordsDictionary(wordList, name2, source, options) {
  return createCache3.get(wordList, () => {
    const testSpecialCharacters = /[*+]/;
    const parseOptions = { stripCaseAndAccents: options?.supportNonStrictSearches ?? true };
    const words = [...parseDictionaryLines(wordList, parseOptions)].map((w) => w.normalize(NormalizeForm));
    const hasSpecial = words.some((word) => testSpecialCharacters.test(word));
    if (hasSpecial) {
      return createSpellingDictionary(words, name2, source, {
        caseSensitive: true,
        noSuggest: true,
        weightMap: void 0,
        supportNonStrictSearches: true
      });
    }
    return new IgnoreWordsDictionary(name2, source, words);
  });
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryCollection.js
function identityString(w) {
  return w;
}
var SpellingDictionaryCollectionImpl = class {
  dictionaries;
  name;
  options = { weightMap: void 0 };
  mapWord = identityString;
  type = "SpellingDictionaryCollection";
  source;
  isDictionaryCaseSensitive;
  containsNoSuggestWords;
  constructor(dictionaries, name2, source) {
    this.dictionaries = dictionaries;
    this.name = name2;
    this.dictionaries = this.dictionaries.sort((a, b) => b.size - a.size);
    this.source = source || dictionaries.map((d) => d.name).join(", ");
    this.isDictionaryCaseSensitive = this.dictionaries.reduce((a, b) => a || b.isDictionaryCaseSensitive, false);
    this.containsNoSuggestWords = this.dictionaries.reduce((a, b) => a || b.containsNoSuggestWords, false);
  }
  has(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return !!isWordInAnyDictionary(this.dictionaries, word, options) && !this.isForbidden(word);
  }
  find(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return findInAnyDictionary(this.dictionaries, word, options);
  }
  isNoSuggestWord(word, options) {
    return this._isNoSuggestWord(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents) {
    const ignoreCase2 = ignoreCaseAndAccents ?? isForbiddenIgnoreCaseAndAccents;
    return !!this._isForbiddenInDict(word, ignoreCase2) && !this.isNoSuggestWord(word, { ignoreCase: ignoreCase2 });
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, ignoreCase: ignoreCase2, includeTies, timeout } = suggestOptions;
    const prefixNoCase = CASE_INSENSITIVE_PREFIX;
    const filter3 = (word2, _cost) => {
      return (ignoreCase2 || word2[0] !== prefixNoCase) && !this.isForbidden(word2) && !this.isNoSuggestWord(word2, suggestOptions);
    };
    const collectorOptions = {
      numSuggestions,
      filter: filter3,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout
    };
    const collector = suggestionCollector(word, collectorOptions);
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions;
  }
  get size() {
    return this.dictionaries.reduce((a, b) => a + b.size, 0);
  }
  getPreferredSuggestions(word) {
    const sugs = this.dictionaries.flatMap((dict) => dict.getPreferredSuggestions?.(word)).filter(isDefined);
    if (sugs.length <= 1)
      return sugs;
    const unique2 = /* @__PURE__ */ new Set();
    return sugs.filter((sug) => {
      if (unique2.has(sug.word))
        return false;
      unique2.add(sug.word);
      return true;
    });
  }
  genSuggestions(collector, suggestOptions) {
    const _suggestOptions = { ...suggestOptions };
    const { compoundMethod = CompoundWordsMethod.SEPARATE_WORDS } = suggestOptions;
    _suggestOptions.compoundMethod = this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : compoundMethod;
    this.dictionaries.forEach((dict) => dict.genSuggestions(collector, _suggestOptions));
  }
  getErrors() {
    return this.dictionaries.reduce((errors, dict) => [...errors, ...dict.getErrors?.() || []], []);
  }
  _isForbiddenInDict(word, ignoreCase2) {
    return isWordForbiddenInAnyDictionary(this.dictionaries, word, ignoreCase2);
  }
  _isNoSuggestWord = (word, options) => {
    if (!this.containsNoSuggestWords)
      return false;
    return !!isNoSuggestWordInAnyDictionary(this.dictionaries, word, options || {});
  };
};
function createCollection(dictionaries, name2, source) {
  return new SpellingDictionaryCollectionImpl(dictionaries, name2, source);
}
function isWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.has(word, options));
}
function findInAnyDictionary(dicts, word, options) {
  const found = dicts.map((dict) => dict.find(word, options)).filter(isDefined);
  if (!found.length)
    return void 0;
  return found.reduce((a, b) => ({
    found: a.forbidden ? a.found : b.forbidden ? b.found : a.found || b.found,
    forbidden: a.forbidden || b.forbidden,
    noSuggest: a.noSuggest || b.noSuggest
  }));
}
function isNoSuggestWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.isNoSuggestWord(word, options));
}
function isWordForbiddenInAnyDictionary(dicts, word, ignoreCase2) {
  return dicts.find((dict) => dict.isForbidden(word, ignoreCase2));
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/SuggestDictionary.js
var SuggestDictionaryImpl = class {
  name;
  source;
  typosDef;
  containsNoSuggestWords = false;
  options = {};
  type = "suggest";
  size;
  /**
   * Note: ignoreWordsLower is only suggestions with the case and accents removed.
   * The logic is that if someone explicity ignored an upper case version, it does not
   * mean that the lower case version is ok.
   */
  suggestions;
  suggestionsLower;
  constructor(name2, source, typosDef) {
    this.name = name2;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.suggestions = extractAllSuggestions(typosDef);
    this.suggestionsLower = new Set(pipeSync(this.suggestions, mapperRemoveCaseAndAccents));
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(_word, _options) {
    return void 0;
  }
  isForbidden(_word, _ignoreCaseAndAccents) {
    return false;
  }
  isNoSuggestWord(_word, _options) {
    return false;
  }
  /**
   * Determine if the word can appear in a list of suggestions.
   * @param word - word
   * @param ignoreCaseAndAccents - ignore case.
   * @returns true if a word is suggested, otherwise false.
   */
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    if (!ignoreCaseAndAccents)
      return false;
    const lcWord = word.toLowerCase();
    return this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord);
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (!(word in this.typosDef))
      return void 0;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  mapWord(word) {
    return word;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache4 = createAutoResolveWeakCache();
function createSuggestDictionary(entries, name2, source) {
  return createCache4.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new SuggestDictionaryImpl(name2, source, def);
  });
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/SpellingDictionary/createInlineSpellingDictionary.js
var cache = createAutoResolveWeakCache();
function createInlineSpellingDictionary(inlineDict, source) {
  return cache.get(inlineDict, () => {
    const { words, flagWords, ignoreWords, suggestWords, name: name2, supportNonStrictSearches } = inlineDict;
    const options = { supportNonStrictSearches };
    const dictSources = [
      words && createSpellingDictionary(words, name2 + "-words", source, inlineDict),
      flagWords && createFlagWordsDictionary(flagWords, name2 + "-flag-words", source),
      ignoreWords && createIgnoreWordsDictionary(ignoreWords, name2 + "-ignore-words", source, options),
      suggestWords && createSuggestDictionary(suggestWords, name2 + "-suggest", source)
    ].filter(isDefined);
    return createCollection(dictSources, name2, source);
  });
}

// ../node_modules/.pnpm/cspell-dictionary@9.1.5/node_modules/cspell-dictionary/dist/index.js
var _debug = {
  cacheDictionaryEnableLogging: enableLogging,
  cacheDictionaryGetLog: getLog
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/DictionarySettings.js
var path6 = __toESM(require("node:path"), 1);

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/util.js
var uniqueFn = uniqueFilterFnGenerator;
function uniqueFilterFnGenerator(extractFn) {
  const values = /* @__PURE__ */ new Set();
  const extractor = extractFn || ((a) => a);
  return (v) => {
    const vv = extractor(v);
    const ret = !values.has(vv);
    values.add(vv);
    return ret;
  };
}
function clean3(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === void 0 || r[key] === null) {
      delete r[key];
    }
  }
  return r;
}
function scanMap(accFn, init) {
  let acc = init;
  let first3 = true;
  return function(value) {
    if (first3 && acc === void 0) {
      first3 = false;
      acc = value;
      return acc;
    }
    acc = accFn(acc, value);
    return acc;
  };
}
function isDefined3(v) {
  return v !== void 0;
}
function isArrayEqual(a, b) {
  if (a === b)
    return true;
  let isMatch = a.length === b.length;
  for (let i = 0; i < a.length && isMatch; ++i) {
    isMatch = a[i] === b[i];
  }
  return isMatch;
}
function doSetsIntersect(a, b) {
  function compare3(a2, b2) {
    for (const item of a2) {
      if (b2.has(item))
        return true;
    }
    return false;
  }
  return a.size <= b.size ? compare3(a, b) : compare3(b, a);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Models/CSpellSettingsInternalDef.js
var SymbolCSpellSettingsInternal = Symbol("CSpellSettingsInternal");
function cleanCSpellSettingsInternal(parts) {
  return parts ? Object.assign(clean3(parts), { [SymbolCSpellSettingsInternal]: true }) : { [SymbolCSpellSettingsInternal]: true };
}
function createCSpellSettingsInternal(parts) {
  return cleanCSpellSettingsInternal({ ...parts });
}
function isCSpellSettingsInternal(cs) {
  return !!cs[SymbolCSpellSettingsInternal];
}
function isDictionaryDefinitionInlineInternal(def) {
  if (def.path)
    return false;
  const defInline = def;
  return !!(defInline.words || defInline.flagWords || defInline.ignoreWords || defInline.suggestWords);
}
function isDictionaryFileDefinitionInternal(def) {
  return !!(def.path || def.file);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/AutoResolve.js
function autoResolve(map3, key, resolve5) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve5(key);
  map3.set(key, value);
  return value;
}
var CacheStatsTracker = class {
  hits = 0;
  misses = 0;
  resolved = 0;
  deletes = 0;
  sets = 0;
  clears = 0;
  disposals = 0;
  stats() {
    return {
      hits: this.hits,
      misses: this.misses,
      resolved: this.resolved,
      deletes: this.deletes,
      sets: this.sets,
      clears: this.clears,
      disposals: this.disposals
    };
  }
  clear() {
    this.hits = 0;
    this.misses = 0;
    this.resolved = 0;
    this.deletes = 0;
    this.sets = 0;
    ++this.clears;
  }
};
var AutoResolveCache = class {
  map = /* @__PURE__ */ new Map();
  get(k, resolve5) {
    return resolve5 ? autoResolve(this.map, k, resolve5) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
  delete(k) {
    return this.map.delete(k);
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    this.clear();
  }
};
function createAutoResolveCache() {
  return new AutoResolveCache();
}
function autoResolveWeak2(map3, key, resolve5) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve5(key);
  map3.set(key, value);
  return value;
}
var AutoResolveWeakCache2 = class {
  _map = /* @__PURE__ */ new WeakMap();
  _stats = new CacheStatsTracker();
  get(k, resolve5) {
    const map3 = this._map;
    const found = map3.get(k);
    if (found !== void 0 || map3.has(k)) {
      ++this._stats.hits;
      return found;
    }
    ++this._stats.misses;
    if (!resolve5) {
      return void 0;
    }
    ++this._stats.resolved;
    const value = resolve5(k);
    map3.set(k, value);
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    return this._map.has(k);
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, v);
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = /* @__PURE__ */ new WeakMap();
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
};
function createAutoResolveWeakCache2() {
  return new AutoResolveWeakCache2();
}
var AutoResolveWeakWeakCache = class {
  _map = /* @__PURE__ */ new WeakMap();
  _stats = new CacheStatsTracker();
  get(k, resolve5) {
    const map3 = this._map;
    const found = map3.get(k);
    const foundValue = found?.deref();
    if (found !== void 0 && foundValue) {
      ++this._stats.hits;
      return foundValue;
    }
    ++this._stats.misses;
    if (!resolve5) {
      if (found) {
        map3.delete(k);
      }
      return void 0;
    }
    ++this._stats.resolved;
    const value = resolve5(k);
    map3.set(k, new WeakRef(value));
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    return !!this._map.get(k)?.deref();
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, new WeakRef(v));
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = /* @__PURE__ */ new WeakMap();
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
};
function createAutoResolveWeakWeakCache() {
  return new AutoResolveWeakWeakCache();
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/resolveFile.js
var import_node_module2 = require("node:module");
var os3 = __toESM(require("node:os"), 1);
var path5 = __toESM(require("node:path"), 1);
var import_node_url8 = require("node:url");

// ../node_modules/.pnpm/global-directory@4.0.1/node_modules/global-directory/index.js
var import_node_process2 = __toESM(require("node:process"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_node_os3 = __toESM(require("node:os"), 1);
var import_node_fs = __toESM(require("node:fs"), 1);
var import_ini = __toESM(require_ini(), 1);
var isWindows = import_node_process2.default.platform === "win32";
var readRc = (filePath) => {
  try {
    return import_ini.default.parse(import_node_fs.default.readFileSync(filePath, "utf8")).prefix;
  } catch {
  }
};
var getEnvNpmPrefix = () => Object.keys(import_node_process2.default.env).reduce((prefix, name2) => /^npm_config_prefix$/i.test(name2) ? import_node_process2.default.env[name2] : prefix, void 0);
var getGlobalNpmrc = () => {
  if (isWindows && import_node_process2.default.env.APPDATA) {
    return import_node_path.default.join(import_node_process2.default.env.APPDATA, "/npm/etc/npmrc");
  }
  if (import_node_process2.default.execPath.includes("/Cellar/node")) {
    const homebrewPrefix = import_node_process2.default.execPath.slice(0, import_node_process2.default.execPath.indexOf("/Cellar/node"));
    return import_node_path.default.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
  }
  if (import_node_process2.default.execPath.endsWith("/bin/node")) {
    const installDir = import_node_path.default.dirname(import_node_path.default.dirname(import_node_process2.default.execPath));
    return import_node_path.default.join(installDir, "/etc/npmrc");
  }
};
var getDefaultNpmPrefix = () => {
  if (isWindows) {
    const { APPDATA } = import_node_process2.default.env;
    return APPDATA ? import_node_path.default.join(APPDATA, "npm") : import_node_path.default.dirname(import_node_process2.default.execPath);
  }
  return import_node_path.default.dirname(import_node_path.default.dirname(import_node_process2.default.execPath));
};
var getNpmPrefix = () => {
  const envPrefix = getEnvNpmPrefix();
  if (envPrefix) {
    return envPrefix;
  }
  const homePrefix = readRc(import_node_path.default.join(import_node_os3.default.homedir(), ".npmrc"));
  if (homePrefix) {
    return homePrefix;
  }
  if (import_node_process2.default.env.PREFIX) {
    return import_node_process2.default.env.PREFIX;
  }
  const globalPrefix = readRc(getGlobalNpmrc());
  if (globalPrefix) {
    return globalPrefix;
  }
  return getDefaultNpmPrefix();
};
var npmPrefix = import_node_path.default.resolve(getNpmPrefix());
var getYarnWindowsDirectory = () => {
  if (isWindows && import_node_process2.default.env.LOCALAPPDATA) {
    const dir = import_node_path.default.join(import_node_process2.default.env.LOCALAPPDATA, "Yarn");
    if (import_node_fs.default.existsSync(dir)) {
      return dir;
    }
  }
  return false;
};
var getYarnPrefix = () => {
  if (import_node_process2.default.env.PREFIX) {
    return import_node_process2.default.env.PREFIX;
  }
  const windowsPrefix = getYarnWindowsDirectory();
  if (windowsPrefix) {
    return windowsPrefix;
  }
  const configPrefix = import_node_path.default.join(import_node_os3.default.homedir(), ".config/yarn");
  if (import_node_fs.default.existsSync(configPrefix)) {
    return configPrefix;
  }
  const homePrefix = import_node_path.default.join(import_node_os3.default.homedir(), ".yarn-config");
  if (import_node_fs.default.existsSync(homePrefix)) {
    return homePrefix;
  }
  return npmPrefix;
};
var globalDirectory = {};
globalDirectory.npm = {};
globalDirectory.npm.prefix = npmPrefix;
globalDirectory.npm.packages = import_node_path.default.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules");
globalDirectory.npm.binaries = isWindows ? npmPrefix : import_node_path.default.join(npmPrefix, "bin");
var yarnPrefix = import_node_path.default.resolve(getYarnPrefix());
globalDirectory.yarn = {};
globalDirectory.yarn.prefix = yarnPrefix;
globalDirectory.yarn.packages = import_node_path.default.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules");
globalDirectory.yarn.binaries = import_node_path.default.join(globalDirectory.yarn.packages, ".bin");
var global_directory_default = globalDirectory;

// ../node_modules/.pnpm/@cspell+cspell-resolver@9.1.5/node_modules/@cspell/cspell-resolver/dist/resolveGlobal.mjs
var import_requireResolve = __toESM(require_requireResolve(), 1);
function resolveGlobal(modulesName) {
  const paths = [global_directory_default.npm.packages, global_directory_default.yarn.packages];
  return (0, import_requireResolve.requireResolve)(modulesName, paths);
}

// ../node_modules/.pnpm/@cspell+dynamic-import@9.1.5/node_modules/@cspell/dynamic-import/dist/esm/dynamicImport.mjs
var import_node_fs4 = require("node:fs");
var import_node_path5 = require("node:path");

// ../node_modules/.pnpm/@cspell+url@9.1.5/node_modules/@cspell/url/dist/index.js
var import_node_assert3 = __toESM(require("node:assert"), 1);
var import_node_path2 = __toESM(require("node:path"), 1);
var import_node_url2 = require("node:url");
var isURLRegEx = /^(\w[\w-]{1,63}:\/|data:|stdin:)/i;
function toURL(url2, relativeTo) {
  return normalizeWindowsUrl(url2 instanceof URL ? url2 : new URL(url2, relativeTo));
}
function urlParent(url2) {
  url2 = toURL(url2);
  if (url2.protocol === "data:") return url2;
  const hasTrailingSlash = url2.pathname.endsWith("/");
  if (!url2.pathname.startsWith("/")) {
    if (!url2.pathname) return url2;
    const parts = url2.pathname.split("/").slice(0, hasTrailingSlash ? -2 : -1);
    const pathname = parts.join("/") + "/";
    return new URL(url2.protocol + (url2.host ? "//" + url2.host : "") + pathname + url2.search + url2.hash);
  }
  return new URL(hasTrailingSlash ? ".." : ".", url2);
}
var urlDirname = urlParent;
function basenameOfUrlPathname(path17) {
  const adj = path17.endsWith("/") ? 2 : 0;
  const idx2 = path17.lastIndexOf("/", path17.length - adj);
  return idx2 >= 0 ? path17.slice(idx2 + 1) : path17;
}
function isUrlLike(filename) {
  return filename instanceof URL || isURLRegEx.test(filename);
}
function hasProtocol(url2, protocol) {
  protocol = protocol.endsWith(":") ? protocol : protocol + ":";
  return typeof url2 === "string" ? url2.startsWith(protocol) : url2.protocol === protocol;
}
function addTrailingSlash(url2) {
  if (url2.pathname.endsWith("/")) return url2;
  const urlWithSlash = new URL(url2.href);
  urlWithSlash.pathname += "/";
  return urlWithSlash;
}
function urlRelative(urlFrom, urlTo) {
  return urlToUrlRelative(toURL(urlFrom), toURL(urlTo));
}
function urlToUrlRelative(urlFrom, urlTo) {
  let pFrom = urlFrom.pathname;
  const pTo = urlTo.pathname;
  if (pFrom === pTo) return "";
  pFrom = pFrom.endsWith("/") ? pFrom : new URL("./", urlFrom).pathname;
  if (pTo.startsWith(pFrom)) return decodeURIComponent(pTo.slice(pFrom.length));
  const p0 = pFrom;
  const p1 = pTo;
  if (p1.startsWith(p0)) return decodeURIComponent(p0 === p1 ? "" : p1.slice(p0.lastIndexOf("/") + 1));
  const p0Parts = p0.split("/").slice(0, -1);
  const p1Parts = p1.split("/");
  let i = 0;
  for (i = 0; i < p0Parts.length && i < p1Parts.length - 1 && p0Parts[i] === p1Parts[i]; ++i) ;
  const rel = "../".repeat(p0Parts.length - i) + p1Parts.slice(i).join("/");
  return decodeURIComponent(rel.length < p1.length ? rel : p1);
}
var regExpWindowsPath = /^[\\/]([a-zA-Z]:[\\/])/;
var badUncLocalhostUrl = /^(\/+[a-zA-Z])\$/;
function normalizeWindowsUrl(url2) {
  url2 = typeof url2 === "string" ? new URL(url2) : url2;
  if (url2.protocol === "file:") {
    let pathname = url2.pathname.replaceAll("%3A", ":").replaceAll("%3a", ":").replaceAll("%24", "$");
    if (!url2.host) pathname = pathname.replace(badUncLocalhostUrl, "$1:");
    pathname = pathname.replace(regExpWindowsPath, (d) => d.toUpperCase());
    if (pathname !== url2.pathname) {
      url2 = new URL(url2);
      url2.pathname = pathname;
      return fixUncUrl(url2);
    }
  }
  return fixUncUrl(url2);
}
function fixUncUrl(url2) {
  if (url2.href.startsWith("file:////")) return new URL(url2.href.replace(/^file:\/{4}/, "file://"));
  return url2;
}
var regMatchFilename = /filename=([^;,]*)/;
function urlBasename(url2) {
  function guessDataUrlName(header) {
    const filenameMatch = header.match(regMatchFilename);
    if (filenameMatch) return filenameMatch[1];
    const mime = header.split(";", 1)[0];
    return mime.replaceAll(/\W/g, ".");
  }
  url2 = toURL(url2);
  if (url2.protocol === "data:") return guessDataUrlName(url2.pathname.split(",", 1)[0]);
  return basenameOfUrlPathname(url2.pathname);
}
function isDataURL(url2) {
  return hasProtocol(url2, "data:");
}
var isWindows2 = process.platform === "win32";
var windowsUrlPathRegExp = /^\/[a-zA-Z]:\//;
function isWindowsPathnameWithDriveLatter(pathname) {
  return windowsUrlPathRegExp.test(pathname);
}
function isFileURL(url2) {
  return hasProtocol(url2, "file:");
}
function toFilePathOrHref(url2) {
  return isFileURL(url2) && url2.toString().startsWith("file:///") ? toFilePath(url2) : url2.toString();
}
function toFilePath(url2) {
  try {
    if (isWindows2) {
      const u = new URL(url2);
      if (!isWindowsPathnameWithDriveLatter(u.pathname)) {
        const cwdUrl = (0, import_node_url2.pathToFileURL)(process.cwd());
        if (cwdUrl.hostname) return (0, import_node_url2.fileURLToPath)(new URL(u.pathname, cwdUrl));
        const drive = cwdUrl.pathname.split("/")[1];
        u.pathname = `/${drive}${u.pathname}`;
        return (0, import_node_url2.fileURLToPath)(u);
      }
    }
    return pathWindowsDriveLetterToUpper((0, import_node_url2.fileURLToPath)(url2));
  } catch {
    return url2.toString();
  }
}
var regExpWindowsPathDriveLetter = /^([a-zA-Z]):[\\/]/;
function pathWindowsDriveLetterToUpper(absoluteFilePath) {
  return absoluteFilePath.replace(regExpWindowsPathDriveLetter, (s) => s.toUpperCase());
}
var regExpWindowsFileUrl = /^file:\/\/\/[a-zA-Z]:\//;
function isWindowsFileUrl(url2) {
  return regExpWindowsFileUrl.test(url2.toString());
}
var isWindowsPathRegEx = regExpWindowsPathDriveLetter;
var isWindowsPathname = regExpWindowsPath;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
var questionRegex = /\?/g;
var hashRegex = /#/g;
var ProtocolFile = "file:";
var FileUrlBuilder = class {
  windows;
  path;
  cwd;
  constructor(options = {}) {
    const sep3 = options.path?.sep;
    this.windows = options.windows ?? (sep3 ? sep3 === "\\" : void 0) ?? isWindows2;
    this.path = options.path ?? (this.windows ? import_node_path2.default.win32 : import_node_path2.default.posix);
    this.cwd = options.cwd ?? this.pathToFileURL(this.path.resolve() + "/", this.rootFileURL());
    (0, import_node_assert3.default)(this.path.sep === (this.windows ? "\\" : "/"), `Path separator should match OS type Windows: ${this.windows === true ? "true" : (this.windows ?? "undefined") || "false"}, sep: ${this.path.sep}, options: ` + JSON.stringify({
      isWindows: isWindows2,
      sep: `${sep3}`,
      windows: options.windows,
      pathSep: options.path?.sep,
      n: options.path?.normalize("path/file.txt"),
      cwd: options.cwd?.href,
      win32: this.path === import_node_path2.default.win32,
      posix: this.path === import_node_path2.default.posix,
      "win32.normalize": this.path.normalize === import_node_path2.default.win32.normalize,
      "posix.normalize": this.path.normalize === import_node_path2.default.posix.normalize
    }));
  }
  /**
  * Encode special characters in a file path to use in a URL.
  * @param filepath
  * @returns
  */
  encodePathChars(filepath) {
    filepath = filepath.replaceAll(percentRegEx, "%25");
    if (!this.windows && !isWindows2 && filepath.includes("\\")) filepath = filepath.replaceAll(backslashRegEx, "%5C");
    filepath = filepath.replaceAll(newlineRegEx, "%0A");
    filepath = filepath.replaceAll(carriageReturnRegEx, "%0D");
    filepath = filepath.replaceAll(tabRegEx, "%09");
    return filepath;
  }
  /**
  * Normalize a file path for use in a URL.
  * ```js
  * const url = new URL(normalizeFilePathForUrl('path\\to\\file.txt'), 'file:///Users/user/');
  * // Result: file:///Users/user/path/to/file.txt
  * ```
  * @param filePath
  * @returns a normalized file path for use as a relative path in a URL.
  */
  normalizeFilePathForUrl(filePath) {
    filePath = this.encodePathChars(filePath);
    filePath = filePath.replaceAll(questionRegex, "%3F");
    filePath = filePath.replaceAll(hashRegex, "%23");
    const pathname = filePath.replaceAll("\\", "/");
    return pathname.replace(isWindowsPathRegEx, (drive) => `/${drive}`.toUpperCase());
  }
  /**
  * Try to make a file URL.
  * - if filenameOrUrl is already a URL, it is returned as is.
  * @param filenameOrUrl
  * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
  * @returns a URL
  */
  toFileURL(filenameOrUrl, relativeTo) {
    return normalizeWindowsUrl(this.#toFileURL(filenameOrUrl, relativeTo));
  }
  /**
  * Try to make a file URL.
  * - if filenameOrUrl is already a URL, it is returned as is.
  * @param filenameOrUrl
  * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
  * @returns a URL
  */
  #toFileURL(filenameOrUrl, relativeTo) {
    if (typeof filenameOrUrl !== "string") return filenameOrUrl;
    if (isUrlLike(filenameOrUrl)) return normalizeWindowsUrl(new URL(filenameOrUrl));
    relativeTo ??= this.cwd;
    isWindows2 && (filenameOrUrl = filenameOrUrl.replaceAll("\\", "/"));
    if (this.isAbsolute(filenameOrUrl) && isFileURL(relativeTo)) {
      const pathname$1 = this.normalizeFilePathForUrl(filenameOrUrl);
      if (isWindowsFileUrl(relativeTo) && !isWindowsPathnameWithDriveLatter(pathname$1)) {
        const relFilePrefix = relativeTo.toString().slice(0, 10);
        return normalizeWindowsUrl(new URL(relFilePrefix + pathname$1));
      }
      return normalizeWindowsUrl(new URL("file://" + pathname$1));
    }
    if (isUrlLike(relativeTo)) {
      const pathname$1 = this.normalizeFilePathForUrl(filenameOrUrl);
      return normalizeWindowsUrl(new URL(pathname$1, relativeTo));
    }
    const appendSlash = filenameOrUrl.endsWith("/") ? "/" : "";
    const pathname = this.normalizeFilePathForUrl(this.path.resolve(relativeTo.toString(), filenameOrUrl)) + appendSlash;
    return normalizeWindowsUrl(new URL("file://" + pathname));
  }
  /**
  * Try to make a URL for a directory.
  * - if dirOrUrl is already a URL, a slash is appended to the pathname.
  * @param dirOrUrl - directory path to convert to a file URL.
  * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
  * @returns a URL
  */
  toFileDirURL(dirOrUrl, relativeTo) {
    return addTrailingSlash(this.toFileURL(dirOrUrl, relativeTo));
  }
  urlToFilePathOrHref(url2) {
    url2 = this.toFileURL(url2);
    return this.#urlToFilePathOrHref(url2);
  }
  #urlToFilePathOrHref(url2) {
    if (url2.protocol !== ProtocolFile || url2.hostname) return url2.href;
    const p = this.path === import_node_path2.default ? toFilePathOrHref(url2) : decodeURIComponent(url2.pathname.split("/").join(this.path.sep));
    return pathWindowsDriveLetterToUpper(p.replace(isWindowsPathname, "$1"));
  }
  /**
  * Calculate the relative path to go from `urlFrom` to `urlTo`.
  * The protocol is not evaluated. Only the `url.pathname` is used.
  * The result: `new URL(relative(urlFrom, urlTo), urlFrom).pathname === urlTo.pathname`
  * @param urlFrom
  * @param urlTo
  * @returns the relative path
  */
  relative(urlFrom, urlTo) {
    if (urlFrom.protocol === urlTo.protocol && urlFrom.protocol === ProtocolFile) {
      if (urlFrom.href === urlTo.href) return "";
      urlFrom = urlFrom.pathname.endsWith("/") ? urlFrom : new URL("./", urlFrom);
      const fromPath = urlFrom.pathname;
      const toPath = urlTo.pathname;
      if (toPath.startsWith(fromPath)) return decodeURIComponent(toPath.slice(fromPath.length));
      const pFrom = this.#urlToFilePathOrHref(urlFrom);
      const pTo = this.#urlToFilePathOrHref(urlTo);
      const toIsDir = urlTo.pathname.endsWith("/");
      let pathname = this.normalizeFilePathForUrl(this.path.relative(pFrom, pTo));
      if (toIsDir && !pathname.endsWith("/")) pathname += "/";
      return decodeURIComponent(pathname);
    }
    return decodeURIComponent(urlToUrlRelative(urlFrom, urlTo));
  }
  /**
  * Get the parent directory of a URL.
  * @param url
  */
  urlDirname(url2) {
    return urlParent(this.toFileURL(url2));
  }
  pathToFileURL(pathname, relativeToURL) {
    return new URL(this.normalizeFilePathForUrl(pathname), relativeToURL || this.cwd);
  }
  rootFileURL(filePath) {
    const path17 = this.path;
    const p = path17.parse(path17.normalize(path17.resolve(filePath ?? ".")));
    return new URL(this.normalizeFilePathForUrl(p.root), this.#getFsRootURL());
  }
  #getFsRootURL() {
    if (this.path === import_node_path2.default) return (0, import_node_url2.pathToFileURL)("/");
    const p = this.path.resolve("/");
    return new URL(this.normalizeFilePathForUrl(p), "file:///");
  }
  /**
  * Determine if a filePath is absolute.
  *
  * @param filePath
  * @returns true if `URL` or `path.isAbsolute(filePath)`
  */
  isAbsolute(filePath) {
    return isUrlLike(filePath) || this.path.isAbsolute(filePath);
  }
  isUrlLike(url2) {
    return isUrlLike(url2);
  }
};
var fileUrlBuilder = new FileUrlBuilder();
function toFileURL(filenameOrUrl, relativeTo) {
  return fileUrlBuilder.toFileURL(filenameOrUrl, relativeTo);
}
function toFileDirURL(dir) {
  return fileUrlBuilder.toFileDirURL(dir);
}

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/resolve.js
var import_node_assert5 = __toESM(require("node:assert"), 1);
var import_node_fs3 = require("node:fs");
var import_node_process3 = __toESM(require("node:process"), 1);
var import_node_url5 = require("node:url");
var import_node_path4 = __toESM(require("node:path"), 1);
var import_node_module = require("node:module");

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/get-format.js
var import_node_url4 = require("node:url");

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/package-json-reader.js
var import_node_fs2 = __toESM(require("node:fs"), 1);
var import_node_path3 = __toESM(require("node:path"), 1);
var import_node_url3 = require("node:url");

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/errors.js
var import_node_v8 = __toESM(require("node:v8"), 1);
var import_node_assert4 = __toESM(require("node:assert"), 1);
var import_node_util3 = require("node:util");
var own = {}.hasOwnProperty;
var classRegExp = /^([A-Z][a-z\d]*)+$/;
var kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
var codes2 = {};
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
codes2.ERR_INVALID_ARG_TYPE = createError(
  "ERR_INVALID_ARG_TYPE",
  /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */
  (name2, expected, actual) => {
    (0, import_node_assert4.default)(typeof name2 === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name2.endsWith(" argument")) {
      message += `${name2} `;
    } else {
      const type = name2.includes(".") ? "property" : "argument";
      message += `"${name2}" ${type} `;
    }
    message += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      (0, import_node_assert4.default)(
        typeof value === "string",
        "All expected entries have to be of type string"
      );
      if (kTypes.has(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.exec(value) === null) {
        (0, import_node_assert4.default)(
          value !== "object",
          'The value "object" should be written as "Object"'
        );
        other.push(value);
      } else {
        instances.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
        types,
        "or"
      )}`;
      if (instances.length > 0 || other.length > 0) message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0) message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0].toLowerCase() !== other[0]) message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  },
  TypeError
);
codes2.ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  },
  TypeError
);
codes2.ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path17, base, message) => {
    return `Invalid package config ${path17}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
codes2.ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} packagePath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (packagePath, key, target, isImport = false, base = void 0) => {
    const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      (0, import_node_assert4.default)(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
codes2.ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {boolean} [exactUrl]
   */
  (path17, base, exactUrl = false) => {
    return `Cannot find ${exactUrl ? "module" : "package"} '${path17}' imported from ${base}`;
  },
  Error
);
codes2.ERR_NETWORK_IMPORT_DISALLOWED = createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
codes2.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
  },
  TypeError
);
codes2.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */
  (packagePath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);
codes2.ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
codes2.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
  "ERR_UNSUPPORTED_RESOLVE_REQUEST",
  'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
  TypeError
);
codes2.ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} extension
   * @param {string} path
   */
  (extension, path17) => {
    return `Unknown file extension "${extension}" for ${path17}`;
  },
  TypeError
);
codes2.ERR_INVALID_ARG_VALUE = createError(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name2, value, reason = "is invalid") => {
    let inspected = (0, import_node_util3.inspect)(value);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name2.includes(".") ? "property" : "argument";
    return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error4 = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error4);
    Object.defineProperties(error4, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error4);
    error4.code = key;
    return error4;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
var captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error4) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error4);
    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
    return error4;
  }
);
function getMessage(key, parameters, self) {
  const message = messages.get(key);
  (0, import_node_assert4.default)(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert4.default)(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  (0, import_node_assert4.default)(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(import_node_util3.format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === void 0) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${(0, import_node_util3.inspect)(value, { depth: -1 })}`;
  }
  let inspected = (0, import_node_util3.inspect)(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/package-json-reader.js
var hasOwnProperty2 = {}.hasOwnProperty;
var { ERR_INVALID_PACKAGE_CONFIG } = codes2;
var cache2 = /* @__PURE__ */ new Map();
function read(jsonPath, { base, specifier }) {
  const existing = cache2.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string;
  try {
    string = import_node_fs2.default.readFileSync(import_node_path3.default.toNamespacedPath(jsonPath), "utf8");
  } catch (error4) {
    const exception = (
      /** @type {ErrnoException} */
      error4
    );
    if (exception.code !== "ENOENT") {
      throw exception;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const cause = (
        /** @type {ErrnoException} */
        error_
      );
      const error4 = new ERR_INVALID_PACKAGE_CONFIG(
        jsonPath,
        (base ? `"${specifier}" from ` : "") + (0, import_node_url3.fileURLToPath)(base || specifier),
        cause.message
      );
      error4.cause = cause;
      throw error4;
    }
    result.exists = true;
    if (hasOwnProperty2.call(parsed, "name") && typeof parsed.name === "string") {
      result.name = parsed.name;
    }
    if (hasOwnProperty2.call(parsed, "main") && typeof parsed.main === "string") {
      result.main = parsed.main;
    }
    if (hasOwnProperty2.call(parsed, "exports")) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty2.call(parsed, "imports")) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty2.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
      result.type = parsed.type;
    }
  }
  cache2.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (packageJSONPath2.endsWith("node_modules/package.json")) {
      break;
    }
    const packageConfig = read((0, import_node_url3.fileURLToPath)(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = (0, import_node_url3.fileURLToPath)(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: "none"
  };
}
function getPackageType(url2) {
  return getPackageScopeConfig(url2).type;
}

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/get-format.js
var { ERR_UNKNOWN_FILE_EXTENSION } = codes2;
var hasOwnProperty3 = {}.hasOwnProperty;
var extensionFormatMap = {
  // @ts-expect-error: hush.
  __proto__: null,
  ".cjs": "commonjs",
  ".js": "module",
  ".json": "json",
  ".mjs": "module"
};
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json") return "json";
  return null;
}
var protocolHandlers = {
  // @ts-expect-error: hush.
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "http:": getHttpProtocolModuleFormat,
  "https:": getHttpProtocolModuleFormat,
  "node:"() {
    return "builtin";
  }
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url2) {
  const pathname = url2.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url2, _context, ignoreErrors) {
  const value = extname(url2);
  if (value === ".js") {
    const packageType = getPackageType(url2);
    if (packageType !== "none") {
      return packageType;
    }
    return "commonjs";
  }
  if (value === "") {
    const packageType = getPackageType(url2);
    if (packageType === "none" || packageType === "commonjs") {
      return "commonjs";
    }
    return "module";
  }
  const format4 = extensionFormatMap[value];
  if (format4) return format4;
  if (ignoreErrors) {
    return void 0;
  }
  const filepath = (0, import_node_url4.fileURLToPath)(url2);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url2, context) {
  const protocol = url2.protocol;
  if (!hasOwnProperty3.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url2, context, true) || null;
}

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/utils.js
var { ERR_INVALID_ARG_VALUE } = codes2;
var DEFAULT_CONDITIONS = Object.freeze(["node", "import"]);
var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== void 0 && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE(
        "conditions",
        conditions,
        "expected an array"
      );
    }
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/resolve.js
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_RESOLVE_REQUEST
} = codes2;
var own2 = {}.hasOwnProperty;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
var invalidPackageNameRegEx = /^\.|%|\\/;
var patternRegEx = /\*/g;
var encodedSeparatorRegEx = /%2f|%5c/i;
var emittedPackageWarnings = /* @__PURE__ */ new Set();
var doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match2, packageJsonUrl, internal, base, isTarget) {
  if (import_node_process3.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url5.fileURLToPath)(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  import_node_process3.default.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match2 ? "" : `matched to "${match2}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url5.fileURLToPath)(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url2, packageJsonUrl, base, main) {
  if (import_node_process3.default.noDeprecation) {
    return;
  }
  const format4 = defaultGetFormatWithoutErrors(url2, { parentURL: base.href });
  if (format4 !== "module") return;
  const urlPath = (0, import_node_url5.fileURLToPath)(url2.href);
  const packagePath = (0, import_node_url5.fileURLToPath)(new import_node_url5.URL(".", packageJsonUrl));
  const basePath = (0, import_node_url5.fileURLToPath)(base);
  if (!main) {
    import_node_process3.default.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  } else if (import_node_path4.default.resolve(packagePath, main) !== urlPath) {
    import_node_process3.default.emitWarning(
      `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  }
}
function tryStatSync(path17) {
  try {
    return (0, import_node_fs3.statSync)(path17);
  } catch {
  }
}
function fileExists(url2) {
  const stats2 = (0, import_node_fs3.statSync)(url2, { throwIfNoEntry: false });
  const isFile2 = stats2 ? stats2.isFile() : void 0;
  return isFile2 === null || isFile2 === void 0 ? false : isFile2;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new import_node_url5.URL(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new import_node_url5.URL(tries2[i2], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new import_node_url5.URL(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    (0, import_node_url5.fileURLToPath)(new import_node_url5.URL(".", packageJsonUrl)),
    (0, import_node_url5.fileURLToPath)(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      (0, import_node_url5.fileURLToPath)(base)
    );
  }
  let filePath;
  try {
    filePath = (0, import_node_url5.fileURLToPath)(resolved);
  } catch (error4) {
    const cause = (
      /** @type {ErrnoException} */
      error4
    );
    Object.defineProperty(cause, "input", { value: String(resolved) });
    Object.defineProperty(cause, "module", { value: String(base) });
    throw cause;
  }
  const stats2 = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats2 && stats2.isDirectory()) {
    const error4 = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, import_node_url5.fileURLToPath)(base));
    error4.url = String(resolved);
    throw error4;
  }
  if (!stats2 || !stats2.isFile()) {
    const error4 = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && (0, import_node_url5.fileURLToPath)(base),
      true
    );
    error4.url = String(resolved);
    throw error4;
  }
  if (!preserveSymlinks) {
    const real = (0, import_node_fs3.realpathSync)(filePath);
    const { search, hash } = resolved;
    resolved = (0, import_node_url5.pathToFileURL)(real + (filePath.endsWith(import_node_path4.default.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && (0, import_node_url5.fileURLToPath)(new import_node_url5.URL(".", packageJsonUrl)),
    (0, import_node_url5.fileURLToPath)(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    (0, import_node_url5.fileURLToPath)(new import_node_url5.URL(".", packageJsonUrl)),
    subpath,
    base && (0, import_node_url5.fileURLToPath)(base)
  );
}
function throwInvalidSubpath(request, match2, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match2}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, import_node_url5.fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && (0, import_node_url5.fileURLToPath)(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    (0, import_node_url5.fileURLToPath)(new import_node_url5.URL(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && (0, import_node_url5.fileURLToPath)(base)
  );
}
function resolvePackageTargetString(target, subpath, match2, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL2 = false;
      try {
        new import_node_url5.URL(target);
        isURL2 = true;
      } catch {
      }
      if (!isURL2) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match2.replace("*", () => subpath) : match2 + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match2,
          packageJsonUrl,
          internal,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new import_node_url5.URL(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new import_node_url5.URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  if (subpath === "") return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match2.replace("*", () => subpath) : match2 + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match2,
          packageJsonUrl,
          internal,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match2, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new import_node_url5.URL(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new import_node_url5.URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key) return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error4) {
        const exception = (
          /** @type {ErrnoException} */
          error4
        );
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
        throw error4;
      }
      if (resolveResult === void 0) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys3 = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys3.length) {
      const key = keys3[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG2(
          (0, import_node_url5.fileURLToPath)(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys3.length) {
      const key = keys3[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports2, packageJsonUrl, base) {
  if (typeof exports2 === "string" || Array.isArray(exports2)) return true;
  if (typeof exports2 !== "object" || exports2 === null) return false;
  const keys3 = Object.getOwnPropertyNames(exports2);
  let isConditionalSugar = false;
  let i = 0;
  let keyIndex = -1;
  while (++keyIndex < keys3.length) {
    const key = keys3[keyIndex];
    const currentIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG2(
        (0, import_node_url5.fileURLToPath)(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match2, pjsonUrl, base) {
  if (import_node_process3.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url5.fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match2)) return;
  emittedPackageWarnings.add(pjsonPath + "|" + match2);
  import_node_process3.default.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match2}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url5.fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports2 = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base)) {
    exports2 = { ".": exports2 };
  }
  if (own2.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports2[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys3 = Object.getOwnPropertyNames(exports2);
  let i = -1;
  while (++i < keys3.length) {
    const key = keys3[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports2[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB) return -1;
  if (baseLengthB > baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
function packageImportsResolve(name2, base, conditions) {
  if (name2 === "#" || name2.startsWith("#/") || name2.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name2, reason, (0, import_node_url5.fileURLToPath)(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, import_node_url5.pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own2.call(imports, name2) && !name2.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name2],
          "",
          name2,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys3 = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys3.length) {
          const key = keys3[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name2.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name2.length >= key.length && name2.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name2.slice(
                patternIndex,
                name2.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name2, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName2 = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName2) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      (0, import_node_url5.fileURLToPath)(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName: packageName2, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (import_node_module.builtinModules.includes(specifier)) {
    return new import_node_url5.URL("node:" + specifier);
  }
  const { packageName: packageName2, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = (0, import_node_url5.pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName2 && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
    }
  }
  let packageJsonUrl = new import_node_url5.URL(
    "./node_modules/" + packageName2 + "/package.json",
    base
  );
  let packageJsonPath = (0, import_node_url5.fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat3 = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat3 || !stat3.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new import_node_url5.URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName2 + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = (0, import_node_url5.fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig2 = read(packageJsonPath, { base, specifier });
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new import_node_url5.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName2, (0, import_node_url5.fileURLToPath)(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/") return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "") return false;
  if (specifier[0] === "/") return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isData = protocol === "data:";
  const isRemote = isData || protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new import_node_url5.URL(specifier, base);
    } catch (error_) {
      const error4 = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error4.cause = error_;
      throw error4;
    }
  } else if (protocol === "file:" && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new import_node_url5.URL(specifier);
    } catch (error_) {
      if (isRemote && !import_node_module.builtinModules.includes(specifier)) {
        const error4 = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        error4.cause = error_;
        throw error4;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  (0, import_node_assert5.default)(resolved !== void 0, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    const parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === "http:" || parentProtocol === "https:") {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        const parsedProtocol = parsed?.protocol;
        if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:") {
          throw new ERR_NETWORK_IMPORT_DISALLOWED(
            specifier,
            parsedParentURL,
            "remote imports cannot import from a local location."
          );
        }
        return { url: parsed?.href || "" };
      }
      if (import_node_module.builtinModules.includes(specifier)) {
        throw new ERR_NETWORK_IMPORT_DISALLOWED(
          specifier,
          parsedParentURL,
          "remote imports cannot import from a local location."
        );
      }
      throw new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "only relative and absolute specifiers are supported."
      );
    }
  }
}
function isURL(self) {
  return Boolean(
    self && typeof self === "object" && "href" in self && typeof self.href === "string" && "protocol" in self && typeof self.protocol === "string" && self.href && self.protocol
  );
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL === void 0) {
    return;
  }
  if (typeof parentURL !== "string" && !isURL(parentURL)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(
      "parentURL",
      ["string", "URL"],
      parentURL
    );
  }
}
function defaultResolve(specifier, context = {}) {
  const { parentURL } = context;
  (0, import_node_assert5.default)(parentURL !== void 0, "expected `parentURL` to be defined");
  throwIfInvalidParentURL(parentURL);
  let parsedParentURL;
  if (parentURL) {
    try {
      parsedParentURL = new import_node_url5.URL(parentURL);
    } catch {
    }
  }
  let parsed;
  let protocol;
  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new import_node_url5.URL(specifier, parsedParentURL) : new import_node_url5.URL(specifier);
    protocol = parsed.protocol;
    if (protocol === "data:") {
      return { url: parsed.href, format: null };
    }
  } catch {
  }
  const maybeReturn = checkIfDisallowedImport(
    specifier,
    parsed,
    parsedParentURL
  );
  if (maybeReturn) return maybeReturn;
  if (protocol === void 0 && parsed) {
    protocol = parsed.protocol;
  }
  if (protocol === "node:") {
    return { url: specifier };
  }
  if (parsed && parsed.protocol === "node:") return { url: specifier };
  const conditions = getConditionsSet(context.conditions);
  const url2 = moduleResolve(specifier, new import_node_url5.URL(parentURL), conditions, false);
  return {
    // Do NOT cast `url` to a string: that will work even when there are real
    // problems, silencing them
    url: url2.href,
    format: defaultGetFormatWithoutErrors(url2, { parentURL })
  };
}

// ../node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/index.js
function resolve(specifier, parent) {
  if (!parent) {
    throw new Error(
      "Please pass `parent`: `import-meta-resolve` cannot ponyfill that"
    );
  }
  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error4) {
    const exception = (
      /** @type {ErrnoException} */
      error4
    );
    if ((exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception.code === "ERR_MODULE_NOT_FOUND") && typeof exception.url === "string") {
      return exception.url;
    }
    throw error4;
  }
}

// ../node_modules/.pnpm/@cspell+dynamic-import@9.1.5/node_modules/@cspell/dynamic-import/dist/esm/dynamicImport.mjs
var isWindowsPath = /^[a-z]:\\/i;
async function dynamicImportFrom(moduleName, paths) {
  paths = Array.isArray(paths) ? paths : paths ? [paths] : void 0;
  const modulesNameToImport = normalizeModuleName(moduleName);
  if (!paths || !paths.length || typeof moduleName !== "string") {
    try {
      return await import(modulesNameToImport.toString());
    } catch (e) {
      const err = toError3(e);
      throw err;
    }
  }
  const location = importResolveModuleName(moduleName, paths);
  return await import(location.href);
}
function importResolveModuleName(moduleName, paths) {
  const modulesNameToImport = normalizeModuleName(moduleName);
  let lastError = void 0;
  for (const parent of paths) {
    try {
      const url2 = typeof parent === "string" ? parent.startsWith("file://") ? new URL(parent) : dirToUrl(parent) : parent;
      const resolvedURL = new URL(resolve(modulesNameToImport.toString(), url2.toString()));
      try {
        const s = (0, import_node_fs4.statSync)(resolvedURL);
        if (s.isFile()) {
          return resolvedURL;
        }
      } catch {
        const error4 = new Error(`Cannot find module ${moduleName}`);
        error4.code = "ERR_MODULE_NOT_FOUND";
        lastError = error4;
      }
    } catch (err) {
      lastError = err;
    }
  }
  throw lastError;
}
function normalizeModuleName(moduleName) {
  return typeof moduleName === "string" && isWindowsPath.test(moduleName) ? toFileURL(moduleName) : moduleName;
}
function toError3(e) {
  if (isError2(e))
    return e;
  return new Error(e?.toString());
}
function isError2(e) {
  return e instanceof Error;
}
function dirToUrl(dir) {
  const abs = (0, import_node_path5.resolve)(dir);
  return toFileDirURL(abs);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/resolveFile.js
var import_resolve_from = __toESM(require_resolve_from(), 1);

// ../node_modules/.pnpm/cspell-io@9.1.5/node_modules/cspell-io/dist/index.js
var import_node_zlib = require("node:zlib");

// ../node_modules/.pnpm/@cspell+cspell-service-bus@9.1.5/node_modules/@cspell/cspell-service-bus/dist/esm/errors.js
var ErrorUnhandledRequest = class extends Error {
  request;
  constructor(request) {
    super(`Unhandled Request: ${request.type}`);
    this.request = request;
  }
};
var ErrorServiceRequestDepthExceeded = class extends Error {
  request;
  depth;
  constructor(request, depth) {
    super(`Service Request Depth ${depth} Exceeded: ${request.type}`);
    this.request = request;
    this.depth = depth;
  }
};
var UnhandledHandlerError = class extends Error {
  handlerName;
  handlerDescription;
  cause;
  constructor(handlerName, handlerDescription, cause) {
    super(`Unhandled Error in Handler: ${handlerName}`);
    this.handlerName = handlerName;
    this.handlerDescription = handlerDescription;
    this.cause = cause;
  }
};

// ../node_modules/.pnpm/@cspell+cspell-service-bus@9.1.5/node_modules/@cspell/cspell-service-bus/dist/esm/request.js
var BaseServiceRequest = class {
  type;
  params;
  __r;
  constructor(type, params) {
    this.type = type;
    this.params = params;
  }
};
var ServiceRequestCls = class extends BaseServiceRequest {
  constructor(type, params) {
    super(type, params);
  }
};
function createResponse(value, _req) {
  return { value };
}
function createResponseFail(_request, error4) {
  return { error: error4 };
}
function isServiceResponseSuccess(res) {
  return "value" in res && res.error === void 0;
}

// ../node_modules/.pnpm/@cspell+cspell-service-bus@9.1.5/node_modules/@cspell/cspell-service-bus/dist/esm/bus.js
var MAX_DEPTH = 10;
var ServiceBus = class {
  handlers = [];
  constructor(handlers = []) {
    handlers.forEach((h) => this.addHandler(h));
  }
  addHandler(handler, name2 = "anonymous", description) {
    const h = typeof handler === "function" ? { fn: handler, name: name2, description } : handler;
    const { fn, name: _name, description: _description } = h;
    this.handlers.push({ fn, name: _name, description: _description });
    return this;
  }
  dispatch(request) {
    let depth = 0;
    const dispatcher = { dispatch };
    const handler = this.reduceHandlers(this.handlers, request, dispatcher, this.defaultHandler);
    function dispatch(request2) {
      ++depth;
      if (depth >= MAX_DEPTH) {
        return createResponseFail(request2, new ErrorServiceRequestDepthExceeded(request2, depth));
      }
      const response = handler(request2);
      --depth;
      return response;
    }
    return dispatch(request);
  }
  defaultHandler(request) {
    return createResponseFail(request, new ErrorUnhandledRequest(request));
  }
  reduceHandlers(handlers, request, dispatcher, defaultHandler) {
    const _handlers = handlers.map((m) => ({ ...m, fn: m.fn(dispatcher) }));
    const handler = _handlers.reduce((next, h) => {
      const fn = h.fn(next);
      return (req) => {
        try {
          return fn(req);
        } catch (e) {
          return createResponseFail(request, new UnhandledHandlerError(h.name, h.description, e));
        }
      };
    }, defaultHandler);
    return handler;
  }
};

// ../node_modules/.pnpm/@cspell+cspell-service-bus@9.1.5/node_modules/@cspell/cspell-service-bus/dist/esm/createRequestHandler.js
function createRequestHandler(requestDef, fn, name2, description) {
  return createIsRequestHandler(requestDef.is, fn, name2 ?? requestDef.type, description);
}
function createIsRequestHandlerFn(isA, fn) {
  return (dispatcher) => (next) => (request) => isA(request) ? fn(request, next, dispatcher) : next(request);
}
function createIsRequestHandler(isA, fn, name2, description) {
  return {
    fn: createIsRequestHandlerFn(isA, fn),
    name: name2,
    description
  };
}

// ../node_modules/.pnpm/@cspell+cspell-service-bus@9.1.5/node_modules/@cspell/cspell-service-bus/dist/esm/requestFactory.js
function requestFactory(requestType) {
  class RequestClass extends ServiceRequestCls {
    static type = requestType;
    constructor(params) {
      super(requestType, params);
    }
    static is(req) {
      return req instanceof RequestClass && req.type === requestType;
    }
    static create(params) {
      return new RequestClass(params);
    }
    static createRequestHandler(fn, name2, description) {
      return createRequestHandler(RequestClass, fn, name2, description);
    }
    static __request;
  }
  return RequestClass;
}

// ../node_modules/.pnpm/cspell-io@9.1.5/node_modules/cspell-io/dist/index.js
var import_node_fs5 = require("node:fs");
var import_node_url6 = require("node:url");
var import_node_util4 = require("node:util");
var Stream = __toESM(require("node:stream"), 1);
var CFileReference = class CFileReference2 {
  /**
  * Use to ensure the nominal type separation between CFileReference and FileReference
  * See: https://github.com/microsoft/TypeScript/wiki/FAQ#when-and-why-are-classes-nominal
  */
  _;
  gz;
  constructor(url2, encoding, baseFilename, gz) {
    this.url = url2;
    this.encoding = encoding;
    this.baseFilename = baseFilename;
    this.gz = gz ?? (baseFilename?.endsWith(".gz") || void 0) ?? (url2.pathname.endsWith(".gz") || void 0);
  }
  static isCFileReference(obj) {
    return obj instanceof CFileReference2;
  }
  static from(fileReference, encoding, baseFilename, gz) {
    if (CFileReference2.isCFileReference(fileReference)) return fileReference;
    if (fileReference instanceof URL) return new CFileReference2(fileReference, encoding, baseFilename, gz);
    return new CFileReference2(fileReference.url, fileReference.encoding, fileReference.baseFilename, fileReference.gz);
  }
  toJson() {
    return {
      url: this.url.href,
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
};
function toFileReference(file, encoding, baseFilename, gz) {
  const fileReference = typeof file === "string" ? toFileURL(file) : file;
  if (fileReference instanceof URL) return new CFileReference(fileReference, encoding, baseFilename, gz);
  return CFileReference.from(fileReference);
}
function isFileReference(ref) {
  return CFileReference.isCFileReference(ref) || !(ref instanceof URL) && typeof ref !== "string";
}
function toFileResourceRequest(file, encoding, signal) {
  const fileReference = typeof file === "string" ? toFileURL(file) : file;
  if (fileReference instanceof URL) return {
    url: fileReference,
    encoding,
    signal
  };
  return {
    url: fileReference.url,
    encoding: encoding ?? fileReference.encoding,
    signal
  };
}
var ErrorNotImplemented = class extends Error {
  constructor(method, options) {
    super(`Method ${method} is not supported.`, options);
    this.method = method;
  }
};
var AssertionError = class extends Error {
  constructor(message, options) {
    super(message, options);
    this.message = message;
  }
};
function assert$1(value, message) {
  if (!value) throw new AssertionError(message ?? "Assertion failed");
}
function asUint8Array(data) {
  return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
function arrayBufferViewToBuffer(data) {
  if (data instanceof Buffer) return data;
  const buf = Buffer.from(data.buffer);
  if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) return buf;
  return buf.subarray(data.byteOffset, data.byteOffset + data.byteLength);
}
function copyArrayBufferView(data) {
  return new Uint8Array(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
}
function swap16Poly(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  for (let i = 0; i < view.byteLength; i += 2) view.setUint16(i, view.getUint16(i, false), true);
  return data;
}
function swap16(data) {
  if (typeof Buffer !== "undefined") return arrayBufferViewToBuffer(data).swap16();
  return swap16Poly(data);
}
function swapBytes(data) {
  const buf = copyArrayBufferView(data);
  return swap16(buf);
}
var BOM_BE = 65279;
var BOM_LE = 65534;
var decoderUTF8 = new TextDecoder("utf8");
var decoderUTF16LE = new TextDecoder("utf-16le");
var decoderUTF16BE = createTextDecoderUtf16BE();
var encoderUTF8 = new TextEncoder();
function decodeUtf16LE(data) {
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16LE.decode(bom === BOM_LE ? buf.subarray(2) : buf);
}
function decodeUtf16BE(data) {
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16BE.decode(bom === BOM_BE ? buf.subarray(2) : buf);
}
function decodeToString(data, encoding) {
  if (isGZipped(data)) return decodeToString(decompressBuffer(data), encoding);
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  if (bom === BOM_BE || buf[0] === 0 && buf[1] !== 0) return decodeUtf16BE(buf);
  if (bom === BOM_LE || buf[0] !== 0 && buf[1] === 0) return decodeUtf16LE(buf);
  if (!encoding) return decoderUTF8.decode(buf);
  switch (encoding) {
    case "utf-16be":
    case "utf16be":
      return decodeUtf16BE(buf);
    case "utf-16le":
    case "utf16le":
      return decodeUtf16LE(buf);
    case "utf-8":
    case "utf8":
      return decoderUTF8.decode(buf);
  }
  throw new UnsupportedEncodingError(encoding);
}
function decode(data, encoding) {
  switch (encoding) {
    case "base64":
    case "base64url":
    case "hex":
      return arrayBufferViewToBuffer(data).toString(encoding);
  }
  const result = decodeToString(data, encoding);
  return result;
}
function encodeString(str, encoding, bom) {
  switch (encoding) {
    case void 0:
    case "utf-8":
    case "utf8":
      return encoderUTF8.encode(str);
    case "utf-16be":
    case "utf16be":
      return encodeUtf16BE(str, bom);
    case "utf-16le":
    case "utf16le":
      return encodeUtf16LE(str, bom);
  }
  return Buffer.from(str, encoding);
}
function encodeUtf16LE(str, bom = true) {
  const buf = Buffer.from(str, "utf16le");
  if (bom) {
    const target = Buffer.alloc(buf.length + 2);
    target.writeUint16LE(BOM_BE);
    buf.copy(target, 2);
    return target;
  }
  return buf;
}
function encodeUtf16BE(str, bom = true) {
  return swap16(encodeUtf16LE(str, bom));
}
function createTextDecoderUtf16BE() {
  try {
    const decoder = new TextDecoder("utf-16be");
    return decoder;
  } catch {
    return {
      encoding: "utf-16be",
      fatal: false,
      ignoreBOM: false,
      decode: (input) => decoderUTF16LE.decode(swapBytes(input))
    };
  }
}
var UnsupportedEncodingError = class extends Error {
  constructor(encoding) {
    super(`Unsupported encoding: ${encoding}`);
  }
};
function isGZipped(data) {
  if (typeof data === "string") return false;
  const buf = asUint8Array(data);
  return buf[0] === 31 && buf[1] === 139;
}
function decompressBuffer(data) {
  if (!isGZipped(data)) return data;
  const buf = arrayBufferViewToBuffer(data);
  return (0, import_node_zlib.gunzipSync)(buf);
}
var CFileResource = class CFileResource2 {
  _text;
  baseFilename;
  _gz;
  constructor(url2, content, encoding, baseFilename, gz) {
    this.url = url2;
    this.content = content;
    this.encoding = encoding;
    this.baseFilename = baseFilename ?? (url2.protocol !== "data:" && url2.pathname.split("/").pop() || void 0);
    this._gz = gz;
  }
  get gz() {
    if (this._gz !== void 0) return this._gz;
    if (this.url.pathname.endsWith(".gz")) return true;
    if (typeof this.content === "string") return false;
    return isGZipped(this.content);
  }
  getText(encoding) {
    if (this._text !== void 0) return this._text;
    const text = typeof this.content === "string" ? this.content : decode(this.content, encoding ?? this.encoding);
    this._text = text;
    return text;
  }
  getBytes() {
    const arrayBufferview = typeof this.content === "string" ? encodeString(this.content, this.encoding) : this.content;
    return arrayBufferview instanceof Uint8Array ? arrayBufferview : new Uint8Array(arrayBufferview.buffer, arrayBufferview.byteOffset, arrayBufferview.byteLength);
  }
  toJson() {
    return {
      url: this.url.href,
      content: this.getText(),
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
  static isCFileResource(obj) {
    return obj instanceof CFileResource2;
  }
  static from(urlOrFileResource, content, encoding, baseFilename, gz) {
    if (CFileResource2.isCFileResource(urlOrFileResource)) {
      if (content) {
        const { url: url2, encoding: encoding$1, baseFilename: baseFilename$1, gz: gz$1 } = urlOrFileResource;
        return new CFileResource2(url2, content, encoding$1, baseFilename$1, gz$1);
      }
      return urlOrFileResource;
    }
    if (urlOrFileResource instanceof URL) {
      assert$1(content !== void 0);
      return new CFileResource2(urlOrFileResource, content, encoding, baseFilename, gz);
    }
    if (content !== void 0) {
      const fileRef = urlOrFileResource;
      return new CFileResource2(fileRef.url, content, fileRef.encoding, fileRef.baseFilename, fileRef.gz);
    }
    assert$1("content" in urlOrFileResource && urlOrFileResource.content !== void 0);
    const fileResource = urlOrFileResource;
    return new CFileResource2(fileResource.url, fileResource.content, fileResource.encoding, fileResource.baseFilename, fileResource.gz);
  }
};
function fromFileResource(fileResource, encoding) {
  return CFileResource.from(encoding ? {
    ...fileResource,
    encoding
  } : fileResource);
}
function compareStats(left, right) {
  if (left === right) return 0;
  if (left.eTag || right.eTag) return left.eTag === right.eTag ? 0 : (left.eTag || "") < (right.eTag || "") ? -1 : 1;
  const diff = left.size - right.size || left.mtimeMs - right.mtimeMs;
  return diff < 0 ? -1 : diff > 0 ? 1 : 0;
}
function urlOrReferenceToUrl(urlOrReference) {
  return urlOrReference instanceof URL ? urlOrReference : urlOrReference.url;
}
function toReadFileOptions(options) {
  if (!options) return options;
  if (typeof options === "string") return { encoding: options };
  return options;
}
function toError4(e) {
  if (e instanceof Error) return e;
  if (typeof e === "object" && e && "message" in e && typeof e.message === "string") return new Error(e.message, { cause: e });
  return new Error(e && e.toString());
}
var FileType = /* @__PURE__ */ function(FileType$1) {
  FileType$1[FileType$1["Unknown"] = 0] = "Unknown";
  FileType$1[FileType$1["File"] = 1] = "File";
  FileType$1[FileType$1["Directory"] = 2] = "Directory";
  FileType$1[FileType$1["SymbolicLink"] = 64] = "SymbolicLink";
  return FileType$1;
}({});
function encodeDataUrl(data, mediaType, attributes) {
  if (typeof data === "string") return encodeString$1(data, mediaType, attributes);
  const attribs = encodeAttributes(attributes || []);
  const buf = arrayBufferViewToBuffer(data);
  return `data:${mediaType}${attribs};base64,${buf.toString("base64url")}`;
}
function toDataUrl(data, mediaType, attributes) {
  return new URL(encodeDataUrl(data, mediaType, attributes));
}
function encodeString$1(data, mediaType, attributes) {
  mediaType = mediaType || "text/plain";
  attributes = attributes || [];
  const asUrlComp = encodeURIComponent(data);
  const asBase64 = Buffer.from(data).toString("base64url");
  const useBase64 = asBase64.length < asUrlComp.length - 7;
  const encoded = useBase64 ? asBase64 : asUrlComp;
  const attribMap = new Map([["charset", "utf-8"], ...attributes]);
  attribMap.set("charset", "utf-8");
  const attribs = encodeAttributes(attribMap);
  return `data:${mediaType}${attribs}${useBase64 ? ";base64" : ""},${encoded}`;
}
function encodeAttributes(attributes) {
  return [...attributes].map(([key, value]) => `;${key}=${encodeURIComponent(value)}`).join("");
}
var dataUrlRegExHead = /^data:(?<mediaType>[^;,]*)(?<attributes>(?:;[^=]+=[^;,]*)*)(?<base64>;base64)?$/;
function decodeDataUrl(url2) {
  url2 = url2.toString();
  const [head, encodedData] = url2.split(",", 2);
  if (!head || encodedData === void 0) throw new Error("Not a data url");
  const match2 = head.match(dataUrlRegExHead);
  if (!match2 || !match2.groups) throw new Error("Not a data url");
  const mediaType = match2.groups["mediaType"] || "";
  const rawAttributes = (match2.groups["attributes"] || "").split(";").filter((a) => !!a).map((entry) => entry.split("=", 2)).map(([key, value]) => [key, decodeURIComponent(value)]);
  const attributes = new Map(rawAttributes);
  const encoding = attributes.get("charset");
  const isBase64 = !!match2.groups["base64"];
  const data = isBase64 ? Buffer.from(encodedData, "base64url") : Buffer.from(decodeURIComponent(encodedData));
  return {
    mediaType,
    data,
    encoding,
    attributes
  };
}
function guessMimeType(filename) {
  if (filename.endsWith(".trie")) return {
    mimeType: "application/vnd.cspell.dictionary+trie",
    encoding: "utf-8"
  };
  if (filename.endsWith(".trie.gz")) return { mimeType: "application/vnd.cspell.dictionary+trie.gz" };
  if (filename.endsWith(".txt")) return {
    mimeType: "text/plain",
    encoding: "utf-8"
  };
  if (filename.endsWith(".txt.gz")) return { mimeType: "application/gzip" };
  if (filename.endsWith(".gz")) return { mimeType: "application/gzip" };
  if (filename.endsWith(".json")) return {
    mimeType: "application/json",
    encoding: "utf-8"
  };
  if (filename.endsWith(".yaml") || filename.endsWith(".yml")) return {
    mimeType: "application/x-yaml",
    encoding: "utf-8"
  };
  return void 0;
}
var _fetch = global.fetch;
var FetchUrlError = class FetchUrlError2 extends Error {
  constructor(message, code, status, url2) {
    super(message);
    this.code = code;
    this.status = status;
    this.url = url2;
    this.name = "FetchUrlError";
  }
  static create(url2, status, message) {
    if (status === 404) return new FetchUrlError2(message || "URL not found.", "ENOENT", status, url2);
    if (status >= 400 && status < 500) return new FetchUrlError2(message || "Permission denied.", "EACCES", status, url2);
    return new FetchUrlError2(message || "Fatal Error", "ECONNREFUSED", status, url2);
  }
  static fromError(url2, e) {
    const cause = getCause(e);
    if (cause) return new FetchUrlError2(cause.message, cause.code, void 0, url2);
    if (isNodeError(e)) return new FetchUrlError2(e.message, e.code, void 0, url2);
    return new FetchUrlError2(e.message, void 0, void 0, url2);
  }
};
function isNodeError(e) {
  if (e instanceof Error && "code" in e && typeof e.code === "string") return true;
  if (e && typeof e === "object" && "code" in e && typeof e.code === "string") return true;
  return false;
}
function isError3(e) {
  return e instanceof Error;
}
function isErrorWithOptionalCause(e) {
  return isError3(e) && (!("cause" in e) || isNodeError(e.cause) || isNodeError(e));
}
function getCause(e) {
  return isErrorWithOptionalCause(e) ? e.cause : void 0;
}
function toFetchUrlError(err, url2) {
  return err instanceof FetchUrlError ? err : FetchUrlError.fromError(url2, toError$1(err));
}
function toError$1(err) {
  return err instanceof Error ? err : new Error("Unknown Error", { cause: err });
}
async function fetchHead(request) {
  const url2 = toURL$1(request);
  try {
    const r = await _fetch(url2, { method: "HEAD" });
    if (!r.ok) throw FetchUrlError.create(url2, r.status);
    return r.headers;
  } catch (e) {
    throw toFetchUrlError(e, url2);
  }
}
async function fetchURL(url2, signal) {
  try {
    const request = signal ? new Request(url2, { signal }) : url2;
    const response = await _fetch(request);
    if (!response.ok) throw FetchUrlError.create(url2, response.status);
    return Buffer.from(await response.arrayBuffer());
  } catch (e) {
    throw toFetchUrlError(e, url2);
  }
}
function toURL$1(url2) {
  return typeof url2 === "string" ? new URL(url2) : url2;
}
async function getStatHttp(url2) {
  const headers = await fetchHead(url2);
  const eTag = headers.get("etag") || void 0;
  const guessSize = Number.parseInt(headers.get("content-length") || "0", 10);
  return {
    size: eTag ? -1 : guessSize,
    mtimeMs: 0,
    eTag
  };
}
var RequestType$4 = "fs:readFile";
var RequestFsReadFile = requestFactory(RequestType$4);
var RequestType$3 = "fs:readFileSync";
var RequestFsReadFileTextSync = requestFactory(RequestType$3);
var RequestTypeStat = "fs:stat";
var RequestFsStat = requestFactory(RequestTypeStat);
var RequestTypeStatSync = "fs:statSync";
var RequestFsStatSync = requestFactory(RequestTypeStatSync);
var RequestType$2 = "fs:writeFile";
var RequestFsWriteFile = requestFactory(RequestType$2);
var RequestType$1 = "zlib:inflate";
var RequestZlibInflate = requestFactory(RequestType$1);
var RequestType = "fs:readDir";
var RequestFsReadDirectory = requestFactory(RequestType);
var isGzFileRegExp = /\.gz($|[?#])/;
function isGzFile(url2) {
  return isGzFileRegExp.test(typeof url2 === "string" ? url2 : url2.pathname);
}
var pGzip = (0, import_node_util4.promisify)(import_node_zlib.gzip);
var handleRequestFsReadFile = RequestFsReadFile.createRequestHandler(({ params }) => {
  const baseFilename = urlBasename(params.url);
  return createResponse(import_node_fs5.promises.readFile((0, import_node_url6.fileURLToPath)(params.url)).then((content) => CFileResource.from(params.url, content, params.encoding, baseFilename)));
}, void 0, "Node: Read Binary File.");
var handleRequestFsReadFileSync = RequestFsReadFileTextSync.createRequestHandler(({ params }) => createResponse(CFileResource.from({
  ...params,
  content: (0, import_node_fs5.readFileSync)((0, import_node_url6.fileURLToPath)(params.url))
})), void 0, "Node: Sync Read Binary File.");
var handleRequestFsReadDirectory = RequestFsReadDirectory.createRequestHandler(({ params }) => {
  return createResponse(import_node_fs5.promises.readdir((0, import_node_url6.fileURLToPath)(params.url), { withFileTypes: true }).then((entries) => direntToDirEntries(params.url, entries)));
}, void 0, "Node: Read Directory.");
var handleRequestZlibInflate = RequestZlibInflate.createRequestHandler(({ params }) => createResponse((0, import_node_zlib.gunzipSync)(arrayBufferViewToBuffer(params.data))), void 0, "Node: gz deflate.");
var supportedFetchProtocols = {
  "http:": true,
  "https:": true
};
var handleRequestFsReadFileHttp = RequestFsReadFile.createRequestHandler((req, next) => {
  const { url: url2, signal, encoding } = req.params;
  if (!(url2.protocol in supportedFetchProtocols)) return next(req);
  return createResponse(fetchURL(url2, signal).then((content) => CFileResource.from({
    url: url2,
    encoding,
    content
  })));
}, void 0, "Node: Read Http(s) file.");
var handleRequestFsReadFileSyncData = RequestFsReadFileTextSync.createRequestHandler((req, next) => {
  const { url: url2, encoding } = req.params;
  if (url2.protocol !== "data:") return next(req);
  const data = decodeDataUrl(url2);
  return createResponse(CFileResource.from({
    url: url2,
    content: data.data,
    encoding,
    baseFilename: data.attributes.get("filename")
  }));
}, void 0, "Node: Read data: urls.");
var handleRequestFsReadFileData = RequestFsReadFile.createRequestHandler((req, next, dispatcher) => {
  const { url: url2 } = req.params;
  if (url2.protocol !== "data:") return next(req);
  const res = dispatcher.dispatch(RequestFsReadFileTextSync.create(req.params));
  if (!isServiceResponseSuccess(res)) return res;
  return createResponse(Promise.resolve(res.value));
}, void 0, "Node: Read data: urls.");
var handleRequestFsStat = RequestFsStat.createRequestHandler(({ params }) => createResponse(toPromiseStats(import_node_fs5.promises.stat((0, import_node_url6.fileURLToPath)(params.url)))), void 0, "Node: fs.stat.");
function toStats(stat3) {
  return {
    size: stat3.size,
    mtimeMs: stat3.mtimeMs,
    fileType: toFileType(stat3)
  };
}
function toPromiseStats(pStat) {
  return pStat.then(toStats);
}
var handleRequestFsStatSync = RequestFsStatSync.createRequestHandler((req) => {
  const { params } = req;
  try {
    return createResponse((0, import_node_fs5.statSync)((0, import_node_url6.fileURLToPath)(params.url)));
  } catch (e) {
    return createResponseFail(req, toError4(e));
  }
}, void 0, "Node: fs.stat.");
var handleRequestFsStatHttp = RequestFsStat.createRequestHandler((req, next) => {
  const { url: url2 } = req.params;
  if (!(url2.protocol in supportedFetchProtocols)) return next(req);
  return createResponse(getStatHttp(url2));
}, void 0, "Node: http get stat");
var handleRequestFsWriteFile = RequestFsWriteFile.createRequestHandler(({ params }) => createResponse(writeFile(params, params.content)), void 0, "Node: fs.writeFile");
async function writeFile(fileRef, content) {
  const gz = isGZipped(content);
  const { url: url2, encoding, baseFilename } = fileRef;
  const resultRef = {
    url: url2,
    encoding,
    baseFilename,
    gz
  };
  await import_node_fs5.promises.writeFile((0, import_node_url6.fileURLToPath)(fileRef.url), encodeContent(fileRef, content));
  return resultRef;
}
var handleRequestFsWriteFileDataUrl = RequestFsWriteFile.createRequestHandler((req, next) => {
  const fileResource = req.params;
  const { url: url2 } = req.params;
  if (url2.protocol !== "data:") return next(req);
  const gz = isGZipped(fileResource.content);
  const baseFilename = fileResource.baseFilename || "file.txt" + (gz ? ".gz" : "");
  const mt = guessMimeType(baseFilename);
  const mediaType = mt?.mimeType || "text/plain";
  const dataUrl = toDataUrl(fileResource.content, mediaType, [["filename", baseFilename]]);
  return createResponse(Promise.resolve({
    url: dataUrl,
    baseFilename,
    gz,
    encoding: mt?.encoding
  }));
}, void 0, "Node: fs.writeFile DataUrl");
var handleRequestFsWriteFileGz = RequestFsWriteFile.createRequestHandler((req, next, dispatcher) => {
  const fileResource = req.params;
  if (!fileResource.gz && !isGzFile(fileResource.url) && (!fileResource.baseFilename || !isGzFile(fileResource.baseFilename))) return next(req);
  if (typeof fileResource.content !== "string" && isGZipped(fileResource.content)) return next(req);
  return createResponse(compressAndChainWriteRequest(dispatcher, fileResource, fileResource.content));
}, void 0, "Node: fs.writeFile compressed");
async function compressAndChainWriteRequest(dispatcher, fileRef, content) {
  const buf = await pGzip(encodeContent(fileRef, content));
  const res = dispatcher.dispatch(RequestFsWriteFile.create({
    ...fileRef,
    content: buf
  }));
  assert$1(isServiceResponseSuccess(res));
  return res.value;
}
function registerHandlers(serviceBus) {
  const handlers = [
    handleRequestFsReadFile,
    handleRequestFsReadFileSync,
    handleRequestFsWriteFile,
    handleRequestFsWriteFileDataUrl,
    handleRequestFsWriteFileGz,
    handleRequestFsReadFileHttp,
    handleRequestFsReadFileData,
    handleRequestFsReadFileSyncData,
    handleRequestFsReadDirectory,
    handleRequestZlibInflate,
    handleRequestFsStatSync,
    handleRequestFsStat,
    handleRequestFsStatHttp
  ];
  handlers.forEach((handler) => serviceBus.addHandler(handler));
}
function encodeContent(ref, content) {
  if (typeof content === "string") {
    if ([
      void 0,
      "utf8",
      "utf-8"
    ].includes(ref.encoding)) return content;
    return arrayBufferViewToBuffer(encodeString(content, ref.encoding));
  }
  return arrayBufferViewToBuffer(content);
}
function mapperDirentToDirEntry(dir) {
  return (dirent) => direntToDirEntry(dir, dirent);
}
function direntToDirEntries(dir, dirent) {
  return dirent.map(mapperDirentToDirEntry(dir));
}
function direntToDirEntry(dir, dirent) {
  return {
    name: dirent.name,
    dir,
    fileType: toFileType(dirent)
  };
}
function toFileType(statLike) {
  const t = statLike.isFile() ? FileType.File : statLike.isDirectory() ? FileType.Directory : FileType.Unknown;
  return statLike.isSymbolicLink() ? t | FileType.SymbolicLink : t;
}
var defaultCSpellIONode = void 0;
var CSpellIONode = class {
  constructor(serviceBus = new ServiceBus()) {
    this.serviceBus = serviceBus;
    registerHandlers(serviceBus);
  }
  readFile(urlOrFilename, options) {
    const readOptions = toReadFileOptions(options);
    const ref = toFileResourceRequest(urlOrFilename, readOptions?.encoding, readOptions?.signal);
    const res = this.serviceBus.dispatch(RequestFsReadFile.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "readFile");
    return res.value;
  }
  readDirectory(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsReadDirectory.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "readDirectory");
    return res.value;
  }
  readFileSync(urlOrFilename, encoding) {
    const ref = toFileReference(urlOrFilename, encoding);
    const res = this.serviceBus.dispatch(RequestFsReadFileTextSync.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "readFileSync");
    return res.value;
  }
  writeFile(urlOrFilename, content) {
    const ref = toFileReference(urlOrFilename);
    const fileResource = CFileResource.from(ref, content);
    const res = this.serviceBus.dispatch(RequestFsWriteFile.create(fileResource));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "writeFile");
    return res.value;
  }
  getStat(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStat.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "getStat");
    return res.value;
  }
  getStatSync(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStatSync.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "getStatSync");
    return res.value;
  }
  compareStats(left, right) {
    return compareStats(left, right);
  }
  toURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename)) return urlOrFilename.url;
    return toURL(urlOrFilename, relativeTo);
  }
  toFileURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename)) return urlOrFilename.url;
    return toFileURL(urlOrFilename, relativeTo);
  }
  urlBasename(urlOrFilename) {
    return urlBasename(this.toURL(urlOrFilename));
  }
  urlDirname(urlOrFilename) {
    return urlParent(this.toURL(urlOrFilename));
  }
};
function genError(err, alt) {
  return err || new ErrorNotImplemented(alt);
}
function getDefaultCSpellIO() {
  if (defaultCSpellIONode) return defaultCSpellIONode;
  const cspellIO = new CSpellIONode();
  defaultCSpellIONode = cspellIO;
  return cspellIO;
}
var debug2 = false;
async function findUpFromUrl(name2, from, options) {
  const { type: entryType = "file", stopAt, fs: fs$12 } = options;
  let dir = new URL(".", from);
  const root = new URL("/", dir);
  const predicate = makePredicate(fs$12, name2, entryType);
  const stopAtHrefs = new Set((Array.isArray(stopAt) ? stopAt : [stopAt || root]).map((p) => new URL(".", p).href));
  let last = "";
  while (dir.href !== last) {
    const found = await predicate(dir);
    if (found !== void 0) return found;
    last = dir.href;
    if (dir.href === root.href || stopAtHrefs.has(dir.href)) break;
    dir = new URL("..", dir);
  }
  return void 0;
}
function makePredicate(fs$12, name2, entryType) {
  if (typeof name2 === "function") return name2;
  const checkStat = entryType === "file" || entryType === "!file" ? "isFile" : "isDirectory";
  const checkValue = entryType.startsWith("!") ? false : true;
  function checkName(dir, name$1) {
    const f = new URL(name$1, dir);
    return fs$12.stat(f).then((stats2) => (stats2.isUnknown() || stats2[checkStat]() === checkValue) && f || void 0).catch(() => void 0);
  }
  if (!Array.isArray(name2)) return (dir) => checkName(dir, name2);
  return async (dir) => {
    const pending = name2.map((n) => checkName(dir, n));
    for (const p of pending) {
      const found = await p;
      if (found) return found;
    }
    return void 0;
  };
}
var CVFileSystem = class {
  #core;
  readFile;
  writeFile;
  stat;
  readDirectory;
  getCapabilities;
  constructor(core4) {
    this.#core = core4;
    this.readFile = this.#core.readFile.bind(this.#core);
    this.writeFile = this.#core.writeFile.bind(this.#core);
    this.stat = this.#core.stat.bind(this.#core);
    this.readDirectory = this.#core.readDirectory.bind(this.#core);
    this.getCapabilities = this.#core.getCapabilities.bind(this.#core);
  }
  get providerInfo() {
    return this.#core.providerInfo;
  }
  get hasProvider() {
    return this.#core.hasProvider;
  }
  findUp(name2, from, options = {}) {
    const opts = {
      ...options,
      fs: this.#core
    };
    return findUpFromUrl(name2, from, opts);
  }
};
var FSCapabilityFlags = /* @__PURE__ */ function(FSCapabilityFlags$1) {
  FSCapabilityFlags$1[FSCapabilityFlags$1["None"] = 0] = "None";
  FSCapabilityFlags$1[FSCapabilityFlags$1["Stat"] = 1] = "Stat";
  FSCapabilityFlags$1[FSCapabilityFlags$1["Read"] = 2] = "Read";
  FSCapabilityFlags$1[FSCapabilityFlags$1["Write"] = 4] = "Write";
  FSCapabilityFlags$1[FSCapabilityFlags$1["ReadWrite"] = 6] = "ReadWrite";
  FSCapabilityFlags$1[FSCapabilityFlags$1["ReadDir"] = 8] = "ReadDir";
  FSCapabilityFlags$1[FSCapabilityFlags$1["WriteDir"] = 16] = "WriteDir";
  FSCapabilityFlags$1[FSCapabilityFlags$1["ReadWriteDir"] = 24] = "ReadWriteDir";
  return FSCapabilityFlags$1;
}({});
function cspellIOToFsProvider(cspellIO) {
  const capabilities = FSCapabilityFlags.Stat | FSCapabilityFlags.ReadWrite | FSCapabilityFlags.ReadDir;
  const capabilitiesHttp = capabilities & ~FSCapabilityFlags.Write & ~FSCapabilityFlags.ReadDir;
  const capMap = {
    "file:": capabilities,
    "http:": capabilitiesHttp,
    "https:": capabilitiesHttp
  };
  const name2 = "CSpellIO";
  const supportedProtocols = /* @__PURE__ */ new Set([
    "file:",
    "http:",
    "https:"
  ]);
  const fs$12 = {
    providerInfo: { name: name2 },
    stat: (url2) => cspellIO.getStat(url2),
    readFile: (url2, options) => cspellIO.readFile(url2, options),
    readDirectory: (url2) => cspellIO.readDirectory(url2),
    writeFile: (file) => cspellIO.writeFile(file.url, file.content),
    dispose: () => void 0,
    capabilities,
    getCapabilities(url2) {
      return fsCapabilities(capMap[url2.protocol] || FSCapabilityFlags.None);
    }
  };
  return {
    name: name2,
    getFileSystem: (url2, _next) => {
      return supportedProtocols.has(url2.protocol) ? fs$12 : void 0;
    }
  };
}
function wrapError(e) {
  if (e instanceof VFSError) return e;
  return e;
}
var VFSError = class extends Error {
  constructor(message, options) {
    super(message, options);
  }
};
var VFSErrorUnsupportedRequest = class extends VFSError {
  url;
  constructor(request, url2, parameters) {
    super(`Unsupported request: ${request}`);
    this.request = request;
    this.parameters = parameters;
    this.url = url2?.toString();
  }
};
var CFsCapabilities = class {
  constructor(flags) {
    this.flags = flags;
  }
  get readFile() {
    return !!(this.flags & FSCapabilityFlags.Read);
  }
  get writeFile() {
    return !!(this.flags & FSCapabilityFlags.Write);
  }
  get readDirectory() {
    return !!(this.flags & FSCapabilityFlags.ReadDir);
  }
  get writeDirectory() {
    return !!(this.flags & FSCapabilityFlags.WriteDir);
  }
  get stat() {
    return !!(this.flags & FSCapabilityFlags.Stat);
  }
};
function fsCapabilities(flags) {
  return new CFsCapabilities(flags);
}
var WrappedProviderFs = class WrappedProviderFs2 {
  hasProvider;
  capabilities;
  providerInfo;
  _capabilities;
  constructor(fs$12, eventLogger) {
    this.fs = fs$12;
    this.eventLogger = eventLogger;
    this.hasProvider = !!fs$12;
    this.capabilities = fs$12?.capabilities || FSCapabilityFlags.None;
    this._capabilities = fsCapabilities(this.capabilities);
    this.providerInfo = fs$12?.providerInfo || { name: "unknown" };
  }
  logEvent(method, event, traceID, url2, message) {
    this.eventLogger({
      method,
      event,
      url: url2,
      traceID,
      ts: performance.now(),
      message
    });
  }
  getCapabilities(url2) {
    if (this.fs?.getCapabilities) return this.fs.getCapabilities(url2);
    return this._capabilities;
  }
  async stat(urlRef) {
    const traceID = performance.now();
    const url2 = urlOrReferenceToUrl(urlRef);
    this.logEvent("stat", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Stat, "stat", url2);
      return new CVfsStat(await this.fs.stat(urlRef));
    } catch (e) {
      this.logEvent("stat", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("stat", "end", traceID, url2);
    }
  }
  async readFile(urlRef, optionsOrEncoding) {
    const traceID = performance.now();
    const url2 = urlOrReferenceToUrl(urlRef);
    this.logEvent("readFile", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Read, "readFile", url2);
      const readOptions = toOptions(optionsOrEncoding);
      return fromFileResource(await this.fs.readFile(urlRef, readOptions), readOptions?.encoding);
    } catch (e) {
      this.logEvent("readFile", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readFile", "end", traceID, url2);
    }
  }
  async readDirectory(url2) {
    const traceID = performance.now();
    this.logEvent("readDir", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.ReadDir, "readDirectory", url2);
      return (await this.fs.readDirectory(url2)).map((e) => new CVfsDirEntry(e));
    } catch (e) {
      this.logEvent("readDir", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readDir", "end", traceID, url2);
    }
  }
  async writeFile(file) {
    const traceID = performance.now();
    const url2 = file.url;
    this.logEvent("writeFile", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Write, "writeFile", file.url);
      return await this.fs.writeFile(file);
    } catch (e) {
      this.logEvent("writeFile", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("writeFile", "end", traceID, url2);
    }
  }
  static disposeOf(fs$12) {
    fs$12 instanceof WrappedProviderFs2 && fs$12.fs?.dispose();
  }
};
function checkCapabilityOrThrow(fs$12, capabilities, flag, name2, url2) {
  if (!(capabilities & flag)) throw new VFSErrorUnsupportedRequest(name2, url2);
}
var CFileType = class {
  constructor(fileType) {
    this.fileType = fileType;
  }
  isFile() {
    return this.fileType === FileType.File;
  }
  isDirectory() {
    return this.fileType === FileType.Directory;
  }
  isUnknown() {
    return !this.fileType;
  }
  isSymbolicLink() {
    return !!(this.fileType & FileType.SymbolicLink);
  }
};
var CVfsStat = class extends CFileType {
  constructor(stat3) {
    super(stat3.fileType || FileType.Unknown);
    this.stat = stat3;
  }
  get size() {
    return this.stat.size;
  }
  get mtimeMs() {
    return this.stat.mtimeMs;
  }
  get eTag() {
    return this.stat.eTag;
  }
};
var CVfsDirEntry = class extends CFileType {
  _url;
  constructor(entry) {
    super(entry.fileType);
    this.entry = entry;
  }
  get name() {
    return this.entry.name;
  }
  get dir() {
    return this.entry.dir;
  }
  get url() {
    if (this._url) return this._url;
    this._url = new URL(this.entry.name, this.entry.dir);
    return this._url;
  }
  toJSON() {
    return {
      name: this.name,
      dir: this.dir,
      fileType: this.fileType
    };
  }
};
function chopUrl(url2) {
  if (!url2) return "";
  const href = url2.href;
  const parts = href.split("/");
  const n = parts.indexOf("node_modules");
  if (n > 0) {
    const tail = parts.slice(Math.max(parts.length - 3, n + 1));
    return parts.slice(0, n + 1).join("/") + "/\u2026/" + tail.join("/");
  }
  return href;
}
function rPad(str, len, ch = " ") {
  return str.padEnd(len, ch);
}
function toOptions(val) {
  return typeof val === "string" ? { encoding: val } : val;
}
var CVirtualFS = class {
  providers = /* @__PURE__ */ new Set();
  cachedFs = /* @__PURE__ */ new Map();
  revCacheFs = /* @__PURE__ */ new Map();
  fsc;
  fs;
  loggingEnabled = debug2;
  constructor() {
    this.fsc = fsPassThroughCore((url2) => this._getFS(url2));
    this.fs = new CVFileSystem(this.fsc);
  }
  enableLogging(value) {
    this.loggingEnabled = value ?? true;
  }
  log = console.log;
  logEvent = (event) => {
    if (this.loggingEnabled) {
      const id = event.traceID.toFixed(13).replaceAll(/\d{4}(?=\d)/g, "$&.");
      const msg = event.message ? `
		${event.message}` : "";
      const method = rPad(`${event.method}-${event.event}`, 16);
      this.log(`${method} ID:${id} ts:${event.ts.toFixed(13)} ${chopUrl(event.url)}${msg}`);
    }
  };
  registerFileSystemProvider(...providers) {
    providers.forEach((provider) => this.providers.add(provider));
    this.reset();
    return { dispose: () => {
      for (const provider of providers) {
        for (const key of this.revCacheFs.get(provider) || []) this.cachedFs.delete(key);
        this.providers.delete(provider);
      }
      this.reset();
    } };
  }
  getFS(url2) {
    return new CVFileSystem(this._getFS(url2));
  }
  _getFS(url2) {
    const key = `${url2.protocol}${url2.hostname}`;
    const cached = this.cachedFs.get(key);
    if (cached) return cached;
    const fnNext = (provider, next$1) => {
      return (url$1) => {
        let calledNext = false;
        const fs$2 = provider.getFileSystem(url$1, (_url) => {
          calledNext = calledNext || url$1 === _url;
          return next$1(_url);
        });
        if (fs$2) {
          const s = this.revCacheFs.get(provider) || /* @__PURE__ */ new Set();
          s.add(key);
          this.revCacheFs.set(provider, s);
          return fs$2;
        }
        if (!calledNext) return next$1(url$1);
        return void 0;
      };
    };
    let next = (_url) => void 0;
    for (const provider of this.providers) next = fnNext(provider, next);
    const fs$12 = new WrappedProviderFs(next(url2), this.logEvent);
    this.cachedFs.set(key, fs$12);
    return fs$12;
  }
  reset() {
    this.disposeOfCachedFs();
  }
  disposeOfCachedFs() {
    for (const [key, fs$12] of [...this.cachedFs].reverse()) {
      try {
        WrappedProviderFs.disposeOf(fs$12);
      } catch {
      }
      this.cachedFs.delete(key);
    }
    this.cachedFs.clear();
    this.revCacheFs.clear();
  }
  dispose() {
    this.disposeOfCachedFs();
    const providers = [...this.providers].reverse();
    for (const provider of providers) try {
      provider.dispose?.();
    } catch {
    }
  }
};
function fsPassThroughCore(fs$12) {
  function gfs(ur, name2) {
    const url2 = urlOrReferenceToUrl(ur);
    const f = fs$12(url2);
    if (!f.hasProvider) throw new VFSErrorUnsupportedRequest(name2, url2, ur instanceof URL ? void 0 : {
      url: ur.url.toString(),
      encoding: ur.encoding
    });
    return f;
  }
  return {
    providerInfo: { name: "default" },
    hasProvider: true,
    stat: async (url2) => gfs(url2, "stat").stat(url2),
    readFile: async (url2, options) => gfs(url2, "readFile").readFile(url2, options),
    writeFile: async (file) => gfs(file, "writeFile").writeFile(file),
    readDirectory: async (url2) => gfs(url2, "readDirectory").readDirectory(url2).then((entries) => entries.map((e) => new CVfsDirEntry(e))),
    getCapabilities: (url2) => gfs(url2, "getCapabilities").getCapabilities(url2)
  };
}
function createVirtualFS(cspellIO) {
  const cspell = cspellIO || getDefaultCSpellIO();
  const vfs = new CVirtualFS();
  vfs.registerFileSystemProvider(cspellIOToFsProvider(cspell));
  return vfs;
}
var defaultVirtualFs = void 0;
function getDefaultVirtualFs() {
  if (!defaultVirtualFs) defaultVirtualFs = createVirtualFS();
  return defaultVirtualFs;
}
var pipeline2 = (0, import_node_util4.promisify)(Stream.pipeline);
async function readFileText(filename, encoding) {
  const fr = await getDefaultCSpellIO().readFile(filename, encoding);
  return fr.getText();
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/fileSystem.js
function getVirtualFS() {
  return getDefaultVirtualFs();
}
function getFileSystem() {
  return getVirtualFS().fs;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/pkg-info.mjs
var import_node_url7 = require("node:url");
var import_meta = {};
var url = import_meta.url;
function calcSrcDirectory() {
  try {
    return __dirname;
  } catch {
    return url ? (0, import_node_url7.fileURLToPath)(new URL("./", url)) : process.cwd();
  }
}
var srcDirectory = calcSrcDirectory();

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/templates.js
function replaceTemplate(template2, replacements) {
  const templateStart = "${";
  const tLen = templateStart.length;
  const templateEnd = "}";
  const parts = [];
  let lastPos = 0;
  let p = template2.indexOf(templateStart, lastPos);
  if (p < 0)
    return template2;
  while (p >= 0) {
    parts.push(template2.substring(lastPos, p));
    lastPos = p;
    const end = template2.indexOf(templateEnd, p);
    if (end < 0)
      break;
    const name2 = template2.substring(p + tLen, end);
    if (name2 in replacements) {
      parts.push(replacements[name2] || "");
    } else {
      parts.push(template2.substring(p, end + 1));
    }
    lastPos = end + 1;
    p = template2.indexOf(templateStart, lastPos);
  }
  parts.push(template2.substring(lastPos));
  return parts.join("");
}
function envToTemplateVars(env4) {
  const vars = {};
  for (const [key, value] of Object.entries(env4)) {
    vars[`env:${key}`] = value || "";
  }
  return vars;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/url.js
function getSourceDirectoryUrl() {
  const srcDirectoryURL = toFileDirURL(srcDirectory);
  return srcDirectoryURL;
}
function cwdURL() {
  return toFileDirURL("./");
}
function toFileUrl(file) {
  return toFileURL(file, cwdURL());
}
function fileURLOrPathToPath(filenameOrURL) {
  return toFilePathOrHref(filenameOrURL);
}
var regExpWindowsPathDriveLetter2 = /^([a-zA-Z]):[\\]/;
function windowsDriveLetterToUpper(absoluteFilePath) {
  return absoluteFilePath.replace(regExpWindowsPathDriveLetter2, (s) => s.toUpperCase());
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/resolveFile.js
var regExpStartsWidthNodeModules = /^node_modules[/\\]/;
var debugMode = false;
var FileResolver = class {
  fs;
  templateReplacements;
  constructor(fs6, templateReplacements) {
    this.fs = fs6;
    this.templateReplacements = templateReplacements;
  }
  /**
   * Resolve filename to absolute paths.
   * - Replaces `${env:NAME}` with the value of the environment variable `NAME`.
   * - Replaces `~` with the user's home directory.
   * It tries to look for local files as well as node_modules
   * @param filename an absolute path, relative path, `~` path, a node_module, or URL.
   * @param relativeTo absolute path
   */
  async resolveFile(filename, relativeTo) {
    if (filename instanceof URL) {
      return {
        filename: toFilePathOrHref(filename),
        relativeTo: relativeTo.toString(),
        found: await this.doesExist(filename),
        method: "url"
      };
    }
    const result = await this._resolveFile(filename, relativeTo);
    const match2 = filename.match(regExpStartsWidthNodeModules);
    if (match2) {
      result.warning ??= `Import of '${filename}' should not start with '${match2[0]}' in '${toFilePathOrHref(relativeTo)}'. Use '${filename.replace(regExpStartsWidthNodeModules, "")}' or a relative path instead.`;
    }
    return result;
  }
  async _resolveFile(filename, relativeTo) {
    filename = patchFilename(filename, this.templateReplacements);
    const steps = [
      { filename, fn: this.tryUrlRel },
      { filename, fn: this.tryCreateRequire },
      { filename, fn: this.tryNodeRequireResolve },
      { filename, fn: this.tryImportResolve },
      { filename, fn: this.tryResolveExists },
      { filename, fn: this.tryNodeResolveDefaultPaths },
      { filename, fn: this.tryResolveFrom },
      { filename, fn: this.tryResolveGlobal },
      { filename, fn: this.tryLegacyResolve }
    ];
    for (const step of steps) {
      const r = await step.fn(step.filename, relativeTo);
      if (r?.found)
        return r;
    }
    const result = await this.tryUrl(filename, relativeTo) || {
      filename: isRelative(filename) ? joinWith(filename, relativeTo) : filename.toString(),
      relativeTo: relativeTo.toString(),
      found: false,
      method: "not found"
    };
    return result;
  }
  async doesExist(file) {
    try {
      const s = await this.fs.stat(file);
      return s.isFile() || s.isUnknown();
    } catch {
      return false;
    }
  }
  /**
   * Check to see if it is a URL.
   * Note: URLs are absolute!
   * If relativeTo is a non-file URL, then it will try to resolve the filename relative to it.
   * @param filename - url string
   * @returns ResolveFileResult
   */
  tryUrlRel = async (filename, relativeToURL) => {
    if (isUrlLike(filename)) {
      const fileURL = toURL(filename);
      return {
        filename: toFilePathOrHref(fileURL),
        relativeTo: void 0,
        found: await this.doesExist(fileURL),
        method: "tryUrl"
      };
    }
    if (isRelative(filename) && isUrlLike(relativeToURL) && !isDataURL(relativeToURL)) {
      const relToURL = toURL(relativeToURL);
      const url2 = toFileURL(filename, relToURL);
      return {
        filename: toFilePathOrHref(url2),
        relativeTo: toFilePathOrHref(relToURL),
        found: await this.doesExist(url2),
        method: "tryUrl"
      };
    }
    return void 0;
  };
  /**
   * Check to see if it is a URL.
   * Note: URLs are absolute!
   * If relativeTo is a non-file URL, then it will try to resolve the filename relative to it.
   * @param filename - url string
   * @returns ResolveFileResult
   */
  tryUrl = async (filename, relativeToURL) => {
    if (isUrlLike(relativeToURL) && !isDataURL(relativeToURL)) {
      const relToURL = toURL(relativeToURL);
      const url2 = toFileURL(filename, relToURL);
      return {
        filename: toFilePathOrHref(url2),
        relativeTo: toFilePathOrHref(relToURL),
        found: await this.doesExist(url2),
        method: "tryUrl"
      };
    }
    return void 0;
  };
  tryCreateRequire = (filename, relativeTo) => {
    if (filename instanceof URL)
      return void 0;
    const rel = !isUrlLike(relativeTo) || isFileURL(relativeTo) ? relativeTo : toFileDirURL("./");
    try {
      const require2 = (0, import_node_module2.createRequire)(rel);
      const r = require2.resolve(filename);
      return { filename: r, relativeTo: rel.toString(), found: true, method: "tryCreateRequire" };
    } catch (error4) {
      if (debugMode) {
        console.error("Error in tryCreateRequire: %o", { filename, rel, relativeTo, error: `${error4}` });
      }
      return void 0;
    }
  };
  tryNodeResolveDefaultPaths = (filename) => {
    try {
      const r = require.resolve(filename);
      return { filename: r, relativeTo: void 0, found: true, method: "tryNodeResolveDefaultPaths" };
    } catch {
      return void 0;
    }
  };
  tryNodeRequireResolve = (filenameOrURL, relativeTo) => {
    if (isUrlLike(relativeTo) && !isFileURL(relativeTo))
      return void 0;
    const filename = fileURLOrPathToPath(filenameOrURL);
    const relativeToPath = pathFromRelativeTo(relativeTo);
    const home = os3.homedir();
    function calcPaths(p) {
      const paths2 = [p];
      if (isRelative(filename)) {
        return paths2;
      }
      for (; p && path5.dirname(p) !== p && p !== home; p = path5.dirname(p)) {
        paths2.push(p);
      }
      return paths2;
    }
    const paths = calcPaths(path5.resolve(relativeToPath));
    try {
      const r = require.resolve(filename, { paths });
      return { filename: r, relativeTo: relativeToPath, found: true, method: "tryNodeRequireResolve" };
    } catch {
      return void 0;
    }
  };
  tryImportResolve = (filename, relativeTo) => {
    try {
      const paths = isRelative(filename) ? [relativeTo] : [relativeTo, srcDirectory];
      const resolved = (0, import_node_url8.fileURLToPath)(importResolveModuleName(filename, paths));
      return { filename: resolved, relativeTo: relativeTo.toString(), found: true, method: "tryImportResolve" };
    } catch {
      return void 0;
    }
  };
  tryResolveGlobal = (filename) => {
    const r = resolveGlobal(filename);
    return r && { filename: r, relativeTo: void 0, found: true, method: "tryResolveGlobal" } || void 0;
  };
  tryResolveExists = async (filename, relativeTo) => {
    if (filename instanceof URL || isUrlLike(filename) || isUrlLike(relativeTo) && !isFileURL(relativeTo)) {
      return void 0;
    }
    relativeTo = pathFromRelativeTo(relativeTo);
    const toTry = [{ filename }, { filename: path5.resolve(relativeTo, filename), relativeTo }];
    for (const { filename: filename2, relativeTo: relativeTo2 } of toTry) {
      const found = path5.isAbsolute(filename2) && await this.doesExist(toFileUrl(filename2));
      if (found)
        return { filename: filename2, relativeTo: relativeTo2?.toString(), found, method: "tryResolveExists" };
    }
    filename = path5.resolve(filename);
    return {
      filename,
      relativeTo: path5.resolve("."),
      found: await this.doesExist(toFileUrl(filename)),
      method: "tryResolveExists"
    };
  };
  tryResolveFrom = (filename, relativeTo) => {
    if (relativeTo instanceof URL)
      return void 0;
    try {
      return {
        filename: (0, import_resolve_from.default)(pathFromRelativeTo(relativeTo), filename),
        relativeTo,
        found: true,
        method: "tryResolveFrom"
      };
    } catch {
      return void 0;
    }
  };
  tryLegacyResolve = (filename, relativeTo) => {
    if (filename instanceof URL || isUrlLike(filename) || isUrlLike(relativeTo) && !isFileURL(relativeTo)) {
      return void 0;
    }
    const relativeToPath = isUrlLike(relativeTo) ? (0, import_node_url8.fileURLToPath)(new URL("./", relativeTo)) : relativeTo.toString();
    const match2 = filename.match(regExpStartsWidthNodeModules);
    if (match2) {
      const fixedFilename = filename.replace(regExpStartsWidthNodeModules, "");
      const found = this.tryImportResolve(fixedFilename, relativeToPath) || this.tryResolveFrom(fixedFilename, relativeToPath);
      if (found?.found) {
        found.method = "tryLegacyResolve";
        return found;
      }
    }
    return void 0;
  };
};
function patchFilename(filename, templateReplacements) {
  const defaultReplacements = {
    cwd: process.cwd(),
    pathSeparator: path5.sep,
    userHome: os3.homedir()
  };
  filename = filename.replace(/^~(?=[/\\])/, defaultReplacements.userHome);
  filename = replaceTemplate(filename, { ...defaultReplacements, ...templateReplacements });
  return filename;
}
function resolveRelativeTo(filename, relativeTo, templateReplacements = envToTemplateVars(process.env)) {
  if (filename instanceof URL)
    return filename;
  filename = patchFilename(filename, templateReplacements);
  const relativeToUrl = toFileUrl(relativeTo);
  return toFileURL(filename, relativeToUrl);
}
function isRelative(filename) {
  if (filename instanceof URL)
    return false;
  if (isUrlLike(filename))
    return false;
  if (filename.startsWith("./"))
    return true;
  if (filename.startsWith("../"))
    return true;
  if (filename.startsWith("." + path5.sep))
    return true;
  if (filename.startsWith(".." + path5.sep))
    return true;
  return false;
}
function joinWith(filename, relativeTo) {
  return relativeTo instanceof URL || isUrlLike(relativeTo) ? toFilePathOrHref(new URL(filename, relativeTo)) : path5.resolve(relativeTo, filename);
}
function pathFromRelativeTo(relativeTo) {
  return relativeTo instanceof URL || isUrlLike(relativeTo) ? (0, import_node_url8.fileURLToPath)(new URL("./", relativeTo)) : relativeTo;
}
var loaderCache = /* @__PURE__ */ new WeakMap();
function createFileResolver(fs6, templateVariables = envToTemplateVars(process.env)) {
  let loader2 = loaderCache.get(fs6);
  if (!loader2) {
    loader2 = new FileResolver(fs6, templateVariables);
    loaderCache.set(fs6, loader2);
  }
  return loader2;
}
async function resolveFile(filename, relativeTo, fs6 = getFileSystem()) {
  const resolver = createFileResolver(fs6);
  return resolver.resolveFile(filename, relativeTo);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/DictionaryReferenceCollection.js
function createDictionaryReferenceCollection(dictionaries) {
  return new _DictionaryReferenceCollection(dictionaries);
}
var _DictionaryReferenceCollection = class {
  dictionaries;
  collection;
  constructor(dictionaries) {
    this.dictionaries = dictionaries;
    this.collection = collect(dictionaries);
  }
  isEnabled(name2) {
    const entry = this.collection[name2];
    return entry === void 0 ? void 0 : !!(entry & 1);
  }
  isBlocked(name2) {
    const entry = this.collection[name2];
    return entry === void 0 ? void 0 : !(entry & 1);
  }
  enabled() {
    return this.dictionaryIds.filter((n) => this.isEnabled(n));
  }
  blocked() {
    return this.dictionaryIds.filter((n) => this.isBlocked(n));
  }
  get dictionaryIds() {
    return Object.keys(this.collection);
  }
};
function collect(dictionaries) {
  const refs = dictionaries.map(normalizeName).map(mapReference);
  const col = {};
  for (const ref of refs) {
    col[ref.name] = Math.max(ref.weight, col[ref.name] || 0);
  }
  return col;
}
function normalizeName(entry) {
  return entry.normalize().trim();
}
function mapReference(ref) {
  const name2 = ref.replace(/^!+/, "");
  const weight = ref.length - name2.length + 1;
  return { name: name2.trim(), weight };
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/DictionarySettings.js
function filterDictDefsToLoad(dictRefCol, defs) {
  const allActiveDefs = defs.filter(({ name: name2 }) => dictRefCol.isEnabled(name2)).map(fixPath);
  return [...new Map(allActiveDefs.map((d) => [d.name, d])).values()];
}
function fixPath(def) {
  if (def instanceof _DictionaryDefinitionInternalWithSource) {
    return def;
  }
  const newPath = fixDicPath(def.path, def.file);
  return {
    ...def,
    file: void 0,
    path: newPath
  };
}
function fixDicPath(defPath, defFile) {
  const parts = [defPath || "", defFile || ""].filter((p) => !!p);
  return parts.length > 1 ? path6.join(...parts) : parts[0] || "";
}
function mapDictDefsToInternal(defs, pathToSettingsFile) {
  return defs?.map((def) => mapDictDefToInternal(def, pathToSettingsFile));
}
var internalDefs = createAutoResolveWeakWeakCache();
function mapDictDefToInternal(def, pathToSettingsFile) {
  return internalDefs.get(def, (def2) => _mapDictDefToInternal(def2, pathToSettingsFile));
}
function _mapDictDefToInternal(def, pathToSettingsFile) {
  if (isDictionaryDefinitionWithSource(def)) {
    return def;
  }
  const source = pathToSettingsFile.href;
  if (isDictionaryDefinitionInlineInternal(def)) {
    return { ...def, __source: source };
  }
  return new _DictionaryDefinitionInternalWithSource(def, pathToSettingsFile);
}
function determineName(filename, options) {
  return options.name || path6.basename(filename);
}
function calcDictionaryDefsToLoad(settings) {
  const { dictionaries = [], dictionaryDefinitions = [], noSuggestDictionaries = [] } = settings;
  const colNoSug = createDictionaryReferenceCollection(noSuggestDictionaries);
  const colDicts = createDictionaryReferenceCollection([...dictionaries, ...colNoSug.enabled()]);
  const modDefs = dictionaryDefinitions.map((def) => {
    const enabled = colNoSug.isEnabled(def.name);
    if (enabled === void 0)
      return def;
    return { ...def, noSuggest: enabled };
  });
  return filterDictDefsToLoad(colDicts, modDefs);
}
function isDictionaryDefinitionWithSource(d) {
  return isDictionaryFileDefinitionInternalWithSource(d) || isDictionaryDefinitionInlineInternalWithSource(d);
}
function isDictionaryFileDefinitionInternalWithSource(def) {
  return def instanceof _DictionaryDefinitionInternalWithSource;
}
function isDictionaryDefinitionInlineInternalWithSource(def) {
  return isDictionaryDefinitionInlineInternal(def) && !!def.__source;
}
var _DictionaryDefinitionInternalWithSource = class {
  sourceURL;
  _weightMap;
  name;
  path;
  addWords;
  description;
  dictionaryInformation;
  type;
  file;
  repMap;
  useCompounds;
  noSuggest;
  ignoreForbiddenWords;
  scope;
  __source;
  ddi;
  constructor(def, sourceURL) {
    this.sourceURL = sourceURL;
    this.__source = sourceURL.href;
    const defAll = def;
    const { path: relPath = "", file = "", addWords, description, dictionaryInformation, type, repMap, noSuggest, ignoreForbiddenWords, scope, supportNonStrictSearches, useCompounds } = defAll;
    const defaultPath = sourceURL;
    const filePath = fixDicPath(relPath, file);
    const name2 = determineName(filePath, def);
    const resolvedPath = toFilePathOrHref(resolveRelativeTo(filePath, defaultPath));
    const ddi = {
      name: name2,
      file: void 0,
      path: resolvedPath,
      addWords,
      description,
      dictionaryInformation,
      type,
      repMap,
      noSuggest,
      ignoreForbiddenWords,
      supportNonStrictSearches,
      scope,
      useCompounds
    };
    Object.assign(this, clean3(ddi));
    this.ddi = ddi;
    this.name = ddi.name;
    this.file = ddi.file;
    this.path = ddi.path;
    this._weightMap = this.dictionaryInformation ? mapDictionaryInformationToWeightMap(this.dictionaryInformation) : void 0;
  }
  get weightMap() {
    return this._weightMap;
  }
  toJSON() {
    return this.ddi;
  }
};

// ../node_modules/.pnpm/@cspell+strong-weak-map@9.1.5/node_modules/@cspell/strong-weak-map/dist/esm/StrongWeakMap.js
var StrongWeakMap = class {
  map;
  constructor(init) {
    this.map = new Map(init?.map(([k, v]) => [k, new WeakRef(v)]));
  }
  clear() {
    this.map.clear();
  }
  /**
   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    return this.map.delete(key);
  }
  /**
   * Executes a provided function once per each key/value pair in the Map, in insertion order.
   */
  forEach(callbackfn, thisArg) {
    if (thisArg) {
      callbackfn = callbackfn.bind(thisArg);
    }
    for (const [key, value] of this) {
      callbackfn(value, key, this);
    }
  }
  /**
   * Returns a specified element from the Map object. You will get a reference to the value object and any change made to that
   * object will effectively modify it inside the Map.
   * @returns Returns the element associated with the specified key.
   *   If no element is associated with the specified key, undefined is returned.
   */
  get(key) {
    const ref = this.map.get(key);
    if (!ref)
      return void 0;
    const value = ref.deref();
    if (!value) {
      this.map.delete(key);
      return void 0;
    }
    return value;
  }
  /**
   * Returns a specified element from the Map. If the element isn't found, the resolver function is called and the result is stored in the map and returned.
   */
  autoGet(key, resolver) {
    const found = this.get(key);
    if (found)
      return found;
    const created = resolver(key);
    this.set(key, created);
    return created;
  }
  /**
   * Note: has will cause the value object to live longer.
   * See: [WeakRef - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef#notes_on_weakrefs)
   * @returns boolean indicating whether an element with the specified key exists or not.
   */
  has(key) {
    const value = this.get(key);
    return !!value;
  }
  /**
   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.
   */
  set(key, value) {
    this.map.set(key, new WeakRef(value));
    return this;
  }
  /**
   * @returns the number of elements in the Map. Note: it is possible that some of the values have been dereferenced
   */
  get size() {
    return this.map.size;
  }
  /** Returns an iterable of entries in the map. */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Returns an iterable of key, value pairs for every entry in the map.
   */
  *entries() {
    for (const key of this.map.keys()) {
      const value = this.get(key);
      if (!value)
        continue;
      yield [key, value];
    }
  }
  /**
   * Returns an iterable of keys in the map
   *
   * Note: It is possible that the value associated with the key was released.
   */
  keys() {
    return this.map.keys();
  }
  /**
   * Returns an iterable of values in the map
   */
  *values() {
    for (const [_, value] of this) {
      yield value;
    }
  }
  /**
   * Removes any keys that reference released objects.
   */
  cleanKeys() {
    const keysToDel = [];
    for (const [key, ref] of this.map.entries()) {
      if (!ref.deref()) {
        keysToDel.push(key);
      }
    }
    for (const key of keysToDel) {
      this.map.delete(key);
    }
    return this;
  }
  [Symbol.toStringTag] = "StrongWeakMap";
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/simpleCache.js
var SimpleCache2 = class {
  size;
  L0 = /* @__PURE__ */ new Map();
  L1 = /* @__PURE__ */ new Map();
  L2 = /* @__PURE__ */ new Map();
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  delete(key) {
    let deleted = false;
    for (const c of this.caches()) {
      deleted = c.delete(key) || deleted;
    }
    return deleted;
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    const L2 = this.L2;
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = L2;
    this.L0.clear();
  }
};
var AutoCache = class extends SimpleCache2 {
  factory;
  constructor(factory, size) {
    super(size);
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== void 0)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/SpellingDictionary/SpellingDictionaryError.js
var SpellingDictionaryLoadError = class extends Error {
  uri;
  options;
  cause;
  name;
  constructor(uri, options, cause, message) {
    super(message);
    this.uri = uri;
    this.options = options;
    this.cause = cause;
    this.name = options.name;
  }
};
function isSpellingDictionaryLoadError(e) {
  return e instanceof SpellingDictionaryLoadError;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryController/DictionaryLoader.js
var MAX_AGE = 1e4;
var loaders = {
  S: loadSimpleWordList,
  C: legacyWordList,
  W: wordsPerLineWordList,
  T: loadTrie,
  default: loadSimpleWordList
};
var LoadingState;
(function(LoadingState2) {
  LoadingState2[LoadingState2["Loaded"] = 0] = "Loaded";
  LoadingState2[LoadingState2["Loading"] = 1] = "Loading";
})(LoadingState || (LoadingState = {}));
var DictionaryLoader = class {
  fs;
  dictionaryCache = new StrongWeakMap();
  inlineDictionaryCache = new AutoResolveWeakCache2();
  dictionaryCacheByDef = new AutoResolveWeakWeakCache();
  reader;
  /** The keepAliveCache is to hold onto the most recently loaded dictionaries. */
  keepAliveCache;
  constructor(fs6, keepAliveSize = 10) {
    this.fs = fs6;
    this.reader = toReader(fs6);
    this.keepAliveCache = new SimpleCache2(keepAliveSize);
  }
  loadDictionary(def) {
    if (isDictionaryDefinitionInlineInternal(def)) {
      return Promise.resolve(this.loadInlineDict(def));
    }
    if (isDictionaryFileDefinitionInternal(def)) {
      const { key, entry } = this.getCacheEntry(def);
      if (entry) {
        return entry.pending.then(([dictionary]) => dictionary);
      }
      const loadedEntry = this.loadEntry(def.path, def);
      this.setCacheEntry(key, loadedEntry, def);
      this.keepAliveCache.set(def, loadedEntry);
      return loadedEntry.pending.then(([dictionary]) => dictionary);
    }
    return Promise.resolve(this.loadSimpleDict(def));
  }
  /**
   * Check to see if any of the cached dictionaries have changed. If one has changed, reload it.
   * @param maxAge - Only check the dictionary if it has been at least `maxAge` ms since the last check.
   * @param now - optional timestamp representing now. (Mostly used in testing)
   */
  async refreshCacheEntries(maxAge = MAX_AGE, now = Date.now()) {
    await Promise.all([...this.dictionaryCache.values()].map((entry) => this.refreshEntry(entry, maxAge, now)));
  }
  getCacheEntry(def) {
    const defEntry = this.dictionaryCacheByDef.get(def);
    if (defEntry) {
      this.keepAliveCache.get(def);
      return defEntry;
    }
    const key = this.calcKey(def);
    const entry = this.dictionaryCache.get(key);
    if (entry) {
      entry.options = def;
      this.keepAliveCache.set(def, entry);
    }
    return { key, entry };
  }
  setCacheEntry(key, entry, def) {
    this.dictionaryCache.set(key, entry);
    this.dictionaryCacheByDef.set(def, { key, entry });
  }
  async refreshEntry(entry, maxAge, now) {
    if (now - entry.ts >= maxAge) {
      const sig = now + Math.random();
      entry.sig = sig;
      entry.ts = now;
      const pStat = this.getStat(entry.uri);
      const [newStat] = await Promise.all([pStat, entry.pending]);
      const hasChanged = !this.isEqual(newStat, entry.stat);
      const sigMatches = entry.sig === sig;
      if (sigMatches && hasChanged) {
        entry.loadingState = LoadingState.Loading;
        const key = this.calcKey(entry.options);
        const newEntry = this.loadEntry(entry.uri, entry.options);
        this.dictionaryCache.set(key, newEntry);
        this.dictionaryCacheByDef.set(entry.options, { key, entry: newEntry });
      }
    }
  }
  loadEntry(fileOrUri, options, now = Date.now()) {
    const url2 = toFileURL(fileOrUri);
    options = this.normalizeOptions(url2, options);
    const pDictionary = load(this.reader, toFileURL(fileOrUri), options).catch((e) => createFailedToLoadDictionary(options.name, fileOrUri, new SpellingDictionaryLoadError(url2.href, options, e, "failed to load"), options));
    const pStat = this.getStat(fileOrUri);
    const pending = Promise.all([pDictionary, pStat]);
    const sig = now + Math.random();
    const entry = {
      uri: url2.href,
      options,
      ts: now,
      stat: void 0,
      dictionary: void 0,
      pending,
      loadingState: LoadingState.Loading,
      sig
    };
    pending.then(([dictionary, stat3]) => {
      entry.stat = stat3;
      entry.dictionary = dictionary;
      entry.loadingState = LoadingState.Loaded;
      return;
    }).catch(() => void 0);
    return entry;
  }
  getStat(uri) {
    return this.fs.stat(toFileURL(uri)).catch(toError2);
  }
  isEqual(a, b) {
    if (!b)
      return false;
    if (isError4(a)) {
      return isError4(b) && a.message === b.message && a.name === b.name;
    }
    return !isError4(b) && !compareStats(a, b);
  }
  normalizeOptions(uri, options) {
    if (options.name)
      return options;
    return { ...options, name: urlBasename(uri) };
  }
  loadInlineDict(def) {
    return this.inlineDictionaryCache.get(def, (def2) => createInlineSpellingDictionary(def2, def2.__source || "memory"));
  }
  loadSimpleDict(def) {
    return createInlineSpellingDictionary({ name: def.name, words: [] }, def.__source || "memory");
  }
  calcKey(def) {
    const path17 = def.path;
    const loaderType = determineType(toFileURL(path17), def);
    const optValues = importantOptionKeys.map((k) => def[k]?.toString() || "");
    const parts = [path17, loaderType, ...optValues];
    return parts.join("|");
  }
};
function toReader(fs6) {
  async function readFile4(url2) {
    return (await fs6.readFile(url2)).getText();
  }
  return {
    read: readFile4,
    readLines: async (filename) => toLines(await readFile4(filename))
  };
}
var importantOptionKeys = ["name", "noSuggest", "useCompounds", "type"];
function isError4(e) {
  const err = e;
  return !!err.message;
}
function determineType(uri, opts) {
  const t = opts.type && opts.type in loaders && opts.type || "S";
  const defLoaderType = t;
  const defType = uri.pathname.endsWith(".trie.gz") ? "T" : defLoaderType;
  const regTrieTest = /\.trie\b/i;
  return regTrieTest.test(uri.pathname) ? "T" : defType;
}
function load(reader, uri, options) {
  const type = determineType(uri, options);
  const loader2 = loaders[type] || loaders.default;
  return loader2(reader, uri, options);
}
async function legacyWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return _legacyWordListSync(lines, filename, options);
}
function _legacyWordListSync(lines, filename, options) {
  const words = pipeSync(
    lines,
    // Remove comments
    opMapSync((line) => line.replaceAll(/#.*/g, "")),
    // Split on everything else
    opConcatMapSync((line) => line.split(/[^\w\p{L}\p{M}'’]+/gu)),
    opFilterSync((word) => !!word)
  );
  return createSpellingDictionary(words, options.name, filename.toString(), options);
}
async function wordsPerLineWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return _wordsPerLineWordList(lines, filename.toString(), options);
}
function _wordsPerLineWordList(lines, filename, options) {
  const words = pipeSync(
    lines,
    // Remove comments
    opMapSync((line) => line.replaceAll(/#.*/g, "")),
    // Split on everything else
    opConcatMapSync((line) => line.split(/\s+/gu)),
    opFilterSync((word) => !!word)
  );
  return createSpellingDictionary(words, options.name, filename, options);
}
async function loadSimpleWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return createSpellingDictionary(lines, options.name, filename.href, options);
}
async function loadTrie(reader, filename, options) {
  const content = await reader.read(filename);
  return createSpellingDictionaryFromTrieFile(content, options.name, filename.href, options);
}
function toLines(content) {
  return content.split(/\n|\r\n|\r/);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryLoader.js
var loader;
function getDictionaryLoader(vfs) {
  if (loader)
    return loader;
  return loader = new DictionaryLoader(vfs || getFileSystem());
}
function loadDictionary(def) {
  return getDictionaryLoader().loadDictionary(def);
}
async function refreshCacheEntries(maxAge, now) {
  return getDictionaryLoader().refreshCacheEntries(maxAge, now);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/SpellingDictionary/Dictionaries.js
function loadDictionaryDefs(defsToLoad) {
  return defsToLoad.map(loadDictionary);
}
function refreshDictionaryCache(maxAge) {
  return refreshCacheEntries(maxAge);
}
var emptyWords = Object.freeze([]);
async function getDictionaryInternal(settings) {
  const spellDictionaries = await Promise.all(loadDictionaryDefs(calcDictionaryDefsToLoad(settings)));
  return _getDictionaryInternal(settings, spellDictionaries);
}
var specialDictionaryNames = {
  words: "[words]",
  userWords: "[userWords]",
  flagWords: "[flagWords]",
  ignoreWords: "[ignoreWords]",
  suggestWords: "[suggestWords]"
};
var mapSpecialDictionaryNamesToSettings = new Map(Object.entries(specialDictionaryNames).map(([k, v]) => [v, k]));
function getInlineConfigDictionaries(settings) {
  const { words = emptyWords, userWords = emptyWords, flagWords = emptyWords, ignoreWords = emptyWords, suggestWords = emptyWords } = settings;
  const settingsWordsDictionary = createSpellingDictionary(words, specialDictionaryNames.words, "From Settings `words`", {
    caseSensitive: true,
    weightMap: void 0
  });
  const settingsUserWordsDictionary = userWords.length ? createSpellingDictionary(userWords, specialDictionaryNames.userWords, "From Settings `userWords`", {
    caseSensitive: true,
    weightMap: void 0
  }) : void 0;
  const ignoreWordsDictionary = createIgnoreWordsDictionary(ignoreWords, specialDictionaryNames.ignoreWords, "From Settings `ignoreWords`");
  const flagWordsDictionary = createFlagWordsDictionary(flagWords, specialDictionaryNames.flagWords, "From Settings `flagWords`");
  const suggestWordsDictionary = createSuggestDictionary(suggestWords, "[suggestWords]", "From Settings `suggestWords`");
  const dictionaries = [
    settingsWordsDictionary,
    settingsUserWordsDictionary,
    ignoreWordsDictionary,
    flagWordsDictionary,
    suggestWordsDictionary
  ].filter(isDefined3);
  return dictionaries;
}
function _getDictionaryInternal(settings, spellDictionaries) {
  const dictionaries = [...spellDictionaries, ...getInlineConfigDictionaries(settings)];
  return createCollection(dictionaries, "dictionary collection");
}

// ../node_modules/.pnpm/@cspell+filetypes@9.1.5/node_modules/@cspell/filetypes/dist/definitions.js
var definitions = [
  { id: "ada", extensions: [".adb", ".ads"] },
  { id: "apiblueprint", extensions: [".apib", ".apiblueprint"] },
  { id: "argdown", extensions: [".ad", ".adown", ".argdn", ".argdown"] },
  { id: "asciidoc", extensions: [".adoc", ".asc", ".asciidoc"] },
  { id: "bat", extensions: [".bat", ".cmd"] },
  { id: "bazel", extensions: [".bazel", ".bzl"] },
  { id: "bibtex", extensions: [".bib"] },
  { id: "bicep", extensions: [".bicep"] },
  { id: "c", extensions: [".c", ".i"] },
  { id: "cache_files", extensions: [], filenames: [".DS_Store", ".cspellcache", ".eslintcache"] },
  { id: "clojure", extensions: [".clj", ".cljc", ".cljs", ".cljx", ".clojure", ".edn"] },
  { id: "cmake", extensions: [".cmake"], filenames: ["CMakeLists.txt"] },
  { id: "coffeescript", extensions: [".coffee", ".cson", ".iced"] },
  {
    id: "cpp",
    extensions: [
      ".c++",
      ".c++m",
      ".cc",
      ".ccm",
      ".cpp",
      ".cppm",
      ".cxx",
      ".cxxm",
      ".h",
      ".h++",
      ".h.in",
      ".hh",
      ".hpp",
      ".hpp.in",
      ".hxx",
      ".ii",
      ".inl",
      ".ino",
      ".ipp",
      ".ixx",
      ".mm",
      ".tpp",
      ".txx"
    ]
  },
  { id: "cpp_embedded_latex", extensions: [] },
  { id: "csharp", extensions: [".cake", ".cs", ".csx"] },
  { id: "css", extensions: [".css"] },
  { id: "cuda-cpp", extensions: [".cu", ".cuh"] },
  { id: "dart", extensions: [".dart"] },
  { id: "dhall", extensions: [".dhall"] },
  { id: "diff", extensions: [".diff", ".patch", ".rej"] },
  { id: "dockercompose", extensions: [], filenames: ["*docker*compose*.yaml", "*docker*compose*.yml", "compose.*.yaml", "compose.*.yml", "compose.yaml", "compose.yml"] },
  {
    id: "dockerfile",
    extensions: [".containerfile", ".dockerfile"],
    filenames: ["*.Dockerfile.*", "Containerfile", "Containerfile.*", "Dockerfile", "Dockerfile.*", "Dockerfile.dev", "dockerfile"]
  },
  { id: "elisp", extensions: [".el"] },
  { id: "elixir", extensions: [".ex", ".exs"] },
  { id: "elm", extensions: [".elm"] },
  { id: "erb", extensions: [".erb", ".html.erb", ".rhtml"] },
  { id: "fsharp", extensions: [".fs", ".fsi", ".fsscript", ".fsx"] },
  { id: "git-commit", extensions: [], filenames: ["COMMIT_EDITMSG", "MERGE_MSG"] },
  { id: "git-rebase", extensions: [], filenames: ["git-rebase-todo"] },
  { id: "github-issues", extensions: [".github-issues"] },
  { id: "go", extensions: [".go"] },
  { id: "godot", extensions: [".gd", ".godot", ".tres", ".tscn"] },
  { id: "gradle", extensions: [".gradle"] },
  { id: "groovy", extensions: [".gradle", ".groovy", ".gvy", ".jenkinsfile", ".nf"], filenames: ["Jenkinsfile", "Jenkinsfile*"] },
  { id: "haml", extensions: [".haml"] },
  { id: "handlebars", extensions: [".handlebars", ".hbs", ".hjs"] },
  { id: "haskell", extensions: [".hs", ".lhs"] },
  { id: "haxe", extensions: [".hx"] },
  { id: "hlsl", extensions: [".cginc", ".compute", ".fx", ".fxh", ".hlsl", ".hlsli", ".psh", ".vsh"] },
  { id: "html", extensions: [".asp", ".aspx", ".ejs", ".htm", ".html", ".jshtm", ".jsp", ".mdoc", ".rhtml", ".shtml", ".volt", ".vue", ".xht", ".xhtml"] },
  { id: "ignore", extensions: [".git-blame-ignore-revs", ".gitignore", ".gitignore_global", ".npmignore"], filenames: [".vscodeignore"] },
  { id: "ini", extensions: [".conf", ".ini"] },
  { id: "jade", extensions: [".jade", ".pug"] },
  { id: "java", extensions: [".jav", ".java"] },
  { id: "javascript", extensions: [".cjs", ".es6", ".js", ".mjs", ".pac"], filenames: ["jakefile"] },
  { id: "javascriptreact", extensions: [".jsx"] },
  { id: "jinja", extensions: [".jinja"] },
  {
    id: "json",
    extensions: [
      ".babelrc",
      ".bowerrc",
      ".code-profile",
      ".css.map",
      ".eslintrc",
      ".geojson",
      ".har",
      ".ipynb",
      ".js.map",
      ".jscsrc",
      ".jshintrc",
      ".jslintrc",
      ".json",
      ".jsonc",
      ".jsonld",
      ".ts.map",
      ".tsbuildinfo",
      ".vuerc",
      ".webmanifest"
    ],
    filenames: [".watchmanconfig", "composer.lock"]
  },
  {
    id: "jsonc",
    extensions: [
      ".babelrc",
      ".code-workspace",
      ".color-theme.json",
      ".eslintrc",
      ".eslintrc.json",
      ".hintrc",
      ".icon-theme.json",
      ".jsfmtrc",
      ".jshintrc",
      ".jsonc",
      ".language-configuration.json",
      ".swcrc"
    ],
    filenames: [
      ".babelrc.json",
      ".code-workspace",
      ".devcontainer.json",
      ".ember-cli",
      "argv.json",
      "babel.config.json",
      "devcontainer.json",
      "extensions.json",
      "jsconfig-*.json",
      "jsconfig.*.json",
      "jsconfig.json",
      "keybindings.json",
      "launch.json",
      "profiles.json",
      "settings.json",
      "tasks.json",
      "tsconfig-*.json",
      "tsconfig.*.json",
      "tsconfig.json",
      "typedoc.json"
    ]
  },
  { id: "jsonl", extensions: [".jsonl"] },
  { id: "jsx-tags", extensions: [] },
  { id: "julia", extensions: [".jl"] },
  { id: "juliamarkdown", extensions: [".jmd"] },
  { id: "jungle", extensions: [".jungle"] },
  { id: "kotlin", extensions: [".kt"] },
  { id: "latex", extensions: [".ctx", ".ltx", ".tex"] },
  { id: "less", extensions: [".less"] },
  { id: "lisp", extensions: [".fasl", ".l", ".lisp", ".lsp"] },
  { id: "literate haskell", extensions: [".lhs"] },
  { id: "lock", extensions: [".lock"], filenames: ["Cargo.lock", "berksfile.lock", "composer.lock", "package-lock.json"] },
  { id: "log", extensions: [".log"], filenames: ["*.log.?"] },
  { id: "lua", extensions: [".lua"] },
  { id: "makefile", extensions: [".mak", ".mk"], filenames: ["GNUmakefile", "Makefile", "OCamlMakefile", "makefile"] },
  { id: "map", extensions: [".map", ".css.map", ".ts.map", ".js.map"] },
  { id: "markdown", extensions: [".markdn", ".markdown", ".md", ".mdown", ".mdtext", ".mdtxt", ".mdwn", ".mkd", ".workbook"] },
  { id: "markdown_latex_combined", extensions: [] },
  { id: "markdown-math", extensions: [] },
  { id: "mdx", extensions: [".mdx"] },
  { id: "monkeyc", extensions: [".mb", ".mc"] },
  { id: "mustache", extensions: [".mst", ".mu", ".mustache", ".stache"] },
  { id: "nix", extensions: [".nix"] },
  { id: "nunjucks", extensions: [".nj", ".njk", ".nunj", ".nunjs", ".nunjucks", ".tmpl", ".tpl"] },
  { id: "objective-c", extensions: [".m"] },
  { id: "objective-cpp", extensions: [".mm"] },
  { id: "ocaml", extensions: [".eliom", ".eliomi", ".ml", ".mli", ".mll", ".mly"] },
  { id: "pdf", extensions: [".pdf"] },
  { id: "pem", extensions: [".pem", ".private-key.pem"] },
  { id: "pem-private-key", extensions: [".private-key.pem"] },
  { id: "perl", extensions: [".PL", ".pl", ".pm", ".pod", ".psgi", ".t"] },
  { id: "perl6", extensions: [".nqp", ".p6", ".pl6", ".pm6"] },
  { id: "php", extensions: [".ctp", ".php", ".php4", ".php5", ".phtml"] },
  { id: "plaintext", extensions: [".txt"] },
  { id: "powershell", extensions: [".ps1", ".psd1", ".psm1", ".psrc", ".pssc"] },
  {
    id: "properties",
    extensions: [".cfg", ".conf", ".directory", ".editorconfig", ".gitattributes", ".gitconfig", ".gitmodules", ".npmrc", ".properties", ".repo"],
    filenames: [".env", "gitconfig"]
  },
  { id: "puppet", extensions: [".puppet"] },
  { id: "purescript", extensions: [".purs"] },
  { id: "python", extensions: [".cpy", ".gyp", ".gypi", ".ipy", ".py", ".pyi", ".pyt", ".pyw", ".rpy"], filenames: ["SConscript", "SConstruct"] },
  { id: "r", extensions: [".R", ".r", ".rhistory", ".rprofile", ".rt"] },
  { id: "raku", extensions: [".nqp", ".p6", ".pl6", ".pm6", ".raku", ".rakudoc", ".rakumod", ".rakutest"] },
  { id: "razor", extensions: [".cshtml", ".razor"] },
  { id: "rescript", extensions: [".res", ".resi"] },
  { id: "restructuredtext", extensions: [".rst"] },
  { id: "rsa", extensions: [".pub"], filenames: ["id_rsa", "id_rsa.pub"] },
  {
    id: "ruby",
    extensions: [".erb", ".gemspec", ".podspec", ".rake", ".rb", ".rbi", ".rbx", ".rjs", ".ru"],
    filenames: [
      "Gemfile",
      "appfile",
      "appraisals",
      "berksfile",
      "berksfile.lock",
      "brewfile",
      "capfile",
      "cheffile",
      "dangerfile",
      "deliverfile",
      "fastfile",
      "gemfile",
      "guardfile",
      "gymfile",
      "hobofile",
      "matchfile",
      "podfile",
      "puppetfile",
      "rakefile",
      "rantfile",
      "scanfile",
      "snapfile",
      "thorfile",
      "vagrantfile"
    ]
  },
  { id: "rust", extensions: [".rs"] },
  { id: "sass", extensions: [".sass"] },
  { id: "scala", extensions: [".sbt", ".sc", ".scala"] },
  { id: "scss", extensions: [".scss"] },
  { id: "search-result", extensions: [".code-search"] },
  { id: "shaderlab", extensions: [".cginc", ".shader"] },
  {
    id: "shellscript",
    extensions: [
      ".Xsession",
      ".bash",
      ".bash_aliases",
      ".bash_login",
      ".bash_logout",
      ".bash_profile",
      ".bashrc",
      ".csh",
      ".cshrc",
      ".ebuild",
      ".eclass",
      ".fish",
      ".install",
      ".ksh",
      ".profile",
      ".sh",
      ".tcshrc",
      ".xprofile",
      ".xsession",
      ".xsessionrc",
      ".yash_profile",
      ".yashrc",
      ".zlogin",
      ".zlogout",
      ".zprofile",
      ".zsh",
      ".zsh-theme",
      ".zshenv",
      ".zshrc"
    ],
    filenames: [".env.*", ".envrc", ".hushlogin", "APKBUILD", "PKGBUILD", "bashrc_Apple_Terminal", "zlogin", "zlogout", "zprofile", "zshenv", "zshrc", "zshrc_Apple_Terminal"]
  },
  { id: "snippets", extensions: [".code-snippets"] },
  { id: "sql", extensions: [".dsql", ".sql"] },
  { id: "stylus", extensions: [".styl"] },
  { id: "svelte", extensions: [".svelte"] },
  { id: "swift", extensions: [".swift"] },
  { id: "terraform", extensions: [".hcl", ".tf", ".tf.json", ".tfvars"] },
  { id: "tex", extensions: [".bbx", ".cbx", ".cls", ".sty"] },
  { id: "tfvars", extensions: [".tfvars"], description: "Terraform Variables" },
  { id: "todo", extensions: [], filenames: ["todo"] },
  { id: "toml", extensions: [".toml"], filenames: ["Cargo.lock", "Cargo.toml"] },
  { id: "typescript", extensions: [".cts", ".mts", ".ts"] },
  { id: "typescriptreact", extensions: [".tsx"] },
  { id: "typst", extensions: [".typst"] },
  { id: "vala", extensions: [".vala"] },
  { id: "vb", extensions: [".bas", ".brs", ".vb", ".vba", ".vbs"] },
  { id: "vue", extensions: [".vue"] },
  {
    id: "xml",
    extensions: [
      ".ascx",
      ".atom",
      ".axaml",
      ".axml",
      ".bpmn",
      ".config",
      ".cpt",
      ".csl",
      ".csproj",
      ".csproj.user",
      ".dita",
      ".ditamap",
      ".dtd",
      ".dtml",
      ".ent",
      ".fsproj",
      ".fxml",
      ".iml",
      ".isml",
      ".jmx",
      ".launch",
      ".menu",
      ".mod",
      ".mxml",
      ".nuspec",
      ".opml",
      ".owl",
      ".proj",
      ".props",
      ".pt",
      ".publishsettings",
      ".pubxml",
      ".pubxml.user",
      ".rbxlx",
      ".rbxmx",
      ".rdf",
      ".rng",
      ".rss",
      ".shproj",
      ".storyboard",
      ".svg",
      ".targets",
      ".tld",
      ".tmx",
      ".vbproj",
      ".vbproj.user",
      ".vcxproj",
      ".vcxproj.filters",
      ".wsdl",
      ".wxi",
      ".wxl",
      ".wxs",
      ".xaml",
      ".xbl",
      ".xib",
      ".xlf",
      ".xliff",
      ".xml",
      ".xoml",
      ".xpdl",
      ".xsd",
      ".xul"
    ]
  },
  { id: "xsl", extensions: [".xsl", ".xslt"] },
  { id: "yaml", extensions: [".cff", ".eyaml", ".eyml", ".yaml", ".yaml-tmlanguage", ".yaml-tmpreferences", ".yaml-tmtheme", ".yml"] },
  { id: "binary", extensions: [".bin", ".cur", ".dll", ".eot", ".exe", ".gz", ".lib", ".o", ".obj", ".phar", ".zip"], format: "Binary" },
  { id: "dll", extensions: [".dll"], format: "Binary" },
  { id: "exe", extensions: [".exe"], format: "Binary" },
  { id: "fonts", extensions: [".ttf", ".woff", ".woff2"], format: "Binary" },
  { id: "gzip", extensions: [".gz"], format: "Binary" },
  {
    id: "image",
    extensions: [".bmp", ".exr", ".gif", ".heic", ".ico", ".jpeg", ".jpg", ".pbm", ".pgm", ".png", ".ppm", ".ras", ".sgi", ".tiff", ".webp", ".xbm"],
    format: "Binary",
    description: "Some image extensions"
  },
  { id: "jar", extensions: [".jar"], format: "Binary" },
  { id: "mdb", extensions: [".mdb"], format: "Binary", description: "Microsoft Access DB" },
  { id: "object-file", extensions: [".o", ".obj"], format: "Binary" },
  { id: "spv", extensions: [".spv"], format: "Binary", description: "SPSS Output Document" },
  { id: "trie", extensions: [".trie"], format: "Binary", description: "CSpell dictionary file." },
  { id: "video", extensions: [".avi", ".flv", ".mkv", ".mov", ".mp4", ".mpeg", ".mpg", ".wmv"], format: "Binary" },
  { id: "webm", extensions: [".webm"], format: "Binary", description: "WebM is an audiovisual media file format." },
  { id: "wheel", extensions: [".whl"], format: "Binary" }
];

// ../node_modules/.pnpm/@cspell+filetypes@9.1.5/node_modules/@cspell/filetypes/dist/filetypes.js
var binaryFormatIds = definitions.filter((d) => d.format === "Binary").map((d) => d.id);
var binaryLanguages = /* @__PURE__ */ new Set(["binary", "image", "video", "fonts", ...binaryFormatIds]);
var generatedFiles = /* @__PURE__ */ new Set([
  ...binaryLanguages,
  "map",
  "lock",
  "pdf",
  "cache_files",
  "rsa",
  "pem",
  "trie",
  "log"
]);
var languageIds = definitions.map(({ id }) => id);
var mapExtensionToSetOfLanguageIds = buildLanguageExtensionMapSet(definitions);
var mapExtensionToLanguageIds = buildExtensionToLanguageIdMap(mapExtensionToSetOfLanguageIds);
var idsWithRegExp = definitions.map(defToRegExp).filter((f) => !!f);
function isFileTypeGenerated(fileTypeId) {
  return doesSetContainAnyOf(generatedFiles, fileTypeId);
}
function doesSetContainAnyOf(setOfIds, fileTypeId) {
  if (typeof fileTypeId === "string") {
    return setOfIds.has(fileTypeId);
  }
  for (const id of fileTypeId) {
    if (setOfIds.has(id)) {
      return true;
    }
  }
  return false;
}
function buildLanguageExtensionMapSet(defs) {
  return defs.reduce((map3, def) => {
    function addId(value) {
      autoResolve2(map3, value, () => /* @__PURE__ */ new Set()).add(def.id);
    }
    def.extensions.forEach(addId);
    def.filenames?.forEach((filename) => typeof filename === "string" ? addId(filename) : void 0);
    return map3;
  }, /* @__PURE__ */ new Map());
}
function buildExtensionToLanguageIdMap(map3) {
  return new Map([...map3].map(([k, s]) => [k, [...s]]));
}
function matchPatternsToFilename(basename5) {
  return idsWithRegExp.filter(({ regexp }) => regexp.test(basename5)).map(({ id }) => id);
}
function _getLanguagesForBasename(basename5) {
  const found = mapExtensionToLanguageIds.get(basename5);
  if (found)
    return found;
  const patternMatches = matchPatternsToFilename(basename5);
  if (patternMatches.length)
    return patternMatches;
  for (let pos = basename5.indexOf("."); pos >= 0; pos = basename5.indexOf(".", pos + 1)) {
    const ids = mapExtensionToLanguageIds.get(basename5.slice(pos));
    if (ids)
      return ids;
  }
  return void 0;
}
function findMatchingFileTypes(filename) {
  filename = basename2(filename);
  return _getLanguagesForBasename(filename) || _getLanguagesForBasename(filename.toLowerCase()) || [];
}
var regExpPathSep = /[\\/]/g;
function basename2(filename) {
  return regExpPathSep.test(filename) ? filename.split(regExpPathSep).slice(-1).join("") : filename;
}
function autoResolve2(map3, key, resolve5) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve5(key);
  map3.set(key, value);
  return value;
}
function escapeRegEx2(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}
function stringOrGlob(s) {
  return s.includes("*") ? simpleGlob(s) : s;
}
function simpleGlob(s) {
  s = s.replaceAll("**", "*");
  let pattern = "";
  for (const char of s) {
    switch (char) {
      case "?": {
        pattern += ".";
        break;
      }
      case "*": {
        pattern += ".*";
        break;
      }
      default: {
        pattern += escapeRegEx2(char);
      }
    }
  }
  return new RegExp(pattern);
}
function defToRegExp(def) {
  if (!def.filenames)
    return void 0;
  const regExps = def.filenames.map(stringOrGlob).map((f) => f instanceof RegExp ? f : void 0).filter((f) => !!f);
  if (!regExps.length)
    return void 0;
  const regexp = new RegExp(regExps.map((r) => r.source).join("|"));
  return { regexp, id: def.id };
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/Uri.js
var import_node_assert6 = __toESM(require("node:assert"), 1);
var STDIN_PROTOCOL = "stdin:";
function toUri(uriOrFile) {
  if (UriImpl.isUri(uriOrFile))
    return uriOrFile;
  if (URI.isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (uriOrFile instanceof URL)
    return UriImpl.parse(uriOrFile.toString());
  if (isHRef(uriOrFile))
    return UriImpl.parse(uriOrFile.href);
  if (isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (isUrlLike(uriOrFile))
    return UriImpl.parse(uriOrFile);
  return UriImpl.file(normalizeDriveLetter(uriOrFile));
}
var isWindows3 = process.platform === "win32";
var hasDriveLetter = /^[a-zA-Z]:[\\/]/;
var rootUrl = toFileDirURL("/");
function uriToFilePath(uri) {
  let url2 = documentUriToURL(uri);
  url2 = url2.protocol === "stdin:" ? new URL(url2.pathname, rootUrl) : url2;
  return toFilePathOrHref(url2);
}
function normalizeDriveLetter(path17) {
  return hasDriveLetter.test(path17) ? path17[0].toUpperCase() + path17.slice(1) : path17;
}
function isHRef(url2) {
  return !!url2 && typeof url2 === "object" && typeof url2.href === "string" || false;
}
function isUri(uri) {
  if (!uri || typeof uri !== "object")
    return false;
  if (UriImpl.isUri(uri))
    return true;
  if (URI.isUri(uri))
    return true;
  const u = uri;
  return typeof u.path === "string" && typeof u.scheme === "string";
}
function basename3(uri) {
  return Utils.basename(URI.from(uri));
}
function uriFrom(uri, ...parts) {
  return UriImpl.from(uri, ...parts);
}
var keys2 = ["scheme", "authority", "path", "query", "fragment"];
var UriImpl = class _UriImpl extends URI {
  constructor(uri) {
    super(uri.scheme, uri.authority, uri.path, uri.query, uri.fragment);
  }
  toString() {
    const path17 = encodeURI(this.path || "").replaceAll(/[#?]/g, (c) => `%${(c.codePointAt(0) || 0).toString(16)}`);
    const base = `${this.scheme}://${this.authority || ""}${path17}`;
    const query = this.query && `?${this.query}` || "";
    const fragment = this.fragment && `#${this.fragment}` || "";
    const url2 = base + query + fragment;
    return url2;
  }
  toJSON() {
    const { scheme, authority, path: path17, query, fragment } = this;
    return { scheme, authority, path: path17, query, fragment };
  }
  with(change) {
    const { scheme, authority, path: path17, query, fragment } = this;
    const u = { scheme, authority, path: path17, query, fragment };
    for (const key of keys2) {
      if (change[key] && typeof change[key] === "string") {
        u[key] = change[key];
      }
    }
    return new _UriImpl(u);
  }
  static isUri(uri) {
    return uri instanceof _UriImpl;
  }
  static from(uri, ...parts) {
    let u = new _UriImpl(uri);
    for (const part of parts) {
      u = u.with(part);
    }
    return u;
  }
  static parse(uri) {
    if (uri.startsWith(STDIN_PROTOCOL)) {
      return _UriImpl.from(parseStdinUri(uri));
    }
    const u = URI.parse(uri);
    return _UriImpl.from(u);
  }
  static file(filename) {
    if (!isWindows3 && hasDriveLetter.test(filename)) {
      filename = "/" + filename.replaceAll("\\", "/");
    }
    const url2 = toFileURL(filename);
    return _UriImpl.parse(url2.href);
  }
  static stdin(filePath = "") {
    return _UriImpl.from(_UriImpl.file(filePath), { scheme: "stdin" });
  }
};
function normalizeFilePath(path17) {
  return normalizeDriveLetter(path17.replaceAll("\\", "/"));
}
function parseStdinUri(uri) {
  (0, import_node_assert6.default)(uri.startsWith(STDIN_PROTOCOL));
  const idxSlash = STDIN_PROTOCOL.length;
  let idxSlashEnd = idxSlash;
  for (; uri[idxSlashEnd] === "/"; ++idxSlashEnd) {
  }
  const pathStart = idxSlashEnd;
  const iH = uri.indexOf("#", pathStart);
  const idxHash = iH > 0 ? iH : uri.length;
  const iQ = uri.indexOf("?", pathStart);
  const idxQ = iQ > 0 && iQ < idxHash ? iQ : idxHash;
  const pathEnd = idxQ;
  const path17 = uri.slice(pathStart, pathEnd);
  const query = idxQ < idxHash ? uri.slice(idxQ + 1, idxHash) : "";
  const hash = uri.slice(idxHash + 1);
  const pathPrefix = idxSlashEnd - idxSlash > 2 ? "/" : "";
  return {
    scheme: "stdin",
    path: pathPrefix + normalizeFilePath(decodeURI(path17)),
    query: decodeURI(query),
    fragment: decodeURI(hash)
  };
}
function documentUriToURL(uri) {
  return toURL(uri instanceof URL ? uri : typeof uri === "string" ? toFileURL(uri) : new URL(uriFrom(uri).toString()));
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Document/normalizeLanguageIds.js
function normalizeLanguageIds(languageId) {
  return (Array.isArray(languageId) ? languageId.join(",") : languageId).split(",").map((s) => s.trim());
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Document/isBinaryDoc.js
function isBinaryDoc(document) {
  return isBinaryFile2(toUri(document.uri), document.languageId, document.text);
}
function isBinaryFile2(filename, languageId, text) {
  const filenameUri = toUri(filename);
  if (languageId) {
    const ids2 = normalizeLanguageIds(languageId);
    if (ids2.length)
      return isFileTypeGenerated(ids2);
  }
  const file = basename3(filenameUri);
  const ids = findMatchingFileTypes(file);
  if (ids.length)
    return isFileTypeGenerated(ids);
  return text?.slice(0, 1024).includes("\0") || false;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Document/resolveDocument.js
var import_promises = require("node:fs/promises");

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Models/TextDocument.js
var import_node_assert7 = __toESM(require("node:assert"), 1);

// ../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var FullTextDocument = class _FullTextDocument {
  constructor(uri, languageId, version3, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version3;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version3) {
    for (const change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version3;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    const lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    const line = low - 1;
    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    const lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    const lineOffset = lineOffsets[position.line];
    if (position.character <= 0) {
      return lineOffset;
    }
    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    const offset = Math.min(lineOffset + position.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
      offset--;
    }
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version3, content) {
    return new FullTextDocument(uri, languageId, version3, content);
  }
  TextDocument2.create = create;
  function update(document, changes, version3) {
    if (document instanceof FullTextDocument) {
      document.update(changes, version3);
      return document;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument2.update = update;
  function applyEdits2(document, edits) {
    const text = document.getText();
    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      const diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      const startOffset = document.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument2.applyEdits = applyEdits2;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare3) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare3);
  mergeSort(right, compare3);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare3(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset2 = 0) {
  const result = isAtLineStart ? [textOffset2] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset2 + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Models/TextDocument.js
var TextDocumentImpl = class {
  languageId;
  locale;
  vsTextDoc;
  uri;
  constructor(uri, text, languageId, locale, version3) {
    this.languageId = languageId;
    this.locale = locale;
    const primaryLanguageId = typeof languageId === "string" ? languageId : languageId[0] || "plaintext";
    this.vsTextDoc = TextDocument.create(uri.toString(), primaryLanguageId, version3, text);
    this.uri = documentUriToURL(uri);
  }
  get version() {
    return this.vsTextDoc.version;
  }
  get text() {
    return this.vsTextDoc.getText();
  }
  positionAt(offset) {
    return this.vsTextDoc.positionAt(offset);
  }
  offsetAt(position) {
    return this.vsTextDoc.offsetAt(position);
  }
  lineAt(offset) {
    const position = this.vsTextDoc.positionAt(offset);
    return this.getLine(position.line);
  }
  getLine(lineNum) {
    const position = { line: lineNum, character: 0 };
    const end = { line: lineNum + 1, character: 0 };
    const range = {
      start: position,
      end
    };
    const lineOffset = this.vsTextDoc.offsetAt(position);
    const text = this.vsTextDoc.getText(range);
    return {
      text,
      offset: lineOffset,
      position
    };
  }
  /**
   * Iterate over the lines of a document one-by-one.
   * Changing the document between iterations can change the result
   */
  *getLines() {
    const range = {
      start: { line: 0, character: 0 },
      end: { line: 1, character: 0 }
    };
    while (this.vsTextDoc.offsetAt(range.end) > this.vsTextDoc.offsetAt(range.start)) {
      const offset = this.vsTextDoc.offsetAt(range.start);
      yield {
        text: this.vsTextDoc.getText(range),
        offset,
        position: range.start
      };
      ++range.start.line;
      ++range.end.line;
    }
  }
  /**
   * Apply edits to the text.
   * Note: the edits are applied one after the other.
   * @param edits - changes to the text
   * @param version - optional version to use.
   * @returns this
   */
  update(edits, version3) {
    version3 = version3 ?? this.version + 1;
    for (const edit of edits) {
      const vsEdit = edit.range ? {
        range: { start: this.positionAt(edit.range[0]), end: this.positionAt(edit.range[1]) },
        text: edit.text
      } : edit;
      TextDocument.update(this.vsTextDoc, [vsEdit], version3);
    }
    return this;
  }
};
function createTextDocument({ uri, content, languageId, locale, version: version3 }) {
  version3 = version3 ?? 1;
  uri = toUri(uri);
  languageId = languageId ?? findMatchingFileTypes(basename3(uri));
  languageId = languageId.length === 0 ? "text" : languageId;
  return new TextDocumentImpl(uri, content, languageId, locale, version3);
}
function updateTextDocument(doc, edits, version3) {
  (0, import_node_assert7.default)(isTextDocumentImpl(doc), "Unknown TextDocument type");
  return doc.update(edits, version3);
}
function isTextDocumentImpl(doc) {
  return doc instanceof TextDocumentImpl;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Document/resolveDocument.js
var defaultEncoding = "utf8";
function fileToDocument(file, text, languageId, locale) {
  return clean3({
    uri: toUri(file).toString(),
    text,
    languageId,
    locale
  });
}
function documentToTextDocument(document) {
  const { uri, text: content, languageId, locale } = document;
  return createTextDocument({ uri, content, languageId, locale });
}
async function readDocument(filename, encoding = defaultEncoding) {
  const text = await (0, import_promises.readFile)(filename, encoding);
  const uri = toUri(filename).toString();
  return {
    uri,
    text
  };
}
function resolveDocument(document, encoding) {
  if (isDocumentWithText(document))
    return Promise.resolve(document);
  const uri = toUri(document.uri);
  if (uri.scheme !== "file") {
    throw new Error(`Unsupported schema: "${uri.scheme}", open "${uri.toString()}"`);
  }
  return readDocument(uriToFilePath(uri), encoding);
}
function isDocumentWithText(doc) {
  return doc.text !== void 0;
}

// ../node_modules/.pnpm/cspell-glob@9.1.5/node_modules/cspell-glob/dist/globHelper.js
var Path2 = __toESM(require("node:path"), 1);
var { posix } = Path2;
var isGlobalPatternRegExp = /^!*[*]{2}/;
var hasGlobCharactersRegExp = /[*?{}[\]]/;
var fileUrlBuilder2 = new FileUrlBuilder();
var GlobPlaceHolders = {
  cwd: "${cwd}"
};
var GlobPatterns = {
  suffixAny: "/**",
  /**
   * Use as as suffix for a directory. Example `node_modules/` becomes `node_modules/**​/*`.
   */
  suffixDir: "/**/*",
  prefixAny: "**/"
};
var cacheCalls = 0;
var cacheMisses = 0;
var cachePath = Path2;
var cacheRoot = "<>";
var cache3 = /* @__PURE__ */ new Map();
var debugCache = false;
function fileOrGlobToGlob(fileOrGlob, root, path17 = Path2) {
  if (cacheRoot !== root || cachePath !== path17) {
    cache3.clear();
    cacheCalls = 0;
    cacheMisses = 0;
    cacheRoot = root;
    cachePath = path17;
  }
  ++cacheCalls;
  debugCache && !(cacheCalls & 7) && console.error("cache miss rate: %d%% cache size: %d", cacheMisses / cacheCalls * 100, cache3.size);
  const found = cache3.get(fileOrGlob);
  if (found)
    return found;
  ++cacheMisses;
  const pattern = _fileOrGlobToGlob(fileOrGlob, root, path17);
  cache3.set(fileOrGlob, pattern);
  return pattern;
}
function _fileOrGlobToGlob(fileOrGlob, root, path17 = Path2) {
  const toForwardSlash = path17.sep === "\\" ? (p) => p.replaceAll("\\", "/") : (p) => p;
  const builder = urlBuilder(path17);
  fileOrGlob = typeof fileOrGlob === "string" ? toForwardSlash(fileOrGlob) : fileOrGlob;
  const rootUrl2 = builder.toFileDirURL(root);
  root = builder.urlToFilePathOrHref(rootUrl2);
  const pattern = toGlobPatternWithRoot(fileOrGlob, root, builder);
  return pattern;
}
function toGlobPatternWithRoot(glob2, root, builder) {
  function toPattern() {
    if (isGlobPatternWithRoot(glob2))
      return fixPatternRoot({ ...glob2 }, builder);
    const rootUrl2 = builder.toFileDirURL(root);
    if (typeof glob2 === "string")
      return filePathOrGlobToGlob(glob2, rootUrl2, builder);
    const pattern2 = { isGlobalPattern: isGlobalGlob(glob2.glob), ...glob2, root: glob2.root ?? root };
    fixPatternRoot(pattern2, builder);
    fixPatternGlob(pattern2, builder);
    return pattern2;
  }
  const pattern = toPattern();
  if (pattern.glob.startsWith(GlobPlaceHolders.cwd)) {
    pattern.root = GlobPlaceHolders.cwd;
    pattern.glob = pattern.glob.replace(GlobPlaceHolders.cwd, "");
  }
  return pattern;
}
function isGlobPatternWithOptionalRoot(g) {
  return typeof g !== "string" && typeof g.glob === "string";
}
function isGlobPatternWithRoot(g) {
  if (typeof g === "string")
    return false;
  return typeof g.root === "string" && "isGlobalPattern" in g;
}
function isGlobPatternNormalized(g) {
  if (!isGlobPatternWithRoot(g))
    return false;
  const gr = g;
  return "rawGlob" in gr && "rawRoot" in gr && typeof gr.rawGlob === "string";
}
function isGlobPatternNormalizedToRoot(g, options) {
  if (!isGlobPatternNormalized(g))
    return false;
  return g.root === options.root;
}
function urlBuilder(path17 = Path2) {
  return path17 === Path2 ? fileUrlBuilder2 : new FileUrlBuilder({ path: path17 });
}
function normalizePattern(pattern, nested) {
  pattern = pattern.replace(/^(!!)+/, "");
  const isNeg = pattern.startsWith("!");
  const prefix = isNeg ? "!" : "";
  pattern = isNeg ? pattern.slice(1) : pattern;
  const patterns = nested ? normalizePatternNested(pattern) : normalizePatternGeneral(pattern);
  return patterns.map((p) => prefix + p);
}
function normalizePatternNested(pattern) {
  if (!pattern.includes("/")) {
    if (pattern === "**")
      return ["**"];
    return ["**/" + pattern, "**/" + pattern + "/**"];
  }
  const hasLeadingSlash = pattern.startsWith("/");
  pattern = hasLeadingSlash ? pattern.slice(1) : pattern;
  if (pattern.endsWith("/")) {
    return hasLeadingSlash || pattern.slice(0, -1).includes("/") ? [pattern + "**/*"] : ["**/" + pattern + "**/*"];
  }
  if (pattern.endsWith("**")) {
    return [pattern];
  }
  return [pattern, pattern + "/**"];
}
function normalizePatternGeneral(pattern) {
  pattern = pattern.startsWith("/") ? pattern.slice(1) : pattern;
  pattern = pattern.endsWith("/") ? pattern + "**/*" : pattern;
  return [pattern];
}
function normalizeGlobPatterns(patterns, options) {
  function* normalize3() {
    for (const glob2 of patterns) {
      if (isGlobPatternNormalized(glob2)) {
        yield isGlobPatternNormalizedToRoot(glob2, options) ? glob2 : normalizeGlobToRoot(glob2, options.root, options.nodePath || Path2);
        continue;
      }
      yield* normalizeGlobPattern(glob2, options);
    }
  }
  return [...normalize3()];
}
function normalizeGlobPattern(g, options) {
  const { root, nodePath: path17 = Path2, nested } = options;
  const builder = urlBuilder(path17);
  const cwd = options.cwd ?? path17.resolve();
  const cwdUrl = builder.toFileDirURL(cwd);
  const rootUrl2 = builder.toFileDirURL(root, cwdUrl);
  const gIsGlobalPattern = isGlobPatternWithRoot(g) ? g.isGlobalPattern : void 0;
  g = !isGlobPatternWithOptionalRoot(g) ? { glob: g } : g;
  const gr = { ...g, root: g.root ?? root };
  const rawRoot = gr.root;
  const rawGlob = g.glob;
  gr.glob = trimGlob(g.glob);
  if (gr.glob.startsWith(GlobPlaceHolders.cwd)) {
    gr.glob = gr.glob.replace(GlobPlaceHolders.cwd, "");
    gr.root = GlobPlaceHolders.cwd;
  }
  if (gr.root.startsWith(GlobPlaceHolders.cwd)) {
    const relRoot = gr.root.replace(GlobPlaceHolders.cwd, "./");
    const r = builder.toFileDirURL(relRoot, cwdUrl);
    r.pathname = posix.normalize(r.pathname);
    gr.root = builder.urlToFilePathOrHref(r);
  }
  const isGlobalPattern = gIsGlobalPattern ?? isGlobalGlob(gr.glob);
  gr.root = builder.urlToFilePathOrHref(builder.toFileDirURL(gr.root, rootUrl2));
  const globs = normalizePattern(gr.glob, nested);
  return globs.map((glob2) => ({ ...gr, glob: glob2, rawGlob, rawRoot, isGlobalPattern }));
}
function normalizeGlobToRoot(glob2, root, path17) {
  const builder = urlBuilder(path17);
  glob2 = { ...glob2 };
  fixPatternRoot(glob2, builder);
  const rootURL = builder.toFileDirURL(root);
  root = builder.urlToFilePathOrHref(rootURL);
  if (glob2.root === root) {
    return glob2;
  }
  const globRootUrl = builder.toFileDirURL(glob2.root);
  const relFromRootToGlob = builder.relative(rootURL, globRootUrl);
  if (!relFromRootToGlob) {
    return glob2;
  }
  if (glob2.isGlobalPattern) {
    return { ...glob2, root };
  }
  const relFromGlobToRoot = builder.relative(globRootUrl, rootURL);
  const globIsUnderRoot = isRelativeValueNested(relFromRootToGlob);
  const rootIsUnderGlob = isRelativeValueNested(relFromGlobToRoot);
  if (!globIsUnderRoot && !rootIsUnderGlob) {
    return glob2;
  }
  const isNeg = glob2.glob.startsWith("!");
  const g = isNeg ? glob2.glob.slice(1) : glob2.glob;
  const prefix = isNeg ? "!" : "";
  if (globIsUnderRoot) {
    const relGlob = relFromRootToGlob;
    return {
      ...glob2,
      glob: prefix + posix.join(relGlob, g),
      root
    };
  }
  const rebasedGlob = rebaseGlob(g, nRel(relFromRootToGlob), nRel(relFromGlobToRoot));
  return rebasedGlob ? { ...glob2, glob: prefix + rebasedGlob, root } : glob2;
}
function nRel(rel) {
  return rel.endsWith("/") ? rel : rel + "/";
}
function isRelativeValueNested(rel) {
  return !rel || !(rel === ".." || rel.startsWith("../") || rel.startsWith("/"));
}
function rebaseGlob(glob2, fromRootToGlob, fromGlobToRoot) {
  if (!fromGlobToRoot || fromGlobToRoot === "/")
    return glob2;
  if (fromRootToGlob.startsWith("../") && !fromGlobToRoot.startsWith("../") && glob2.startsWith("**"))
    return glob2;
  fromRootToGlob = nRel(fromRootToGlob);
  fromGlobToRoot = nRel(fromGlobToRoot);
  const relToParts = fromRootToGlob.split("/");
  const relFromParts = fromGlobToRoot.split("/");
  if (glob2.startsWith(fromGlobToRoot) && fromRootToGlob === "../".repeat(relToParts.length - 1)) {
    return glob2.slice(fromGlobToRoot.length);
  }
  const lastRelIdx = relToParts.findIndex((s) => s !== "..");
  const lastRel = lastRelIdx < 0 ? relToParts.length : lastRelIdx;
  const globParts = [...relToParts.slice(lastRel).filter((a) => a), ...glob2.split("/")];
  relToParts.length = lastRel;
  if (fromRootToGlob.startsWith("../") && relFromParts.length !== relToParts.length + 1) {
    return fromRootToGlob + (glob2.startsWith("/") ? glob2.slice(1) : glob2);
  }
  for (let i = 0; i < relFromParts.length && i < globParts.length; ++i) {
    const relSeg = relFromParts[i];
    const globSeg = globParts[i];
    if (!relSeg || globSeg === "**") {
      return globParts.slice(i).join("/");
    }
    if (relSeg !== globSeg && globSeg !== "*") {
      break;
    }
  }
  return fromRootToGlob + (glob2.startsWith("/") ? glob2.slice(1) : glob2);
}
function trimGlob(glob2) {
  glob2 = globRemoveComment(glob2);
  glob2 = trimGlobLeft(glob2);
  glob2 = trimGlobRight(glob2);
  return glob2;
}
function globRemoveComment(glob2) {
  return glob2.replace(/(?<=^|\s)#.*/, "");
}
var spaces = {
  " ": true,
  "	": true,
  "\n": true,
  "\r": true
};
function trimGlobRight(glob2) {
  const lenMin1 = glob2.length - 1;
  let i = lenMin1;
  while (i >= 0 && glob2[i] in spaces) {
    --i;
  }
  if (glob2[i] === "\\") {
    ++i;
  }
  ++i;
  return i ? glob2.slice(0, i) : "";
}
function trimGlobLeft(glob2) {
  return glob2.trimStart();
}
function isGlobalGlob(glob2) {
  return isGlobalPatternRegExp.test(glob2);
}
function hasGlobCharacters(glob2) {
  return hasGlobCharactersRegExp.test(glob2);
}
function isGlobPart(part) {
  if (part === GlobPlaceHolders.cwd)
    return false;
  return hasGlobCharacters(part);
}
function splitGlob(glob2) {
  const parts = glob2.split("/");
  const p = parts.findIndex(isGlobPart);
  const s = p < 0 ? parts.length - 1 : p;
  return createSplitGlob(s ? parts.slice(0, s).join("/") + "/" : void 0, parts.slice(s).join("/"));
}
function splitGlobRel(glob2) {
  const parts = glob2.split("/");
  if (!parts.includes("..") && !parts.includes("."))
    return { path: void 0, glob: glob2 };
  const firstGlobPartIdx = parts.findIndex(isGlobPart);
  const lastRelIdx = Math.max(parts.lastIndexOf(".."), parts.lastIndexOf("."));
  const p = firstGlobPartIdx >= 0 ? Math.min(firstGlobPartIdx, lastRelIdx + 1) : lastRelIdx + 1;
  const s = p < 0 ? parts.length - 1 : p;
  return createSplitGlob(s ? parts.slice(0, s).join("/") + "/" : void 0, parts.slice(s).join("/"));
}
function createSplitGlob(path17, glob2) {
  glob2 = path17 ? "/" + glob2 : glob2;
  glob2 = glob2.startsWith("/**") ? glob2.slice(1) : glob2;
  return { path: path17, glob: glob2 };
}
function rootToUrl(root, builder) {
  if (root.startsWith(GlobPlaceHolders.cwd)) {
    return new URL(builder.normalizeFilePathForUrl(root.replace(GlobPlaceHolders.cwd, ".")), builder.cwd);
  }
  return builder.toFileDirURL(root);
}
function fixPatternRoot(glob2, builder) {
  if (glob2.root.startsWith(GlobPlaceHolders.cwd)) {
    return glob2;
  }
  glob2.root = builder.urlToFilePathOrHref(rootToUrl(glob2.root, builder));
  return glob2;
}
function fixPatternGlob(glob2, builder) {
  const rootURL = builder.toFileURL(glob2.root);
  const split2 = splitGlobRel(glob2.glob);
  glob2.glob = split2.glob;
  if (split2.path !== void 0) {
    const relRootPath = split2.path.startsWith("/") ? "." + split2.path : split2.path;
    glob2.root = builder.urlToFilePathOrHref(builder.toFileDirURL(relRootPath, glob2.root));
  }
  fixPatternRelativeToRoot(glob2, rootURL, builder);
}
function fixPatternRelativeToRoot(glob2, root, builder) {
  if (glob2.root.startsWith(GlobPlaceHolders.cwd))
    return;
  const rel = builder.relative(root, builder.toFileDirURL(glob2.root));
  if (rel.startsWith("/") || rel.startsWith("../"))
    return;
  glob2.root = builder.urlToFilePathOrHref(root);
  glob2.glob = rel + glob2.glob;
}
function filePathOrGlobToGlob(filePathOrGlob, root, builder) {
  const isGlobalPattern = isGlobalGlob(filePathOrGlob);
  const isAbsolute3 = builder.isAbsolute(filePathOrGlob);
  const { path: path17, glob: glob2 } = isAbsolute3 ? splitGlob(filePathOrGlob) : splitGlobRel(filePathOrGlob);
  const url2 = builder.toFileDirURL(path17 || "./", root);
  return { root: builder.urlToFilePathOrHref(url2), glob: glob2, isGlobalPattern };
}
function workaroundPicomatchBug(glob2) {
  const obj = {};
  return glob2.split("/").map((s) => obj[s] ? `{${s},${s}}` : s).join("/");
}

// ../node_modules/.pnpm/cspell-glob@9.1.5/node_modules/cspell-glob/dist/GlobMatcher.js
var Path3 = __toESM(require("node:path"), 1);
var import_picomatch = __toESM(require_picomatch2(), 1);
var traceMode = false;
var idGlobMatcher = 0;
var GlobMatcher = class {
  /**
   * @param filename full path of file to match against.
   * @returns a GlobMatch - information about the match.
   */
  matchEx;
  path;
  patterns;
  patternsNormalizedToRoot;
  /**
   * path or href of the root directory.
   */
  root;
  dot;
  options;
  /**
   * Instance ID
   */
  id;
  constructor(patterns, rootOrOptions, _nodePath) {
    this.id = idGlobMatcher++;
    const options = typeof rootOrOptions === "string" || rootOrOptions instanceof URL ? { root: rootOrOptions.toString() } : rootOrOptions ?? {};
    const mode = options.mode ?? "exclude";
    const isExcludeMode = mode !== "include";
    const nodePath = options.nodePath ?? _nodePath ?? Path3;
    this.path = nodePath;
    const cwd = options.cwd ?? nodePath.resolve();
    const dot = options.dot ?? isExcludeMode;
    const nested = options.nested ?? isExcludeMode;
    const nobrace = options.nobrace;
    const root = options.root ?? nodePath.resolve();
    const builder = new FileUrlBuilder({ path: nodePath });
    const rootURL = builder.toFileDirURL(root);
    const normalizedRoot = builder.urlToFilePathOrHref(rootURL);
    this.options = { root: normalizedRoot, dot, nodePath, nested, mode, nobrace, cwd };
    patterns = Array.isArray(patterns) ? patterns : typeof patterns === "string" ? patterns.split(/\r?\n/g) : [patterns];
    const globPatterns = normalizeGlobPatterns(patterns, this.options);
    this.patternsNormalizedToRoot = globPatterns.map((g) => normalizeGlobToRoot(g, normalizedRoot, nodePath)).filter((g) => builder.relative(builder.toFileDirURL(g.root), rootURL) === "");
    this.patterns = globPatterns;
    this.root = normalizedRoot;
    this.dot = dot;
    this.matchEx = buildMatcherFn(this.id, this.patterns, this.options);
  }
  /**
   * Check to see if a filename matches any of the globs.
   * If filename is relative, it is considered relative to the root.
   * If filename is absolute and contained within the root, it will be made relative before being tested for a glob match.
   * If filename is absolute and not contained within the root, it will be tested as is.
   * @param filename full path of the file to check.
   */
  match(filename) {
    return this.matchEx(filename).matched;
  }
};
function buildMatcherFn(_id, patterns, options) {
  const { nodePath, dot, nobrace } = options;
  const builder = new FileUrlBuilder({ path: nodePath });
  const makeReOptions = { dot, nobrace };
  const suffixDir = GlobPatterns.suffixDir;
  const rules = patterns.map((pattern, index) => ({ pattern, index })).filter((r) => !!r.pattern.glob).filter((r) => !r.pattern.glob.startsWith("#")).map(({ pattern, index }) => {
    const matchNeg = pattern.glob.match(/^!/);
    const glob2 = pattern.glob.replace(/^!/, "");
    const isNeg = matchNeg && matchNeg[0].length & 1 && true || false;
    const reg = import_picomatch.default.makeRe(workaroundPicomatchBug(glob2), makeReOptions);
    const fn2 = pattern.glob.endsWith(suffixDir) ? (filename) => {
      return reg.test(filename) || filename.endsWith("/") && reg.test(filename + " ");
    } : (filename) => {
      return reg.test(filename);
    };
    return { pattern, index, isNeg, fn: fn2, reg };
  });
  const negRules = rules.filter((r) => r.isNeg);
  const posRules = rules.filter((r) => !r.isNeg);
  const mapRoots = /* @__PURE__ */ new Map();
  const fn = (filename) => {
    const fileUrl = builder.toFileURL(filename);
    const relFilePathname = builder.relative(new URL("file:///"), fileUrl);
    let lastRoot = new URL("placeHolder://");
    let lastRel = "";
    function rootToUrl2(root) {
      const found = mapRoots.get(root);
      if (found)
        return found;
      const url2 = builder.toFileDirURL(root);
      mapRoots.set(root, url2);
      return url2;
    }
    function relativeToRoot(root) {
      if (root.href !== lastRoot.href) {
        lastRoot = root;
        lastRel = builder.relative(root, fileUrl);
      }
      return lastRel;
    }
    function testRules(rules2, matched) {
      for (const rule of rules2) {
        const pattern = rule.pattern;
        const root = pattern.root;
        const rootURL = rootToUrl2(root);
        const isRelPat = !pattern.isGlobalPattern;
        let fname = relFilePathname;
        if (isRelPat) {
          const relPathToFile = relativeToRoot(rootURL);
          if (!isRelativeValueNested(relPathToFile)) {
            continue;
          }
          fname = relPathToFile;
        }
        if (rule.fn(fname)) {
          return {
            matched,
            glob: pattern.glob,
            root,
            pattern,
            index: rule.index,
            isNeg: rule.isNeg
          };
        }
      }
    }
    const result = testRules(negRules, false) || testRules(posRules, true) || { matched: false };
    traceMode && logMatchTest(_id, filename, result);
    return result;
  };
  return fn;
}
function logMatchTest(id, filename, match2) {
  console.warn("%s;%d;%s", filename, id, JSON.stringify(match2.matched));
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/FeatureFlags/FeatureFlags.js
var systemFeatureFlags;
var FeatureFlags = class {
  flags;
  flagValues = /* @__PURE__ */ new Map();
  constructor(flags = []) {
    this.flags = new Map(flags.map((f) => [f.name, f]));
  }
  register(flagOrName, description) {
    if (typeof flagOrName === "string") {
      return this.register({ name: flagOrName, description: description || "" });
    }
    this.flags.set(flagOrName.name, flagOrName);
    return this;
  }
  getFlag(flag) {
    return this.flagValues.get(flag);
  }
  getFlagBool(flag) {
    return toBool(this.getFlag(flag));
  }
  setFlag(flag, value = true) {
    if (!this.flags.has(flag)) {
      throw new UnknownFeatureFlagError(flag);
    }
    this.flagValues.set(flag, value);
    return this;
  }
  getFlagInfo(flag) {
    return this.flags.get(flag);
  }
  getFlags() {
    return [...this.flags.values()];
  }
  getFlagValues() {
    return new Map(this.flagValues);
  }
  reset() {
    this.flagValues.clear();
    return this;
  }
};
var UnknownFeatureFlagError = class extends Error {
  flag;
  constructor(flag) {
    super(`Unknown feature flag: ${flag}`);
    this.flag = flag;
  }
};
function getSystemFeatureFlags() {
  return systemFeatureFlags || (systemFeatureFlags = new FeatureFlags());
}
var boolValues = {
  0: false,
  1: true,
  f: false,
  false: false,
  n: false,
  no: false,
  t: true,
  true: true,
  y: true,
  yes: true
};
function toBool(value) {
  if (typeof value !== "string")
    return value;
  return boolValues[value.toLowerCase()];
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
var import_node_assert8 = __toESM(require("node:assert"), 1);

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/constants.js
var configSettingsFileVersion0_1 = "0.1";
var configSettingsFileVersion0_2 = "0.2";
var currentSettingsFileVersion = configSettingsFileVersion0_2;
var ENV_CSPELL_GLOB_ROOT = "CSPELL_GLOB_ROOT";
var defaultConfigFileModuleRef = "@cspell/cspell-bundled-dicts/cspell-default.json";

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/mergeCache.js
var CalcLeftRightResultWeakCache = class {
  map = new AutoResolveWeakCache2();
  _toDispose;
  constructor() {
    this._toDispose = onClearCache(() => {
      this.clear();
    });
  }
  get(left, right, calc) {
    const m = this.map.get(left, () => new AutoResolveWeakCache2());
    return m.get(right, () => calc(left, right));
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    this.map.dispose();
    this._toDispose?.dispose();
    this._toDispose = void 0;
  }
  stats() {
    return this.map.stats();
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/mergeList.js
var cacheMergeListUnique = new CalcLeftRightResultWeakCache();
var cacheMergeLists = new CalcLeftRightResultWeakCache();
function mergeListUnique(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : void 0;
  if (!Array.isArray(right))
    return left;
  if (!right.length)
    return left;
  if (!left.length)
    return right;
  const result = cacheMergeListUnique.get(left, right, (left2, right2) => [.../* @__PURE__ */ new Set([...left2, ...right2])]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}
function mergeList(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : void 0;
  if (!Array.isArray(right))
    return left;
  if (!left.length)
    return right;
  if (!right.length)
    return left;
  const result = cacheMergeLists.get(left, right, (left2, right2) => [...left2, ...right2]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}
function stats() {
  return {
    cacheMergeListUnique: cacheMergeListUnique.stats(),
    cacheMergeLists: cacheMergeLists.stats()
  };
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/textRegex.js
var regExSplitWords = /(\p{Ll}\p{M}?)(\p{Lu})/gu;
var regExSplitWords2 = /(\p{Lu}\p{M}?)((\p{Lu}\p{M}?)\p{Ll})/gu;
var regExpCamelCaseWordBreaksWithEnglishSuffix = /(?<=\p{Ll}\p{M}?)(?=\p{Lu})|(?<=\p{Lu}\p{M}?)(?=\p{Lu}\p{M}?\p{Ll})(?!\p{Lu}\p{M}?(?:s|ing|ies|es|ings|ed|ning)(?!\p{Ll}))/gu;
var regExWords = /\p{L}\p{M}?(?:(?:\\?['’])?\p{L}\p{M}?)*/gu;
var regExWordsAndDigits = /[\p{L}\w'’`.+-](?:(?:\\(?=[']))?[\p{L}\p{M}\w'’`.+-])*/gu;
var regExIgnoreCharacters = /[\p{sc=Hiragana}\p{sc=Han}\p{sc=Katakana}\u30A0-\u30FF\p{sc=Hangul}]/gu;
var regExFirstUpper = /^\p{Lu}\p{M}?\p{Ll}+$/u;
var regExAllUpper2 = /^(?:\p{Lu}\p{M}?)+$/u;
var regExAllLower = /^(?:\p{Ll}\p{M}?)+$/u;
var regExPossibleWordBreaks = /[-+_’'`.\s]/g;
var regExMatchRegExParts = /^\s*\/([\s\S]*?)\/([gimuxy]*)\s*$/;
var regExAccents2 = /\p{M}/gu;
var regExEscapeCharacters = /(?<=\\)[anrvtbf]/gi;
var regExDanglingQuote = /(?<=(?:^|(?!\p{M})\P{L})(?:\p{L}\p{M}?)?)[']/gu;
var regExTrailingEndings = /(?<=(?:\p{Lu}\p{M}?){2})['’]?(?:s|d|ings?|ies|e[ds]?|ning|th|nth)(?!\p{Ll})/gu;
var regExNumericLiteral = /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/;
function stringToRegExp(pattern, defaultFlags = "gimu", forceFlags = "g") {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  try {
    const [, pat, flag] = [
      ...pattern.match(regExMatchRegExParts) || ["", pattern.trim(), defaultFlags],
      forceFlags
    ];
    if (pat) {
      const regPattern = flag.includes("x") ? removeVerboseFromRegExp(pat) : pat;
      const flags = [...new Set(forceFlags + flag)].join("").replaceAll(/[^gimuy]/g, "");
      const regex = new RegExp(regPattern, flags);
      return regex;
    }
  } catch {
  }
  return void 0;
}
var SPACES = {
  " ": true,
  "\n": true,
  "\r": true,
  "	": true
};
function removeVerboseFromRegExp(pattern) {
  function escape(acc) {
    const char = pattern[acc.idx];
    if (char !== "\\")
      return void 0;
    const next = pattern[++acc.idx];
    acc.idx++;
    if (next === "#") {
      acc.result += "#";
      return acc;
    }
    if (!(next in SPACES)) {
      acc.result += "\\" + next;
      return acc;
    }
    acc.result += next;
    if (next === "\r" && pattern[acc.idx] === "\n") {
      acc.result += "\n";
      acc.idx++;
    }
    return acc;
  }
  function braces(acc) {
    const char = pattern[acc.idx];
    if (char !== "[")
      return void 0;
    acc.result += char;
    acc.idx++;
    let escCount = 0;
    while (acc.idx < pattern.length) {
      const char2 = pattern[acc.idx];
      acc.result += char2;
      acc.idx++;
      if (char2 === "]" && !(escCount & 1))
        break;
      escCount = char2 === "\\" ? escCount + 1 : 0;
    }
    return acc;
  }
  function spaces2(acc) {
    const char = pattern[acc.idx];
    if (!(char in SPACES))
      return void 0;
    acc.idx++;
    return acc;
  }
  function comments(acc) {
    const char = pattern[acc.idx];
    if (char !== "#")
      return void 0;
    while (acc.idx < pattern.length && pattern[acc.idx] !== "\n") {
      acc.idx++;
    }
    return acc;
  }
  function copy(acc) {
    const char = pattern[acc.idx++];
    acc.result += char;
    return acc;
  }
  const reducers = [escape, braces, spaces2, comments, copy];
  const result = { idx: 0, result: "" };
  while (result.idx < pattern.length) {
    for (const r of reducers) {
      if (r(result))
        break;
    }
  }
  return result.result;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/patterns.js
var emptyRegExpList = [];
var emptyPatternDefinitions = [];
var cache4 = new CalcLeftRightResultWeakCache();
function resolvePatterns(regExpList = emptyRegExpList, patternDefinitions = emptyPatternDefinitions) {
  return cache4.get(regExpList, patternDefinitions, _resolvePatterns);
}
function _resolvePatterns(regExpList, patternDefinitions) {
  const patternMap = new Map(patternDefinitions.map((def) => [def.name.toLowerCase(), def.pattern]));
  const resolved = /* @__PURE__ */ new Set();
  function resolvePattern(p) {
    if (resolved.has(p))
      return void 0;
    resolved.add(p);
    return patternMap.get(p.toString().toLowerCase()) || p;
  }
  function* flatten2(patterns) {
    for (const pattern of patterns) {
      if (Array.isArray(pattern)) {
        yield* flatten2(pattern.map(resolvePattern).filter(isDefined3));
      } else {
        yield pattern;
      }
    }
  }
  const patternList = regExpList.map(resolvePattern).filter(isDefined3);
  const result = [...flatten2(patternList)].map(toRegExp).filter(isDefined3);
  Object.freeze(regExpList);
  Object.freeze(patternDefinitions);
  Object.freeze(result);
  return result;
}
function toRegExp(pattern) {
  return pattern instanceof RegExp ? new RegExp(pattern) : stringToRegExp(pattern, "gim", "g");
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/resolveCwd.js
var CwdUrlResolver = class {
  #lastPath;
  #lastUrl;
  #cwd;
  #cwdUrl;
  constructor() {
    this.#cwd = process.cwd();
    this.#cwdUrl = toFileDirURL(this.#cwd);
    this.#lastPath = this.#cwd;
    this.#lastUrl = this.#cwdUrl;
  }
  resolveUrl(path17) {
    path17 = path17 || this.#cwd;
    if (path17 === this.#lastPath)
      return this.#lastUrl;
    if (path17 === this.#cwd)
      return this.#cwdUrl;
    this.#lastPath = path17;
    this.#lastUrl = toFileURL(path17);
    return this.#lastUrl;
  }
  reset(cwd = process.cwd()) {
    this.#cwd = cwd;
    this.#cwdUrl = toFileDirURL(this.#cwd);
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
var emptyWords2 = [];
Object.freeze(emptyWords2);
var cachedMerges = new AutoResolveWeakCache2();
var mergeCache = new AutoResolveWeakCache2();
var cacheInternalSettings = new AutoResolveWeakCache2();
var parserCache = new AutoResolveWeakCache2();
var emptyParserMap = /* @__PURE__ */ new Map();
var cwdResolver = new CwdUrlResolver();
var envCSpellGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
onClearCache(() => {
  parserCache.clear();
  emptyParserMap.clear();
  cachedMerges.clear();
  mergeCache.clear();
  cacheInternalSettings.clear();
  cwdResolver.reset();
  envCSpellGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
});
function _mergeWordsCached(left, right) {
  const map3 = autoResolveWeak2(cachedMerges, left, () => /* @__PURE__ */ new WeakMap());
  return autoResolveWeak2(map3, right, () => [...left, ...right]);
}
function mergeWordsCached(left, right) {
  if (!Array.isArray(left) || !left.length) {
    return Array.isArray(right) ? right.length ? right : emptyWords2 : void 0;
  }
  if (!Array.isArray(right) || !right.length)
    return left;
  return _mergeWordsCached(left, right);
}
function mergeObjects(left, right) {
  if (!left || typeof left !== "object")
    return !right || typeof right !== "object" ? void 0 : right;
  if (!right || typeof right !== "object")
    return left;
  return { ...left, ...right };
}
function replaceIfNotEmpty(left = [], right = []) {
  const filtered = right.filter((a) => !!a);
  if (filtered.length) {
    return filtered;
  }
  return left;
}
function mergeSettings(left, ...settings) {
  const rawSettings = settings.filter(isDefined3).reduce(merge2, toInternalSettings(left));
  return clean3(rawSettings);
}
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
function merge2(left, right) {
  const map3 = mergeCache.get(left, () => /* @__PURE__ */ new WeakMap());
  return autoResolveWeak2(map3, right, () => _merge(left, right));
}
function _merge(left, right) {
  const _left = toInternalSettings(left);
  const _right = toInternalSettings(right);
  if (left === right) {
    return _left;
  }
  if (isEmpty(right)) {
    return _left;
  }
  if (isEmpty(left)) {
    return _right;
  }
  if (isLeftAncestorOfRight(_left, _right)) {
    return _right;
  }
  if (doesLeftHaveRightAncestor(_left, _right)) {
    return _left;
  }
  const includeRegExpList = takeRightOtherwiseLeft(_left.includeRegExpList, _right.includeRegExpList);
  const optionals = includeRegExpList?.length ? { includeRegExpList } : {};
  const version3 = max3(_left.version, _right.version);
  const valuesToClear = {
    name: void 0,
    id: void 0,
    description: void 0,
    globRoot: void 0,
    import: void 0,
    __importRef: void 0
  };
  const settings = cleanCSpellSettingsInternal({
    ..._left,
    ..._right,
    ...optionals,
    ...valuesToClear,
    version: version3,
    words: mergeWordsCached(_left.words, _right.words),
    userWords: mergeWordsCached(_left.userWords, _right.userWords),
    flagWords: mergeWordsCached(_left.flagWords, _right.flagWords),
    ignoreWords: mergeWordsCached(_left.ignoreWords, _right.ignoreWords),
    suggestWords: mergeWordsCached(_left.suggestWords, _right.suggestWords),
    enabledLanguageIds: replaceIfNotEmpty(_left.enabledLanguageIds, _right.enabledLanguageIds),
    enableFiletypes: mergeList(_left.enableFiletypes, _right.enableFiletypes),
    enabledFileTypes: mergeObjects(_left.enabledFileTypes, _right.enabledFileTypes),
    ignoreRegExpList: mergeListUnique(_left.ignoreRegExpList, _right.ignoreRegExpList),
    patterns: mergeListUnique(_left.patterns, _right.patterns),
    dictionaryDefinitions: mergeListUnique(_left.dictionaryDefinitions, _right.dictionaryDefinitions),
    dictionaries: mergeListUnique(_left.dictionaries, _right.dictionaries),
    noSuggestDictionaries: mergeListUnique(_left.noSuggestDictionaries, _right.noSuggestDictionaries),
    languageSettings: mergeList(_left.languageSettings, _right.languageSettings),
    enabled: _right.enabled !== void 0 ? _right.enabled : _left.enabled,
    files: mergeListUnique(_left.files, _right.files),
    ignorePaths: versionBasedMergeList(_left.ignorePaths, _right.ignorePaths, version3),
    overrides: versionBasedMergeList(_left.overrides, _right.overrides, version3),
    features: mergeObjects(_left.features, _right.features),
    source: mergeSources(_left, _right),
    plugins: mergeList(_left.plugins, _right.plugins),
    __imports: mergeImportRefs(_left, _right)
  });
  return settings;
}
function versionBasedMergeList(left, right, version3) {
  if (version3 === configSettingsFileVersion0_1) {
    return takeRightOtherwiseLeft(left, right);
  }
  return mergeListUnique(left, right);
}
function isLeftAncestorOfRight(left, right) {
  return hasAncestor(right, left, 0);
}
function doesLeftHaveRightAncestor(left, right) {
  return hasAncestor(left, right, 1);
}
function hasAncestor(s, ancestor, side) {
  const sources = s.source?.sources;
  if (!sources)
    return false;
  const i = side ? sources.length - 1 : 0;
  const src = sources[i];
  return src === ancestor || src && hasAncestor(src, ancestor, side) || false;
}
function takeRightOtherwiseLeft(left, right) {
  if (right?.length) {
    return right;
  }
  return left || right;
}
function finalizeSettings(settings) {
  return _finalizeSettings(toInternalSettings(settings));
}
function _finalizeSettings(settings) {
  const finalized = {
    ...settings,
    finalized: true,
    ignoreRegExpList: resolvePatterns(settings.ignoreRegExpList, settings.patterns),
    includeRegExpList: resolvePatterns(settings.includeRegExpList, settings.patterns),
    parserFn: resolveParser(settings)
  };
  finalized.name = "Finalized " + (finalized.name || "");
  finalized.source = { name: settings.name || "src", sources: [settings] };
  return finalized;
}
function toInternalSettings(settings) {
  if (settings === void 0)
    return void 0;
  if (isCSpellSettingsInternal(settings))
    return settings;
  return cacheInternalSettings.get(settings, _toInternalSettings);
}
function _toInternalSettings(settings) {
  const { dictionaryDefinitions: defs, ...rest } = settings;
  const dictionaryDefinitions = defs && mapDictDefsToInternal(defs, settings.source?.filename && toFileUrl(settings.source?.filename) || resolveCwd());
  const setting = dictionaryDefinitions ? { ...rest, dictionaryDefinitions } : rest;
  return cleanCSpellSettingsInternal(setting);
}
function mergeSources(left, right) {
  return {
    name: "merged",
    sources: [left, right]
  };
}
function max3(a, b) {
  if (a === void 0 || a === null)
    return b;
  if (b === void 0 || b === null)
    return a;
  return a > b ? a : b;
}
function getSources(settings) {
  const visited = /* @__PURE__ */ new Set();
  const sources = [];
  function _walkSourcesTree(settings2) {
    if (!settings2 || visited.has(settings2))
      return;
    visited.add(settings2);
    if (!settings2.source?.sources?.length) {
      sources.push(settings2);
      return;
    }
    settings2.source.sources.forEach(_walkSourcesTree);
  }
  _walkSourcesTree(settings);
  return sources;
}
function mergeImportRefs(left, right = {}) {
  const imports = new Map(left.__imports || []);
  if (left.__importRef) {
    imports.set(left.__importRef.filename, left.__importRef);
  }
  if (right.__importRef) {
    imports.set(right.__importRef.filename, right.__importRef);
  }
  const rightImports = right.__imports?.values() || [];
  for (const ref of rightImports) {
    imports.set(ref.filename, ref);
  }
  return imports.size ? imports : void 0;
}
function extractDependencies(settings) {
  const settingsI = toInternalSettings(settings);
  const configFiles = [...mergeImportRefs(settingsI) || []].map(([filename]) => filename);
  const dictionaryFiles = calcDictionaryDefsToLoad(settingsI).map((dict) => dict.path).filter((file) => !!file);
  return {
    configFiles,
    dictionaryFiles
  };
}
function resolveCwd() {
  return cwdResolver.resolveUrl(envCSpellGlobRoot);
}
function resolveParser(settings) {
  if (!settings.parser)
    return void 0;
  if (typeof settings.parser === "function")
    return settings.parser;
  const parserName = settings.parser;
  (0, import_node_assert8.default)(typeof parserName === "string");
  const parsers3 = extractParsers(settings.plugins);
  const parser2 = parsers3.get(parserName);
  (0, import_node_assert8.default)(parser2, `Parser "${parserName}" not found.`);
  return parser2;
}
function* parsers(plugins) {
  for (const plugin of plugins) {
    if (!plugin.parsers)
      continue;
    for (const parser2 of plugin.parsers) {
      yield [parser2.name, parser2];
    }
  }
}
function mapPlugins(plugins) {
  return new Map(parsers(plugins));
}
function extractParsers(plugins) {
  if (!plugins || !plugins.length)
    return emptyParserMap;
  return parserCache.get(plugins, mapPlugins);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/getDictionary.js
async function getDictionary(settings) {
  return getDictionaryInternal(toInternalSettings(settings));
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/perf/timer.js
function createPerfTimer2(name2, onEnd, timeNowFn) {
  return new SimpleTimer(name2, onEnd, timeNowFn);
}
var SimpleTimer = class {
  name;
  onEnd;
  timeNowFn;
  _start = performance.now();
  _elapsed = void 0;
  _running = true;
  constructor(name2, onEnd, timeNowFn = performance.now) {
    this.name = name2;
    this.onEnd = onEnd;
    this.timeNowFn = timeNowFn;
  }
  get startTime() {
    return this._start;
  }
  get elapsed() {
    return this._elapsed ?? performance.now() - this._start;
  }
  end() {
    if (!this._running)
      return;
    this._running = false;
    const end = performance.now();
    this._elapsed = end - this._start;
    this.onEnd?.(this._elapsed, this.name);
  }
  start() {
    this._start = performance.now();
    this._running = true;
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/globs/getGlobMatcher.js
var simpleGlobCache = /* @__PURE__ */ new Map();
var globCache = /* @__PURE__ */ new WeakMap();
onClearCache(() => {
  globCache = /* @__PURE__ */ new WeakMap();
  simpleGlobCache.clear();
});
var emptyIgnorePaths = [];
function getGlobMatcherForExcluding(glob2) {
  if (!glob2 || Array.isArray(glob2) && !glob2.length)
    return getGlobMatcherGlobGlob(emptyIgnorePaths);
  return typeof glob2 === "string" ? getGlobMatcherGlobString(glob2) : getGlobMatcherGlobGlob(glob2);
}
function getGlobMatcherGlobString(glob2) {
  const cached = simpleGlobCache.get(glob2);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob2);
  simpleGlobCache.set(glob2, m);
  return m;
}
function getGlobMatcherGlobGlob(glob2) {
  const cached = globCache.get(glob2);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob2);
  globCache.set(glob2, m);
  return m;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/globs/checkFilenameMatchesGlob.js
function checkFilenameMatchesExcludeGlob(filename, globs) {
  const m = getGlobMatcherForExcluding(globs);
  return m.match(filename);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/calcOverrideSettings.js
function calcOverrideSettings(settings, filename) {
  const _settings = toInternalSettings(settings);
  const overrides = _settings.overrides || [];
  const result = overrides.filter((override) => checkFilenameMatchesExcludeGlob(filename, override.filename)).reduce((settings2, override) => mergeSettings(settings2, override), _settings);
  return result;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLoader.js
var import_node_assert10 = __toESM(require("node:assert"), 1);
var import_node_path9 = __toESM(require("node:path"), 1);
var import_node_url12 = require("node:url");

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFileReaderWriter.js
var import_posix = require("node:path/posix");

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile.js
var CSpellConfigFile = class {
  url;
  constructor(url2) {
    this.url = url2;
  }
  get readonly() {
    return this.settings.readonly || this.url.protocol !== "file:";
  }
  get virtual() {
    return false;
  }
  get remote() {
    return this.url.protocol !== "file:";
  }
};
var MutableCSpellConfigFile = class extends CSpellConfigFile {
};
var ImplCSpellConfigFile = class extends CSpellConfigFile {
  url;
  settings;
  constructor(url2, settings) {
    super(url2);
    this.url = url2;
    this.settings = settings;
  }
  setSchema(_schema) {
    return this;
  }
  removeAllComments() {
    if (this.readonly) {
      throw new Error(`Config file is readonly: ${this.url.href}`);
    }
    return this;
  }
  addWords(words) {
    if (this.readonly)
      throw new Error(`Config file is readonly: ${this.url.href}`);
    const w = this.settings.words || [];
    this.settings.words = w;
    addUniqueWordsToListAndSort(w, words);
    return this;
  }
  setComment(_key, _comment, _inline) {
    if (this.readonly)
      throw new Error(`Config file is readonly: ${this.url.href}`);
    return this;
  }
  setValue(key, value) {
    if (this.readonly)
      throw new Error(`Config file is readonly: ${this.url.href}`);
    this.settings[key] = value;
    return this;
  }
};
function addUniqueWordsToListAndSort(list, toAdd) {
  list.push(...toAdd);
  list.sort();
  for (let i = 1; i < list.length; ++i) {
    if (list[i] === list[i - 1]) {
      list.splice(i, 1);
      --i;
    }
  }
}
function satisfiesCSpellConfigFile(obj) {
  const r = obj instanceof CSpellConfigFile || !!obj && typeof obj === "object" && "url" in obj && obj.url instanceof URL && "settings" in obj && !!obj.settings && typeof obj.settings === "object";
  return r;
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileInMemory.js
var CSpellConfigFileInMemory = class _CSpellConfigFileInMemory extends ImplCSpellConfigFile {
  url;
  settings;
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  setSchema(schema) {
    this.settings.$schema = schema;
    return this;
  }
  get virtual() {
    return true;
  }
  static from(url2, settings, _indent) {
    return new _CSpellConfigFileInMemory(url2, settings);
  }
};

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJavaScript.js
var CSpellConfigFileJavaScript = class extends ImplCSpellConfigFile {
  url;
  settings;
  get readonly() {
    return true;
  }
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  addWords(_words) {
    throw new Error("Unable to add words to a JavaScript config file.");
  }
};

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJson.js
var import_comment_json = __toESM(require_src2(), 1);

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/serializers/util.js
function detectIndent(content) {
  const m = content.match(/^[ \t]+/m);
  return m && m[0] || "  ";
}
function detectIndentAsNum(content) {
  const indent = detectIndent(content).replaceAll("	", "    ").replaceAll(/[^ ]/g, "");
  return indent.length;
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/Errors.js
var ParseError = class extends Error {
  url;
  constructor(url2, message, options) {
    super(message || `Unable to parse ${url2}`, options);
    this.url = url2;
  }
};

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJson.js
var CSpellConfigFileJson = class _CSpellConfigFileJson extends ImplCSpellConfigFile {
  url;
  indent = 2;
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
  }
  serialize() {
    return (0, import_comment_json.stringify)(this.settings, void 0, this.indent) + "\n";
  }
  removeAllComments() {
    for (const key of Object.getOwnPropertySymbols(this.settings)) {
      delete this.settings[key];
    }
    Object.assign(this.settings, JSON.parse(JSON.stringify(this.settings)));
    return this;
  }
  setSchema(schema) {
    this.settings.$schema = schema;
    return this;
  }
  setComment(field, comment, inline) {
    const prefix = inline ? "after:" : "before:";
    const symbolKey = Symbol.for(prefix + field);
    const token = {
      type: "LineComment",
      value: comment,
      inline
    };
    const settings = this.settings;
    settings[symbolKey] = [token];
    return this;
  }
  static parse(file) {
    try {
      const cspell = parseJson(file.content);
      if (!isCSpellSettings(cspell)) {
        throw new ParseError(file.url);
      }
      const indent = detectIndent(file.content);
      const cfg = new _CSpellConfigFileJson(file.url, cspell);
      cfg.indent = indent;
      return cfg;
    } catch (cause) {
      if (cause instanceof ParseError) {
        throw cause;
      }
      throw new ParseError(file.url, void 0, { cause });
    }
  }
  static from(url2, settings, indent = 2) {
    const cfg = new _CSpellConfigFileJson(url2, settings);
    cfg.indent = indent;
    return cfg;
  }
};
function parseJson(content) {
  try {
    return JSON.parse(content);
  } catch {
    return (0, import_comment_json.parse)(content);
  }
}
function parseCSpellConfigFileJson(file) {
  return CSpellConfigFileJson.parse(file);
}
function isCSpellSettings(cfg) {
  return !(!cfg || typeof cfg !== "object" || Array.isArray(cfg));
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFilePackageJson.js
var CSpellConfigFilePackageJson = class extends ImplCSpellConfigFile {
  url;
  settings;
  serializer;
  constructor(url2, settings, serializer5) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
    this.serializer = serializer5;
  }
  serialize() {
    return this.serializer(this.settings);
  }
};
function parseCSpellConfigFilePackageJson(file) {
  const { url: url2, content } = file;
  const packageJson = JSON.parse(content);
  if (!packageJson || typeof packageJson !== "object" || Array.isArray(packageJson)) {
    throw new Error(`Unable to parse ${url2}`);
  }
  packageJson["cspell"] = packageJson["cspell"] || {};
  const cspell = packageJson["cspell"];
  if (typeof cspell !== "object" || Array.isArray(cspell)) {
    throw new TypeError(`Unable to parse ${url2}`);
  }
  const indent = detectIndent(content);
  function serialize(settings) {
    packageJson["cspell"] = settings;
    return JSON.stringify(packageJson, void 0, indent) + "\n";
  }
  return new CSpellConfigFilePackageJson(url2, cspell, serialize);
}

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/error.js
function getLineColFromPtr(string, ptr) {
  let lines = string.slice(0, ptr).split(/\r\n|\n|\r/g);
  return [lines.length, lines.pop().length + 1];
}
function makeCodeBlock(string, line, column) {
  let lines = string.split(/\r\n|\n|\r/g);
  let codeblock = "";
  let numberLen = (Math.log10(line + 1) | 0) + 1;
  for (let i = line - 1; i <= line + 1; i++) {
    let l = lines[i - 1];
    if (!l)
      continue;
    codeblock += i.toString().padEnd(numberLen, " ");
    codeblock += ":  ";
    codeblock += l;
    codeblock += "\n";
    if (i === line) {
      codeblock += " ".repeat(numberLen + column + 2);
      codeblock += "^\n";
    }
  }
  return codeblock;
}
var TomlError = class extends Error {
  line;
  column;
  codeblock;
  constructor(message, options) {
    const [line, column] = getLineColFromPtr(options.toml, options.ptr);
    const codeblock = makeCodeBlock(options.toml, line, column);
    super(`Invalid TOML document: ${message}

${codeblock}`, options);
    this.line = line;
    this.column = column;
    this.codeblock = codeblock;
  }
};

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/util.js
function indexOfNewline(str, start = 0, end = str.length) {
  let idx2 = str.indexOf("\n", start);
  if (str[idx2 - 1] === "\r")
    idx2--;
  return idx2 <= end ? idx2 : -1;
}
function skipComment(str, ptr) {
  for (let i = ptr; i < str.length; i++) {
    let c = str[i];
    if (c === "\n")
      return i;
    if (c === "\r" && str[i + 1] === "\n")
      return i + 1;
    if (c < " " && c !== "	" || c === "\x7F") {
      throw new TomlError("control characters are not allowed in comments", {
        toml: str,
        ptr
      });
    }
  }
  return str.length;
}
function skipVoid(str, ptr, banNewLines, banComments) {
  let c;
  while ((c = str[ptr]) === " " || c === "	" || !banNewLines && (c === "\n" || c === "\r" && str[ptr + 1] === "\n"))
    ptr++;
  return banComments || c !== "#" ? ptr : skipVoid(str, skipComment(str, ptr), banNewLines);
}
function skipUntil(str, ptr, sep3, end, banNewLines = false) {
  if (!end) {
    ptr = indexOfNewline(str, ptr);
    return ptr < 0 ? str.length : ptr;
  }
  for (let i = ptr; i < str.length; i++) {
    let c = str[i];
    if (c === "#") {
      i = indexOfNewline(str, i);
    } else if (c === sep3) {
      return i + 1;
    } else if (c === end || banNewLines && (c === "\n" || c === "\r" && str[i + 1] === "\n")) {
      return i;
    }
  }
  throw new TomlError("cannot find end of structure", {
    toml: str,
    ptr
  });
}
function getStringEnd(str, seek) {
  let first3 = str[seek];
  let target = first3 === str[seek + 1] && str[seek + 1] === str[seek + 2] ? str.slice(seek, seek + 3) : first3;
  seek += target.length - 1;
  do
    seek = str.indexOf(target, ++seek);
  while (seek > -1 && first3 !== "'" && str[seek - 1] === "\\" && (str[seek - 2] !== "\\" || str[seek - 3] === "\\"));
  if (seek > -1) {
    seek += target.length;
    if (target.length > 1) {
      if (str[seek] === first3)
        seek++;
      if (str[seek] === first3)
        seek++;
    }
  }
  return seek;
}

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/date.js
var DATE_TIME_RE = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
var TomlDate = class _TomlDate extends Date {
  #hasDate = false;
  #hasTime = false;
  #offset = null;
  constructor(date) {
    let hasDate = true;
    let hasTime = true;
    let offset = "Z";
    if (typeof date === "string") {
      let match2 = date.match(DATE_TIME_RE);
      if (match2) {
        if (!match2[1]) {
          hasDate = false;
          date = `0000-01-01T${date}`;
        }
        hasTime = !!match2[2];
        hasTime && date[10] === " " && (date = date.replace(" ", "T"));
        if (match2[2] && +match2[2] > 23) {
          date = "";
        } else {
          offset = match2[3] || null;
          date = date.toUpperCase();
          if (!offset && hasTime)
            date += "Z";
        }
      } else {
        date = "";
      }
    }
    super(date);
    if (!isNaN(this.getTime())) {
      this.#hasDate = hasDate;
      this.#hasTime = hasTime;
      this.#offset = offset;
    }
  }
  isDateTime() {
    return this.#hasDate && this.#hasTime;
  }
  isLocal() {
    return !this.#hasDate || !this.#hasTime || !this.#offset;
  }
  isDate() {
    return this.#hasDate && !this.#hasTime;
  }
  isTime() {
    return this.#hasTime && !this.#hasDate;
  }
  isValid() {
    return this.#hasDate || this.#hasTime;
  }
  toISOString() {
    let iso = super.toISOString();
    if (this.isDate())
      return iso.slice(0, 10);
    if (this.isTime())
      return iso.slice(11, 23);
    if (this.#offset === null)
      return iso.slice(0, -1);
    if (this.#offset === "Z")
      return iso;
    let offset = +this.#offset.slice(1, 3) * 60 + +this.#offset.slice(4, 6);
    offset = this.#offset[0] === "-" ? offset : -offset;
    let offsetDate = new Date(this.getTime() - offset * 6e4);
    return offsetDate.toISOString().slice(0, -1) + this.#offset;
  }
  static wrapAsOffsetDateTime(jsDate, offset = "Z") {
    let date = new _TomlDate(jsDate);
    date.#offset = offset;
    return date;
  }
  static wrapAsLocalDateTime(jsDate) {
    let date = new _TomlDate(jsDate);
    date.#offset = null;
    return date;
  }
  static wrapAsLocalDate(jsDate) {
    let date = new _TomlDate(jsDate);
    date.#hasTime = false;
    date.#offset = null;
    return date;
  }
  static wrapAsLocalTime(jsDate) {
    let date = new _TomlDate(jsDate);
    date.#hasDate = false;
    date.#offset = null;
    return date;
  }
};

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/primitive.js
var INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;
var FLOAT_REGEX = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
var LEADING_ZERO = /^[+-]?0[0-9_]/;
var ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i;
var ESC_MAP = {
  b: "\b",
  t: "	",
  n: "\n",
  f: "\f",
  r: "\r",
  '"': '"',
  "\\": "\\"
};
function parseString(str, ptr = 0, endPtr = str.length) {
  let isLiteral = str[ptr] === "'";
  let isMultiline = str[ptr++] === str[ptr] && str[ptr] === str[ptr + 1];
  if (isMultiline) {
    endPtr -= 2;
    if (str[ptr += 2] === "\r")
      ptr++;
    if (str[ptr] === "\n")
      ptr++;
  }
  let tmp = 0;
  let isEscape;
  let parsed = "";
  let sliceStart = ptr;
  while (ptr < endPtr - 1) {
    let c = str[ptr++];
    if (c === "\n" || c === "\r" && str[ptr] === "\n") {
      if (!isMultiline) {
        throw new TomlError("newlines are not allowed in strings", {
          toml: str,
          ptr: ptr - 1
        });
      }
    } else if (c < " " && c !== "	" || c === "\x7F") {
      throw new TomlError("control characters are not allowed in strings", {
        toml: str,
        ptr: ptr - 1
      });
    }
    if (isEscape) {
      isEscape = false;
      if (c === "u" || c === "U") {
        let code = str.slice(ptr, ptr += c === "u" ? 4 : 8);
        if (!ESCAPE_REGEX.test(code)) {
          throw new TomlError("invalid unicode escape", {
            toml: str,
            ptr: tmp
          });
        }
        try {
          parsed += String.fromCodePoint(parseInt(code, 16));
        } catch {
          throw new TomlError("invalid unicode escape", {
            toml: str,
            ptr: tmp
          });
        }
      } else if (isMultiline && (c === "\n" || c === " " || c === "	" || c === "\r")) {
        ptr = skipVoid(str, ptr - 1, true);
        if (str[ptr] !== "\n" && str[ptr] !== "\r") {
          throw new TomlError("invalid escape: only line-ending whitespace may be escaped", {
            toml: str,
            ptr: tmp
          });
        }
        ptr = skipVoid(str, ptr);
      } else if (c in ESC_MAP) {
        parsed += ESC_MAP[c];
      } else {
        throw new TomlError("unrecognized escape sequence", {
          toml: str,
          ptr: tmp
        });
      }
      sliceStart = ptr;
    } else if (!isLiteral && c === "\\") {
      tmp = ptr - 1;
      isEscape = true;
      parsed += str.slice(sliceStart, tmp);
    }
  }
  return parsed + str.slice(sliceStart, endPtr - 1);
}
function parseValue(value, toml, ptr, integersAsBigInt) {
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  if (value === "-inf")
    return -Infinity;
  if (value === "inf" || value === "+inf")
    return Infinity;
  if (value === "nan" || value === "+nan" || value === "-nan")
    return NaN;
  if (value === "-0")
    return integersAsBigInt ? 0n : 0;
  let isInt = INT_REGEX.test(value);
  if (isInt || FLOAT_REGEX.test(value)) {
    if (LEADING_ZERO.test(value)) {
      throw new TomlError("leading zeroes are not allowed", {
        toml,
        ptr
      });
    }
    value = value.replace(/_/g, "");
    let numeric = +value;
    if (isNaN(numeric)) {
      throw new TomlError("invalid number", {
        toml,
        ptr
      });
    }
    if (isInt) {
      if ((isInt = !Number.isSafeInteger(numeric)) && !integersAsBigInt) {
        throw new TomlError("integer value cannot be represented losslessly", {
          toml,
          ptr
        });
      }
      if (isInt || integersAsBigInt === true)
        numeric = BigInt(value);
    }
    return numeric;
  }
  const date = new TomlDate(value);
  if (!date.isValid()) {
    throw new TomlError("invalid value", {
      toml,
      ptr
    });
  }
  return date;
}

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/extract.js
function sliceAndTrimEndOf(str, startPtr, endPtr, allowNewLines) {
  let value = str.slice(startPtr, endPtr);
  let commentIdx = value.indexOf("#");
  if (commentIdx > -1) {
    skipComment(str, commentIdx);
    value = value.slice(0, commentIdx);
  }
  let trimmed = value.trimEnd();
  if (!allowNewLines) {
    let newlineIdx = value.indexOf("\n", trimmed.length);
    if (newlineIdx > -1) {
      throw new TomlError("newlines are not allowed in inline tables", {
        toml: str,
        ptr: startPtr + newlineIdx
      });
    }
  }
  return [trimmed, commentIdx];
}
function extractValue(str, ptr, end, depth, integersAsBigInt) {
  if (depth === 0) {
    throw new TomlError("document contains excessively nested structures. aborting.", {
      toml: str,
      ptr
    });
  }
  let c = str[ptr];
  if (c === "[" || c === "{") {
    let [value, endPtr2] = c === "[" ? parseArray(str, ptr, depth, integersAsBigInt) : parseInlineTable(str, ptr, depth, integersAsBigInt);
    let newPtr = end ? skipUntil(str, endPtr2, ",", end) : endPtr2;
    if (endPtr2 - newPtr && end === "}") {
      let nextNewLine = indexOfNewline(str, endPtr2, newPtr);
      if (nextNewLine > -1) {
        throw new TomlError("newlines are not allowed in inline tables", {
          toml: str,
          ptr: nextNewLine
        });
      }
    }
    return [value, newPtr];
  }
  let endPtr;
  if (c === '"' || c === "'") {
    endPtr = getStringEnd(str, ptr);
    let parsed = parseString(str, ptr, endPtr);
    if (end) {
      endPtr = skipVoid(str, endPtr, end !== "]");
      if (str[endPtr] && str[endPtr] !== "," && str[endPtr] !== end && str[endPtr] !== "\n" && str[endPtr] !== "\r") {
        throw new TomlError("unexpected character encountered", {
          toml: str,
          ptr: endPtr
        });
      }
      endPtr += +(str[endPtr] === ",");
    }
    return [parsed, endPtr];
  }
  endPtr = skipUntil(str, ptr, ",", end);
  let slice = sliceAndTrimEndOf(str, ptr, endPtr - +(str[endPtr - 1] === ","), end === "]");
  if (!slice[0]) {
    throw new TomlError("incomplete key-value declaration: no value specified", {
      toml: str,
      ptr
    });
  }
  if (end && slice[1] > -1) {
    endPtr = skipVoid(str, ptr + slice[1]);
    endPtr += +(str[endPtr] === ",");
  }
  return [
    parseValue(slice[0], str, ptr, integersAsBigInt),
    endPtr
  ];
}

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/struct.js
var KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \t]*$/;
function parseKey(str, ptr, end = "=") {
  let dot = ptr - 1;
  let parsed = [];
  let endPtr = str.indexOf(end, ptr);
  if (endPtr < 0) {
    throw new TomlError("incomplete key-value: cannot find end of key", {
      toml: str,
      ptr
    });
  }
  do {
    let c = str[ptr = ++dot];
    if (c !== " " && c !== "	") {
      if (c === '"' || c === "'") {
        if (c === str[ptr + 1] && c === str[ptr + 2]) {
          throw new TomlError("multiline strings are not allowed in keys", {
            toml: str,
            ptr
          });
        }
        let eos = getStringEnd(str, ptr);
        if (eos < 0) {
          throw new TomlError("unfinished string encountered", {
            toml: str,
            ptr
          });
        }
        dot = str.indexOf(".", eos);
        let strEnd = str.slice(eos, dot < 0 || dot > endPtr ? endPtr : dot);
        let newLine = indexOfNewline(strEnd);
        if (newLine > -1) {
          throw new TomlError("newlines are not allowed in keys", {
            toml: str,
            ptr: ptr + dot + newLine
          });
        }
        if (strEnd.trimStart()) {
          throw new TomlError("found extra tokens after the string part", {
            toml: str,
            ptr: eos
          });
        }
        if (endPtr < eos) {
          endPtr = str.indexOf(end, eos);
          if (endPtr < 0) {
            throw new TomlError("incomplete key-value: cannot find end of key", {
              toml: str,
              ptr
            });
          }
        }
        parsed.push(parseString(str, ptr, eos));
      } else {
        dot = str.indexOf(".", ptr);
        let part = str.slice(ptr, dot < 0 || dot > endPtr ? endPtr : dot);
        if (!KEY_PART_RE.test(part)) {
          throw new TomlError("only letter, numbers, dashes and underscores are allowed in keys", {
            toml: str,
            ptr
          });
        }
        parsed.push(part.trimEnd());
      }
    }
  } while (dot + 1 && dot < endPtr);
  return [parsed, skipVoid(str, endPtr + 1, true, true)];
}
function parseInlineTable(str, ptr, depth, integersAsBigInt) {
  let res = {};
  let seen = /* @__PURE__ */ new Set();
  let c;
  let comma = 0;
  ptr++;
  while ((c = str[ptr++]) !== "}" && c) {
    let err = { toml: str, ptr: ptr - 1 };
    if (c === "\n") {
      throw new TomlError("newlines are not allowed in inline tables", err);
    } else if (c === "#") {
      throw new TomlError("inline tables cannot contain comments", err);
    } else if (c === ",") {
      throw new TomlError("expected key-value, found comma", err);
    } else if (c !== " " && c !== "	") {
      let k;
      let t = res;
      let hasOwn2 = false;
      let [key, keyEndPtr] = parseKey(str, ptr - 1);
      for (let i = 0; i < key.length; i++) {
        if (i)
          t = hasOwn2 ? t[k] : t[k] = {};
        k = key[i];
        if ((hasOwn2 = Object.hasOwn(t, k)) && (typeof t[k] !== "object" || seen.has(t[k]))) {
          throw new TomlError("trying to redefine an already defined value", {
            toml: str,
            ptr
          });
        }
        if (!hasOwn2 && k === "__proto__") {
          Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
        }
      }
      if (hasOwn2) {
        throw new TomlError("trying to redefine an already defined value", {
          toml: str,
          ptr
        });
      }
      let [value, valueEndPtr] = extractValue(str, keyEndPtr, "}", depth - 1, integersAsBigInt);
      seen.add(value);
      t[k] = value;
      ptr = valueEndPtr;
      comma = str[ptr - 1] === "," ? ptr - 1 : 0;
    }
  }
  if (comma) {
    throw new TomlError("trailing commas are not allowed in inline tables", {
      toml: str,
      ptr: comma
    });
  }
  if (!c) {
    throw new TomlError("unfinished table encountered", {
      toml: str,
      ptr
    });
  }
  return [res, ptr];
}
function parseArray(str, ptr, depth, integersAsBigInt) {
  let res = [];
  let c;
  ptr++;
  while ((c = str[ptr++]) !== "]" && c) {
    if (c === ",") {
      throw new TomlError("expected value, found comma", {
        toml: str,
        ptr: ptr - 1
      });
    } else if (c === "#")
      ptr = skipComment(str, ptr);
    else if (c !== " " && c !== "	" && c !== "\n" && c !== "\r") {
      let e = extractValue(str, ptr - 1, "]", depth - 1, integersAsBigInt);
      res.push(e[0]);
      ptr = e[1];
    }
  }
  if (!c) {
    throw new TomlError("unfinished array encountered", {
      toml: str,
      ptr
    });
  }
  return [res, ptr];
}

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/parse.js
function peekTable(key, table, meta, type) {
  let t = table;
  let m = meta;
  let k;
  let hasOwn2 = false;
  let state;
  for (let i = 0; i < key.length; i++) {
    if (i) {
      t = hasOwn2 ? t[k] : t[k] = {};
      m = (state = m[k]).c;
      if (type === 0 && (state.t === 1 || state.t === 2)) {
        return null;
      }
      if (state.t === 2) {
        let l = t.length - 1;
        t = t[l];
        m = m[l].c;
      }
    }
    k = key[i];
    if ((hasOwn2 = Object.hasOwn(t, k)) && m[k]?.t === 0 && m[k]?.d) {
      return null;
    }
    if (!hasOwn2) {
      if (k === "__proto__") {
        Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
        Object.defineProperty(m, k, { enumerable: true, configurable: true, writable: true });
      }
      m[k] = {
        t: i < key.length - 1 && type === 2 ? 3 : type,
        d: false,
        i: 0,
        c: {}
      };
    }
  }
  state = m[k];
  if (state.t !== type && !(type === 1 && state.t === 3)) {
    return null;
  }
  if (type === 2) {
    if (!state.d) {
      state.d = true;
      t[k] = [];
    }
    t[k].push(t = {});
    state.c[state.i++] = state = { t: 1, d: false, i: 0, c: {} };
  }
  if (state.d) {
    return null;
  }
  state.d = true;
  if (type === 1) {
    t = hasOwn2 ? t[k] : t[k] = {};
  } else if (type === 0 && hasOwn2) {
    return null;
  }
  return [k, t, state.c];
}
function parse2(toml, { maxDepth = 1e3, integersAsBigInt } = {}) {
  let res = {};
  let meta = {};
  let tbl = res;
  let m = meta;
  for (let ptr = skipVoid(toml, 0); ptr < toml.length; ) {
    if (toml[ptr] === "[") {
      let isTableArray = toml[++ptr] === "[";
      let k = parseKey(toml, ptr += +isTableArray, "]");
      if (isTableArray) {
        if (toml[k[1] - 1] !== "]") {
          throw new TomlError("expected end of table declaration", {
            toml,
            ptr: k[1] - 1
          });
        }
        k[1]++;
      }
      let p = peekTable(
        k[0],
        res,
        meta,
        isTableArray ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!p) {
        throw new TomlError("trying to redefine an already defined table or value", {
          toml,
          ptr
        });
      }
      m = p[2];
      tbl = p[1];
      ptr = k[1];
    } else {
      let k = parseKey(toml, ptr);
      let p = peekTable(
        k[0],
        tbl,
        m,
        0
        /* Type.DOTTED */
      );
      if (!p) {
        throw new TomlError("trying to redefine an already defined table or value", {
          toml,
          ptr
        });
      }
      let v = extractValue(toml, k[1], void 0, maxDepth, integersAsBigInt);
      p[1][p[0]] = v[0];
      ptr = v[1];
    }
    ptr = skipVoid(toml, ptr, true);
    if (toml[ptr] && toml[ptr] !== "\n" && toml[ptr] !== "\r") {
      throw new TomlError("each key-value declaration must be followed by an end-of-line", {
        toml,
        ptr
      });
    }
    ptr = skipVoid(toml, ptr);
  }
  return res;
}

// ../node_modules/.pnpm/smol-toml@1.4.1/node_modules/smol-toml/dist/stringify.js
var BARE_KEY = /^[a-z0-9-_]+$/i;
function extendedTypeOf(obj) {
  let type = typeof obj;
  if (type === "object") {
    if (Array.isArray(obj))
      return "array";
    if (obj instanceof Date)
      return "date";
  }
  return type;
}
function isArrayOfTables(obj) {
  for (let i = 0; i < obj.length; i++) {
    if (extendedTypeOf(obj[i]) !== "object")
      return false;
  }
  return obj.length != 0;
}
function formatString(s) {
  return JSON.stringify(s).replace(/\x7f/g, "\\u007f");
}
function stringifyValue(val, type, depth, numberAsFloat) {
  if (depth === 0) {
    throw new Error("Could not stringify the object: maximum object depth exceeded");
  }
  if (type === "number") {
    if (isNaN(val))
      return "nan";
    if (val === Infinity)
      return "inf";
    if (val === -Infinity)
      return "-inf";
    if (numberAsFloat && Number.isInteger(val))
      return val.toFixed(1);
    return val.toString();
  }
  if (type === "bigint" || type === "boolean") {
    return val.toString();
  }
  if (type === "string") {
    return formatString(val);
  }
  if (type === "date") {
    if (isNaN(val.getTime())) {
      throw new TypeError("cannot serialize invalid date");
    }
    return val.toISOString();
  }
  if (type === "object") {
    return stringifyInlineTable(val, depth, numberAsFloat);
  }
  if (type === "array") {
    return stringifyArray(val, depth, numberAsFloat);
  }
}
function stringifyInlineTable(obj, depth, numberAsFloat) {
  let keys3 = Object.keys(obj);
  if (keys3.length === 0)
    return "{}";
  let res = "{ ";
  for (let i = 0; i < keys3.length; i++) {
    let k = keys3[i];
    if (i)
      res += ", ";
    res += BARE_KEY.test(k) ? k : formatString(k);
    res += " = ";
    res += stringifyValue(obj[k], extendedTypeOf(obj[k]), depth - 1, numberAsFloat);
  }
  return res + " }";
}
function stringifyArray(array, depth, numberAsFloat) {
  if (array.length === 0)
    return "[]";
  let res = "[ ";
  for (let i = 0; i < array.length; i++) {
    if (i)
      res += ", ";
    if (array[i] === null || array[i] === void 0) {
      throw new TypeError("arrays cannot contain null or undefined values");
    }
    res += stringifyValue(array[i], extendedTypeOf(array[i]), depth - 1, numberAsFloat);
  }
  return res + " ]";
}
function stringifyArrayTable(array, key, depth, numberAsFloat) {
  if (depth === 0) {
    throw new Error("Could not stringify the object: maximum object depth exceeded");
  }
  let res = "";
  for (let i = 0; i < array.length; i++) {
    res += `[[${key}]]
`;
    res += stringifyTable(array[i], key, depth, numberAsFloat);
    res += "\n\n";
  }
  return res;
}
function stringifyTable(obj, prefix, depth, numberAsFloat) {
  if (depth === 0) {
    throw new Error("Could not stringify the object: maximum object depth exceeded");
  }
  let preamble = "";
  let tables = "";
  let keys3 = Object.keys(obj);
  for (let i = 0; i < keys3.length; i++) {
    let k = keys3[i];
    if (obj[k] !== null && obj[k] !== void 0) {
      let type = extendedTypeOf(obj[k]);
      if (type === "symbol" || type === "function") {
        throw new TypeError(`cannot serialize values of type '${type}'`);
      }
      let key = BARE_KEY.test(k) ? k : formatString(k);
      if (type === "array" && isArrayOfTables(obj[k])) {
        tables += stringifyArrayTable(obj[k], prefix ? `${prefix}.${key}` : key, depth - 1, numberAsFloat);
      } else if (type === "object") {
        let tblKey = prefix ? `${prefix}.${key}` : key;
        tables += `[${tblKey}]
`;
        tables += stringifyTable(obj[k], tblKey, depth - 1, numberAsFloat);
        tables += "\n\n";
      } else {
        preamble += key;
        preamble += " = ";
        preamble += stringifyValue(obj[k], type, depth, numberAsFloat);
        preamble += "\n";
      }
    }
  }
  return `${preamble}
${tables}`.trim();
}
function stringify2(obj, { maxDepth = 1e3, numbersAsFloat = false } = {}) {
  if (extendedTypeOf(obj) !== "object") {
    throw new TypeError("stringify can only be called with an object");
  }
  return stringifyTable(obj, "", maxDepth, numbersAsFloat);
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileToml.js
var CSpellConfigFileToml = class _CSpellConfigFileToml extends ImplCSpellConfigFile {
  url;
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
  }
  serialize() {
    return stringify2(this.settings) + "\n";
  }
  removeAllComments() {
    return this;
  }
  setSchema(schema) {
    this.settings.$schema = schema;
    return this;
  }
  setComment(_field, _comment, _inline) {
    return this;
  }
  static parse(file) {
    try {
      const cspell = parse2(file.content);
      if (!isCSpellSettings2(cspell)) {
        throw new ParseError(file.url);
      }
      const cfg = new _CSpellConfigFileToml(file.url, cspell);
      return cfg;
    } catch (cause) {
      if (cause instanceof ParseError) {
        throw cause;
      }
      throw new ParseError(file.url, void 0, { cause });
    }
  }
  static from(url2, settings, _indent) {
    return new _CSpellConfigFileToml(url2, settings);
  }
};
function parseCSpellConfigFileToml(file) {
  return CSpellConfigFileToml.parse(file);
}
function isCSpellSettings2(cfg) {
  return !(!cfg || typeof cfg !== "object" || Array.isArray(cfg));
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileYaml.js
var import_node_assert9 = __toESM(require("node:assert"), 1);
var import_yaml = __toESM(require_dist(), 1);

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/UpdateConfig/CfgTree.js
var nodeValueSymbol = Symbol.for("cspell.config.nodeValue");
function isNodeValue(value) {
  if (!(typeof value === "object" && value !== null))
    return false;
  if (nodeValueSymbol in value)
    return true;
  return "value" in value && "comment" in value && "commentBefore" in value && Object.keys(value).length === 3;
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileYaml.js
var CSpellConfigFileYaml = class _CSpellConfigFileYaml extends MutableCSpellConfigFile {
  url;
  yamlDoc;
  indent;
  #settings = void 0;
  constructor(url2, yamlDoc, indent) {
    super(url2);
    this.url = url2;
    this.yamlDoc = yamlDoc;
    this.indent = indent;
    this.#settings = this.yamlDoc.toJS();
  }
  get settings() {
    return this.#settings ?? this.yamlDoc.toJS();
  }
  addWords(wordsToAdd) {
    const cfgWords = this.yamlDoc.get("words") || new import_yaml.YAMLSeq();
    (0, import_node_assert9.default)((0, import_yaml.isSeq)(cfgWords), "Expected words to be a YAML sequence");
    const knownWords = new Set(cfgWords.items.map((item) => getScalarValue(item)));
    wordsToAdd.forEach((w) => {
      if (knownWords.has(w))
        return;
      cfgWords.add(w);
      knownWords.add(w);
    });
    const sorted = sortWords(cfgWords.items);
    sorted.forEach((item, index) => cfgWords.set(index, item));
    cfgWords.items.length = sorted.length;
    this.#setValue("words", cfgWords);
    this.#markAsMutable();
    return this;
  }
  serialize() {
    return (0, import_yaml.stringify)(this.yamlDoc, { indent: this.indent });
  }
  setValue(key, value) {
    if (isNodeValue(value)) {
      let node = this.#getNode(key);
      if (!node) {
        node = this.yamlDoc.createNode(value.value);
        setYamlNodeComments(node, value);
        this.#setValue(key, node);
      } else {
        setYamlNodeValue(node, value);
      }
    } else {
      this.#setValue(key, value);
    }
    this.#markAsMutable();
    return this;
  }
  getValue(key) {
    const node = this.#getNode(key);
    return node?.toJS(this.yamlDoc);
  }
  #getNode(key) {
    return getYamlNode(this.yamlDoc, key);
  }
  getNode(key, defaultValue) {
    let yNode = this.#getNode(key);
    if (!yNode) {
      if (defaultValue === void 0) {
        return void 0;
      }
      yNode = this.yamlDoc.createNode(defaultValue);
      this.#setValue(key, yNode);
    }
    this.#markAsMutable();
    return toConfigNode(this.yamlDoc, yNode);
  }
  getFieldNode(key) {
    const contents = this.yamlDoc.contents;
    if (!(0, import_yaml.isMap)(contents)) {
      return void 0;
    }
    const found = findPair(contents, key);
    const pair = found && this.#fixPair(found);
    if (!pair) {
      return void 0;
    }
    return toConfigNode(this.yamlDoc, pair.key);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const removed = this.yamlDoc.delete(key);
    if (removed) {
      this.#markAsMutable();
    }
    return removed;
  }
  get comment() {
    return this.yamlDoc.comment ?? void 0;
  }
  set comment(comment) {
    this.yamlDoc.comment = comment ?? null;
  }
  setSchema(schemaRef) {
    removeSchemaComment(this.yamlDoc);
    let commentBefore = this.yamlDoc.commentBefore || "";
    commentBefore = commentBefore.replace(/^ yaml-language-server: \$schema=.*\n?/m, "");
    commentBefore = ` yaml-language-server: $schema=${schemaRef}` + (commentBefore ? "\n" + commentBefore : "");
    this.yamlDoc.commentBefore = commentBefore;
    const contents = this.#getContentsMap();
    const firstPair = contents.items[0];
    if (firstPair && (0, import_yaml.isPair)(firstPair)) {
      const key = firstPair.key;
      if ((0, import_yaml.isNode)(key)) {
        removeSchemaComment(key);
      }
    }
    if (this.getNode("$schema")) {
      this.setValue("$schema", schemaRef);
    }
    return this;
  }
  removeAllComments() {
    const doc = this.yamlDoc;
    doc.comment = null;
    doc.commentBefore = null;
    (0, import_yaml.visit)(this.yamlDoc, (_, node) => {
      if (!((0, import_yaml.isScalar)(node) || (0, import_yaml.isMap)(node) || (0, import_yaml.isSeq)(node)))
        return;
      node.comment = null;
      node.commentBefore = null;
    });
    return this;
  }
  setComment(key, comment, inline) {
    const node = this.getFieldNode(key);
    if (!node)
      return this;
    if (inline) {
      node.comment = comment;
    } else {
      node.commentBefore = comment;
    }
    return this;
  }
  /**
   * Marks the config file as mutable. Any access to settings will the settings to be regenerated
   * from the YAML document.
   */
  #markAsMutable() {
    this.#settings = void 0;
  }
  #setValue(key, value) {
    this.yamlDoc.set(key, value);
    const contents = this.#getContentsMap();
    const pair = findPair(contents, key);
    (0, import_node_assert9.default)(pair, `Expected pair for key: ${String(key)}`);
    this.#fixPair(pair);
  }
  #toNode(value) {
    return (0, import_yaml.isNode)(value) ? value : this.yamlDoc.createNode(value);
  }
  #fixPair(pair) {
    (0, import_node_assert9.default)((0, import_yaml.isPair)(pair), "Expected pair to be a Pair");
    pair.key = this.#toNode(pair.key);
    pair.value = this.#toNode(pair.value);
    return pair;
  }
  #getContentsMap() {
    const contents = this.yamlDoc.contents;
    (0, import_node_assert9.default)((0, import_yaml.isMap)(contents), "Expected contents to be a YAMLMap");
    return contents;
  }
  static parse(file) {
    return parseCSpellConfigFileYaml(file);
  }
  static from(url2, settings, indent = 2) {
    const yamlDoc = new import_yaml.Document(settings);
    return new _CSpellConfigFileYaml(url2, yamlDoc, indent);
  }
};
function parseCSpellConfigFileYaml(file) {
  const { url: url2, content } = file;
  try {
    const doc = (0, import_yaml.parseDocument)(content);
    if (doc.contents === null || (0, import_yaml.isScalar)(doc.contents) && !doc.contents.value) {
      doc.contents = new import_yaml.YAMLMap();
    }
    if (!(0, import_yaml.isMap)(doc.contents)) {
      throw new ParseError(url2, `Invalid YAML content ${url2}`);
    }
    const indent = detectIndentAsNum(content);
    return new CSpellConfigFileYaml(url2, doc, indent);
  } catch (e) {
    if (e instanceof ParseError) {
      throw e;
    }
    throw new ParseError(url2, void 0, { cause: e });
  }
}
function getScalarValue(node) {
  if ((0, import_yaml.isScalar)(node)) {
    return node.value;
  }
  return node;
}
function toScalar(node) {
  if ((0, import_yaml.isScalar)(node)) {
    return node;
  }
  return new import_yaml.Scalar(node);
}
function groupWords(words) {
  const groups = [];
  if (words.length === 0) {
    return groups;
  }
  let currentGroup = [];
  groups.push(currentGroup);
  for (const word of words) {
    if (isSectionHeader(word)) {
      currentGroup = [];
      groups.push(currentGroup);
    }
    currentGroup.push(cloneWord(word));
  }
  return groups;
}
function isSectionHeader(word) {
  if (!(0, import_yaml.isScalar)(word) || !word.commentBefore && !word.spaceBefore)
    return false;
  if (word.spaceBefore)
    return true;
  if (!word.commentBefore)
    return false;
  return word.commentBefore.includes("\n\n");
}
function adjustSectionHeader(word, prev, isFirstSection) {
  if (!(0, import_yaml.isScalar)(prev))
    return;
  let captureComment = isFirstSection;
  if (prev.spaceBefore) {
    word.spaceBefore = true;
    captureComment = true;
    delete prev.spaceBefore;
  }
  if (!prev.commentBefore)
    return;
  const originalComment = prev.commentBefore;
  const lines = originalComment.split(/^\n/gm);
  const lastLine = lines[lines.length - 1];
  captureComment = captureComment && originalComment.trim() === lastLine.trim() || originalComment.endsWith("\n");
  let header = originalComment;
  if (captureComment) {
    delete prev.commentBefore;
  } else {
    prev.commentBefore = lastLine;
    lines.pop();
    header = lines.join("\n");
  }
  if (word.commentBefore) {
    header += header.endsWith("\n\n") ? "" : "\n";
    header += header.endsWith("\n\n") ? "" : "\n";
    header += word.commentBefore;
  }
  word.commentBefore = header;
}
function sortWords(words) {
  const compare3 = new Intl.Collator().compare;
  const groups = groupWords(words);
  let firstGroup = true;
  for (const group of groups) {
    const head = group[0];
    group.sort((a, b) => {
      return compare3(getScalarValue(a), getScalarValue(b));
    });
    if (group[0] !== head && (0, import_yaml.isScalar)(head)) {
      const first3 = group[0] = toScalar(group[0]);
      adjustSectionHeader(first3, head, firstGroup);
    }
    firstGroup = false;
  }
  const result = groups.flat();
  return result.map((w) => toScalar(w));
}
function cloneWord(word) {
  if ((0, import_yaml.isScalar)(word)) {
    return word.clone();
  }
  return word;
}
function getYamlNode(yamlDoc, key) {
  return Array.isArray(key) ? yamlDoc.getIn(key, true) : yamlDoc.get(key, true);
}
function toConfigNode(doc, yNode) {
  if (isYamlSeq(yNode)) {
    return toConfigArrayNode(doc, yNode);
  }
  if ((0, import_yaml.isMap)(yNode)) {
    return toConfigObjectNode(doc, yNode);
  }
  if ((0, import_yaml.isScalar)(yNode)) {
    return toConfigScalarNode(doc, yNode);
  }
  throw new Error(`Unsupported YAML node type: ${yamlNodeType(yNode)}`);
}
var ConfigNodeBase = class {
  type;
  constructor(type) {
    this.type = type;
  }
};
var ConfigArrayNode = class extends ConfigNodeBase {
  #doc;
  #yNode;
  constructor(doc, yNode) {
    super("array");
    this.#doc = doc;
    this.#yNode = yNode;
  }
  get value() {
    return this.#yNode.toJS(this.#doc);
  }
  get comment() {
    return this.#yNode.comment ?? void 0;
  }
  set comment(comment) {
    this.#yNode.comment = comment ?? null;
  }
  get commentBefore() {
    return this.#yNode.commentBefore ?? void 0;
  }
  set commentBefore(comment) {
    this.#yNode.commentBefore = comment ?? null;
  }
  getNode(key) {
    const node = getYamlNode(this.#yNode, key);
    if (!node)
      return void 0;
    return toConfigNode(this.#doc, node);
  }
  getValue(key) {
    const node = getYamlNode(this.#yNode, key);
    if (!node)
      return void 0;
    return node.toJS(this.#doc);
  }
  setValue(key, value) {
    if (!isNodeValue(value)) {
      this.#yNode.set(key, value);
      return;
    }
    this.#yNode.set(key, value.value);
    const yNodeValue = getYamlNode(this.#yNode, key);
    (0, import_node_assert9.default)(yNodeValue);
    yNodeValue.comment = value.comment ?? null;
    yNodeValue.commentBefore = value.commentBefore ?? null;
  }
  delete(key) {
    return this.#yNode.delete(key);
  }
  push(value) {
    if (!isNodeValue(value)) {
      this.#yNode.add(value);
      return this.#yNode.items.length;
    }
    this.#yNode.add(value.value);
    setYamlNodeComments(getYamlNode(this.#yNode, this.#yNode.items.length - 1), value);
    return this.#yNode.items.length;
  }
  get length() {
    return this.#yNode.items.length;
  }
};
function toConfigArrayNode(doc, yNode) {
  return new ConfigArrayNode(doc, yNode);
}
var ConfigObjectNode = class extends ConfigNodeBase {
  #doc;
  #yNode;
  constructor(doc, yNode) {
    super("object");
    this.#doc = doc;
    this.#yNode = yNode;
  }
  get value() {
    return this.#yNode.toJS(this.#doc);
  }
  get comment() {
    return this.#yNode.comment ?? void 0;
  }
  set comment(comment) {
    this.#yNode.comment = comment ?? null;
  }
  get commentBefore() {
    return this.#yNode.commentBefore ?? void 0;
  }
  set commentBefore(comment) {
    this.#yNode.commentBefore = comment ?? null;
  }
  getValue(key) {
    const node = getYamlNode(this.#yNode, key);
    if (!node)
      return void 0;
    return node.toJS(this.#doc);
  }
  getNode(key) {
    const node = getYamlNode(this.#yNode, key);
    if (!node)
      return void 0;
    return toConfigNode(this.#doc, node);
  }
  setValue(key, value) {
    if (!isNodeValue(value)) {
      this.#yNode.set(key, value);
      return;
    }
    this.#yNode.set(key, value.value);
    const yNodeValue = getYamlNode(this.#yNode, key);
    (0, import_node_assert9.default)(yNodeValue);
    yNodeValue.comment = value.comment ?? null;
    yNodeValue.commentBefore = value.commentBefore ?? null;
  }
  delete(key) {
    return this.#yNode.delete(key);
  }
};
function toConfigObjectNode(doc, yNode) {
  return new ConfigObjectNode(doc, yNode);
}
var ConfigScalarNode = class extends ConfigNodeBase {
  $doc;
  $yNode;
  type = "scalar";
  constructor(doc, yNode) {
    super("scalar");
    this.$doc = doc;
    this.$yNode = yNode;
    (0, import_node_assert9.default)((0, import_yaml.isScalar)(yNode), "Expected yNode to be a Scalar");
  }
  get value() {
    return this.$yNode.toJS(this.$doc);
  }
  set value(value) {
    this.$yNode.value = value;
  }
  get comment() {
    return this.$yNode.comment ?? void 0;
  }
  set comment(comment) {
    this.$yNode.comment = comment ?? null;
  }
  get commentBefore() {
    return this.$yNode.commentBefore ?? void 0;
  }
  set commentBefore(comment) {
    this.$yNode.commentBefore = comment ?? null;
  }
  toJSON() {
    return {
      type: this.type,
      value: this.value,
      comment: this.comment,
      commentBefore: this.commentBefore
    };
  }
};
function toConfigScalarNode(doc, yNode) {
  return new ConfigScalarNode(doc, yNode);
}
function isYamlSeq(node) {
  return (0, import_yaml.isSeq)(node);
}
function yamlNodeType(node) {
  if ((0, import_yaml.isScalar)(node))
    return "scalar";
  if ((0, import_yaml.isSeq)(node))
    return "seq";
  if ((0, import_yaml.isMap)(node))
    return "map";
  if ((0, import_yaml.isAlias)(node))
    return "alias";
  return "unknown";
}
function setYamlNodeComments(yamlNode, comments) {
  if (!yamlNode)
    return;
  if ("comment" in comments) {
    yamlNode.comment = comments.comment ?? null;
  }
  if ("commentBefore" in comments) {
    yamlNode.commentBefore = comments.commentBefore ?? null;
  }
}
function setYamlNodeValue(yamlNode, nodeValue) {
  setYamlNodeComments(yamlNode, nodeValue);
  if ((0, import_yaml.isScalar)(yamlNode)) {
    yamlNode.value = nodeValue.value;
    return;
  }
  const value = nodeValue.value;
  if ((0, import_yaml.isSeq)(yamlNode)) {
    (0, import_node_assert9.default)(Array.isArray(value), "Expected value to be an array for YAMLSeq");
    yamlNode.items = [];
    for (let i = 0; i < value.length; ++i) {
      yamlNode.set(i, value[i]);
    }
    return;
  }
  if ((0, import_yaml.isMap)(yamlNode)) {
    (0, import_node_assert9.default)(typeof value === "object" && value !== null, "Expected value to be an object for YAMLMap");
    yamlNode.items = [];
    for (const [key, val] of Object.entries(value)) {
      yamlNode.set(key, val);
    }
    return;
  }
  throw new Error(`Unsupported YAML node type: ${yamlNodeType(yamlNode)}`);
}
function findPair(yNode, yKey) {
  const key = (0, import_yaml.isScalar)(yKey) ? yKey.value : yKey;
  if (!(0, import_yaml.isMap)(yNode))
    return void 0;
  const items = yNode.items;
  for (const item of items) {
    if (!(0, import_yaml.isPair)(item))
      continue;
    if (item.key === key) {
      return item;
    }
    if ((0, import_yaml.isScalar)(item.key) && item.key.value === key) {
      return item;
    }
  }
  return void 0;
}
function removeSchemaComment(node) {
  if (!node.commentBefore)
    return;
  node.commentBefore = node.commentBefore?.replace(/^ yaml-language-server: \$schema=.*\n?/gm, "") ?? null;
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/defaultNext.js
var defaultNextDeserializer = (content) => {
  throw new Error(`Unable to parse config file: "${content.url}"`);
};
var defaultNextSerializer = (file) => {
  throw new Error(`Unable to serialize config file: "${file.url}"`);
};

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/middlewareHelper.js
function getDeserializer(middleware) {
  let next = defaultNextDeserializer;
  for (const des of middleware) {
    next = curryDeserialize(des, next);
  }
  return next;
}
function getSerializer(middleware) {
  let next = defaultNextSerializer;
  for (const des of middleware) {
    next = currySerialize(des, next);
  }
  return next;
}
function curryDeserialize(middle, next) {
  return (content) => middle.deserialize(content, next);
}
function currySerialize(middle, next) {
  return (cfg) => middle.serialize(cfg, next);
}
function curryLoader(loader2, next) {
  return (req) => loader2.load(req, next);
}
async function defaultLoader(req) {
  const { io, deserialize } = req.context;
  const url2 = req.url;
  const file = await io.readFile(url2);
  return deserialize(file);
}
function getLoader(loaders2) {
  let next = defaultLoader;
  for (const loader2 of loaders2) {
    next = curryLoader(loader2, next);
  }
  return next;
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/util/toURL.js
function toURL2(url2) {
  return typeof url2 === "string" ? new URL(url2) : url2;
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/CSpellConfigFileReaderWriter.js
var CSpellConfigFileReaderWriterImpl = class {
  io;
  middleware;
  loaders;
  /**
   * @param io - an optional injectable IO interface. The default is to use the file system.
   * @param deserializers - Additional deserializers to use when reading a config file. The order of the deserializers is
   *    important. The last one in the list will be the first one to be called.
   */
  constructor(io, middleware, loaders2) {
    this.io = io;
    this.middleware = middleware;
    this.loaders = loaders2;
  }
  _untrustedExtensions = /* @__PURE__ */ new Set();
  _trustedUrls = [];
  /**
   * Untrusted extensions are extensions that are not trusted to be loaded from a file system.
   * Extension are case insensitive and should include the leading dot.
   */
  get untrustedExtensions() {
    return [...this._untrustedExtensions];
  }
  /**
   * Urls starting with these urls are trusted to be loaded from a file system.
   */
  get trustedUrls() {
    return [...this._trustedUrls].map((url2) => new URL(url2));
  }
  readConfig(uri) {
    const url2 = new URL(uri);
    if (!isTrusted(url2, this._trustedUrls, this._untrustedExtensions)) {
      return Promise.reject(new UntrustedUrlError(url2));
    }
    const loader2 = getLoader(this.loaders);
    return loader2({ url: toURL2(uri), context: { deserialize: this.getDeserializer(), io: this.io } });
  }
  toCSpellConfigFile(configFile) {
    return configFile instanceof CSpellConfigFile ? configFile : new CSpellConfigFileInMemory(configFile.url, configFile.settings);
  }
  getDeserializer() {
    return getDeserializer(this.middleware);
  }
  parse(textFile) {
    const deserializer5 = this.getDeserializer();
    return deserializer5(textFile);
  }
  serialize(configFile) {
    const serializer5 = getSerializer(this.middleware);
    return serializer5(configFile);
  }
  async writeConfig(configFile) {
    if (configFile.readonly)
      throw new Error(`Config file is readonly: ${configFile.url.href}`);
    const content = this.serialize(configFile);
    const ref = await this.io.writeFile({ url: configFile.url, content });
    return { url: ref.url };
  }
  setUntrustedExtensions(ext) {
    this._untrustedExtensions.clear();
    ext.forEach((e) => this._untrustedExtensions.add(e.toLowerCase()));
    return this;
  }
  setTrustedUrls(urls) {
    this._trustedUrls = [...new Set(urls.map((url2) => new URL(url2).href))].sort();
    return this;
  }
  clearCachedFiles() {
    for (const loader2 of this.loaders) {
      loader2.reset?.();
    }
  }
};
function isTrusted(url2, trustedUrls, untrustedExtensions) {
  const path17 = url2.pathname;
  const ext = (0, import_posix.extname)(path17).toLowerCase();
  if (!untrustedExtensions.has(ext))
    return true;
  const href = url2.href;
  return trustedUrls.some((trustedUrl) => href.startsWith(trustedUrl));
}
var UntrustedUrlError = class extends Error {
  constructor(url2) {
    super(`Untrusted URL: "${url2.href}"`);
  }
};

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/defaultIO.js
var import_node_fs6 = require("node:fs");
var defaultIO = {
  readFile: readFile2,
  writeFile: writeFile2
};
async function readFile2(url2) {
  const content = await import_node_fs6.promises.readFile(url2, "utf8");
  return { url: url2, content };
}
async function writeFile2(file) {
  await import_node_fs6.promises.writeFile(file.url, file.content);
  return { url: file.url };
}

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/loaders/loaderJavaScript.js
var import_posix2 = require("node:path/posix");
var _debug2 = false;
var _log = _debug2 ? console.warn.bind(console) : () => void 0;
async function importJavaScript(url2, hashSuffix) {
  try {
    const _url = new URL(url2.href);
    _url.hash = `${_url.hash};loaderSuffix=${hashSuffix}`;
    _log("importJavaScript: %o", { url: _url.href });
    const result = await import(_url.href);
    const settingsOrFunction = await (result.default ?? result);
    const settings = typeof settingsOrFunction === "function" ? await settingsOrFunction() : settingsOrFunction;
    return new CSpellConfigFileJavaScript(url2, settings);
  } catch (e) {
    _log("importJavaScript Error: %o", { url: url2.href, error: e, hashSuffix });
    throw e;
  } finally {
    _log("importJavaScript Done: %o", { url: url2.href, hashSuffix });
  }
}
var LoaderJavaScript = class {
  hashSuffix = 1;
  async _load(req, next) {
    const { url: url2 } = req;
    const ext = (0, import_posix2.extname)(url2.pathname).toLowerCase();
    switch (ext) {
      case ".js":
      case ".cjs":
      case ".mjs": {
        return importJavaScript(url2, this.hashSuffix);
      }
    }
    return next(req);
  }
  load = this._load.bind(this);
  reset() {
    this.hashSuffix += 1;
  }
};
var loaderJavaScript = new LoaderJavaScript();

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/loaders/index.js
var defaultLoaders = [loaderJavaScript];

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/serializers/cspellJson.js
function deserializer(params, next) {
  if (!isJsonFile(params.url.pathname))
    return next(params);
  return parseCSpellConfigFileJson(params);
}
function isJsonFile(pathname) {
  pathname = pathname.toLowerCase();
  return pathname.endsWith(".json") || pathname.endsWith(".jsonc");
}
function serializer(settings, next) {
  if (!(settings instanceof CSpellConfigFileJson))
    return next(settings);
  return settings.serialize();
}
var serializerCSpellJson = { deserialize: deserializer, serialize: serializer };

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/serializers/cspellToml.js
function deserializer2(params, next) {
  if (!isTomlFile(params.url.pathname))
    return next(params);
  return parseCSpellConfigFileToml(params);
}
function isTomlFile(pathname) {
  pathname = pathname.toLowerCase();
  return pathname.endsWith(".toml");
}
function serializer2(settings, next) {
  if (!(settings instanceof CSpellConfigFileToml))
    return next(settings);
  return settings.serialize();
}
var serializerCSpellToml = { deserialize: deserializer2, serialize: serializer2 };

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/serializers/cspellYaml.js
function deserializer3(params, next) {
  if (!isYamlFile(params.url.pathname))
    return next(params);
  return parseCSpellConfigFileYaml(params);
}
function isYamlFile(pathname) {
  pathname = pathname.toLowerCase();
  return pathname.endsWith(".yml") || pathname.endsWith(".yaml");
}
function serializer3(settings, next) {
  if (!(settings instanceof CSpellConfigFileYaml))
    return next(settings);
  return settings.serialize();
}
var serializerCSpellYaml = { deserialize: deserializer3, serialize: serializer3 };

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/serializers/packageJson.js
var isSupportedFormat = /\bpackage\.json$/i;
function deserializer4(params, next) {
  if (!isSupportedFormat.test(params.url.pathname))
    return next(params);
  return parseCSpellConfigFilePackageJson(params);
}
function serializer4(settings, next) {
  if (!(settings instanceof CSpellConfigFilePackageJson))
    return next(settings);
  return settings.serialize();
}
var serializerPackageJson = { deserialize: deserializer4, serialize: serializer4 };

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/serializers/index.js
var defaultDeserializers = [
  serializerCSpellJson,
  serializerCSpellYaml,
  serializerPackageJson,
  serializerCSpellToml
];

// ../node_modules/.pnpm/cspell-config-lib@9.1.5/node_modules/cspell-config-lib/dist/createReaderWriter.js
function createReaderWriter(deserializers = [], loaders2 = [], io = defaultIO) {
  return new CSpellConfigFileReaderWriterImpl(io, [...defaultDeserializers, ...deserializers], [...defaultLoaders, ...loaders2]);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/logger.js
var _logger = console;
function logError(...args) {
  _logger.error(...args);
}
function logWarning(...args) {
  _logger.warn(...args);
}
function setLogger(logger) {
  const oldLogger = _logger;
  _logger = logger;
  return oldLogger;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/cfgStore.js
var import_promises2 = __toESM(require("node:fs/promises"), 1);
var import_node_path7 = __toESM(require("node:path"), 1);

// ../node_modules/.pnpm/env-paths@3.0.0/node_modules/env-paths/index.js
var import_node_path6 = __toESM(require("node:path"), 1);
var import_node_os4 = __toESM(require("node:os"), 1);
var import_node_process4 = __toESM(require("node:process"), 1);
var homedir2 = import_node_os4.default.homedir();
var tmpdir = import_node_os4.default.tmpdir();
var { env: env2 } = import_node_process4.default;
var macos = (name2) => {
  const library = import_node_path6.default.join(homedir2, "Library");
  return {
    data: import_node_path6.default.join(library, "Application Support", name2),
    config: import_node_path6.default.join(library, "Preferences", name2),
    cache: import_node_path6.default.join(library, "Caches", name2),
    log: import_node_path6.default.join(library, "Logs", name2),
    temp: import_node_path6.default.join(tmpdir, name2)
  };
};
var windows = (name2) => {
  const appData = env2.APPDATA || import_node_path6.default.join(homedir2, "AppData", "Roaming");
  const localAppData = env2.LOCALAPPDATA || import_node_path6.default.join(homedir2, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: import_node_path6.default.join(localAppData, name2, "Data"),
    config: import_node_path6.default.join(appData, name2, "Config"),
    cache: import_node_path6.default.join(localAppData, name2, "Cache"),
    log: import_node_path6.default.join(localAppData, name2, "Log"),
    temp: import_node_path6.default.join(tmpdir, name2)
  };
};
var linux = (name2) => {
  const username = import_node_path6.default.basename(homedir2);
  return {
    data: import_node_path6.default.join(env2.XDG_DATA_HOME || import_node_path6.default.join(homedir2, ".local", "share"), name2),
    config: import_node_path6.default.join(env2.XDG_CONFIG_HOME || import_node_path6.default.join(homedir2, ".config"), name2),
    cache: import_node_path6.default.join(env2.XDG_CACHE_HOME || import_node_path6.default.join(homedir2, ".cache"), name2),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: import_node_path6.default.join(env2.XDG_STATE_HOME || import_node_path6.default.join(homedir2, ".local", "state"), name2),
    temp: import_node_path6.default.join(tmpdir, username, name2)
  };
};
function envPaths(name2, { suffix = "nodejs" } = {}) {
  if (typeof name2 !== "string") {
    throw new TypeError(`Expected a string, got ${typeof name2}`);
  }
  if (suffix) {
    name2 += `-${suffix}`;
  }
  if (import_node_process4.default.platform === "darwin") {
    return macos(name2);
  }
  if (import_node_process4.default.platform === "win32") {
    return windows(name2);
  }
  return linux(name2);
}

// ../node_modules/.pnpm/xdg-basedir@5.1.0/node_modules/xdg-basedir/index.js
var import_os = __toESM(require("os"), 1);
var import_path = __toESM(require("path"), 1);
var homeDirectory = import_os.default.homedir();
var { env: env3 } = process;
var xdgData = env3.XDG_DATA_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".local", "share") : void 0);
var xdgConfig = env3.XDG_CONFIG_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".config") : void 0);
var xdgState = env3.XDG_STATE_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".local", "state") : void 0);
var xdgCache = env3.XDG_CACHE_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".cache") : void 0);
var xdgRuntime = env3.XDG_RUNTIME_DIR || void 0;
var xdgDataDirectories = (env3.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":");
if (xdgData) {
  xdgDataDirectories.unshift(xdgData);
}
var xdgConfigDirectories = (env3.XDG_CONFIG_DIRS || "/etc/xdg").split(":");
if (xdgConfig) {
  xdgConfigDirectories.unshift(xdgConfig);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/cfgStore.js
var packageName = "cspell";
var legacyLocationDir = xdgConfig ? import_node_path7.default.join(xdgConfig, "configstore") : void 0;
var cspellGlobalLocationDir = envPaths(packageName, { suffix: "" }).config;
var defaultConfigFileName = "cspell.json";
var searchOrder = [cspellGlobalLocationDir, legacyLocationDir].filter(isDefined3);
var GlobalConfigStore = class {
  #foundLocation;
  #baseFilename;
  constructor(filename = defaultConfigFileName) {
    this.#baseFilename = filename;
  }
  async #readConfigFile(location) {
    try {
      const json = await import_promises2.default.readFile(location, "utf8");
      return { filename: location, config: JSON.parse(json) };
    } catch {
      return void 0;
    }
  }
  async readConfigFile() {
    if (this.#foundLocation) {
      const found = await this.#readConfigFile(this.#foundLocation);
      if (found)
        return found;
    }
    const firstFile = import_node_path7.default.resolve(cspellGlobalLocationDir, this.#baseFilename);
    const possibleLocations = /* @__PURE__ */ new Set([
      firstFile,
      ...searchOrder.map((p) => import_node_path7.default.resolve(p, defaultConfigFileName))
    ]);
    for (const filename of possibleLocations) {
      const found = await this.#readConfigFile(filename);
      if (found) {
        this.#foundLocation = found.filename;
        return found;
      }
    }
    return void 0;
  }
  async writeConfigFile(cfg) {
    this.#foundLocation ??= import_node_path7.default.join(cspellGlobalLocationDir, this.#baseFilename);
    await import_promises2.default.mkdir(import_node_path7.default.dirname(this.#foundLocation), { recursive: true });
    await import_promises2.default.writeFile(this.#foundLocation, JSON.stringify(cfg, void 0, 2) + "\n");
    return this.#foundLocation;
  }
  get location() {
    return this.#foundLocation;
  }
  static create() {
    return new this();
  }
  static defaultLocation = import_node_path7.default.join(cspellGlobalLocationDir, defaultConfigFileName);
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/normalizeRawSettings.js
var import_node_os5 = require("node:os");
var import_node_url9 = require("node:url");

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/toGlobDef.js
function toGlobDef(g, root, source) {
  if (g === void 0)
    return void 0;
  if (Array.isArray(g)) {
    return g.map((g2) => toGlobDef(g2, root, source));
  }
  if (typeof g === "string") {
    const glob2 = { glob: g };
    if (root !== void 0) {
      glob2.root = root;
    }
    return toGlobDef(glob2, root, source);
  }
  if (source) {
    return { ...g, source };
  }
  return g;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/normalizeRawSettings.js
function normalizeRawConfig(config) {
  if (typeof config.version === "number") {
    config.version = config.version.toString();
  }
  if (config.import) {
    config.import = normalizeImport(config.import);
  }
}
function normalizeDictionaryDefs(settings, settingsFileUrl) {
  const dictionaryDefinitions = mapDictDefsToInternal(settings.dictionaryDefinitions, settingsFileUrl);
  const languageSettings = settings.languageSettings?.map((langSetting) => clean3({
    ...langSetting,
    dictionaryDefinitions: mapDictDefsToInternal(langSetting.dictionaryDefinitions, settingsFileUrl)
  }));
  return clean3({
    dictionaryDefinitions,
    languageSettings
  });
}
function normalizeOverrides(settings, pathToSettingsFile) {
  const { globRoot = toFilePathOrHref(new URL(".", pathToSettingsFile)) } = settings;
  const overrides = settings.overrides?.map((override) => {
    const filename = toGlobDef(override.filename, globRoot, toFilePathOrHref(pathToSettingsFile));
    const { dictionaryDefinitions, languageSettings } = normalizeDictionaryDefs(override, pathToSettingsFile);
    return clean3({
      ...override,
      filename,
      dictionaryDefinitions,
      languageSettings: normalizeLanguageSettings(languageSettings)
    });
  });
  return overrides ? { overrides } : {};
}
async function normalizeReporters(settings, pathToSettingsFile) {
  if (settings.reporters === void 0)
    return {};
  async function resolve5(s) {
    if (s === "default")
      return s;
    const r = await resolveFile(s, pathToSettingsFile);
    if (!r.found) {
      throw new Error(`Not found: "${s}"`);
    }
    return r.filename;
  }
  async function resolveReporter(s) {
    if (typeof s === "string") {
      return resolve5(s);
    }
    if (!Array.isArray(s) || typeof s[0] !== "string")
      throw new Error("Invalid Reporter");
    const [r, ...rest] = s;
    return [await resolve5(r), ...rest];
  }
  return {
    reporters: await Promise.all(settings.reporters.map(resolveReporter))
  };
}
function normalizeLanguageSettings(languageSettings) {
  if (!languageSettings)
    return void 0;
  function fixLocale(s) {
    const { local: locale, ...rest } = s;
    return clean3({ locale, ...rest });
  }
  return languageSettings.map(fixLocale);
}
function normalizeGitignoreRoot(settings, pathToSettingsFile) {
  const { gitignoreRoot } = settings;
  if (!gitignoreRoot)
    return {};
  const roots = Array.isArray(gitignoreRoot) ? gitignoreRoot : [gitignoreRoot];
  return {
    gitignoreRoot: roots.map((p) => resolveFilePathToPath(p, pathToSettingsFile))
  };
}
function normalizeSettingsGlobs(settings, pathToSettingsFile) {
  const { globRoot } = settings;
  const normalized = {};
  if (settings.ignorePaths) {
    normalized.ignorePaths = toGlobDef(settings.ignorePaths, globRoot, toFilePathOrHref(pathToSettingsFile));
  }
  if (settings.files) {
    normalized.files = toGlobDef(settings.files, globRoot, toFilePathOrHref(pathToSettingsFile));
  }
  return normalized;
}
function normalizeCacheSettings(settings, pathToSettingsFile) {
  const { cache: cache5 } = settings;
  if (cache5 === void 0)
    return {};
  const { cacheLocation } = cache5;
  if (cacheLocation === void 0)
    return { cache: cache5 };
  return { cache: { ...cache5, cacheLocation: toFilePathOrHref(resolveFilePath(cacheLocation, pathToSettingsFile)) } };
}
function resolveFilePath(filename, pathToSettingsFile) {
  const cwd = process.cwd();
  return toFileURL(filename.replace("${cwd}", cwd).replace(/^~/, (0, import_node_os5.homedir)()), pathToSettingsFile);
}
function resolveFilePathToPath(filename, pathToSettingsFile) {
  const url2 = resolveFilePath(filename, pathToSettingsFile);
  return url2.protocol === "file:" ? (0, import_node_url9.fileURLToPath)(url2) : url2.toString();
}
function normalizeImport(imports) {
  if (typeof imports === "string") {
    return [imports];
  }
  if (Array.isArray(imports)) {
    return imports;
  }
  return [];
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configToRawSettings.js
function configToRawSettings(cfgFile) {
  if (!cfgFile)
    return {};
  const url2 = cfgFile.url;
  const filename = toFilePathOrHref(url2);
  const fileRef = {
    filename,
    error: void 0
  };
  const source = {
    name: cfgFile.settings.name || filename,
    filename: cfgFile.virtual ? void 0 : filename
  };
  const rawSettings = { ...cfgFile.settings };
  rawSettings.import = normalizeImport(rawSettings.import);
  normalizeRawConfig(rawSettings);
  rawSettings.source = source;
  if (!cfgFile.virtual) {
    rawSettings.__importRef = fileRef;
  }
  const id = rawSettings.id || urlToSimpleId(url2);
  const name2 = rawSettings.name || id;
  rawSettings.id = id;
  rawSettings.name = cfgFile.settings.name || name2;
  return rawSettings;
}
function urlToSimpleId(url2) {
  return url2.pathname.split("/").slice(-2).join("/");
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/GlobalSettings.js
var globalConfig = new GlobalConfigStore();
async function getGlobalConfig() {
  const name2 = "CSpell Configstore";
  const configPath = getGlobalConfigPath();
  let urlGlobal = configPath ? toFileURL(configPath) : new URL("global-config.json", getSourceDirectoryUrl());
  const source = {
    name: name2,
    filename: toFilePathOrHref(urlGlobal)
  };
  const globalConf = { source };
  let hasGlobalConfig = false;
  const found = await globalConfig.readConfigFile();
  if (found && found.config && found.filename) {
    const cfg = found.config;
    urlGlobal = toFileURL(found.filename);
    if (cfg && Object.keys(cfg).length) {
      Object.assign(globalConf, cfg);
      globalConf.source = {
        name: name2,
        filename: found.filename
      };
      hasGlobalConfig = Object.keys(cfg).length > 0;
    }
  }
  const settings = { ...globalConf, name: name2, source };
  const ConfigFile = hasGlobalConfig ? CSpellConfigFileJson : CSpellConfigFileInMemory;
  return new ConfigFile(urlGlobal, settings);
}
function getGlobalConfigPath() {
  try {
    return globalConfig.location || GlobalConfigStore.defaultLocation;
  } catch {
    return void 0;
  }
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/ImportError.js
var ImportError = class extends Error {
  cause;
  constructor(msg, cause) {
    super(msg);
    this.cause = isError(cause) ? cause : void 0;
  }
};
var UnsupportedPnpFile = class extends Error {
  constructor(msg) {
    super(msg);
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/pnpLoader.js
var import_node_url11 = require("node:url");
var import_clear_module = __toESM(require_clear_module(), 1);
var import_import_fresh = __toESM(require_import_fresh(), 1);

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/findUp.js
var import_promises3 = require("node:fs/promises");
var import_node_path8 = __toESM(require("node:path"), 1);
var import_node_url10 = require("node:url");
async function findUp(name2, options = {}) {
  const { cwd = process.cwd(), type: entryType = "file", stopAt } = options;
  let dir = import_node_path8.default.resolve(toDirPath(cwd));
  const root = import_node_path8.default.parse(dir).root;
  const predicate = makePredicate2(name2, entryType);
  const stopAtDir = import_node_path8.default.resolve(toDirPath(stopAt || root));
  while (dir !== root && dir !== stopAtDir) {
    const found = await predicate(dir);
    if (found !== void 0)
      return found;
    dir = import_node_path8.default.dirname(dir);
  }
  return void 0;
}
function makePredicate2(name2, entryType) {
  if (typeof name2 === "function")
    return name2;
  const checkStat = entryType === "file" ? "isFile" : "isDirectory";
  function checkName(dir, name3) {
    const f = import_node_path8.default.join(dir, name3);
    return (0, import_promises3.stat)(f).then((stats2) => stats2[checkStat]() && f || void 0).catch(() => void 0);
  }
  if (!Array.isArray(name2))
    return (dir) => checkName(dir, name2);
  return async (dir) => {
    const pending = name2.map((n) => checkName(dir, n));
    for (const p of pending) {
      const found = await p;
      if (found)
        return found;
    }
    return void 0;
  };
}
function toDirPath(urlOrPath) {
  return urlOrPath instanceof URL ? (0, import_node_url10.fileURLToPath)(new URL(".", urlOrPath)) : urlOrPath;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/pnpLoader.js
var defaultPnpFiles = [".pnp.cjs", ".pnp.js"];
var supportedSchemas = /* @__PURE__ */ new Set(["file:"]);
var cachedRequests = /* @__PURE__ */ new Map();
var lock = void 0;
var cachedPnpImportsSync = /* @__PURE__ */ new Map();
var cachedRequestsSync = /* @__PURE__ */ new Map();
var PnpLoader = class {
  pnpFiles;
  cacheKeySuffix;
  constructor(pnpFiles = defaultPnpFiles) {
    this.pnpFiles = pnpFiles;
    this.cacheKeySuffix = ":" + pnpFiles.join(",");
  }
  /**
   * Request that the nearest .pnp file gets loaded
   * @param urlDirectory starting directory
   * @returns promise - rejects on error - success if loaded or not found.
   */
  async load(urlDirectory) {
    if (!isSupported(urlDirectory))
      return void 0;
    await lock;
    const cacheKey = this.calcKey(urlDirectory);
    const cached = cachedRequests.get(cacheKey);
    if (cached)
      return cached;
    const r = findPnpAndLoad(urlDirectory, this.pnpFiles);
    cachedRequests.set(cacheKey, r);
    const result = await r;
    cachedRequestsSync.set(cacheKey, result);
    return result;
  }
  async peek(urlDirectory) {
    if (!isSupported(urlDirectory))
      return void 0;
    await lock;
    const cacheKey = this.calcKey(urlDirectory);
    return cachedRequests.get(cacheKey) ?? Promise.resolve(void 0);
  }
  /**
   * Clears the cached so .pnp files will get reloaded on request.
   */
  clearCache() {
    return clearPnPGlobalCache();
  }
  calcKey(urlDirectory) {
    return urlDirectory.toString() + this.cacheKeySuffix;
  }
};
function pnpLoader(pnpFiles) {
  return new PnpLoader(pnpFiles);
}
async function findPnpAndLoad(urlDirectory, pnpFiles) {
  const found = await findUp(pnpFiles, { cwd: (0, import_node_url11.fileURLToPath)(urlDirectory) });
  return loadPnpIfNeeded(found);
}
function loadPnpIfNeeded(found) {
  if (!found)
    return void 0;
  const c = cachedPnpImportsSync.get(found);
  if (c || cachedPnpImportsSync.has(found))
    return c;
  const r = loadPnp(found);
  cachedPnpImportsSync.set(found, r);
  return r;
}
function loadPnp(pnpFile) {
  const pnp = (0, import_import_fresh.default)(pnpFile);
  if (pnp.setup) {
    pnp.setup();
    return toFileUrl(pnpFile);
  }
  throw new UnsupportedPnpFile(`Unsupported pnp file: "${pnpFile}"`);
}
function clearPnPGlobalCache() {
  if (lock)
    return lock;
  lock = _cleanCache().finally(() => {
    lock = void 0;
  });
  return lock;
}
async function _cleanCache() {
  await Promise.all([...cachedRequests.values()].map(rejectToUndefined));
  const modules = [...cachedPnpImportsSync.values()];
  modules.forEach((r) => r && import_clear_module.default.single((0, import_node_url11.fileURLToPath)(r)));
  cachedRequests.clear();
  cachedRequestsSync.clear();
  cachedPnpImportsSync.clear();
  return void 0;
}
function rejectToUndefined(p) {
  return p.catch(() => void 0);
}
function isSupported(url2) {
  return supportedSchemas.has(url2.protocol);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLocations.js
var supportedExtensions = [".json", ".jsonc", ".yaml", ".yml", ".mjs", ".cjs", ".js", ".toml"];
var setOfLocations = /* @__PURE__ */ new Set([
  "package.json",
  // Original locations
  ".cspell.json",
  "cspell.json",
  ".cSpell.json",
  "cSpell.json",
  // Original locations jsonc
  ".cspell.jsonc",
  "cspell.jsonc",
  // Alternate locations
  ".vscode/cspell.json",
  ".vscode/cSpell.json",
  ".vscode/.cspell.json",
  // Standard Locations
  ".cspell.config.json",
  ".cspell.config.jsonc",
  ".cspell.config.yaml",
  ".cspell.config.yml",
  "cspell.config.json",
  "cspell.config.jsonc",
  "cspell.config.yaml",
  "cspell.config.yml",
  // Dynamic config is looked for last
  ...genCfgLoc("cspell.config", supportedExtensions),
  ...genCfgLoc(".cspell.config", supportedExtensions),
  // .config
  ".cspell.yaml",
  ".cspell.yml",
  "cspell.yaml",
  "cspell.yml",
  ".config/.cspell.json",
  ".config/cspell.json",
  ".config/.cSpell.json",
  ".config/cSpell.json",
  ".config/.cspell.jsonc",
  ".config/cspell.jsonc",
  ...genCfgLoc(".config/cspell.config", supportedExtensions),
  ...genCfgLoc(".config/.cspell.config", supportedExtensions),
  ".config/cspell.yaml",
  ".config/cspell.yml"
]);
var searchPlaces = Object.freeze([...setOfLocations]);
var defaultConfigFilenames = Object.freeze([...searchPlaces]);
function genCfgLoc(filename, extensions) {
  return extensions.map((ext) => filename + ext);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configSearch.js
var import_posix3 = require("node:path/posix");

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/findUpFromUrl.js
async function findUpFromUrl2(name2, from, options = {}) {
  const fs6 = options.fs ?? getVirtualFS().fs;
  return fs6.findUp(name2, from, options);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configSearch.js
var ConfigSearch = class {
  /**
   * Cache of search results.
   */
  #searchCache = /* @__PURE__ */ new Map();
  /**
   * The scanner to use to search for config files.
   */
  #scanner;
  /**
   * @param searchPlaces - The list of file names to search for.
   * @param allowedExtensionsByProtocol - Map of allowed extensions by protocol, '*' is used to match all protocols.
   * @param fs - The file system to use.
   */
  constructor(searchPlaces2, allowedExtensionsByProtocol, fs6) {
    this.#scanner = new DirConfigScanner(searchPlaces2, allowedExtensionsByProtocol, fs6);
  }
  async searchForConfig(searchFromURL, stopSearchAtURL) {
    const dirUrl = searchFromURL.pathname.endsWith("/") ? searchFromURL : new URL("./", searchFromURL);
    const stopDirUrls = stopSearchAtURL ? stopSearchAtURL.map((url2) => url2.pathname.endsWith("/") ? url2 : new URL("./", url2)) : void 0;
    return this.#findUp(dirUrl, stopDirUrls);
  }
  clearCache() {
    this.#searchCache.clear();
    this.#scanner.clearCache();
  }
  #findUp(fromDir, stopDirUrls) {
    const searchDirCache = this.#searchCache;
    const cached = searchDirCache.get(fromDir.href);
    if (cached) {
      return cached;
    }
    const visited = [];
    let result = void 0;
    const predicate = (dir) => {
      visit(dir);
      return this.#scanner.scanDirForConfigFile(dir);
    };
    result = findUpFromUrl2(predicate, fromDir, { type: "file", ...stopDirUrls && { stopAt: stopDirUrls } });
    searchDirCache.set(fromDir.href, result);
    visited.forEach((dir) => searchDirCache.set(dir.href, result));
    return result;
    function visit(dir) {
      if (!result) {
        visited.push(dir);
        return;
      }
      searchDirCache.set(dir.href, searchDirCache.get(dir.href) || result);
    }
  }
};
var DirConfigScanner = class {
  allowedExtensionsByProtocol;
  fs;
  #searchDirCache = /* @__PURE__ */ new Map();
  #searchPlacesByProtocol;
  #searchPlaces;
  /**
   * @param searchPlaces - The list of file names to search for.
   * @param allowedExtensionsByProtocol - Map of allowed extensions by protocol, '*' is used to match all protocols.
   * @param fs - The file system to use.
   */
  constructor(searchPlaces2, allowedExtensionsByProtocol, fs6) {
    this.allowedExtensionsByProtocol = allowedExtensionsByProtocol;
    this.fs = fs6;
    this.#searchPlacesByProtocol = setupSearchPlacesByProtocol(searchPlaces2, allowedExtensionsByProtocol);
    this.#searchPlaces = this.#searchPlacesByProtocol.get("*") || searchPlaces2;
  }
  clearCache() {
    this.#searchDirCache.clear();
  }
  /**
   *
   * @param dir - the directory to search for a config file.
   * @param visited - a callback to be called for each directory visited.
   * @returns A promise that resolves to the url of the config file or `undefined`.
   */
  scanDirForConfigFile(dir) {
    const searchDirCache = this.#searchDirCache;
    const href = dir.href;
    const cached = searchDirCache.get(href);
    if (cached) {
      return cached;
    }
    const result = this.#scanDirForConfig(dir);
    searchDirCache.set(href, result);
    return result;
  }
  #createHasFileDirSearch() {
    const dirInfoCache = createAutoResolveCache();
    const hasFile = async (filename) => {
      const dir = new URL(".", filename);
      const parent = new URL("..", dir);
      const parentHref = parent.href;
      const parentInfoP = dirInfoCache.get(parentHref);
      if (parentInfoP) {
        const parentInfo = await parentInfoP;
        const name3 = urlBasename(dir).slice(0, -1);
        const found2 = parentInfo.get(name3);
        if (!found2?.isDirectory() && !found2?.isSymbolicLink())
          return false;
      }
      const dirUrlHref = dir.href;
      const dirInfo = await dirInfoCache.get(dirUrlHref, async () => await this.#readDir(dir));
      const name2 = urlBasename(filename);
      const found = dirInfo.get(name2);
      return found?.isFile() || found?.isSymbolicLink() || false;
    };
    return hasFile;
  }
  async #readDir(dir) {
    try {
      const dirInfo = await this.fs.readDirectory(dir);
      return new Map(dirInfo.map((ent) => [ent.name, ent]));
    } catch {
      return /* @__PURE__ */ new Map();
    }
  }
  #createHasFileStatCheck() {
    const hasFile = async (filename) => {
      const stat3 = await this.fs.stat(filename).catch(() => void 0);
      return !!stat3?.isFile();
    };
    return hasFile;
  }
  /**
   * Scan the directory for the first matching config file.
   * @param dir - url of the directory to scan.
   * @returns A promise that resolves to the url of the config file or `undefined`.
   */
  async #scanDirForConfig(dir) {
    const hasFile = this.fs.getCapabilities(dir).readDirectory ? this.#createHasFileDirSearch() : this.#createHasFileStatCheck();
    const searchPlaces2 = this.#searchPlacesByProtocol.get(dir.protocol) || this.#searchPlaces;
    for (const searchPlace of searchPlaces2) {
      const file = new URL(searchPlace, dir);
      const found = await hasFile(file);
      if (found) {
        if (urlBasename(file) !== "package.json")
          return file;
        if (await checkPackageJson(this.fs, file))
          return file;
      }
    }
    return void 0;
  }
};
function setupSearchPlacesByProtocol(searchPlaces2, allowedExtensionsByProtocol) {
  const map3 = new Map([...allowedExtensionsByProtocol.entries()].map(([k, v]) => [k, new Set(v)]).map(([protocol, exts]) => [protocol, searchPlaces2.filter((url2) => exts.has((0, import_posix3.extname)(url2)))]));
  return map3;
}
async function checkPackageJson(fs6, filename) {
  try {
    const file = await fs6.readFile(filename);
    const pkg = JSON.parse(file.getText());
    return typeof pkg.cspell === "object";
  } catch {
    return false;
  }
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/defaultSettings.js
var defaultSettings = createCSpellSettingsInternal({
  id: "default",
  name: "default",
  version: currentSettingsFileVersion
});

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/PnPSettings.js
var defaultPnPSettings = Object.freeze({});
var lastPnP = defaultPnPSettings;
function normalizePnPSettings(settings) {
  if (equal(lastPnP, settings))
    return lastPnP;
  if (equal(defaultPnPSettings, settings))
    return defaultPnPSettings;
  const { usePnP, pnpFiles } = settings;
  return lastPnP = clean3({ usePnP, pnpFiles });
}
function equal(a, b) {
  return a === b || a.usePnP === b.usePnP && (a.pnpFiles === b.pnpFiles || a.pnpFiles?.join("|") === b.pnpFiles?.join("|"));
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLoader.js
var supportedCSpellConfigVersions = [configSettingsFileVersion0_2];
var setOfSupportedConfigVersions = Object.freeze(new Set(supportedCSpellConfigVersions));
var defaultConfigLoader = void 0;
var defaultExtensions = [".json", ".yaml", ".yml", ".jsonc"];
var defaultJsExtensions = [".js", ".cjs", ".mjs"];
var trustedSearch = /* @__PURE__ */ new Map([
  ["*", defaultExtensions],
  ["file:", [...defaultExtensions, ...defaultJsExtensions]]
]);
var unTrustedSearch = /* @__PURE__ */ new Map([["*", defaultExtensions]]);
var ConfigLoader = class {
  fs;
  templateVariables;
  onReady;
  fileResolver;
  _isTrusted = true;
  /**
   * Use `createConfigLoader`
   * @param virtualFs - virtual file system to use.
   */
  constructor(fs6, templateVariables = envToTemplateVars(process.env)) {
    this.fs = fs6;
    this.templateVariables = templateVariables;
    this.configSearch = new ConfigSearch(searchPlaces, trustedSearch, fs6);
    this.cspellConfigFileReaderWriter = createReaderWriter(void 0, void 0, createIO(fs6));
    this.fileResolver = new FileResolver(fs6, this.templateVariables);
    this.onReady = this.init();
    this.subscribeToEvents();
  }
  subscribeToEvents() {
    this.toDispose.push(onClearCache(() => this.clearCachedSettingsFiles()));
  }
  cachedConfig = /* @__PURE__ */ new Map();
  cachedConfigFiles = /* @__PURE__ */ new Map();
  cachedPendingConfigFile = new AutoResolveCache();
  cachedMergedConfig = /* @__PURE__ */ new WeakMap();
  cachedCSpellConfigFileInMemory = /* @__PURE__ */ new WeakMap();
  globalSettings;
  cspellConfigFileReaderWriter;
  configSearch;
  stopSearchAtCache = /* @__PURE__ */ new WeakMap();
  toDispose = [];
  async readSettingsAsync(filename, relativeTo, pnpSettings) {
    await this.onReady;
    const ref = await this.resolveFilename(filename, relativeTo || toFileDirURL("./"));
    const entry = this.importSettings(ref, pnpSettings || defaultPnPSettings, []);
    return entry.onReady;
  }
  async readConfigFile(filenameOrURL, relativeTo) {
    const ref = await this.resolveFilename(filenameOrURL.toString(), relativeTo || toFileDirURL("./"));
    const url2 = toFileURL(ref.filename);
    const href = url2.href;
    if (ref.error)
      return new ImportError(`Failed to read config file: "${ref.filename}"`, ref.error);
    const cached = this.cachedConfigFiles.get(href);
    if (cached)
      return cached;
    return this.cachedPendingConfigFile.get(href, async () => {
      try {
        const file = await this.cspellConfigFileReaderWriter.readConfig(href);
        this.cachedConfigFiles.set(href, file);
        return file;
      } catch (error4) {
        return new ImportError(`Failed to read config file: "${ref.filename}"`, error4);
      } finally {
        setTimeout(() => this.cachedPendingConfigFile.delete(href), 1);
      }
    });
  }
  async searchForConfigFileLocation(searchFrom, stopSearchAt) {
    const searchFromURL = await this.#normalizeDirURL(searchFrom) || cwdURL();
    return this.configSearch.searchForConfig(searchFromURL, stopSearchAt);
  }
  async searchForConfigFile(searchFrom, stopSearchAt) {
    const location = await this.searchForConfigFileLocation(searchFrom, stopSearchAt);
    if (!location)
      return void 0;
    const file = await this.readConfigFile(location);
    return file instanceof Error ? void 0 : file;
  }
  /**
   *
   * @param searchFrom the directory / file URL to start searching from.
   * @param options - Optional settings including stop location and Yarn PnP configuration.
   * @returns the resulting settings
   */
  async searchForConfig(searchFrom, options) {
    const stopAt = await this.#extractStopSearchAtURLs(options);
    const configFile = await this.searchForConfigFile(searchFrom, stopAt);
    if (!configFile)
      return void 0;
    return this.mergeConfigFileWithImports(configFile, options);
  }
  getGlobalSettings() {
    (0, import_node_assert10.default)(this.globalSettings, "Global settings not loaded");
    return this.globalSettings;
  }
  async getGlobalSettingsAsync() {
    if (!this.globalSettings) {
      const globalConfFile = await getGlobalConfig();
      const normalized = await this.mergeConfigFileWithImports(globalConfFile, void 0);
      normalized.id ??= "global_config";
      this.globalSettings = normalized;
    }
    return this.globalSettings;
  }
  clearCachedSettingsFiles() {
    this.globalSettings = void 0;
    this.cachedConfig.clear();
    this.cachedConfigFiles.clear();
    this.configSearch.clearCache();
    this.cachedPendingConfigFile.clear();
    this.cspellConfigFileReaderWriter.clearCachedFiles();
    this.cachedMergedConfig = /* @__PURE__ */ new WeakMap();
    this.cachedCSpellConfigFileInMemory = /* @__PURE__ */ new WeakMap();
    this.prefetchGlobalSettingsAsync();
  }
  /**
   * Resolve and merge the settings from the imports.
   * @param settings - settings to resolve imports for
   * @param filename - the path / URL to the settings file. Used to resolve imports.
   */
  resolveSettingsImports(settings, filename) {
    const settingsFile = this.createCSpellConfigFile(filename, settings);
    return this.mergeConfigFileWithImports(settingsFile, settings);
  }
  init() {
    this.onReady = Promise.all([this.prefetchGlobalSettingsAsync(), this.resolveDefaultConfig()]).then(() => void 0);
    return this.onReady;
  }
  async prefetchGlobalSettingsAsync() {
    await this.getGlobalSettingsAsync().catch((e) => logError(e));
  }
  async resolveDefaultConfig() {
    const r = await this.fileResolver.resolveFile(defaultConfigFileModuleRef, srcDirectory);
    const url2 = toFileURL(r.filename);
    this.cspellConfigFileReaderWriter.setTrustedUrls([new URL("../..", url2)]);
    return url2;
  }
  importSettings(fileRef, pnpSettings, backReferences) {
    const url2 = toFileURL(fileRef.filename);
    const cacheKey = url2.href;
    const cachedImport = this.cachedConfig.get(cacheKey);
    if (cachedImport) {
      backReferences.forEach((ref) => cachedImport.referencedSet.add(ref));
      return cachedImport;
    }
    if (fileRef.error) {
      const settings = createCSpellSettingsInternal({
        __importRef: fileRef,
        source: { name: fileRef.filename, filename: fileRef.filename }
      });
      const importedConfig2 = {
        href: cacheKey,
        fileRef,
        configFile: void 0,
        settings,
        isReady: true,
        onReady: Promise.resolve(settings),
        onConfigFileReady: Promise.resolve(fileRef.error),
        referencedSet: new Set(backReferences)
      };
      this.cachedConfig.set(cacheKey, importedConfig2);
      return importedConfig2;
    }
    const source = {
      name: fileRef.filename,
      filename: fileRef.filename
    };
    const mergeImports = (cfgFile) => {
      if (cfgFile instanceof Error) {
        fileRef.error = cfgFile;
        return createCSpellSettingsInternal({ __importRef: fileRef, source });
      }
      return this.mergeConfigFileWithImports(cfgFile, pnpSettings, backReferences);
    };
    const referencedSet = new Set(backReferences);
    const onConfigFileReady = onConfigFileReadyFixUp(this.readConfigFile(fileRef.filename));
    const importedConfig = {
      href: cacheKey,
      fileRef,
      configFile: void 0,
      settings: void 0,
      isReady: false,
      onReady: onReadyFixUp(onConfigFileReady.then(mergeImports)),
      onConfigFileReady,
      referencedSet
    };
    this.cachedConfig.set(cacheKey, importedConfig);
    return importedConfig;
    async function onReadyFixUp(pSettings) {
      const settings = await pSettings;
      settings.source ??= source;
      settings.__importRef ??= fileRef;
      importedConfig.isReady = true;
      importedConfig.settings = settings;
      return settings;
    }
    async function onConfigFileReadyFixUp(pCfgFile) {
      const cfgFile = await pCfgFile;
      if (cfgFile instanceof Error) {
        importedConfig.fileRef.error = cfgFile;
        return cfgFile;
      }
      source.name = cfgFile.settings.name || source.name;
      importedConfig.configFile = cfgFile;
      return cfgFile;
    }
  }
  async setupPnp(cfgFile, pnpSettings) {
    if (!pnpSettings?.usePnP || pnpSettings === defaultPnPSettings)
      return;
    if (cfgFile.url.protocol !== "file:")
      return;
    const { usePnP = pnpSettings.usePnP, pnpFiles = pnpSettings.pnpFiles } = cfgFile.settings;
    const pnpSettingsToUse = normalizePnPSettings({ usePnP, pnpFiles });
    const pathToSettingsDir = new URL(".", cfgFile.url);
    await loadPnP(pnpSettingsToUse, pathToSettingsDir);
  }
  mergeConfigFileWithImports(cfg, pnpSettings, referencedBy) {
    const cfgFile = this.toCSpellConfigFile(cfg);
    const cached = this.cachedMergedConfig.get(cfgFile);
    if (cached && cached.pnpSettings === pnpSettings && cached.referencedBy === referencedBy) {
      return cached.result;
    }
    const pnp = {
      usePnP: cfg.settings.usePnP ?? pnpSettings?.usePnP ?? !!process.versions.pnp,
      pnpFiles: cfg.settings.pnpFiles ?? pnpSettings?.pnpFiles
    };
    const result = this._mergeConfigFileWithImports(cfgFile, pnp, referencedBy);
    this.cachedMergedConfig.set(cfgFile, { pnpSettings, referencedBy, result });
    return result;
  }
  async _mergeConfigFileWithImports(cfgFile, pnpSettings, referencedBy = []) {
    await this.setupPnp(cfgFile, pnpSettings);
    const href = cfgFile.url.href;
    const referencedSet = new Set(referencedBy);
    const imports = normalizeImport(cfgFile.settings.import);
    const __imports = await Promise.all(imports.map((name2) => this.resolveFilename(name2, cfgFile.url)));
    const toImport = __imports.map((ref) => this.importSettings(ref, pnpSettings, [...referencedBy, href]));
    toImport.forEach((entry) => {
      entry.referencedSet.add(href);
    });
    const pendingImports = toImport.map((entry) => {
      return referencedSet.has(entry.href) ? entry.settings || configToRawSettings(entry.configFile) : entry.onReady;
    });
    const importSettings = await Promise.all(pendingImports);
    const cfg = await this.mergeImports(cfgFile, importSettings);
    return cfg;
  }
  /**
   * normalizeSettings handles correcting all relative paths, anchoring globs, and importing other config files.
   * @param rawSettings - raw configuration settings
   * @param pathToSettingsFile - path to the source file of the configuration settings.
   */
  async mergeImports(cfgFile, importedSettings) {
    const rawSettings = configToRawSettings(cfgFile);
    const url2 = cfgFile.url;
    const fileRef = rawSettings.__importRef;
    const source = rawSettings.source;
    (0, import_node_assert10.default)(source);
    const settings = {
      version: defaultSettings.version,
      ...rawSettings,
      globRoot: resolveGlobRoot(rawSettings, cfgFile.url),
      languageSettings: normalizeLanguageSettings(rawSettings.languageSettings)
    };
    const normalizedDictionaryDefs = normalizeDictionaryDefs(settings, url2);
    const normalizedSettingsGlobs = normalizeSettingsGlobs(settings, url2);
    const normalizedOverrides = normalizeOverrides(settings, url2);
    const normalizedReporters = await normalizeReporters(settings, url2);
    const normalizedGitignoreRoot = normalizeGitignoreRoot(settings, url2);
    const normalizedCacheSettings = normalizeCacheSettings(settings, url2);
    const fileSettings = createCSpellSettingsInternal({
      ...settings,
      source,
      ...normalizedDictionaryDefs,
      ...normalizedSettingsGlobs,
      ...normalizedOverrides,
      ...normalizedReporters,
      ...normalizedGitignoreRoot,
      ...normalizedCacheSettings
    });
    if (!importedSettings.length) {
      return fileSettings;
    }
    const mergedImportedSettings = importedSettings.reduce((a, b) => mergeSettings(a, b));
    const finalizeSettings2 = mergeSettings(mergedImportedSettings, fileSettings);
    finalizeSettings2.name = settings.name || finalizeSettings2.name || "";
    finalizeSettings2.id = settings.id || finalizeSettings2.id || "";
    if (fileRef) {
      finalizeSettings2.__importRef = fileRef;
    }
    return finalizeSettings2;
  }
  createCSpellConfigFile(filename, settings) {
    const map3 = autoResolveWeak2(this.cachedCSpellConfigFileInMemory, settings, () => /* @__PURE__ */ new Map());
    return autoResolve(map3, filename, () => this.cspellConfigFileReaderWriter.toCSpellConfigFile({ url: toFileURL(filename), settings }));
  }
  toCSpellConfigFile(cfg) {
    if (cfg instanceof CSpellConfigFile)
      return cfg;
    return this.createCSpellConfigFile(cfg.url, cfg.settings);
  }
  dispose() {
    while (this.toDispose.length) {
      try {
        this.toDispose.pop()?.dispose();
      } catch (e) {
        logError(e);
      }
    }
  }
  getStats() {
    return { ...stats() };
  }
  async resolveConfigFileLocation(filenameOrURL, relativeTo) {
    const r = await this.fileResolver.resolveFile(filenameOrURL, relativeTo);
    return r.found ? toFileURL(r.filename) : void 0;
  }
  async resolveFilename(filename, relativeTo) {
    if (filename instanceof URL)
      return { filename: toFilePathOrHref(filename) };
    if (isUrlLike(filename))
      return { filename: toFilePathOrHref(filename) };
    const r = await this.fileResolver.resolveFile(filename, relativeTo);
    if (r.warning) {
      logWarning(r.warning);
    }
    return {
      filename: r.filename.startsWith("file:/") ? (0, import_node_url12.fileURLToPath)(r.filename) : r.filename,
      error: r.found ? void 0 : new ConfigurationLoaderFailedToResolveError(filename, relativeTo)
    };
  }
  get isTrusted() {
    return this._isTrusted;
  }
  setIsTrusted(isTrusted2) {
    this._isTrusted = isTrusted2;
    this.clearCachedSettingsFiles();
    this.configSearch = new ConfigSearch(searchPlaces, isTrusted2 ? trustedSearch : unTrustedSearch, this.fs);
    this.cspellConfigFileReaderWriter.setUntrustedExtensions(isTrusted2 ? [] : defaultJsExtensions);
  }
  async #extractStopSearchAtURLs(options) {
    if (!options?.stopSearchAt)
      return void 0;
    if (this.stopSearchAtCache.has(options)) {
      return this.stopSearchAtCache.get(options);
    }
    const rawStops = Array.isArray(options.stopSearchAt) ? options.stopSearchAt : [options.stopSearchAt];
    const stopURLs = await Promise.all(rawStops.map((s) => this.#normalizeDirURL(s)));
    this.stopSearchAtCache.set(options, stopURLs);
    return stopURLs;
  }
  async #normalizeDirURL(input) {
    if (!input)
      return void 0;
    const url2 = toFileURL(input, cwdURL());
    if (url2.pathname.endsWith("/"))
      return url2;
    if (input instanceof URL)
      return new URL(".", url2);
    if (typeof input === "string" && !isUrlLike(input) && url2.protocol === "file:" && await isDirectory(this.fs, url2)) {
      return addTrailingSlash(url2);
    }
    return new URL(".", url2);
  }
};
var ConfigLoaderInternal = class extends ConfigLoader {
  constructor(vfs) {
    super(vfs);
  }
  get _cachedFiles() {
    return this.cachedConfig;
  }
};
function loadPnP(pnpSettings, searchFrom) {
  if (!pnpSettings.usePnP) {
    return Promise.resolve(void 0);
  }
  const loader2 = pnpLoader(pnpSettings.pnpFiles);
  return loader2.load(searchFrom);
}
var nestedConfigDirectories = {
  ".vscode": true,
  ".config": true
  // this should be removed in the future, but it is a breaking change.
};
function resolveGlobRoot(settings, urlSettingsFile) {
  const urlSettingsFileDir = new URL(".", urlSettingsFile);
  const uriSettingsFileDir = URI.parse(urlSettingsFileDir.href);
  const settingsFileDirName = Utils.basename(uriSettingsFileDir);
  const isNestedConfig = settingsFileDirName in nestedConfigDirectories;
  const isVSCode = settingsFileDirName === ".vscode";
  const settingsFileDir = (isNestedConfig ? Utils.dirname(uriSettingsFileDir) : uriSettingsFileDir).toString();
  const envGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
  const defaultGlobRoot = envGlobRoot ?? "${cwd}";
  const rawRoot = settings.globRoot ?? (settings.version === configSettingsFileVersion0_1 || envGlobRoot && !settings.version || isVSCode && !settings.version ? defaultGlobRoot : settingsFileDir);
  const globRoot = rawRoot.startsWith("${cwd}") ? rawRoot : toFileURL(rawRoot, new URL(settingsFileDir));
  return typeof globRoot === "string" ? globRoot : globRoot.protocol === "file:" ? windowsDriveLetterToUpper(import_node_path9.default.resolve((0, import_node_url12.fileURLToPath)(globRoot))) : addTrailingSlash(globRoot).href;
}
function createConfigLoaderInternal(fs6) {
  return new ConfigLoaderInternal(fs6 ?? getVirtualFS().fs);
}
function getDefaultConfigLoaderInternal() {
  if (defaultConfigLoader)
    return defaultConfigLoader;
  return defaultConfigLoader = createConfigLoaderInternal();
}
function createIO(fs6) {
  const readFile4 = (url2) => fs6.readFile(url2).then((file) => ({ url: file.url, content: file.getText() }));
  const writeFile3 = (file) => fs6.writeFile(file);
  return {
    readFile: readFile4,
    writeFile: writeFile3
  };
}
async function isDirectory(fs6, path17) {
  try {
    return (await fs6.stat(path17)).isDirectory();
  } catch {
    return false;
  }
}
var ConfigurationLoaderError = class extends Error {
  configurationFile;
  relativeTo;
  constructor(message, configurationFile, relativeTo, cause) {
    super(message);
    this.configurationFile = configurationFile;
    this.relativeTo = relativeTo;
    this.name = "Configuration Loader Error";
    if (cause) {
      this.cause = cause;
    }
  }
};
var ConfigurationLoaderFailedToResolveError = class extends ConfigurationLoaderError {
  configurationFile;
  relativeTo;
  constructor(configurationFile, relativeTo, cause) {
    const filename = configurationFile.startsWith("file:/") ? (0, import_node_url12.fileURLToPath)(configurationFile) : configurationFile;
    const relSource = relativeToCwd(relativeTo);
    const message = `Failed to resolve configuration file: "${filename}" referenced from "${relSource}"`;
    super(message, configurationFile, relativeTo, cause);
    this.configurationFile = configurationFile;
    this.relativeTo = relativeTo;
  }
};
function relativeToCwd(file) {
  const url2 = toFileUrl(file);
  const cwdPath = cwdURL().pathname.split("/").slice(0, -1);
  const urlPath = url2.pathname.split("/");
  if (urlPath[0] !== cwdPath[0])
    return toFilePathOrHref(file);
  let i = 0;
  for (; i < cwdPath.length; ++i) {
    if (cwdPath[i] !== urlPath[i])
      break;
  }
  const segments = cwdPath.length - i;
  if (segments > 3)
    return toFilePathOrHref(file);
  const prefix = [...".".repeat(segments)].map(() => "..").join("/");
  return [prefix || ".", ...urlPath.slice(i)].join("/");
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/defaultConfigLoader.js
var gcl = getDefaultConfigLoaderInternal;
function searchForConfig(searchFrom, options) {
  return gcl().searchForConfig(searchFrom, options);
}
async function loadConfig(file, pnpSettings) {
  return gcl().readSettingsAsync(file, void 0, pnpSettings);
}
async function resolveSettingsImports(settings, filename) {
  return gcl().resolveSettingsImports(settings, filename);
}
async function readConfigFile(filename, relativeTo) {
  const result = await gcl().readConfigFile(filename, relativeTo);
  if (result instanceof Error) {
    throw result;
  }
  return result;
}
async function resolveConfigFileImports(configFile) {
  return gcl().mergeConfigFileWithImports(configFile, configFile.settings);
}
function getGlobalSettingsAsync() {
  return gcl().getGlobalSettingsAsync();
}
function getDefaultConfigLoader() {
  return getDefaultConfigLoaderInternal();
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/extractImportErrors.js
function extractImportErrors(settings) {
  const imports = mergeImportRefs2(settings);
  return !imports ? [] : [...imports.values()].filter(isImportFileRefWithError);
}
function mergeImportRefs2(left, right = {}) {
  const imports = new Map(left.__imports || []);
  if (left.__importRef) {
    imports.set(left.__importRef.filename, left.__importRef);
  }
  if (right.__importRef) {
    imports.set(right.__importRef.filename, right.__importRef);
  }
  const rightImports = right.__imports?.values() || [];
  for (const ref of rightImports) {
    imports.set(ref.filename, ref);
  }
  return imports.size ? imports : void 0;
}
function isImportFileRefWithError(ref) {
  return !!ref.error;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/readSettings.js
async function readSettings(filename, relativeToOrPnP, pnpSettings) {
  const loader2 = getDefaultConfigLoader();
  const relativeTo = typeof relativeToOrPnP === "string" || relativeToOrPnP instanceof URL ? relativeToOrPnP : void 0;
  const pnp = pnpSettings ? pnpSettings : !(typeof relativeToOrPnP === "string" || relativeToOrPnP instanceof URL) ? relativeToOrPnP : void 0;
  return loader2.readSettingsAsync(filename, relativeTo, pnp);
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/grammarTypesHelpers.js
function isPatternInclude(p) {
  return !!p.include;
}
var TypeofMatch = {
  object: true,
  string: true
};
var TypeofBegin = TypeofMatch;
var TypeofEnd = { ...TypeofBegin, undefined: true };
function isPatternMatch(pattern) {
  const p = pattern;
  return !!p.match && typeof p.match in TypeofMatch;
}
function isPatternBeginEnd(pattern) {
  const p = pattern;
  return p.begin !== void 0 && typeof p.begin in TypeofBegin && typeof p.end in TypeofEnd;
}
function isPatternPatterns(p) {
  return Array.isArray(p.patterns);
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/matchResult.js
function segmentMatch(mr) {
  const { matches, index, groups, input } = mr;
  const segments = [];
  let p = index;
  for (let groupNum = 0; groupNum < matches.length; ++groupNum) {
    const m = matches[groupNum];
    if (!m)
      continue;
    const idx0 = input.indexOf(m, p);
    const idx2 = idx0 >= p ? idx0 : input.lastIndexOf(m, p);
    if (idx2 < 0)
      continue;
    segments.push({ match: m, index: idx2, groupNum, groupName: void 0 });
    p = idx2;
  }
  const textToSeg = new Map(segments.map((s) => [s.match, s]));
  for (const [name2, value] of Object.entries(groups)) {
    const s = value && textToSeg.get(value);
    if (!s)
      continue;
    s.groupName = s.groupName ? Array.isArray(s.groupName) ? [...s.groupName, name2] : [s.groupName, name2] : name2;
  }
  return segments;
}
function createMatchResult(r, lineNumber) {
  const groups = /* @__PURE__ */ Object.create(null);
  r.groups && Object.assign(groups, r.groups);
  const matches = r;
  const match2 = r[0];
  return { index: r.index, input: r.input, match: match2, matches, groups, lineNumber };
}
function createSimpleMatchResult(match2, input, index, lineNumber) {
  const groups = /* @__PURE__ */ Object.create(null);
  return { index, input, match: match2, matches: [match2], groups, lineNumber };
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/scope.js
var import_node_assert11 = __toESM(require("node:assert"), 1);
var Scope = class _Scope {
  value;
  parent;
  constructor(value, parent) {
    this.value = value;
    this.parent = parent;
  }
  /**
   * Convert the scope hierarchy to a string
   * @param ltr - return ancestry from left-to-right
   * @returns the scope hierarchy as a string separated by a space.
   */
  toString(ltr = false) {
    if (!this.parent)
      return this.value;
    return ltr ? this.parent.toString(ltr) + " " + this.value : this.value + " " + this.parent.toString(ltr);
  }
  static isScope(value) {
    return value instanceof _Scope;
  }
};
var ScopePool = class {
  pool = /* @__PURE__ */ new Map();
  /**
   * Get a Scope that matches the scope. This method is idempotent.
   * @param scopeValue - a single scope value: i.e. `source.ts`
   * @param parent - optional parent Scope
   */
  getScope(scopeValue, parent) {
    const foundPoolMap = this.pool.get(scopeValue);
    const poolMap = foundPoolMap || /* @__PURE__ */ new Map();
    if (poolMap !== foundPoolMap) {
      this.pool.set(scopeValue, poolMap);
    }
    const foundScope = poolMap.get(parent);
    if (foundScope)
      return foundScope.v;
    const scope = new Scope(scopeValue, parent);
    poolMap.set(parent, { v: scope });
    return scope;
  }
  parseScope(scopes, ltr = false) {
    if (Scope.isScope(scopes))
      return scopes;
    if (isScopeLike(scopes)) {
      const parent = scopes.parent ? this.parseScope(scopes.parent) : void 0;
      return this.getScope(scopes.value, parent);
    }
    return this.parseScopeString(scopes, ltr);
  }
  parseScopeString(scopes, ltr) {
    scopes = Array.isArray(scopes) ? scopes : scopes.split(" ");
    const parentToChild = ltr ? scopes : scopes.reverse();
    let parent = void 0;
    for (const value of parentToChild) {
      parent = this.getScope(value, parent);
    }
    (0, import_node_assert11.default)(parent, "Empty scope is not allowed.");
    return parent;
  }
};
function isScopeLike(value) {
  return typeof value === "object" && !Array.isArray(value) && value.value !== void 0;
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/grammarNormalizer.js
function normalizeGrammar(grammar2) {
  return new ImplNGrammar(grammar2);
}
var SpecialRepositoryReferences = {
  $self: true,
  $base: true
};
function nPattern(p) {
  if (isPatternMatch(p))
    return normalizePatternMatch(p);
  if (isPatternBeginEnd(p))
    return normalizePatternBeginEnd(p);
  if (isPatternInclude(p))
    return normalizePatternInclude(p);
  if (isPatternPatterns(p))
    return normalizePatternsPatterns(p);
  return normalizePatternName(p);
}
function normalizePatternMatch(p) {
  const regExec = makeTestMatchFn(p.match);
  const self = {
    ...p,
    captures: normalizeCapture(p.captures),
    findMatch
  };
  function findMatch(line, parentRule) {
    const match2 = regExec(line);
    if (!match2)
      return void 0;
    const rule = factoryRule(parentRule, self);
    return { rule, match: match2, line };
  }
  return self;
}
function normalizePatternBeginEnd(p) {
  const patterns = normalizePatterns(p.patterns);
  const self = {
    ...p,
    captures: normalizeCapture(p.captures),
    beginCaptures: normalizeCapture(p.beginCaptures),
    endCaptures: normalizeCapture(p.endCaptures),
    patterns,
    findMatch
  };
  function findMatch(line, parentRule) {
    const match2 = testBegin(line);
    if (!match2)
      return void 0;
    const rule = factoryRule(parentRule, self, findNext, end);
    return { rule, match: match2, line };
  }
  const testBegin = makeTestMatchFn(p.begin);
  const testEnd = p.end !== void 0 ? makeTestMatchFn(p.end) : () => void 0;
  function findNext(line) {
    return patterns && findInPatterns(patterns, line, this);
  }
  function end(line) {
    return testEnd(line);
  }
  return self;
}
function normalizePatternName(p) {
  const patterns = void 0;
  const self = {
    ...p,
    patterns,
    findMatch
  };
  function findMatch(line, parentRule) {
    const rule = factoryRule(parentRule, self);
    const input = line.text.slice(line.offset);
    const match2 = createSimpleMatchResult(input, input, line.offset, line.lineNumber);
    return { rule, match: match2, line };
  }
  return self;
}
function normalizePatternInclude(p) {
  const { include } = p;
  return include.startsWith("#") || include in SpecialRepositoryReferences ? normalizePatternIncludeRef(p) : normalizePatternIncludeExt(p);
}
function normalizePatternIncludeRef(p) {
  const { include, ...rest } = p;
  const reference = include.startsWith("#") ? include.slice(1) : include;
  const self = {
    ...rest,
    reference,
    findMatch
  };
  function findMatch(line, parentRule) {
    const pat = parentRule.repository[reference];
    if (pat === void 0)
      throw new Error(`Unknown Include Reference ${include}`);
    return pat.findMatch(line, parentRule);
  }
  return self;
}
function normalizePatternIncludeExt(p) {
  function findMatch(_line) {
    return void 0;
  }
  const self = {
    ...p,
    findMatch
  };
  return self;
}
function normalizePatternsPatterns(p) {
  return new ImplNPatternPatterns(p);
}
function findInPatterns(patterns, line, rule) {
  let r = void 0;
  for (const pat of patterns) {
    if (pat.disabled)
      continue;
    const er = pat.findMatch(line, rule);
    if (er?.match !== void 0 && !er.rule.pattern.disabled) {
      r = r && r.match && r.match.index <= er.match.index && r || er;
    }
  }
  return r;
}
function normalizePatterns(patterns) {
  if (!patterns)
    return void 0;
  return patterns.map((p) => typeof p === "string" ? { include: p } : p).map(nPattern);
}
var emptyRepository = Object.freeze(/* @__PURE__ */ Object.create(null));
function normalizePatternRepository(rep) {
  if (!rep)
    return emptyRepository;
  return normalizeRepository(rep);
}
function normalizeRepository(rep) {
  const repository2 = /* @__PURE__ */ Object.create(null);
  for (const [key, pat] of Object.entries(rep)) {
    repository2[key] = nPattern(pat);
  }
  return repository2;
}
var ruleCounter = 0;
function factoryRuleBase(parent, pattern, repository2, grammar2, findNext, end) {
  const depth = parent ? parent.depth + 1 : 0;
  return {
    id: ruleCounter++,
    grammar: grammar2,
    pattern,
    parent,
    repository: repository2,
    depth,
    findNext,
    end
  };
}
function factoryRule(parent, pattern, findNext, end) {
  return factoryRuleBase(parent, pattern, parent.repository, parent.grammar, findNext, end);
}
function normalizeCapture(cap) {
  if (cap === void 0)
    return void 0;
  if (typeof cap === "string")
    return { [0]: cap };
  const capture = /* @__PURE__ */ Object.create(null);
  for (const [key, pat] of Object.entries(cap)) {
    capture[key] = typeof pat === "string" ? pat : normalizePatternName(pat).name;
  }
  return capture;
}
function makeTestMatchFn(reg) {
  if (typeof reg === "string")
    return matchString(reg);
  return matchRegExp(reg);
}
function matchString(s) {
  return (line) => {
    const input = line.text;
    const index = input.indexOf(s, line.offset);
    if (index < 0)
      return void 0;
    return createSimpleMatchResult(s, input, index, line.lineNumber);
  };
}
function matchRegExp(r) {
  return (line) => {
    const rg = RegExp(r, "gm");
    rg.lastIndex = line.offset;
    const m = rg.exec(line.text);
    return (m && createMatchResult(m, line.lineNumber)) ?? void 0;
  };
}
function extractScope(er, isContent = true) {
  const scope = [];
  for (let rule = er; rule; rule = rule.parent) {
    const pattern = rule.pattern;
    const { name: name2, contentName } = pattern;
    if (contentName && isContent) {
      scope.push(contentName);
    }
    if (name2 !== void 0) {
      scope.push(name2);
    }
    isContent = true;
  }
  return er.grammar.scopePool.parseScope(scope);
}
var ImplNGrammar = class {
  scopeName;
  name;
  comment;
  disabled;
  patterns;
  repository;
  grammarName;
  self;
  scopePool;
  constructor(grammar2) {
    this.scopeName = grammar2.scopeName;
    this.name = grammar2.scopeName;
    this.comment = grammar2.comment;
    this.disabled = grammar2.disabled;
    this.grammarName = grammar2.name;
    const self = nPattern({
      patterns: [{ patterns: grammar2.patterns }]
    });
    const repository2 = normalizePatternRepository(grammar2.repository);
    this.patterns = self.patterns;
    this.repository = repository2;
    this.self = self;
    this.scopePool = new ScopePool();
  }
  begin(parentRule) {
    const patterns = this.patterns;
    function grammarToRule(grammar2, baseGrammar, parent) {
      const repository2 = /* @__PURE__ */ Object.create(null);
      Object.assign(repository2, grammar2.repository);
      repository2["$self"] = grammar2.self;
      repository2["$base"] = repository2["$base"] || baseGrammar.self;
      function findNext(line) {
        return findInPatterns(patterns, line, this);
      }
      function end(_line) {
        return void 0;
      }
      return factoryRuleBase(parent, grammar2, repository2, grammar2, findNext, end);
    }
    return grammarToRule(this, parentRule?.grammar ?? this, parentRule);
  }
};
var ImplNPatternPatterns = class {
  name;
  comment;
  disabled;
  patterns;
  constructor(p) {
    const { name: name2, comment, disabled, ...rest } = p;
    this.patterns = normalizePatterns(rest.patterns);
    this.name = name2;
    this.comment = comment;
    this.disabled = disabled;
  }
  findMatch(line, parentRule) {
    const patterns = this.patterns;
    const rule = factoryRule(parentRule, this, findNext);
    function findNext(line2) {
      return findInPatterns(patterns, line2, this);
    }
    return rule.findNext?.(line);
  }
};

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/grammar.js
function compileGrammar(grammar2) {
  return normalizeGrammar(grammar2);
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/tokenizeLine.js
var import_node_assert12 = __toESM(require("node:assert"), 1);

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/util.js
function isDefined4(t) {
  return t !== void 0 && t !== null;
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/processors/procMatchingRule.js
function applyCaptureToBeginOrMatch(matchRuleResult) {
  const { match: match2, rule } = matchRuleResult;
  const bePattern = rule.pattern;
  const captures = bePattern.beginCaptures ?? bePattern.captures;
  return applyCaptures(rule, match2, captures);
}
function applyCaptureToEnd(rule, match2) {
  const { pattern } = rule;
  const bePattern = pattern;
  const captures = bePattern.endCaptures ?? bePattern.captures;
  return applyCaptures(rule, match2, captures);
}
function applyCaptures(rule, match2, captures) {
  const scope = extractScope(rule, false);
  const pool2 = rule.grammar.scopePool;
  const text = match2.match;
  const input = match2.input;
  const range = [match2.index, match2.index + text.length, match2.lineNumber];
  if (!text && !captures)
    return [];
  if (!captures) {
    const tokenized = {
      scope,
      text,
      range
    };
    return [tokenized];
  }
  const captureScopes = new Map(Object.entries(captures));
  const cap0 = captureScopes.get("0");
  if (captureScopes.size === 1 && cap0) {
    const tokenized = {
      scope: rule.grammar.scopePool.getScope(cap0, scope),
      text,
      range
    };
    return [tokenized];
  }
  const min3 = match2.index;
  const max4 = match2.index + text.length;
  function trimSegment(seg) {
    const { index, match: match3 } = seg;
    const right = match3.length;
    if (index >= min3 && right <= max4)
      return seg;
    if (index >= max4 || right < min3)
      return void 0;
    const a = Math.max(index, min3) - index;
    const b = Math.min(right, max4) - index;
    const text2 = match3.slice(a, b);
    return {
      ...seg,
      index: index + a,
      match: text2
    };
  }
  const segments = segmentMatch(match2).map(trimSegment).filter(isDefined4);
  function processSegments(segments2) {
    const base = segments2[0];
    const root = {
      a: base.index,
      b: base.index + base.match.length,
      s: { seg: base }
    };
    let m;
    for (let i = 1; i < segments2.length; ++i) {
      const seg = segments2[i];
      const index = seg.index;
      const end = index + seg.match.length;
      m = m && m.a <= index ? m : root;
      while (m && m.b <= index) {
        m = m.n;
      }
      while (m && m.a < end) {
        if (m.a < index) {
          const n = { ...m, a: index };
          m.n = n;
          m.b = index;
          m = n;
        }
        if (m.b > end) {
          const n = { ...m, a: end };
          m.b = end;
          m.n = n;
        }
        m.s = { seg, next: m.s };
        m = m.n;
      }
    }
    return root;
  }
  function segChainToScope(chain) {
    function* _chain(chain2) {
      while (chain2) {
        const seg = chain2.seg;
        if (seg.groupName) {
          if (Array.isArray(seg.groupName)) {
            yield* seg.groupName;
          } else {
            yield seg.groupName;
          }
        }
        yield seg.groupNum.toString();
        chain2 = chain2.next;
      }
    }
    const scopeValues = [..._chain(chain)].map((cap) => captureScopes.get(cap)).filter(isDefined4).reverse();
    return scopeValues.reduce((s, v) => pool2.getScope(v, s), scope);
  }
  const merged = processSegments(segments);
  function* emit(m) {
    while (m) {
      const t = {
        text: input.slice(m.a, m.b),
        range: [m.a, m.b, match2.lineNumber],
        scope: segChainToScope(m.s)
      };
      yield t;
      m = m.n;
    }
  }
  const parsedText = [...emit(merged)];
  return parsedText;
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/tokenizeLine.js
function tokenizeLine(line, rule) {
  const text = line.text;
  const lineLen = line.text.length;
  const parsedText = [];
  let ctx = buildContext({ ...line, offset: 0, anchor: -1 }, rule);
  while (ctx.line.offset <= lineLen) {
    let endMatch = ctx.rule.end?.(ctx.line);
    while (endMatch?.index === ctx.line.offset) {
      parsedText.push(...applyCaptureToEnd(ctx.rule, endMatch));
      ctx = findParentWithEnd(ctx);
      ctx.line.offset = endMatch.index + endMatch.match.length;
      endMatch = ctx.rule.end?.(ctx.line);
    }
    if (ctx.line.offset >= lineLen)
      break;
    const { line: line2, rule: rule2 } = ctx;
    const offset = line2.offset;
    const match2 = rule2.findNext?.(line2);
    const limit = endMatch?.index ?? lineLen;
    const emitTil = match2 ? Math.min(match2.match.index, limit) : limit;
    if (offset < emitTil) {
      const scope = extractScope(rule2);
      const start = offset;
      const end = emitTil;
      parsedText.push({
        scope,
        text: text.slice(start, end),
        range: [start, end, line2.lineNumber]
      });
      ctx.line.offset = emitTil;
    }
    if (!match2 || endMatch && endMatch.index <= match2.match.index) {
      continue;
    }
    parsedText.push(...applyCaptureToBeginOrMatch(match2));
    line2.anchor = match2.match.index + match2.match.match.length;
    line2.offset = line2.anchor;
    ctx = findNearestWithEnd(buildContext(line2, match2.rule));
  }
  return toParseLineResult(line, ctx.rule, parsedText);
}
function* tokenizeTextIterable(text, grammar2) {
  const lines = text.split(/(?<=\r\n|\n|\r(?!\n))/);
  const rule = grammar2.begin();
  let documentOffset = 0;
  let tr = tokenizeLine({ text: lines[0], lineNumber: 0, documentOffset }, rule);
  documentOffset += lines[0].length;
  yield toParsedLine(tr);
  for (let i = 1; i < lines.length; ++i) {
    const line = { text: lines[i], lineNumber: i, documentOffset };
    documentOffset += line.text.length;
    tr = tr.parse(line);
    yield toParsedLine(tr);
  }
}
function toParsedLine(pr) {
  const { tokens: parsedText, line, offset } = pr;
  return { tokens: parsedText, line, offset };
}
function toParseLineResult(line, rule, parsedText) {
  return {
    tokens: parsedText,
    line,
    offset: line.documentOffset,
    parse: (line2) => tokenizeLine(line2, rule)
  };
}
function buildContext(line, rule) {
  const rules = calcRuleStack(rule);
  const numRules = rules.length;
  const rootNum = numRules - 1;
  const rootRule = rules[rootNum];
  const rootContext = {
    line,
    rule: rootRule
  };
  let ctx = rootContext;
  for (let i = rootNum - 1; i >= 0; --i) {
    const rule2 = rules[i];
    const line2 = ctx.line;
    ctx = {
      line: line2,
      rule: rule2,
      parent: ctx
    };
  }
  return ctx;
}
function calcRuleStack(rule) {
  const rules = [];
  let r = rule;
  while (r) {
    rules.push(r);
    r = r.parent;
  }
  return rules;
}
function must(t, msg = "Must be defined") {
  (0, import_node_assert12.default)(t !== void 0 && t !== null, msg);
  return t;
}
function findParentWithEnd(ctx) {
  return findNearestWithEnd(must(ctx.parent));
}
function findNearestWithEnd(ctx) {
  while (!ctx.rule.end) {
    ctx = must(ctx.parent);
  }
  return ctx;
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/grammars/typescript.js
var repository = {
  statements: {
    name: "code.ts",
    patterns: [
      "#keyword",
      "#regexp",
      "#string",
      "#comment",
      "#braces",
      "#punctuation",
      "#space",
      { name: "identifier", match: /[^\s;,!|&:^%{}[\]()*/+=<>]+/ }
    ]
  },
  keyword: {
    patterns: ["#keywordBase", "#standardTypes", "#standardLib"]
  },
  keywordBase: {
    name: "keyword.typescript.ts",
    match: /\b(?:any|as|async|await|bigint|boolean|break|case|catch|const|continue|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|in|instanceof|interface|import|let|map|module|new|new|null|number|of|package|private|public|require|return|set|static|string|super|switch|this|throw|true|try|type|typeof|unknown|undefined|var|void|while|yield)\b/
  },
  standardTypes: {
    name: "keyword.type.ts",
    match: /\b(?:Promise|Record|Omit|Extract|Exclude|BigInt|Array)\b/
  },
  standardLib: {
    name: "keyword.lib.ts",
    match: /\b(?:console|process|window)\b/
  },
  string: {
    patterns: ["#string_q_single", "#string_q_double", "#string_template"]
  },
  string_q_single: {
    name: "string.quoted.single.ts",
    begin: "'",
    end: /'|((?:[^\\\n])$)/,
    captures: "punctuation.string.ts",
    patterns: [{ include: "#string_character_escape" }]
  },
  string_q_double: {
    name: "string.quoted.double.ts",
    begin: '"',
    end: /"|((?:[^\\\n])$)/,
    captures: "punctuation.string.ts",
    patterns: [{ include: "#string_character_escape" }]
  },
  string_template: {
    name: "string.template.ts",
    begin: "`",
    end: "`",
    captures: "punctuation.string.ts",
    patterns: [
      {
        name: "meta.template.expression.ts",
        contentName: "meta.embedded.line.ts",
        begin: "${",
        end: "}",
        patterns: ["#statements"],
        captures: "punctuation.definition.template.expression.ts"
      },
      { include: "#string_character_escape" }
    ]
  },
  string_character_escape: {
    name: "constant.character.escape.ts",
    match: /\\(x[0-9A-Fa-f]{2}|[0-3][0-7]{0,2}|[4-7][0-7]?|u[0-9A-Fa-f]{4}|.|\r?\n?$)/
  },
  braces: {
    patterns: [
      {
        begin: "(",
        end: ")",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      },
      {
        begin: "{",
        end: "}",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      },
      {
        begin: "[",
        end: "]",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      }
    ]
  },
  punctuation: {
    name: "punctuation.ts",
    match: /[-;:,!|&^%*/+=<>\n\r]/
  },
  space: {
    name: "punctuation.space.ts",
    match: /\s+/
  },
  comment: {
    patterns: [
      {
        name: "comment.line.ts",
        comment: "line comment",
        begin: "//",
        end: /(?=$)/,
        captures: "punctuation.definition.comment.ts"
      },
      {
        name: "comment.block.documentation.ts",
        comment: "DocBlock",
        begin: /\/\*\*(?!\/)/,
        captures: "punctuation.definition.comment.ts",
        end: "*/"
      },
      {
        name: "comment.block.ts",
        begin: "/*",
        end: "*/",
        captures: "punctuation.definition.comment.ts"
      }
    ]
  },
  regexp: {
    name: "regexp.ts",
    begin: /\/(?![/*])/,
    end: /\/([a-z]*)/i,
    beginCaptures: "punctuation.begin.regexp.ts",
    endCaptures: "punctuation.end.regexp.ts",
    patterns: ["#regexp_escape", "#regexp_brace"]
  },
  regexp_escape: {
    name: "escape.regexp.ts",
    match: /\\./
  },
  regexp_brace: {
    name: "brace.regexp.ts",
    begin: "[",
    end: "]",
    contentName: "character-class.regexp.ts",
    patterns: ["#regexp_escape"]
  }
};
var grammar = {
  name: "TypeScript",
  scopeName: "source.ts",
  patterns: [
    {
      name: "comment.line.shebang.ts",
      match: /^#!.*(?=$)/
    },
    {
      include: "#statements"
    }
  ],
  repository
};

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/mappers/appendMappedText.js
var import_node_assert13 = __toESM(require("node:assert"), 1);
function appendMappedText(a, b) {
  if (!a.map && !b.map) {
    return { text: a.text + b.text };
  }
  const aLen = a.text.length;
  const bLen = b.text.length;
  const aMap = [0, 0, ...a.map || [0, 0, aLen, aLen]];
  const bMap = [0, 0, ...b.map || [0, 0, bLen, bLen]];
  (0, import_node_assert13.default)(aMap[aMap.length - 1] === aLen);
  (0, import_node_assert13.default)(bMap[bMap.length - 1] === bLen);
  (0, import_node_assert13.default)((aMap.length & 1) === 0);
  (0, import_node_assert13.default)((bMap.length & 1) === 0);
  return {
    text: a.text + b.text,
    map: joinMaps(aMap, bMap)
  };
}
function joinMaps(aMap, bMap) {
  const n = aMap.length - 1;
  const offsets = [aMap[n - 1], aMap[n]];
  const ab = [...aMap, ...bMap.map((v, i) => v + offsets[i & 1])];
  const r = [0, 0];
  let last0 = 0, last1 = 0;
  for (let i = 0; i < ab.length; i += 2) {
    const v0 = ab[i];
    const v1 = ab[i + 1];
    if (v0 === last0 && v1 === last1) {
      continue;
    }
    r.push(v0, v1);
    last0 = v0;
    last1 = v1;
  }
  return r;
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/mappers/typescript.js
var hexChars = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15
};
var escapeChars = {
  t: "	",
  n: "\n",
  r: "\r",
  b: "\b",
  "\\": "\\",
  '"': '"',
  "'": "'",
  "\n": ""
};
function mapRawString(text) {
  const end = text.length;
  let t = "";
  const map3 = [];
  const isHex = /^[0-9a-fA-F]+$/;
  let i, j;
  for (i = 0, j = 0; i < end; ++i) {
    let parsed;
    const ti = text[i];
    if (ti === "\\") {
      map3.push(i, j);
      const tc = text[++i];
      const ec = escapeChars[tc];
      if (ec) {
        t += ec;
        j += ec.length;
        map3.push(i, j);
        continue;
      }
      switch (tc) {
        case "u": {
          {
            let char;
            let end2;
            if (text[i + 1] !== "{") {
              const digits = text.slice(i + 1, i + 5);
              parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
              char = Number.isNaN(parsed) ? "" : String.fromCodePoint(parsed);
              end2 = i + 4;
            } else {
              for (end2 = i + 2; text[end2] in hexChars; ++end2) {
              }
              if (text[end2] !== "}") {
                char = "";
              } else {
                const digits = text.slice(i + 2, end2);
                parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
                char = Number.isNaN(parsed) ? "" : String.fromCodePoint(parsed);
              }
            }
            if (!char) {
              t += tc;
              j += 1;
            } else {
              t += char;
              j += char.length;
              i = end2;
            }
          }
          break;
        }
        case "x": {
          {
            const digits = text.slice(i + 1, i + 3);
            parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
            if (Number.isNaN(parsed)) {
              t += tc;
              j += 1;
            } else {
              t += String.fromCodePoint(parsed);
              i += 2;
              ++j;
            }
          }
          break;
        }
        case "0": {
          t += "0";
          j += 1;
          break;
        }
        case "\r": {
          i += text[i + 1] === "\n" ? 1 : 0;
          break;
        }
        case "\n": {
          break;
        }
        case void 0: {
          break;
        }
        default: {
          t += tc;
          ++j;
          break;
        }
      }
      map3.push(i + 1, j);
      continue;
    }
    t += ti;
    ++j;
  }
  if (map3.length) {
    const ii = map3[map3.length - 2];
    const jj = map3[map3.length - 1];
    if (ii !== i || jj !== j) {
      map3.push(i, j);
    }
  }
  return {
    text: t,
    map: map3
  };
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parser/parser.js
function mapTokenizedLine(tl) {
  return tl.tokens.map((t) => ({
    text: t.text,
    range: [tl.offset + t.range[0], tl.offset + t.range[1]],
    scope: t.scope
  }));
}
function mapTokenizedLines(itl) {
  return pipeSync(itl, opMapSync(mapTokenizedLine), opFlattenSync());
}
function createParser(grammar2, name2, transform2 = mapTokenizedLines) {
  function parse3(content, filename) {
    const parsedTexts = pipeSync(tokenizeTextIterable(content, grammar2), transform2);
    return { content, filename, parsedTexts };
  }
  return { name: name2, parse: parse3 };
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parsers/typescript/TypeScriptParser.js
var tsGrammar = compileGrammar(grammar);
var pool = new ScopePool();
var useScope = /* @__PURE__ */ new WeakMap();
function* transform(texts) {
  for (const parsed of texts) {
    if (doesScopeMatch(parsed.scope, "constant.character.escape.ts")) {
      const mapped = mapRawString(parsed.text);
      const scope = parsed.scope ? pool.parseScope(parsed.scope) : void 0;
      yield {
        text: mapped.text,
        scope: scope?.parent,
        map: mapped.map,
        range: parsed.range
      };
      continue;
    }
    yield parsed;
  }
}
function* mergeStringResults(results) {
  let last;
  for (const next of results) {
    if (!doesScopeMatch(next.scope, "string.")) {
      if (last) {
        yield last;
        last = void 0;
      }
      yield next;
      continue;
    }
    if (!last) {
      last = next;
      continue;
    }
    if (next.scope !== last.scope || last.range[1] !== next.range[0]) {
      yield last;
      last = next;
      continue;
    }
    last = mergeParsedText(last, next);
  }
  if (last)
    yield last;
}
function mergeParsedText(a, b) {
  const abT = appendMappedText(a, b);
  const ab = {
    text: abT.text,
    scope: a.scope,
    range: [a.range[0], b.range[1]],
    map: abT.map,
    delegate: a.delegate
  };
  return ab;
}
function filterScope(scope) {
  const cached = useScope.get(scope);
  if (cached !== void 0)
    return cached;
  const value = scope.value;
  const use = !value.startsWith("punctuation") && !value.startsWith("keyword.");
  useScope.set(scope, use);
  return use;
}
function mapTokenizedLine2(tl) {
  return tl.tokens.filter((t) => filterScope(t.scope)).map((t) => ({
    text: t.text,
    range: [tl.offset + t.range[0], tl.offset + t.range[1]],
    scope: t.scope
  }));
}
function mapTokenizedLines2(itl) {
  return pipeSync(itl, opMapSync(mapTokenizedLine2), opFlattenSync(), transform, mergeStringResults);
}
var parser = createParser(tsGrammar, "typescript", mapTokenizedLines2);
function doesScopeMatch(s, match2) {
  if (!s)
    return false;
  return typeof s === "string" ? s.startsWith(match2) : s.value.startsWith(match2);
}

// ../node_modules/.pnpm/cspell-grammar@9.1.5/node_modules/cspell-grammar/dist/parsers/index.js
var parsers2 = [parser];

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Models/PatternRegExp.js
var PatternRegExp = class extends RegExp {
  constructor(pattern) {
    super(pattern);
  }
  toJSON() {
    return this.toString();
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/LanguageSettings.js
var defaultLocale = "en";
var defaultLanguageSettings = [];
function getDefaultLanguageSettings() {
  return defaultLanguageSettings;
}
function localesToList(locales) {
  return stringToList(locales.replaceAll(/\s+/g, ","));
}
function stringToList(sList) {
  return sList.replaceAll(/[|;]/g, ",").split(",").map((s) => s.trim()).filter((s) => !!s);
}
function memorizer(resolver) {
  const cache5 = createAutoResolveCache();
  return (k) => cache5.get(k, resolver);
}
var _normalizeLanguageId = memorizer(__normalizeLanguageId);
function __normalizeLanguageId(langId) {
  const langIds = stringToList(langId);
  return new Set(langIds.map((a) => a.toLowerCase()));
}
function normalizeLanguageId(langId) {
  return _normalizeLanguageId(typeof langId === "string" ? langId : langId.join(","));
}
var _normalizeLocale = memorizer(__normalizeLocale);
function __normalizeLocale(locale) {
  const locales = localesToList(locale);
  return new Set(locales.map((locale2) => locale2.toLowerCase().replaceAll(/[^a-z]/g, "")));
}
function normalizeLocale2(locale) {
  locale = typeof locale === "string" ? locale : locale.join(",");
  return _normalizeLocale(locale);
}
function normalizeLocaleIntl(locale) {
  const values = [...normalizeLocale2(locale)].map((locale2) => locale2.replace(/^([a-z]{2})-?([a-z]{2})$/, (_, lang, locale3) => locale3 ? `${lang}-${locale3.toUpperCase()}` : lang));
  return new Set(values);
}
function isLocaleInSet(locale, setOfLocals) {
  const locales = normalizeLocale2(locale);
  return doSetsIntersect(locales, setOfLocals);
}
var regExpValidIntlLocaleStrict = /^[a-z]{2}(-[A-Z]{2})?$/;
var regExpValidIntlLocale = new RegExp(regExpValidIntlLocaleStrict, "i");
function isValidLocaleIntlFormat(locale, strict = false) {
  if (typeof locale === "string")
    return strict ? regExpValidIntlLocaleStrict.test(locale) : regExpValidIntlLocale.test(locale);
  for (const item of locale) {
    if (!isValidLocaleIntlFormat(item, strict))
      return false;
  }
  return locale.length > 0;
}
var cacheCalcSettingsForLanguage = createAutoResolveWeakCache2();
function calcSettingsForLanguage(languageSettings, languageId, locale) {
  return cacheCalcSettingsForLanguage.get(languageSettings, () => new AutoResolveCache()).get(languageId, () => new AutoResolveCache()).get(locale, () => _calcSettingsForLanguage(languageSettings, languageId, locale));
}
function _calcSettingsForLanguage(languageSettings, languageId, locale) {
  languageId = languageId.toLowerCase();
  const allowedLocals = normalizeLocale2(locale);
  const ls = languageSettings.filter((s) => doesLanguageSettingMatchLanguageId(s, languageId)).filter((s) => !s.locale || s.locale === "*" || isLocaleInSet(s.locale, allowedLocals)).map((langSetting) => {
    const { languageId: _languageId, locale: _locale, ...s } = langSetting;
    return s;
  }).reduce((langSetting, setting) => mergeSettings(langSetting, setting), {});
  ls.languageId = languageId;
  ls.locale = locale;
  return ls;
}
var cacheDoesLanguageSettingMatchLanguageId = createAutoResolveWeakCache2();
function doesLanguageSettingMatchLanguageId(s, languageId) {
  return cacheDoesLanguageSettingMatchLanguageId.get(s, () => new AutoResolveCache()).get(languageId, () => _doesLanguageSettingMatchLanguageId(s, languageId));
}
function _doesLanguageSettingMatchLanguageId(s, languageId) {
  const languageSettingsLanguageIds = s.languageId;
  if (!languageSettingsLanguageIds || languageSettingsLanguageIds === "*")
    return true;
  const ids = normalizeLanguageId(languageSettingsLanguageIds);
  if (ids.has(languageId))
    return true;
  if (ids.has("!" + languageId))
    return false;
  const numExcludes = [...ids].filter((id) => id.startsWith("!")).length;
  return numExcludes === ids.size;
}
function calcUserSettingsForLanguage(settings, languageId) {
  const { languageSettings = [], language: locale = defaultLocale, allowCompoundWords, enabled } = settings;
  const langSettings = {
    allowCompoundWords,
    enabled,
    ...calcSettingsForLanguage(languageSettings, languageId, locale)
  };
  return mergeSettings(settings, langSettings);
}
function calcSettingsForLanguageId(baseSettings, languageId) {
  const langIds = ["*", ...normalizeLanguageId(languageId)];
  const langSettings = langIds.reduce((settings, languageId2) => {
    return calcUserSettingsForLanguage(settings, languageId2);
  }, baseSettings);
  return langSettings;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/RegExpPatterns.js
var regExMatchUrls = /(?:https?|ftp):\/\/[^\s"]+/gi;
var regExHRef = /\bhref\s*=\s*".*?"/gi;
var regExMatchCommonHexFormats = /(?:#[0-9a-f]{3,8})|(?:0x[0-9a-f]+)|(?:\\u[0-9a-f]{4})|(?:\\x\{[0-9a-f]{4}\})/gi;
var regExCommitHash = /\b(?![a-f]+\b)(?:0x)?[0-9a-f]{7,}\b/gi;
var regExCommitHashLink = /\[[0-9a-f]{7,}\]/gi;
var regExCStyleHexValue = /\b0x[0-9a-f_]+\b/gi;
var regExCSSHexValue = /#[0-9a-f]{3,8}\b/gi;
var regExUUID = /\b[0-9a-fx]{8}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{12}\b/gi;
var regExUnicodeRef = /\bU\+[0-9a-f]{4,5}(?:-[0-9a-f]{4,5})?/gi;
var regExSpellingGuardBlock = /(\bc?spell(?:-?checker)?::?)\s*disable(?!-line|-next)\b(?!-)[\s\S]*?((?:\1\s*enable\b)|$)/gi;
var regExSpellingGuardNext = /\bc?spell(?:-?checker)?::?\s*disable-next\b.*\s\s?.*/gi;
var regExSpellingGuardLine = /^.*\bc?spell(?:-?checker)?::?\s*disable-line\b.*/gim;
var regExIgnoreSpellingDirectives = /\bc?spell(?:-?checker)?::?\s*ignoreRegExp.*/gim;
var regExPublicKey = /-{5}BEGIN\s+((?:RSA\s+)?PUBLIC\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
var regExCert = /-{5}BEGIN\s+(CERTIFICATE|(?:RSA\s+)?(?:PRIVATE|PUBLIC)\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
var regExSshRSA = /ssh-rsa\s+[a-z0-9/+]{28,}={0,3}(?![a-z0-9/+=])/gi;
var regExEscapeCharacters2 = /\\(?:[anrvtbf]|[xu][a-f0-9]+)/gi;
var regExBase64 = /(?<![A-Za-z0-9/+])(?:[A-Za-z0-9/+]{40,})(?:\s^\s*[A-Za-z0-9/+]{40,})*(?:\s^\s*[A-Za-z0-9/+]+=*)?(?![A-Za-z0-9/+=])/gm;
var regExBase64SingleLine = /(?<=[^A-Za-z0-9/+_]|^)(?=[A-Za-z]{0,80}[0-9+/])(?=[A-Za-z0-9/+]{0,80}?[A-Z][a-z][A-Z])(?=[A-Za-z0-9/+]{0,80}?(?:[A-Z][0-9][A-Z]|[a-z][0-9][a-z]|[A-Z][0-9][a-z]|[a-z][0-9][A-Z]|[0-9][A-Za-z][0-9]))(?=[A-Za-z0-9/+]{0,80}?(?:[a-z]{3}|[A-Z]{3}))(?:[A-Za-z0-9/+]{40,})=*/gm;
var regExBase64MultiLine = /(?<![A-Za-z0-9/+])["']?(?:[A-Za-z0-9/+]{40,})["']?(?:\s^\s*["']?[A-Za-z0-9/+]{40,}["']?)+(?:\s^\s*["']?[A-Za-z0-9/+]+={0,3}["']?)?(?![A-Za-z0-9/+=])/gm;
var regExPhpHereDoc = /<<<['"]?(\w+)['"]?[\s\S]+?^\1;/gm;
var regExString = /(?:(['"]).*?(?<![^\\]\\(\\\\)*)\1)|(?:`[\s\S]*?(?<![^\\]\\(\\\\)*)`)/g;
var regExCStyleComments = /(?<!\w:)(?:\/\/.*)|(?:\/\*[\s\S]*?\*\/)/g;
var regExEmail = /<?\b[\w.\-+]{1,128}@\w{1,63}(\.\w{1,63}){1,4}\b>?/gi;
var regExRepeatedChar = /^(\w)\1{3,}$/i;
var regExSha = /\bsha\d+-[a-z0-9+/]{25,}={0,3}/gi;
var regExHashStrings = /(?:\b(?:sha\d+|md5|base64|crypt|bcrypt|scrypt|security-token|assertion)[-,:$=]|#code[/])[-\w/+%.]{25,}={0,3}(?:(['"])\s*\+?\s*\1?[-\w/+%.]+={0,3})*(?![-\w/+=%.])/gi;

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/DefaultSettings.js
var defaultConfigFile = () => resolveConfigModule(defaultConfigFileModuleRef);
var regExpSpellCheckerDisable = [
  new PatternRegExp(regExSpellingGuardBlock),
  new PatternRegExp(regExSpellingGuardLine),
  new PatternRegExp(regExSpellingGuardNext)
];
var predefinedPatterns = [
  // Exclude patterns
  { name: "CommitHash", pattern: regExCommitHash },
  { name: "CommitHashLink", pattern: regExCommitHashLink },
  { name: "CStyleHexValue", pattern: regExCStyleHexValue },
  { name: "CSSHexValue", pattern: regExCSSHexValue },
  { name: "Urls", pattern: regExMatchUrls },
  { name: "HexValues", pattern: regExMatchCommonHexFormats },
  { name: "SpellCheckerDisable", pattern: regExpSpellCheckerDisable },
  { name: "PublicKey", pattern: regExPublicKey },
  { name: "RsaCert", pattern: regExCert },
  { name: "SshRsa", pattern: regExSshRSA },
  { name: "EscapeCharacters", pattern: regExEscapeCharacters2 },
  { name: "Base64", pattern: regExBase64 },
  { name: "Base64SingleLine", pattern: regExBase64SingleLine },
  { name: "Base64MultiLine", pattern: regExBase64MultiLine },
  { name: "Email", pattern: regExEmail },
  { name: "SHA", pattern: regExSha },
  { name: "HashStrings", pattern: regExHashStrings },
  { name: "UnicodeRef", pattern: regExUnicodeRef },
  { name: "UUID", pattern: regExUUID },
  { name: "href", pattern: regExHRef },
  { name: "SpellCheckerDisableBlock", pattern: regExSpellingGuardBlock },
  { name: "SpellCheckerDisableLine", pattern: regExSpellingGuardLine },
  { name: "SpellCheckerDisableNext", pattern: regExSpellingGuardNext },
  { name: "SpellCheckerIgnoreInDocSetting", pattern: regExIgnoreSpellingDirectives },
  // Include Patterns
  { name: "PhpHereDoc", pattern: regExPhpHereDoc },
  { name: "string", pattern: regExString },
  { name: "CStyleComment", pattern: regExCStyleComments },
  { name: "Everything", pattern: ".*" }
];
var defaultRegExpPatterns = [...predefinedPatterns].map(normalizePattern2);
var definedDefaultRegExpExcludeList = [
  "SpellCheckerDisable",
  "SpellCheckerIgnoreInDocSetting",
  "Urls",
  "Email",
  "RsaCert",
  "SshRsa",
  "Base64MultiLine",
  "Base64SingleLine",
  "CommitHash",
  "CommitHashLink",
  "CStyleHexValue",
  "CSSHexValue",
  "SHA",
  "HashStrings",
  "UnicodeRef",
  "UUID"
];
var defaultRegExpExcludeList = definedDefaultRegExpExcludeList;
var _defaultSettingsBasis = Object.freeze(createCSpellSettingsInternal({
  id: "static_defaults",
  language: "en",
  name: "Static Defaults",
  enabled: true,
  enabledLanguageIds: [],
  maxNumberOfProblems: 100,
  numSuggestions: 10,
  suggestionsTimeout: 500,
  suggestionNumChanges: 3,
  words: [],
  userWords: [],
  ignorePaths: [],
  allowCompoundWords: false,
  patterns: defaultRegExpPatterns,
  ignoreRegExpList: [],
  languageSettings: [],
  source: { name: "defaultSettings" },
  reporters: [],
  plugins: [{ parsers: parsers2 }]
}));
var _defaultSettings = Object.freeze(createCSpellSettingsInternal({
  ..._defaultSettingsBasis,
  enabledFileTypes: { "*": true },
  ignoreRegExpList: defaultRegExpExcludeList,
  languageSettings: getDefaultLanguageSettings()
}));
async function resolveConfigModule(configModuleName) {
  return (await resolveFile(configModuleName, srcDirectory)).filename;
}
function normalizePattern2(pat) {
  const { name: name2, pattern, description } = pat;
  if (!(pattern instanceof RegExp))
    return pat;
  return {
    name: name2,
    pattern: new PatternRegExp(pattern),
    description
  };
}
var DefaultSettingsLoader = class {
  settings = void 0;
  pending = void 0;
  constructor() {
    this.getDefaultSettingsAsync().catch(() => void 0);
  }
  getDefaultSettingsAsync(useDefaultDictionaries = true) {
    if (!useDefaultDictionaries) {
      return Promise.resolve(_defaultSettingsBasis);
    }
    if (this.settings)
      return Promise.resolve(this.settings);
    if (this.pending)
      return this.pending;
    this.pending = (async () => {
      const defaultConfigLocation = await defaultConfigFile();
      const jsonSettings = await readSettings(defaultConfigLocation);
      this.settings = mergeSettings(_defaultSettings, jsonSettings);
      if (jsonSettings.name !== void 0) {
        this.settings.name = jsonSettings.name;
      } else {
        delete this.settings.name;
      }
      return this.settings;
    })();
    return this.pending;
  }
};
var defaultSettingsLoader = new DefaultSettingsLoader();
function getDefaultSettings(useDefaultDictionaries = true) {
  return defaultSettingsLoader.getDefaultSettingsAsync(useDefaultDictionaries);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/search.js
function binarySearch(arr, item, leftOffset, rightOffset) {
  let left = Math.max(leftOffset ?? 0, 0);
  let right = Math.min(rightOffset ?? arr.length, arr.length);
  while (left < right) {
    const pos = left + right >> 1;
    if (arr[pos] < item) {
      left = pos + 1;
    } else {
      right = pos;
    }
  }
  return left;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/text.js
function splitCamelCaseWordWithOffset(wo) {
  return splitCamelCaseWord(wo.text).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
    text: "",
    offset: wo.offset
  }));
}
function splitCamelCaseWord(word) {
  return splitWord(word, regExpCamelCaseWordBreaksWithEnglishSuffix);
}
function splitWordWithOffset(wo, regExpWordBreaks) {
  return splitWord(wo.text, regExpWordBreaks).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
    text: "",
    offset: wo.offset
  }));
}
function splitWord(word, regExpWordBreaks) {
  return word.split(regExpWordBreaks);
}
function match(reg, text) {
  if (!text)
    return [];
  reg = reg.global ? reg : new RegExp(reg.source, reg.flags + "g");
  return text.matchAll(reg);
}
function matchStringToTextOffset(reg, text) {
  return matchToTextOffset(reg, { text, offset: 0 });
}
function matchToTextOffset(reg, t) {
  const text = t.text;
  const offset = t.offset;
  return pipeSync(match(reg, text), opMapSync((m) => ({ text: m[0], offset: offset + m.index })));
}
function* extractLinesOfText(text) {
  let i = 0;
  for (let j = text.indexOf("\n", i); j >= 0; j = text.indexOf("\n", i)) {
    const end = j + 1;
    yield { text: text.slice(i, end), offset: i };
    i = end;
  }
  yield { text: text.slice(i, text.length), offset: i };
}
function extractWordsFromText(text) {
  return extractWordsFromTextOffset(textOffset(text));
}
function extractWordsFromTextOffset(text) {
  const reg = new RegExp(regExWords);
  return matchToTextOffset(reg, cleanTextOffset(text));
}
function cleanText(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text))
    return text;
  text = text.replace(regExIgnoreCharacters, (match2) => " ".repeat(match2.length));
  return text;
}
function cleanTextOffset(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text.text))
    return text;
  return {
    text: cleanText(text.text),
    offset: text.offset
  };
}
function extractPossibleWordsFromTextOffset(text) {
  const reg = new RegExp(regExWordsAndDigits);
  return matchToTextOffset(reg, text);
}
function extractWordsFromCode(text) {
  return extractWordsFromCodeTextOffset(textOffset(text));
}
function extractWordsFromCodeTextOffset(textOffset2) {
  return pipeSync(extractWordsFromTextOffset(textOffset2), opConcatMapSync(splitCamelCaseWordWithOffset));
}
function isUpperCase2(word) {
  return regExAllUpper2.test(word);
}
function isLowerCase(word) {
  return regExAllLower.test(word);
}
function isFirstCharacterUpper(word) {
  return isUpperCase2(word.slice(0, 1));
}
function isFirstCharacterLower(word) {
  return isLowerCase(word.slice(0, 1));
}
function ucFirst2(word) {
  return word.slice(0, 1).toUpperCase() + word.slice(1);
}
function lcFirst(word) {
  return word.slice(0, 1).toLowerCase() + word.slice(1);
}
function snakeToCamel(word) {
  return word.split("_").map(ucFirst2).join("");
}
function camelToSnake(word) {
  return splitCamelCaseWord(word).join("_").toLowerCase();
}
function matchCase(example, word) {
  if (regExFirstUpper.test(example)) {
    return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();
  }
  if (regExAllLower.test(example)) {
    return word.toLowerCase();
  }
  if (regExAllUpper2.test(example)) {
    return word.toUpperCase();
  }
  if (isFirstCharacterUpper(example)) {
    return ucFirst2(word);
  }
  if (isFirstCharacterLower(example)) {
    return lcFirst(word);
  }
  return word;
}
function textOffset(text, offset = 0) {
  return { text, offset };
}
function extractText(textOffset2, startPos, endPos) {
  const { text, offset: orig } = textOffset2;
  const a = Math.max(startPos - orig, 0);
  const b = Math.max(endPos - orig, 0);
  return text.slice(a, b);
}
function calculateTextDocumentOffsets(uri, doc, wordOffsets) {
  const lines = [
    -1,
    ...pipeSync(match(/\n/g, doc), opMapSync((a) => a.index)),
    doc.length
  ];
  let lastRow = -1;
  let lastOffset = doc.length + 1;
  let lastLineRow = -1;
  let lastLine;
  function findRowCol(offset) {
    const row = binarySearch(lines, offset, offset >= lastOffset ? lastRow : void 0);
    const col = offset - lines[Math.max(0, row - 1)];
    lastOffset = offset;
    lastRow = row;
    return [row, col];
  }
  function extractLine(row) {
    const offset = lines[row - 1] + 1;
    const text = doc.slice(offset, lines[row] + 1);
    return { text, offset };
  }
  function calcLine(row) {
    const last = lastLineRow === row ? lastLine : void 0;
    lastLineRow = row;
    const r = last ?? extractLine(row);
    lastLine = r;
    return r;
  }
  const _uri = toUri(uri).toString();
  return wordOffsets.map((wo) => {
    const [row, col] = findRowCol(wo.offset);
    return { ...wo, row, col, doc, uri: _uri, line: calcLine(row) };
  });
}
function removeAccents2(text) {
  return text.normalize("NFD").replace(regExAccents2, "");
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/InDocSettings.js
var regExMatchRegEx = /\/.*\/[gimuy]*/;
var regExCSpellInDocDirective = /\b(?:spell-?checker|c?spell)::?(.*)/gi;
var regExCSpellDirectiveKey = /(?<=\b(?:spell-?checker|c?spell)::?)(?!:)(.*)/i;
var regExInFileSettings = [regExCSpellInDocDirective, /\b(LocalWords:?.*)/g];
var officialDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next",
  "disable-next-line",
  "word",
  "words",
  "ignore",
  "ignoreWord",
  "ignoreWords",
  "ignore-word",
  "ignore-words",
  "includeRegExp",
  "ignoreRegExp",
  "local",
  // Do not suggest.
  "locale",
  "language",
  "dictionaries",
  "dictionary",
  "forbid",
  "forbidWord",
  "forbid-word",
  "flag",
  "flagWord",
  "flag-word",
  "enableCompoundWords",
  "enableAllowCompoundWords",
  "disableCompoundWords",
  "disableAllowCompoundWords",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var noSuggestDirectives = /* @__PURE__ */ new Set(["local"]);
var preferredDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next-line",
  "words",
  "ignore",
  "forbid",
  "locale",
  "dictionary",
  "dictionaries",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var allDirectives = /* @__PURE__ */ new Set([...preferredDirectives, ...officialDirectives]);
var allDirectiveSuggestions = [
  ...pipeSync(allDirectives, opMapSync((word) => ({ word })))
];
var dictInDocSettings = createSpellingDictionary(allDirectives, "Directives", "Directive List", {
  supportNonStrictSearches: false
});
var EmptyWords = [];
Object.freeze(EmptyWords);
var staticInDocumentDictionaryName = `[in-document-dict]`;
function collectInDocumentDirectives(text) {
  const dirs = [...getPossibleInDocSettings(text)].flatMap((a) => associateDirectivesWithParsers(a));
  return dirs;
}
var baseInDocSettings = { id: "in-doc-settings" };
Object.freeze(baseInDocSettings);
function getInDocumentSettings(text) {
  const found = collectInDocumentDirectives(text);
  if (!found.length)
    return { ...baseInDocSettings };
  const collectedSettings = reducePossibleMatchesToSettings(found, { ...baseInDocSettings });
  const { words, flagWords, ignoreWords, suggestWords, dictionaries = [], dictionaryDefinitions = [], ...rest } = collectedSettings;
  const dict = (words || flagWords || ignoreWords || suggestWords) && clean3({
    name: staticInDocumentDictionaryName,
    words,
    flagWords,
    ignoreWords,
    suggestWords
  });
  const dictSettings = dict ? {
    dictionaries: [...dictionaries, staticInDocumentDictionaryName],
    dictionaryDefinitions: [...dictionaryDefinitions, dict]
  } : clean3({
    dictionaries: dictionaries.length ? dictionaries : void 0,
    dictionaryDefinitions: dictionaryDefinitions.length ? dictionaryDefinitions : void 0
  });
  const settings = {
    ...rest,
    ...dictSettings
  };
  return settings;
}
function validateInDocumentSettings(docText, _settings) {
  return pipeSync(getPossibleInDocSettings(docText), opMapSync(parseSettingMatchValidation), opFilterSync(isDefined3));
}
var settingParsers = [
  [/^(?:enable|disable)(?:allow)?CompoundWords\b(?!-)/i, parseCompoundWords, "CompoundWords"],
  [/^(?:enable|disable)CaseSensitive\b(?!-)/i, parseCaseSensitive, "CaseSensitive"],
  [/^enable\b(?!-)/i, parseEnable, "Enable"],
  [/^disable(-line|-next(-line)?)?\b(?!-)/i, parseDisable, "Disable"],
  [/^words?\b(?!-)/i, parseWords, "Words"],
  [/^ignore(?:-?words?)?\b(?!-)/i, parseIgnoreWords, "Ignore"],
  [/^(?:flag|forbid)(?:-?words?)?\b(?!-)/i, parseFlagWords, "Flag"],
  [/^ignore_?Reg_?Exp\s+.+$/i, parseIgnoreRegExp, "IgnoreRegExp"],
  [/^include_?Reg_?Exp\s+.+$/i, parseIncludeRegExp, "IncludeRegExp"],
  [/^locale?\b(?!-)/i, parseLocale2, "Locale"],
  [/^language\s\b(?!-)/i, parseLocale2, "Locale"],
  [/^dictionar(?:y|ies)\b(?!-)/i, parseDictionaries, "Dictionaries"],
  // cspell:disable-line
  [/^LocalWords:/, (acc, m) => reduceWordList(acc, m.replaceAll(/^LocalWords:?/gi, " "), "words"), "Words"]
];
var issueMessages = {
  unknownDirective: "Unknown CSpell directive"
};
function parseSettingMatchValidation(possibleMatch) {
  const { fullDirective, offset } = possibleMatch;
  const directiveMatch = fullDirective.match(regExCSpellDirectiveKey);
  if (!directiveMatch)
    return void 0;
  const match2 = directiveMatch[1];
  const possibleSetting = match2.trim();
  if (!possibleSetting)
    return void 0;
  const start = offset + (directiveMatch.index || 0) + (match2.length - match2.trimStart().length);
  const text = possibleSetting.replace(/^([-\w]+)?.*/, "$1");
  const end = start + text.length;
  if (!text)
    return void 0;
  const matchingParsers = settingParsers.filter(([regex]) => regex.test(possibleSetting));
  if (matchingParsers.length > 0)
    return void 0;
  const dictSugs = dictInDocSettings.suggest(text, { ignoreCase: false }).map(({ word, isPreferred }) => isPreferred ? { word, isPreferred } : { word }).filter((a) => !noSuggestDirectives.has(a.word));
  const sugs = pipeSync(dictSugs, opAppendSync(allDirectiveSuggestions), filterUniqueSuggestions);
  const suggestionsEx = [...sugs].slice(0, 8);
  const suggestions2 = suggestionsEx.map((s) => s.word);
  const issue = {
    range: [start, end],
    text,
    message: issueMessages.unknownDirective,
    suggestions: suggestions2,
    suggestionsEx
  };
  return issue;
}
function* filterUniqueSuggestions(sugs) {
  const map3 = /* @__PURE__ */ new Map();
  for (const sug of sugs) {
    const existing = map3.get(sug.word);
    if (existing && sug.isPreferred) {
      existing.isPreferred = true;
    }
    yield sug;
  }
}
function associateDirectivesWithParsers(possibleMatch) {
  const { match: match2 } = possibleMatch;
  const possibleSetting = match2.trim();
  return settingParsers.filter(([regex]) => regex.test(possibleSetting)).map(([, fn, directive]) => ({ ...possibleMatch, directive, fn }));
}
function mergeDirectiveIntoSettings(settings, directive) {
  return directive.fn(settings, directive.match);
}
function reducePossibleMatchesToSettings(directives, settings) {
  for (const directive of directives) {
    settings = mergeDirectiveIntoSettings(settings, directive);
  }
  return settings;
}
function parseCompoundWords(acc, match2) {
  acc.allowCompoundWords = /enable/i.test(match2);
  return acc;
}
function parseCaseSensitive(acc, match2) {
  acc.caseSensitive = /enable/i.test(match2);
  return acc;
}
function splitWords(match2) {
  return match2.split(/[,\s;]+/g).slice(1).filter((a) => !!a);
}
function mergeList2(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  return [...a, ...b];
}
function reduceWordList(acc, match2, key) {
  const words = splitWords(match2);
  if (words.length) {
    acc[key] = mergeList2(acc[key], words);
  }
  return acc;
}
function parseWords(acc, match2) {
  return reduceWordList(acc, match2, "words");
}
function parseLocale2(acc, match2) {
  const parts = match2.trim().split(/[\s,]+/);
  const language = parts.slice(1).join(",");
  if (language) {
    acc.language = language;
  }
  return acc;
}
function parseIgnoreWords(acc, match2) {
  return reduceWordList(acc, match2, "ignoreWords");
}
function parseFlagWords(acc, match2) {
  return reduceWordList(acc, match2, "flagWords");
}
function parseRegEx(match2) {
  const patterns = [match2.replace(/^[^\s]+\s+/, "")].map((a) => {
    const m = a.match(regExMatchRegEx);
    if (m && m[0]) {
      return m[0];
    }
    return a.replace(/((?:[^\s]|\\ )+).*/, "$1");
  });
  return patterns;
}
function parseIgnoreRegExp(acc, match2) {
  const ignoreRegExpList = parseRegEx(match2);
  if (ignoreRegExpList.length) {
    acc.ignoreRegExpList = mergeList2(acc.ignoreRegExpList, ignoreRegExpList);
  }
  return acc;
}
function parseIncludeRegExp(acc, match2) {
  const includeRegExpList = parseRegEx(match2);
  if (includeRegExpList.length) {
    acc.includeRegExpList = mergeList2(acc.includeRegExpList, includeRegExpList);
  }
  return acc;
}
function parseDictionaries(acc, match2) {
  const dictionaries = match2.split(/[,\s]+/g).slice(1);
  if (dictionaries.length) {
    acc.dictionaries = mergeList2(acc.dictionaries, dictionaries);
  }
  return acc;
}
function getPossibleInDocSettings(text) {
  return pipeSync(regExInFileSettings, opMapSync((regexp) => match(regexp, text)), opFlattenSync(), opMapSync((match2) => ({ fullDirective: match2[0], offset: match2.index, match: match2[1].trim() })));
}
function parseEnable(acc, _match) {
  return acc;
}
function parseDisable(acc, _match) {
  return acc;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/Settings/TextDocumentSettings.js
function combineTextAndLanguageSettings(settings, text, languageId) {
  if (!text) {
    return toInternalSettings(calcSettingsForLanguageId(settings, languageId));
  }
  const docSettings = extractSettingsFromText(text);
  const settingsForText = mergeSettings(settings, docSettings);
  const langSettings = calcSettingsForLanguageId(settingsForText, languageId);
  const final = mergeSettings(langSettings, docSettings);
  return final;
}
function extractSettingsFromText(text) {
  return getInDocumentSettings(text);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/determineTextDocumentSettings.js
var path12 = __toESM(require("node:path"), 1);
async function determineTextDocumentSettings(doc, settings) {
  const filename = uriToFilePath(doc.uri);
  const settingsWithDefaults = mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings);
  const fileSettings = calcOverrideSettings(settingsWithDefaults, filename);
  const languageIds2 = fileSettings?.languageId?.length ? fileSettings.languageId : doc.languageId ? doc.languageId : getLanguageForFilename(filename);
  if (doc.locale) {
    fileSettings.language = doc.locale;
  }
  return combineTextAndLanguageSettings(fileSettings, doc.text, languageIds2);
}
function getLanguageForFilename(filename) {
  const basename5 = path12.basename(filename);
  return findMatchingFileTypes(basename5);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
var import_node_assert17 = __toESM(require("node:assert"), 1);

// ../node_modules/.pnpm/@cspell+cspell-types@9.1.5/node_modules/@cspell/cspell-types/dist/index.mjs
var IssueType = /* @__PURE__ */ function(IssueType$1) {
  IssueType$1[IssueType$1["spelling"] = 0] = "spelling";
  IssueType$1[IssueType$1["directive"] = 1] = "directive";
  return IssueType$1;
}({});
var MessageTypes = {
  Debug: "Debug",
  Info: "Info",
  Warning: "Warning"
};
var unknownWordsChoices = {
  ReportAll: "report-all",
  ReportSimple: "report-simple",
  ReportCommonTypos: "report-common-typos",
  ReportFlagged: "report-flagged"
};
var defaultCSpellSettings = {
  ignoreRandomStrings: true,
  minRandomLength: 40
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/suggestions.js
var import_node_assert14 = __toESM(require("node:assert"), 1);

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/memorizeLastCall.js
function memorizeLastCall2(fn) {
  let last;
  return (...p) => {
    if (last && isArrayEqual(last.args, p)) {
      return last.value;
    }
    const args = p;
    const value = fn(...args);
    last = { args, value };
    return value;
  };
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/suggestions.js
var emptySuggestionOptions = Object.freeze({});
var emptyCSpellSettings = Object.freeze({});
var memorizeSuggestions = memorizeLastCall2(cacheSuggestionsForWord);
function cacheSuggestionsForWord(options, settings) {
  const cache5 = createAutoResolveCache();
  return (word) => cache5.get(word, (word2) => _suggestionsForWord(word2, options, settings));
}
async function _suggestionsForWord(word, options, settings) {
  const { languageId, locale: language, includeDefaultConfig = true, dictionaries } = options;
  async function determineDictionaries(config2) {
    const withLocale = mergeSettings(config2, clean3({
      language: language || config2.language
      // dictionaries: dictionaries?.length ? dictionaries : config.dictionaries,
    }));
    const withLanguageId = calcSettingsForLanguageId(withLocale, languageId ?? withLocale.languageId ?? "plaintext");
    const settings2 = finalizeSettings(withLanguageId);
    settings2.dictionaries = dictionaries?.length ? dictionaries : settings2.dictionaries || [];
    validateDictionaries(settings2, dictionaries);
    const dictionaryCollection2 = await getDictionaryInternal(settings2);
    settings2.dictionaries = settings2.dictionaryDefinitions?.map((def) => def.name) || [];
    const allDictionaryCollection2 = await getDictionaryInternal(settings2);
    return {
      dictionaryCollection: dictionaryCollection2,
      allDictionaryCollection: allDictionaryCollection2
    };
  }
  await refreshDictionaryCache();
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings) : settings;
  const { dictionaryCollection, allDictionaryCollection } = await determineDictionaries(config);
  return _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection);
}
async function _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection) {
  const extendsDictionaryCollection = allDictionaryCollection || dictionaryCollection;
  const { locale: language, strict = true, numChanges = 4, numSuggestions = 8, includeTies = true, includeDefaultConfig = true } = options;
  const ignoreCase2 = !strict;
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings) : settings;
  const opts = { ignoreCase: ignoreCase2, numChanges, numSuggestions, includeTies };
  const suggestionsByDictionary = dictionaryCollection.dictionaries.flatMap((dict) => dict.suggest(word, opts).map((r) => ({ ...r, dictName: dict.name })));
  const locale = adjustLocale(language || config.language || void 0);
  const collator2 = Intl.Collator(locale);
  const combined = limitResults(combine3(suggestionsByDictionary.sort((a, b) => a.cost - b.cost || collator2.compare(a.word, b.word))), numSuggestions, includeTies);
  const sugsAdjusted = calcSuggestionAdjustedToToMatchCase(word, combined, locale, ignoreCase2, extendsDictionaryCollection);
  const allSugs = sugsAdjusted.map((sug) => {
    const found = extendsDictionaryCollection.find(sug.word);
    return {
      ...sug,
      forbidden: found?.forbidden || false,
      noSuggest: found?.noSuggest || false
    };
  });
  return {
    word,
    suggestions: limitResults(allSugs, numSuggestions, includeTies)
  };
}
function combine3(suggestions2) {
  const words = /* @__PURE__ */ new Map();
  for (const sug of suggestions2) {
    const { word, cost, dictName, ...rest } = sug;
    const f = words.get(word) || { word, cost, ...rest, dictionaries: [] };
    f.cost = Math.min(f.cost, cost);
    f.dictionaries.push(dictName);
    f.dictionaries.sort();
    words.set(word, f);
  }
  return [...words.values()];
}
function adjustLocale(locale) {
  if (!locale)
    return void 0;
  const locales = [...normalizeLocaleIntl(locale)].filter((locale2) => isValidLocaleIntlFormat(locale2));
  if (!locales.length)
    return void 0;
  if (locales.length === 1)
    return locales[0];
  return locales;
}
function calcSuggestionAdjustedToToMatchCase(originalWord, sugs, locale, ignoreCase2, dict) {
  locale = adjustLocale(locale);
  const knownSugs = new Set(sugs.map((sug) => sug.word));
  const matchStyle = { ...analyzeCase(originalWord), locale, ignoreCase: ignoreCase2 };
  return sugs.map((sug) => {
    const alt = matchCase2(sug.word, !!sug.isPreferred, matchStyle);
    if (alt === sug.word || knownSugs.has(alt))
      return sug;
    const found = dict.find(alt);
    if (!found || !found.forbidden || !found.noSuggest) {
      knownSugs.add(alt);
      return { ...sug, wordAdjustedToMatchCase: alt };
    }
    return sug;
  });
}
function limitResults(suggestions2, numSuggestions, includeTies) {
  let cost = suggestions2[0]?.cost;
  let i = 0;
  for (; i < suggestions2.length; ++i) {
    if (i >= numSuggestions && (!includeTies || suggestions2[i].cost > cost)) {
      break;
    }
    cost = suggestions2[i].cost;
  }
  return suggestions2.slice(0, i);
}
function validateDictionaries(settings, dictionaries) {
  if (!dictionaries?.length)
    return;
  const knownDicts2 = new Set(settings.dictionaryDefinitions?.map((def) => def.name) || []);
  for (const dict of dictionaries) {
    if (!knownDicts2.has(dict)) {
      throw new SuggestionError(`Unknown dictionary: "${dict}"`, "E_dictionary_unknown");
    }
  }
}
function matchCase2(word, isPreferred, style) {
  const locale = style.locale;
  if (style.isMixedCaps) {
    return word;
  }
  if (hasCaps(word)) {
    if (style.isAllCaps)
      return word.toLocaleUpperCase(locale);
    if (!style.ignoreCase || style.hasCaps || isPreferred)
      return word;
    if (isTitleCase(word) || isAllCaps(word))
      return word.toLocaleLowerCase(locale);
    return word;
  }
  if (!style.hasCaps)
    return word;
  if (style.isAllCaps)
    return word.toLocaleUpperCase(locale);
  (0, import_node_assert14.default)(style.isTitleCase);
  return word.replace(/^\p{L}/u, (firstLetter) => firstLetter.toLocaleUpperCase(locale));
}
var regExpHasCaps = /\p{Lu}/u;
var regExpIsAllCaps = /^[\P{L}\p{Lu}]+$/u;
var regExpIsTitleCase = /^\p{Lu}[\P{L}\p{Ll}]+$/u;
function analyzeCase(word) {
  const hasCaps2 = regExpHasCaps.test(word);
  const isAllCaps2 = hasCaps2 && regExpIsAllCaps.test(word);
  const isTitleCase2 = hasCaps2 && !isAllCaps2 && regExpIsTitleCase.test(word);
  const isMixedCaps = hasCaps2 && !isAllCaps2 && !isTitleCase2;
  return { hasCaps: hasCaps2, isAllCaps: isAllCaps2, isMixedCaps, isTitleCase: isTitleCase2 };
}
function hasCaps(word) {
  return regExpHasCaps.test(word);
}
function isTitleCase(word) {
  return regExpIsTitleCase.test(word);
}
function isAllCaps(word) {
  return regExpIsAllCaps.test(word);
}
var SuggestionError = class extends Error {
  code;
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/defaultConstants.js
var defaultMaxNumberOfProblems = 200;
var defaultMaxDuplicateProblems = 5;
var defaultMinWordLength = 4;

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
var import_node_assert16 = __toESM(require("node:assert"), 1);

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/PairingHeap.js
var PairingHeap2 = class {
  compare;
  _heap;
  _size = 0;
  constructor(compare3) {
    this.compare = compare3;
  }
  add(v) {
    this._heap = insert2(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  dequeue() {
    const n = this.next();
    if (n.done)
      return void 0;
    return n.value;
  }
  append(i) {
    for (const v of i) {
      this.add(v);
    }
    return this;
  }
  next() {
    if (!this._heap) {
      return { value: void 0, done: true };
    }
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead2(this.compare, this._heap);
    return { value };
  }
  peek() {
    return this._heap?.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  get length() {
    return this._size;
  }
};
function removeHead2(compare3, heap) {
  if (!heap || !heap.c)
    return void 0;
  return mergeSiblings2(compare3, heap.c);
}
function insert2(compare3, heap, v) {
  const n = {
    v,
    s: void 0,
    c: void 0
  };
  if (!heap || compare3(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge3(compare3, a, b) {
  if (compare3(a.v, b.v) <= 0) {
    a.s = void 0;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = void 0;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings2(compare3, n) {
  if (!n.s)
    return n;
  const s = n.s;
  const ss = s.s;
  const m = merge3(compare3, n, s);
  return ss ? merge3(compare3, m, mergeSiblings2(compare3, ss)) : m;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/regexHelper.js
function escapeRegEx3(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/wordSplitter.js
var ignoreBreak = Object.freeze([]);
function split(line, offset, isValidWord, options = {}) {
  const relWordToSplit = findNextWordText({ text: line.text, offset: offset - line.offset });
  const lineOffset = line.offset;
  const requested = /* @__PURE__ */ new Map();
  const regExpIgnoreSegment = /^[-.+\d_eE'`\\\s]+$/;
  if (!relWordToSplit.text) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [],
      endOffset: text.offset + text.text.length
    };
  }
  const lineSegment = {
    line,
    relStart: relWordToSplit.offset,
    relEnd: relWordToSplit.offset + relWordToSplit.text.length
  };
  const possibleBreaks = generateWordBreaks(lineSegment, options);
  if (!possibleBreaks.length) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [{ ...text, isFound: isValidWord(text) }],
      endOffset: text.offset + text.text.length
    };
  }
  function rebaseTextOffset(relText) {
    return {
      ...relText,
      offset: relText.offset + lineOffset
    };
  }
  function has(word) {
    if (regExpIgnoreSegment.test(word.text)) {
      return true;
    }
    const i = word.offset;
    const j = word.text.length;
    let v = i + (j << 20);
    if (i < 1 << 20 && j < 1 << 11) {
      const b = requested.get(v);
      if (b !== void 0)
        return b;
    } else {
      v = -1;
    }
    const r = isValidWord(rebaseTextOffset(word));
    if (v >= 0) {
      requested.set(v, r);
    }
    return r;
  }
  possibleBreaks.push({
    offset: lineSegment.relEnd,
    breaks: [ignoreBreak]
  });
  const result = {
    line,
    offset,
    text: rebaseTextOffset(relWordToSplit),
    words: splitIntoWords(lineSegment, possibleBreaks, has).map(rebaseTextOffset),
    endOffset: lineOffset + lineSegment.relEnd
  };
  return result;
}
function findNextWordText({ text, offset }) {
  const reg = new RegExp(regExWordsAndDigits);
  reg.lastIndex = offset;
  const m = reg.exec(text);
  if (!m) {
    return {
      text: "",
      offset: offset + text.length
    };
  }
  if (regExNumericLiteral.test(m[0])) {
    return findNextWordText({ text, offset: offset + m[0].length });
  }
  return {
    text: m[0],
    offset: m.index
  };
}
function generateWordBreaks(line, options) {
  const camelBreaks = genWordBreakCamel(line);
  const symbolBreaks = genSymbolBreaks(line);
  const optionalBreaks = genOptionalWordBreaks(line, options.optionalWordBreakCharacters);
  return mergeSortedBreaks(...camelBreaks, ...symbolBreaks, ...optionalBreaks);
}
function offsetRegEx(reg, offset) {
  const r = new RegExp(reg);
  r.lastIndex = offset;
  return r;
}
function genWordBreakCamel(line) {
  const breaksCamel1 = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(regExSplitWords, line.relStart))) {
    if (m.index === void 0)
      break;
    const i = m.index + m[1].length;
    breaksCamel1.push({
      offset: m.index,
      breaks: [[i, i], ignoreBreak]
    });
  }
  const breaksCamel2 = [];
  for (const m of text.matchAll(offsetRegEx(regExSplitWords2, line.relStart))) {
    if (m.index === void 0)
      break;
    const i = m.index + m[1].length;
    const j = i + m[3].length;
    breaksCamel2.push({
      offset: m.index,
      breaks: [[i, i], [j, j], ignoreBreak]
    });
  }
  return [breaksCamel1, breaksCamel2];
}
function calcBreaksForRegEx(line, reg, calcBreak) {
  const sb = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(reg, line.relStart))) {
    const b = calcBreak(m);
    if (b) {
      sb.push(b);
    }
  }
  return sb;
}
function genOptionalWordBreaks(line, optionalBreakCharacters) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === void 0)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        // Remove the characters
        ignoreBreak
      ]
    };
  }
  const breaks = [
    calcBreaksForRegEx(line, regExDanglingQuote, calcBreaks),
    calcBreaksForRegEx(line, regExTrailingEndings, calcBreaks)
  ];
  if (optionalBreakCharacters) {
    const regex = new RegExp(`[${escapeRegEx3(optionalBreakCharacters)}]`, "gu");
    breaks.push(calcBreaksForRegEx(line, regex, calcBreaks));
  }
  return breaks;
}
function genSymbolBreaks(line) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === void 0)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        // Remove the characters
        [i, i],
        // keep characters with word to right
        [j, j],
        // keep characters with word to left
        ignoreBreak
      ]
    };
  }
  return [
    calcBreaksForRegEx(line, regExPossibleWordBreaks, calcBreaks),
    calcBreaksForRegEx(line, /\d+/g, calcBreaks),
    calcBreaksForRegEx(line, regExEscapeCharacters, calcBreaks)
  ];
}
function splitIntoWords(lineSeg, breaks, has) {
  const maxIndex = lineSeg.relEnd;
  const maxAttempts = 1e3;
  const knownPathsByIndex = /* @__PURE__ */ new Map();
  function makeCandidates(p, i, bi, currentCost) {
    const len = maxIndex;
    while (bi < breaks.length && breaks[bi].offset < i) {
      bi += 1;
    }
    if (bi >= breaks.length) {
      return [];
    }
    const br = breaks[bi];
    function c(bp) {
      const d = bp.length < 2 ? len - i : (bp[0] - i) * 0.5 + len - bp[1];
      const ec = currentCost + d;
      return {
        p,
        i,
        bi,
        bp,
        c: currentCost,
        ec,
        text: void 0
      };
    }
    return br.breaks.map(c);
  }
  function checkTextOffset(text2, offset) {
    const valid = has({ text: text2, offset });
    return {
      text: text2,
      offset,
      isFound: valid
    };
  }
  function compare3(a, b) {
    return a.ec - b.ec || b.i - a.i;
  }
  function pathToWords(node) {
    const results = [];
    for (let p = node; p; p = p.n) {
      if (p.text) {
        results.push(p.text);
      }
    }
    return results;
  }
  function addToKnownPaths(candidate, path17) {
    for (let can = candidate; can !== void 0; can = can.p) {
      const t = can.text;
      const i = can.i;
      const cost = (!t || t.isFound ? 0 : t.text.length) + (path17?.c ?? 0);
      const exitingPath = knownPathsByIndex.get(i);
      if (exitingPath && exitingPath.c <= cost) {
        return void 0;
      }
      const node = {
        n: path17,
        i,
        c: cost,
        text: t
      };
      knownPathsByIndex.set(i, node);
      path17 = node;
    }
    return path17;
  }
  let maxCost = lineSeg.relEnd - lineSeg.relStart;
  const candidates = new PairingHeap2(compare3);
  const text = lineSeg.line.text;
  candidates.append(makeCandidates(void 0, lineSeg.relStart, 0, 0));
  let attempts = 0;
  let bestPath;
  while (maxCost && candidates.length && attempts++ < maxAttempts) {
    const best = candidates.dequeue();
    if (!best || best.c >= maxCost) {
      continue;
    }
    if (best.bp.length) {
      const i = best.bp[0];
      const j = best.bp[1];
      const t = i > best.i ? checkTextOffset(text.slice(best.i, i), best.i) : void 0;
      const cost = !t || t.isFound ? 0 : t.text.length;
      const mc = maxIndex - j;
      best.c += cost;
      best.ec = best.c + mc;
      best.text = t;
      const possiblePath = knownPathsByIndex.get(j);
      if (possiblePath) {
        const f = addToKnownPaths(best, possiblePath);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      } else if (best.c < maxCost) {
        const c = makeCandidates(t ? best : best.p, j, best.bi + 1, best.c);
        candidates.append(c);
      }
    } else {
      const c = makeCandidates(best.p, best.i, best.bi + 1, best.c);
      candidates.append(c);
      if (!c.length) {
        const t = maxIndex > best.i ? checkTextOffset(text.slice(best.i, maxIndex), best.i) : void 0;
        const cost = !t || t.isFound ? 0 : t.text.length;
        best.c += cost;
        best.ec = best.c;
        best.text = t;
        const segText = t || best.p?.text || checkTextOffset("", best.i);
        const can = t ? { ...best, text: segText } : { ...best, ...best.p, text: segText };
        const f = addToKnownPaths(can, void 0);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      }
    }
    if (bestPath && bestPath.c < maxCost) {
      maxCost = bestPath.c;
    }
  }
  return pathToWords(bestPath);
}
function mergeSortedBreaks(...maps) {
  return maps.flat().sort((a, b) => a.offset - b.offset);
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/isRandomString.js
var maxRadio = 0.5;
function isRandomString(s, maxNoiseToLengthRatio = maxRadio) {
  return scoreRandomString(s) >= maxNoiseToLengthRatio;
}
function scoreRandomString(s) {
  if (!s.length)
    return 0;
  const n = categorizeString(s);
  return n.length / s.length;
}
function categorizeString(s) {
  const n = s.replaceAll(/\d+/g, "0").replaceAll(/\p{Ll}\p{M}+/gu, "a").replaceAll(/\p{Lu}\p{M}+/gu, "A").replaceAll(/\p{Lu}?\p{Ll}+/gu, "1").replaceAll(/\p{Lu}+/gu, "2").replaceAll(/\p{M}/gu, "4").replaceAll("_", "").replaceAll(/[-_.']+/g, "3");
  return n;
}
var hexSequence = /(?:\b|(?<=[\W_]))[0-9a-fA-F][-0-9a-fA-F]*[0-9a-fA-F](?:\b|(?=[\W_]))/g;
var isLetter = /\p{L}/uy;
function isLetterAt(s, idx2) {
  isLetter.lastIndex = idx2;
  return isLetter.test(s);
}
var MIN_HEX_SEQUENCE_LENGTH = 4;
function extractHexSequences(s, minLength = MIN_HEX_SEQUENCE_LENGTH) {
  return [...s.matchAll(hexSequence)].filter((m) => m[0].length >= minLength && (m.index === 0 || !isLetterAt(s, m.index - 1)) && !isLetterAt(s, m.index + m[0].length)).map((m) => ({ text: m[0], offset: m.index }));
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/isWordValid.js
function hasWordCheck(dict, word) {
  word = word.includes("\\") ? word.replaceAll("\\", "") : word;
  return dict.has(word);
}
function isWordValidWithEscapeRetry(dict, wo, line) {
  const firstTry = hasWordCheck(dict, wo.text);
  return firstTry || // Drop the first letter if it is preceded by a '\'.
  line.text[wo.offset - line.offset - 1] === "\\" && hasWordCheck(dict, wo.text.slice(1));
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/TextMap.js
var import_node_assert15 = __toESM(require("node:assert"), 1);
function extractTextMapRangeOrigin(textMap, extractRange) {
  const { text: srcTxt, range: srcRange, map: srcMap } = textMap;
  const [r0, r1] = srcRange;
  const startOrig = Math.min(Math.max(extractRange[0], r0), r1);
  const endOrig = Math.min(Math.max(extractRange[1], r0), r1);
  const a = startOrig - r0;
  const b = endOrig - r0;
  const range = [startOrig, endOrig];
  if (!srcMap || !srcMap.length || a === b) {
    const text2 = srcTxt.slice(a, b);
    return { text: text2, range };
  }
  (0, import_node_assert15.default)((srcMap.length & 1) === 0, "Map must be pairs of values.");
  const mapLen = srcMap.length;
  const mapEndSrc = srcMap[mapLen - 2];
  const mapEndDst = srcMap[mapLen - 1];
  const endDiff = srcTxt.length - mapEndDst;
  const head = !srcMap[0] && !srcMap[1] ? [] : [0, 0];
  const tail = [mapEndSrc + endDiff, mapEndDst + endDiff];
  const sMap = [...head, ...srcMap, ...tail];
  let idx2 = 0;
  for (; idx2 < sMap.length && a >= sMap[idx2]; idx2 += 2) {
  }
  const aIdx = idx2;
  idx2 -= 2;
  const a0 = a - sMap[idx2];
  const a1 = a0 + sMap[idx2 + 1];
  for (; idx2 < sMap.length && b > sMap[idx2]; idx2 += 2) {
  }
  const bIdx = idx2;
  const b0 = b - sMap[idx2];
  const b1 = b0 + sMap[idx2 + 1];
  const text = srcTxt.slice(a1, b1);
  if (bIdx === aIdx) {
    return { text, range };
  }
  const ab = [a0, a1];
  const map3 = sMap.slice(aIdx, bIdx + 2).map((v, i) => v - ab[i & 1]);
  return { text, range, map: map3 };
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/parsedText.js
function mapRangeBackToOriginalPos(offRange, map3) {
  if (!map3 || !map3.length)
    return offRange;
  const [start, end] = offRange;
  let i = 0, j = 0, p = 1;
  while (p < map3.length && map3[p] < start) {
    i = map3[p - 1];
    j = map3[p];
    p += 2;
  }
  const iA = start - j + i;
  while (p < map3.length && map3[p] < end) {
    i = map3[p - 1];
    j = map3[p];
    p += 2;
  }
  const iB = end - j + i;
  return [iA, iB];
}
function createMappedTextSegmenter(includeRanges) {
  let rangePos = 0;
  function* segmenter(pText) {
    if (!includeRanges.length) {
      return;
    }
    const range = pText.range;
    const textEndPos = range[1];
    let textStartPos = range[0];
    while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
      rangePos -= 1;
    }
    const cur = includeRanges[rangePos];
    if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
      yield pText;
      return;
    }
    while (textStartPos < textEndPos) {
      while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
        rangePos += 1;
      }
      if (!includeRanges[rangePos]) {
        break;
      }
      const { startPos, endPos } = includeRanges[rangePos];
      if (textEndPos < startPos) {
        break;
      }
      const a = Math.max(textStartPos, startPos);
      const b = Math.min(textEndPos, endPos);
      if (a !== b) {
        yield extractTextMapRangeOrigin(pText, [a, b]);
      }
      textStartPos = b;
    }
  }
  return segmenter;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
var MIN_HEX_SEQUENCE_LENGTH2 = 8;
function lineValidatorFactory(sDict, options) {
  const { minWordLength = defaultMinWordLength, flagWords = [], allowCompoundWords = false, ignoreCase: ignoreCase2 = true, ignoreRandomStrings = defaultCSpellSettings.ignoreRandomStrings, minRandomLength = defaultCSpellSettings.minRandomLength, unknownWords = unknownWordsChoices.ReportAll } = options;
  const hasWordOptions = {
    ignoreCase: ignoreCase2,
    useCompounds: allowCompoundWords || void 0
    // let the dictionaries decide on useCompounds if allow is false
  };
  const dictCol = createCachingDictionary(sDict, hasWordOptions);
  const knownWords = /* @__PURE__ */ new Map();
  const setOfFlagWords = new Set(flagWords);
  const setOfKnownIssues = /* @__PURE__ */ new Map();
  const setOfKnownSuccessfulWords = /* @__PURE__ */ new Set();
  const rememberFilter = (fn2) => (v) => {
    const keep = fn2(v);
    if (!keep) {
      setOfKnownSuccessfulWords.add(v.text);
    }
    return keep;
  };
  const filterAlreadyChecked = (wo) => {
    return !setOfKnownSuccessfulWords.has(wo.text);
  };
  const hasDict = {
    has(word) {
      const info5 = getWordInfo(word);
      if (info5.isFound !== void 0)
        return info5.isFound;
      if (info5.isFlagged)
        return true;
      if (info5.isFlagged)
        return false;
      info5.isFound = dictCol.has(word);
      return info5.isFound;
    }
  };
  function calcIgnored(info5) {
    info5.isIgnored ??= dictCol.isNoSuggestWord(info5.word);
    return info5.isIgnored;
  }
  function calcFlagged(info5) {
    if (info5.isFlagged !== void 0)
      return info5.isFlagged;
    const word = info5.word;
    info5.isFlagged = (setOfFlagWords.has(word) || setOfFlagWords.has(word.toLowerCase()) || dictCol.isForbidden(word)) && !calcIgnored(info5);
    return info5.isFlagged;
  }
  function isWordIgnored(word) {
    return calcIgnored(getWordInfo(word));
  }
  const cacheGetPreferredSuggestions = /* @__PURE__ */ new Map();
  function getPreferredSuggestions(word) {
    return autoResolve(cacheGetPreferredSuggestions, word, () => dictCol.getPreferredSuggestions(word));
  }
  const cacheHasSimpleSuggestions = /* @__PURE__ */ new Map();
  function hasSimpleSuggestions(word) {
    return autoResolve(cacheHasSimpleSuggestions, word, () => {
      const sugs = dictCol.suggest(word, {
        numSuggestions: 1,
        compoundMethod: 0,
        includeTies: false,
        ignoreCase: ignoreCase2,
        timeout: 100,
        numChanges: 1.8
        // Only consider very simple changes (1 edit distance plus case changes)
      });
      return !!sugs.length;
    });
  }
  function isWordFlagged(wo) {
    return calcFlagged(getWordInfo(wo.text));
  }
  function annotateIsFlagged(word) {
    word.isFlagged = isWordFlagged(word);
    return word;
  }
  function annotateIssue(issue) {
    const sugs = getPreferredSuggestions(issue.text);
    if (!sugs?.length) {
      issue.hasPreferredSuggestions = sugs !== void 0 ? false : void 0;
      if (unknownWords === unknownWordsChoices.ReportSimple) {
        issue.hasSimpleSuggestions = hasSimpleSuggestions(issue.text);
      }
      return issue;
    }
    issue.suggestionsEx = sugs;
    issue.hasPreferredSuggestions = true;
    issue.hasSimpleSuggestions = true;
    return issue;
  }
  const isFlaggedOrMinLength = (wo) => wo.text.length >= minWordLength || !!wo.isFlagged;
  const isFlaggedOrNotFound = rememberFilter((wo) => wo.isFlagged || !wo.isFound);
  const isNotRepeatingChar = rememberFilter((wo) => !regExRepeatedChar.test(wo.text));
  function checkWord(issue) {
    const info5 = getWordInfo(issue.text);
    if (info5.fin) {
      const { isFlagged: isForbidden, isFound, isIgnored: isIgnored2 } = info5;
      const isFlagged2 = issue.isFlagged ?? (!isIgnored2 && isForbidden);
      issue.isFlagged = isFlagged2;
      issue.isFound = isFlagged2 ? void 0 : isFound;
      return issue;
    }
    const isIgnored = calcIgnored(info5);
    const isFlagged = issue.isFlagged ?? calcFlagged(info5);
    info5.isFound ??= isFlagged ? false : isIgnored || isWordValidWithEscapeRetry(hasDict, issue, issue.line);
    info5.isFlagged = !!isFlagged;
    info5.fin = true;
    issue.isFlagged = isFlagged;
    issue.isFound = isFlagged ? void 0 : info5.isFound;
    return issue;
  }
  const regExUpperCaseWithTrailingCommonEnglishSuffix = /^([\p{Lu}\p{M}]{2,})['’]?(?:s|ing|ies|es|ings|ize|ed|ning)$/u;
  const regExpIsLetter = /\p{L}/u;
  const fn = (lineSegment) => {
    const line = lineSegment.line;
    function isWordTooShort(word, ignoreSuffix = false) {
      if (word.text.length >= minWordLength * 2 || [...word.text].length >= minWordLength)
        return false;
      const offset = word.offset - line.offset;
      import_node_assert16.default.equal(line.text.slice(offset, offset + word.text.length), word.text);
      const prefix = [...line.text.slice(Math.max(0, offset - 2), offset)];
      const hasLetterPrefix = !!prefix.length && regExpIsLetter.test(prefix[prefix.length - 1]);
      if (hasLetterPrefix)
        return false;
      if (ignoreSuffix)
        return true;
      const suffix = [...line.text.slice(offset + word.text.length, offset + word.text.length + 2)];
      const hasLetterSuffix = !!suffix.length && regExpIsLetter.test(suffix[0]);
      return !hasLetterSuffix;
    }
    function splitterIsValid(word) {
      if (setOfKnownSuccessfulWords.has(word.text))
        return true;
      if (isWordFlagged(word))
        return false;
      if (isWordValidWithEscapeRetry(hasDict, word, lineSegment.line))
        return true;
      if (isWordTooShort(word))
        return true;
      return isAllCapsWithTrailingCommonEnglishSuffixOk(word);
    }
    function isAllCapsWithTrailingCommonEnglishSuffixOk(tWord) {
      if (!regExUpperCaseWithTrailingCommonEnglishSuffix.test(tWord.text))
        return false;
      const m = tWord.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
      if (!m)
        return false;
      const offset = tWord.offset;
      const v = { offset, text: m[1], line };
      const check = checkWord(v);
      if (check.isFlagged)
        return false;
      if (check.isFound)
        return true;
      if (isWordTooShort(v, true))
        return true;
      return false;
    }
    function checkFullWord(vr) {
      if (vr.isFlagged) {
        return [vr];
      }
      if (isAllCapsWithTrailingCommonEnglishSuffixOk(vr))
        return [];
      if (isWordIgnored(vr.text) || checkWord(vr).isFound) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      if (vr.isFlagged)
        return [vr];
      const codeWordResults = checkCamelCaseWord(vr);
      if (!codeWordResults.length) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      return codeWordResults;
    }
    function checkCamelCaseWord(vr) {
      return _checkCamelCaseWord(vr, regExpCamelCaseWordBreaksWithEnglishSuffix);
    }
    function _checkCamelCaseWord(vr, regExpWordBreaks) {
      const codeWordResults = [];
      for (const wo of splitWordWithOffset(vr, regExpWordBreaks)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = vr.line;
        issue.isFlagged = void 0;
        issue.isFound = void 0;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        checkWord(issue);
        if (!isFlaggedOrNotFound(issue) || !isNotRepeatingChar(issue))
          continue;
        issue.text = extractText(lineSegment.segment, issue.offset, issue.offset + issue.text.length);
        codeWordResults.push(issue);
      }
      return codeWordResults;
    }
    function rebaseKnownIssues(possibleWord, known) {
      const { issues } = known;
      const adjOffset = possibleWord.offset - known.possibleWord.offset;
      return issues.map((issue) => {
        issue = { ...issue };
        issue.offset += adjOffset;
        issue.line = lineSegment.line;
        return issue;
      });
    }
    function checkForFlaggedWord(possibleWord) {
      if (isWordFlagged(possibleWord)) {
        const vr = {
          ...possibleWord,
          line: lineSegment.line,
          isFlagged: true
        };
        return vr;
      }
      if (possibleWord.text.endsWith(".") && possibleWord.text.length > 1) {
        const pw = { ...possibleWord, text: possibleWord.text.slice(0, -1) };
        if (isWordFlagged(pw)) {
          const vr = {
            ...pw,
            line: lineSegment.line,
            isFlagged: true
          };
          return vr;
        }
      }
      return void 0;
    }
    function checkPossibleWords(possibleWord) {
      const known = setOfKnownIssues.get(possibleWord.text);
      if (known) {
        if (!known.issues.length)
          return known.issues;
        const adjusted = rebaseKnownIssues(possibleWord, known);
        return adjusted;
      }
      const issues = _checkPossibleWords(possibleWord).map(annotateIssue);
      setOfKnownIssues.set(possibleWord.text, { possibleWord, issues });
      return issues;
    }
    function _checkPossibleWords(possibleWord) {
      const flagged = checkForFlaggedWord(possibleWord);
      if (flagged)
        return [flagged];
      let mismatches = [];
      for (const wo of extractWordsFromTextOffset(possibleWord)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = lineSegment.line;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        for (const w of checkFullWord(issue)) {
          mismatches.push(w);
        }
      }
      if (!mismatches.length)
        return mismatches;
      const hexSequences = !ignoreRandomStrings ? void 0 : extractHexSequences(possibleWord.text, MIN_HEX_SEQUENCE_LENGTH2).filter(
        // Only consider hex sequences that are all upper case or all lower case and contain a `-` or a digit.
        (w) => (w.text === w.text.toLowerCase() || w.text === w.text.toUpperCase()) && /[\d-]/.test(w.text)
      ).map((w) => (w.offset += possibleWord.offset, w));
      if (hexSequences?.length) {
        mismatches = filterExcludedTextOffsets(mismatches, hexSequences);
      }
      if (mismatches.length) {
        const splitResult = split(lineSegment.segment, possibleWord.offset, splitterIsValid);
        const nonMatching = splitResult.words.filter((w) => !w.isFound).filter((w) => {
          const m = w.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
          if (!m)
            return true;
          const v = checkWord({ ...w, text: m[1], line: lineSegment.line });
          return v.isFlagged || !v.isFound;
        });
        const filtered = filterExcludedTextOffsets(nonMatching.map((w) => ({ ...w, line: lineSegment.line })).map(annotateIsFlagged), hexSequences);
        if (filtered.length < mismatches.length) {
          return filtered;
        }
      }
      return mismatches;
    }
    function isNotRandom(textOff) {
      if (textOff.text.length < minRandomLength || !ignoreRandomStrings)
        return true;
      return !isRandomString(textOff.text);
    }
    const checkedPossibleWords = pipeSync(extractPossibleWordsFromTextOffset(lineSegment.segment), opFilterSync(isNotRandom), opFilterSync(filterAlreadyChecked), opConcatMapSync(checkPossibleWords));
    return checkedPossibleWords;
  };
  function getWordInfo(word) {
    const info5 = knownWords.get(word);
    if (info5)
      return info5;
    const result = { word, isFound: void 0, isFlagged: void 0, isIgnored: void 0, fin: false };
    knownWords.set(word, result);
    return result;
  }
  return { fn, dict: dictCol };
}
function textValidatorFactory(dict, options) {
  const lineValidator = lineValidatorFactory(dict, options);
  const lineValidatorFn = lineValidator.fn;
  function validate(pText) {
    const { text, range: srcRange, map: map3 } = pText;
    const srcOffset = srcRange[0];
    const segment = { text, offset: 0 };
    const lineSegment = { line: segment, segment };
    function mapBackToOriginSimple(vr) {
      const { text: text2, offset, isFlagged, isFound, suggestionsEx, hasPreferredSuggestions, hasSimpleSuggestions } = vr;
      const r = mapRangeBackToOriginalPos([offset, offset + text2.length], map3);
      const range = [r[0] + srcOffset, r[1] + srcOffset];
      return { text: text2, range, isFlagged, isFound, suggestionsEx, hasPreferredSuggestions, hasSimpleSuggestions };
    }
    return [...lineValidatorFn(lineSegment)].map(mapBackToOriginSimple);
  }
  return {
    validate,
    lineValidator
  };
}
function filterExcludedTextOffsets(issues, excluded) {
  if (!excluded?.length)
    return issues;
  const keep = [];
  let i = 0;
  let j = 0;
  for (i = 0; i < issues.length && j < excluded.length; i++) {
    const issue = issues[i];
    while (j < excluded.length && excluded[j].offset + excluded[j].text.length <= issue.offset) {
      j++;
    }
    if (j >= excluded.length) {
      break;
    }
    if (issue.isFlagged || issue.offset < excluded[j].offset) {
      keep.push(issue);
    }
  }
  if (i < issues.length) {
    keep.push(...issues.slice(i));
  }
  return keep;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/settingsToValidateOptions.js
function settingsToValidateOptions(settings) {
  const opt = {
    ...settings,
    ignoreCase: !(settings.caseSensitive ?? false),
    ignoreRandomStrings: settings.ignoreRandomStrings,
    minRandomLength: settings.minRandomLength,
    unknownWords: settings.unknownWords || "report-all"
  };
  return opt;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/TextRange.js
function toMatchRangeWithText(m) {
  const index = m.index || 0;
  const _text = m[0];
  return {
    startPos: index,
    endPos: index + _text.length,
    text: _text
  };
}
function findMatchingRanges(pattern, text) {
  if (pattern.source === ".*") {
    return [{ startPos: 0, endPos: text.length }];
  }
  const regex = new RegExp(pattern);
  if (!regex.global) {
    const m = text.match(regex);
    if (!m)
      return [];
    return [toMatchRangeWithText(m)];
  }
  return [...text.matchAll(regex)].map(toMatchRangeWithText);
}
function compareRanges(a, b) {
  return a.startPos - b.startPos || a.endPos - b.endPos;
}
function unionRanges(ranges) {
  const sortedRanges = sortMatchRangeArray(ranges);
  ranges = sortedRanges.values;
  if (!ranges.length)
    return sortedRanges;
  let i = 0;
  let j = 0;
  let { startPos, endPos } = ranges[i++];
  for (; i < ranges.length; ++i) {
    const r = ranges[i];
    if (r.startPos > endPos) {
      ranges[j++] = { startPos, endPos };
      startPos = r.startPos;
      endPos = r.endPos;
      continue;
    }
    endPos = Math.max(endPos, r.endPos);
  }
  if (startPos < endPos) {
    ranges[j++] = { startPos, endPos };
  }
  ranges.length = j;
  return sortedRanges;
}
function findMatchingRangesForPatterns(patterns, text) {
  const nested = patterns.map((pattern) => findMatchingRanges(pattern, text));
  return unionRanges(flatten(nested)).values;
}
function excludeRanges(includeRanges, excludeRanges2) {
  return _excludeRanges(sortMatchRangeArray(includeRanges), sortMatchRangeArray(excludeRanges2));
}
function _excludeRanges(sortedIncludeRanges, sortedExcludeRanges) {
  const includeRanges = sortedIncludeRanges.values;
  const excludeRanges2 = sortedExcludeRanges.values;
  if (!includeRanges.length)
    return includeRanges;
  if (!excludeRanges2.length) {
    return includeRanges;
  }
  const ranges = [];
  ranges.length = includeRanges.length + excludeRanges2.length + 1;
  let i = 0;
  let exIndex = 0;
  const limit = excludeRanges2.length;
  for (const incRange of includeRanges) {
    const endPos = incRange.endPos;
    let startPos = incRange.startPos;
    for (; exIndex < limit; ++exIndex) {
      const ex = excludeRanges2[exIndex];
      if (ex.startPos >= endPos)
        break;
      if (ex.endPos <= startPos)
        continue;
      if (ex.startPos > startPos) {
        ranges[i++] = { startPos, endPos: ex.startPos };
      }
      startPos = ex.endPos;
      if (startPos >= endPos)
        break;
    }
    if (startPos < endPos) {
      ranges[i++] = { startPos, endPos };
    }
  }
  ranges.length = i;
  return ranges;
}
function sortMatchRangeArray(values) {
  values.sort(compareRanges);
  return { values };
}
function flatten(data) {
  let size = 0;
  for (let i = data.length - 1; i >= 0; --i) {
    size += data[i].length;
  }
  const result = new Array(size);
  let k = 0;
  for (let i = 0; i < data.length; ++i) {
    const d = data[i];
    for (let j = 0; j < d.length; ++j) {
      result[k++] = d[j];
    }
  }
  return result;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/textValidator.js
function calcTextInclusionRanges(text, options) {
  const { ignoreRegExpList = [], includeRegExpList = [] } = options;
  const filteredIncludeList = includeRegExpList.filter((a) => !!a);
  const finalIncludeList = filteredIncludeList.length ? filteredIncludeList : [/.*/gim];
  const includeRanges = excludeRanges(findMatchingRangesForPatterns(finalIncludeList, text), findMatchingRangesForPatterns(ignoreRegExpList, text));
  return includeRanges;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/traceWord.js
function traceWord(word, dictCollection, config) {
  const opts = {
    ignoreCase: config.ignoreCase ?? true,
    useCompounds: config.allowCompoundWords || false
  };
  const splits = split({ text: word, offset: 0 }, 0, checkWord);
  const wfSplits = splits.words.map((s) => ({ word: s.text, found: s.isFound }));
  const unique2 = uniqueFn((w) => w.word + "|" + w.found);
  const wsFound = { word, found: dictCollection.has(word, opts) };
  const wordSplits = wfSplits.some((s) => s.word === word) ? wfSplits : [wsFound, ...wfSplits];
  const traces = wordSplits.filter(unique2).map((s) => s.word).flatMap((word2) => dictCollection.dictionaries.map((dict) => ({ dict, word: word2 }))).map(({ dict, word: word2 }) => ({ dict, findResult: dict.find(word2, opts), word: word2 })).flatMap((r2) => unpackDictionaryFindResult(r2, config));
  const r = new CTraceResult(...traces);
  r.splits = wordSplits;
  return r;
  function checkWord(wo) {
    return dictCollection.has(wo.text, opts);
  }
}
function unpackDictionaryFindResult(found, config) {
  const { word, dict, findResult } = found;
  const dictPreferred = getPreferred(dict, word);
  const baseResult = {
    word,
    found: !!findResult?.found,
    foundWord: findResult?.found || void 0,
    forbidden: findResult?.forbidden || false,
    noSuggest: findResult?.noSuggest || false,
    dictName: dict.name,
    dictSource: dict.source,
    configSource: void 0,
    preferredSuggestions: dictPreferred,
    errors: normalizeErrors(dict.getErrors?.())
  };
  const configFieldName = mapSpecialDictionaryNamesToSettings.get(dict.name);
  if (!findResult?.found || !configFieldName || !config.source) {
    return [baseResult];
  }
  const opts = {
    ignoreCase: true,
    useCompounds: config.allowCompoundWords || false
  };
  const sources = getSources(config);
  const results = [];
  for (const src of sources) {
    if (!src[configFieldName] || !Array.isArray(src[configFieldName]) || !src[configFieldName]?.length || !src.source?.filename) {
      continue;
    }
    const configSource = toFileUrl(src.source.filename).href;
    const cfg = { [configFieldName]: src[configFieldName] };
    const cfgDict = createCollection(getInlineConfigDictionaries(cfg), dict.name, configSource);
    const findResult2 = cfgDict.find(word, opts);
    const preferredSuggestions = getPreferred(cfgDict, word);
    if (!findResult2?.found && !preferredSuggestions)
      continue;
    const result = {
      word,
      found: !!findResult2?.found,
      foundWord: findResult2?.found || void 0,
      forbidden: findResult2?.forbidden || false,
      noSuggest: findResult2?.noSuggest || false,
      dictName: dict.name,
      dictSource: configSource,
      configSource,
      preferredSuggestions,
      errors: normalizeErrors(dict.getErrors?.())
    };
    results.push(result);
  }
  return results.length ? results : [baseResult];
}
function normalizeErrors(errors) {
  return errors?.length ? errors : void 0;
}
function getPreferred(dict, word) {
  const sugs = dict.getPreferredSuggestions?.(word);
  const preferred = sugs?.length ? sugs.filter((s) => s.isPreferred).map((s) => s.word) : void 0;
  return preferred;
}
var CTraceResult = class extends Array {
  splits = [];
  constructor(...items) {
    super(...items);
  }
};

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
var ERROR_NOT_PREPARED = "Validator Must be prepared before calling this function.";
var DocumentValidator = class _DocumentValidator {
  settings;
  _document;
  _ready = false;
  errors = [];
  _prepared;
  _preparations;
  _preparationTime = -1;
  _suggestions = new AutoCache((text) => this.genSuggestions(text), 1e3);
  options;
  perfTiming = {};
  skipValidation;
  static async create(doc, options, settingsOrConfigFile) {
    const settings = satisfiesCSpellConfigFile(settingsOrConfigFile) ? await resolveConfigFileImports(settingsOrConfigFile) : settingsOrConfigFile;
    const validator = new _DocumentValidator(doc, options, settings);
    await validator.prepare();
    return validator;
  }
  /**
   * @param doc - Document to validate
   * @param config - configuration to use (not finalized).
   */
  constructor(doc, options, settings) {
    this.settings = settings;
    this._document = doc;
    this.options = { ...options };
    const numSuggestions = this.options.numSuggestions ?? settings.numSuggestions;
    if (numSuggestions !== void 0) {
      this.options.numSuggestions = numSuggestions;
    }
    this.skipValidation = !!options.skipValidation;
  }
  get ready() {
    return this._ready;
  }
  prepare() {
    if (this._ready)
      return Promise.resolve();
    if (this._prepared)
      return this._prepared;
    this._prepared = this._prepareAsync();
    return this._prepared;
  }
  async _prepareAsync() {
    (0, import_node_assert17.default)(!this._ready);
    const timer = createPerfTimer2("_prepareAsync");
    const { options, settings: rawSettings } = this;
    const resolveImportsRelativeTo = toFileURL(options.resolveImportsRelativeTo || toFileURL("./virtual.settings.json"));
    const settings = rawSettings.import?.length ? await resolveSettingsImports(rawSettings, resolveImportsRelativeTo) : rawSettings;
    const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
    const pLocalConfig = options.configFile ? loadConfig(options.configFile, settings) : useSearchForConfig ? timePromise(this.perfTiming, "__searchForDocumentConfig", searchForDocumentConfig(this._document, settings, settings)) : void 0;
    pLocalConfig && timePromise(this.perfTiming, "_loadConfig", pLocalConfig);
    const localConfig = await catchPromiseError(pLocalConfig, (e) => this.addPossibleError(e)) || {};
    this.addPossibleError(localConfig?.__importRef?.error);
    const config = mergeSettings(settings, localConfig);
    const docSettings = await timePromise(this.perfTiming, "_determineTextDocumentSettings", determineTextDocumentSettings(this._document, config));
    const dict = await timePromise(this.perfTiming, "_getDictionaryInternal", getDictionaryInternal(docSettings));
    const recGlobMatcherTime = recordPerfTime(this.perfTiming, "_GlobMatcher");
    const matcher = getGlobMatcherForExcluding(localConfig?.ignorePaths);
    const uri = this._document.uri;
    recGlobMatcherTime();
    const recShouldCheckTime = recordPerfTime(this.perfTiming, "_shouldCheck");
    const shouldCheck = !matcher.match(uriToFilePath(uri)) && (docSettings.enabled ?? true);
    recShouldCheckTime();
    const recFinalizeTime = recordPerfTime(this.perfTiming, "_finalizeSettings");
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions2 = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions2);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions2);
    recFinalizeTime();
    this._preparations = {
      config,
      dictionary: dict,
      docSettings,
      finalSettings,
      shouldCheck,
      validateOptions: validateOptions2,
      includeRanges,
      segmenter,
      textValidator,
      localConfig,
      localConfigFilepath: localConfig?.__importRef?.filename
    };
    this._ready = true;
    this._preparationTime = timer.elapsed;
    this.perfTiming.prepTime = this._preparationTime;
  }
  async _updatePrep() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const timer = createPerfTimer2("_updatePrep");
    const prep = this._preparations;
    const docSettings = await determineTextDocumentSettings(this._document, prep.config);
    const dict = await getDictionaryInternal(docSettings);
    const shouldCheck = docSettings.enabled ?? true;
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions2 = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions2);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions2);
    this._preparations = {
      ...prep,
      dictionary: dict,
      docSettings,
      shouldCheck,
      validateOptions: validateOptions2,
      includeRanges,
      segmenter,
      textValidator
    };
    this._preparationTime = timer.elapsed;
  }
  /**
   * The amount of time in ms to prepare for validation.
   */
  get prepTime() {
    return this._preparationTime;
  }
  get validateDirectives() {
    return this.options.validateDirectives ?? this._preparations?.config.validateDirectives ?? false;
  }
  /**
   * Check a range of text for validation issues.
   * @param range - the range of text to check.
   * @param _text - the text to check. If not given, the text will be taken from the document.
   * @param scope - the scope to use for validation. If not given, the default scope will be used.
   * @returns the validation issues.
   */
  checkText(range, _text, scope) {
    const text = this._document.text.slice(range[0], range[1]);
    scope = (Array.isArray(scope) ? scope.join(" ") : scope) || "";
    return this.check({ text, range, scope });
  }
  check(parsedText) {
    (0, import_node_assert17.default)(this._ready);
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const { segmenter, textValidator } = this._preparations;
    const document = this._document;
    let line = void 0;
    function mapToIssue(issue) {
      const { range, text, isFlagged, isFound, suggestionsEx, hasPreferredSuggestions, hasSimpleSuggestions } = issue;
      const offset = range[0];
      const length = range[1] - range[0];
      (0, import_node_assert17.default)(!line || line.offset <= offset);
      if (!line || line.offset + line.text.length <= offset) {
        line = document.lineAt(offset);
      }
      return {
        text,
        offset,
        line,
        length,
        isFlagged,
        isFound,
        suggestionsEx,
        hasPreferredSuggestions,
        hasSimpleSuggestions
      };
    }
    const issues = [...pipeSync(segmenter(parsedText), opConcatMapSync(textValidator.validate), opMapSync(mapToIssue))];
    if (!this.options.generateSuggestions) {
      return issues.map((issue) => {
        if (!issue.suggestionsEx)
          return issue;
        const suggestionsEx = this.adjustSuggestions(issue.text, issue.suggestionsEx);
        const suggestions2 = suggestionsEx.map((s) => s.word);
        return { ...issue, suggestionsEx, suggestions: suggestions2 };
      });
    }
    const withSugs = issues.map((t) => {
      const text = t.text;
      const suggestionsEx = this.getSuggestions(text);
      t.suggestionsEx = suggestionsEx;
      t.suggestions = suggestionsEx.map((s) => s.word);
      return t;
    });
    return withSugs;
  }
  /**
   * Check a Document for Validation Issues.
   * @param forceCheck - force a check even if the document would normally be excluded.
   * @returns the validation issues.
   */
  async checkDocumentAsync(forceCheck) {
    await this.prepare();
    return this.checkDocument(forceCheck);
  }
  /**
   * Check a Document for Validation Issues.
   *
   * Note: The validator must be prepared before calling this method.
   * @param forceCheck - force a check even if the document would normally be excluded.
   * @returns the validation issues.
   */
  checkDocument(forceCheck = false) {
    const timerDone = recordPerfTime(this.perfTiming, "checkDocument");
    try {
      if (this.skipValidation)
        return [];
      (0, import_node_assert17.default)(this._ready);
      (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
      const spellingIssues = forceCheck || this.shouldCheckDocument() ? [...this._checkParsedText(this._parse())] : [];
      const directiveIssues = this.checkDocumentDirectives();
      const allIssues = [...spellingIssues, ...directiveIssues].sort((a, b) => a.offset - b.offset);
      return allIssues;
    } finally {
      timerDone();
    }
  }
  checkDocumentDirectives(forceCheck = false) {
    (0, import_node_assert17.default)(this._ready);
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const validateDirectives = forceCheck || this.validateDirectives;
    if (!validateDirectives)
      return [];
    const document = this.document;
    const issueType = IssueType.directive;
    function toValidationIssue(dirIssue) {
      const { text, range, suggestions: suggestions2, suggestionsEx, message } = dirIssue;
      const offset = range[0];
      const pos = document.positionAt(offset);
      const line = document.getLine(pos.line);
      const issue = { text, offset, line, suggestions: suggestions2, suggestionsEx, message, issueType };
      return issue;
    }
    return [...validateInDocumentSettings(this.document.text, this._preparations.config)].map(toValidationIssue);
  }
  get document() {
    return this._document;
  }
  async updateDocumentText(text) {
    updateTextDocument(this._document, [{ text }]);
    await this._updatePrep();
  }
  /**
   * Get the calculated ranges of text that should be included in the spell checking.
   * @returns MatchRanges of text to include.
   */
  getCheckedTextRanges() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.includeRanges;
  }
  traceWord(word) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return traceWord(word, this._preparations.dictionary, this._preparations.config);
  }
  defaultParser() {
    return pipeSync(this.document.getLines(), opMapSync((line) => {
      const { text, offset } = line;
      const range = [offset, offset + text.length];
      return { text, range };
    }));
  }
  *_checkParsedText(parsedTexts) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const { maxNumberOfProblems = defaultMaxNumberOfProblems, maxDuplicateProblems = defaultMaxDuplicateProblems } = this._preparations.validateOptions;
    let numProblems = 0;
    const mapOfProblems = /* @__PURE__ */ new Map();
    for (const pText of parsedTexts) {
      for (const issue of this.check(pText)) {
        const { text } = issue;
        const n = (mapOfProblems.get(text) || 0) + 1;
        mapOfProblems.set(text, n);
        if (n > maxDuplicateProblems)
          continue;
        yield issue;
        if (++numProblems >= maxNumberOfProblems)
          return;
      }
    }
  }
  addPossibleError(error4) {
    if (!error4)
      return;
    error4 = this.errors.push(toError2(error4));
  }
  _parse() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const parser2 = this._preparations.finalSettings.parserFn;
    if (typeof parser2 !== "object")
      return this.defaultParser();
    return parser2.parse(this.document.text, toFilePathOrHref(documentUriToURL(this.document.uri))).parsedTexts;
  }
  getSuggestions(text) {
    return this._suggestions.get(text);
  }
  genSuggestions(text) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const dict = this._preparations.dictionary;
    const sugOptions = {
      compoundMethod: 0,
      numSuggestions: this.options.numSuggestions,
      includeTies: false,
      ignoreCase: !(settings.caseSensitive ?? false),
      timeout: settings.suggestionsTimeout,
      numChanges: settings.suggestionNumChanges
    };
    const rawSuggestions = dict.suggest(text, sugOptions);
    return this.adjustSuggestions(text, rawSuggestions);
  }
  adjustSuggestions(text, rawSuggestions) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const ignoreCase2 = !(settings.caseSensitive ?? false);
    const locale = this._preparations.config.language;
    const dict = this._preparations.dictionary;
    const sugsWithAlt = calcSuggestionAdjustedToToMatchCase(text, rawSuggestions.map(mapSug), locale, ignoreCase2, dict);
    return sugsWithAlt.map(sanitizeSuggestion);
  }
  getFinalizedDocSettings() {
    (0, import_node_assert17.default)(this._ready);
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.docSettings;
  }
  /**
   * Returns true if the final result of the configuration calculation results
   * in the document being enabled. Note: in some cases, checking the document
   * might still make sense, for example, the `@cspell/eslint-plugin` relies on
   * `eslint` configuration to make that determination.
   * @returns true if the document settings have resolved to be `enabled`
   */
  shouldCheckDocument() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.shouldCheck;
  }
  /**
   * Internal `cspell-lib` use.
   */
  _getPreparations() {
    return this._preparations;
  }
};
function sanitizeSuggestion(sug) {
  const { word, isPreferred, wordAdjustedToMatchCase } = sug;
  if (isPreferred && wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase, isPreferred };
  if (isPreferred)
    return { word, isPreferred };
  if (wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase };
  return { word };
}
async function searchForDocumentConfig(document, defaultConfig, pnpSettings) {
  const url2 = documentUriToURL(document.uri);
  try {
    return await searchForConfig(url2, pnpSettings).then((s) => s || defaultConfig);
  } catch (e) {
    if (url2.protocol !== "file:")
      return defaultConfig;
    throw e;
  }
}
function mapSug(sug) {
  return { cost: 999, ...sug };
}
async function shouldCheckDocument(doc, options, settings) {
  const errors = [];
  function addPossibleError(error4) {
    if (!error4)
      return void 0;
    error4 = errors.push(toError2(error4));
    return void 0;
  }
  async function shouldCheck() {
    const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
    const pLocalConfig = options.configFile ? loadConfig(options.configFile, settings) : useSearchForConfig ? searchForDocumentConfig(doc, settings, settings) : void 0;
    const localConfig = await catchPromiseError(pLocalConfig, addPossibleError) || {};
    addPossibleError(localConfig?.__importRef?.error);
    const config = mergeSettings(settings, localConfig);
    const matcher = getGlobMatcherForExcluding(localConfig?.ignorePaths);
    const docSettings = await determineTextDocumentSettings(doc, config);
    return !matcher.match(uriToFilePath(doc.uri)) && (docSettings.enabled ?? true);
  }
  return { errors, shouldCheck: await shouldCheck() };
}
function recordPerfTime(timings, name2) {
  const timer = createPerfTimer2(name2, (elapsed) => timings[name2] = elapsed);
  return () => timer.end();
}
function timePromise(timings, name2, p) {
  return p.finally(recordPerfTime(timings, name2));
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/spellCheckFile.js
async function spellCheckDocument(document, options, settingsOrConfigFile) {
  const settingsUsed = satisfiesCSpellConfigFile(settingsOrConfigFile) ? settingsOrConfigFile.settings : settingsOrConfigFile;
  if (isBinaryDoc(document)) {
    return {
      document,
      options,
      settingsUsed,
      localConfigFilepath: void 0,
      issues: [],
      checked: false,
      errors: void 0
    };
  }
  try {
    const timer = createPerfTimer2("loadFile");
    const doc = await resolveDocument(document).finally(() => timer.end());
    if (isBinaryDoc(doc)) {
      return {
        document,
        options,
        settingsUsed,
        localConfigFilepath: void 0,
        issues: [],
        checked: false,
        errors: void 0
      };
    }
    const result = await spellCheckFullDocument(doc, options, settingsOrConfigFile);
    const perf = result.perf || {};
    perf.loadTimeMs = timer.elapsed;
    result.perf = perf;
    return result;
  } catch (e) {
    const errors = isError(e) ? [e] : [];
    return {
      document,
      options,
      settingsUsed,
      localConfigFilepath: void 0,
      issues: [],
      checked: false,
      errors
    };
  }
}
async function spellCheckFullDocument(document, options, settingsOrConfigFile) {
  const perf = {};
  const timer = createPerfTimer2("spellCheckFullDocument", (elapsed) => perf.totalTimeMs = elapsed);
  const timerCheck = createPerfTimer2("check", (elapsed) => perf.checkTimeMs = elapsed);
  const timerPrepare = createPerfTimer2("prepare", (elapsed) => perf.prepareTimeMs = elapsed);
  const doc = documentToTextDocument(document);
  const docValOptions = options;
  const docValidator = await DocumentValidator.create(doc, docValOptions, settingsOrConfigFile).finally(() => timerPrepare.end());
  Object.assign(perf, Object.fromEntries(Object.entries(docValidator.perfTiming).map(([k, v]) => ["_" + k, v])));
  const prep = docValidator._getPreparations();
  if (docValidator.errors.length) {
    return {
      document,
      options,
      settingsUsed: prep?.localConfig || (satisfiesCSpellConfigFile(settingsOrConfigFile) ? settingsOrConfigFile.settings : settingsOrConfigFile),
      localConfigFilepath: prep?.localConfigFilepath,
      issues: [],
      checked: false,
      errors: docValidator.errors,
      perf
    };
  }
  timerCheck.start();
  const issues = docValidator.checkDocument();
  timerCheck.end();
  Object.assign(perf, Object.fromEntries(Object.entries(docValidator.perfTiming).map(([k, v]) => ["_" + k, v])));
  const result = {
    document,
    options,
    settingsUsed: docValidator.getFinalizedDocSettings(),
    localConfigFilepath: prep?.localConfigFilepath,
    issues,
    checked: docValidator.shouldCheckDocument(),
    errors: void 0,
    perf
  };
  timer.end();
  return result;
}

// ../node_modules/.pnpm/cspell-lib@9.1.5/node_modules/cspell-lib/dist/lib/util/textApi.js
var textApi_exports = {};
__export(textApi_exports, {
  calculateTextDocumentOffsets: () => calculateTextDocumentOffsets,
  camelToSnake: () => camelToSnake,
  cleanText: () => cleanText,
  cleanTextOffset: () => cleanTextOffset,
  extractLinesOfText: () => extractLinesOfText,
  extractPossibleWordsFromTextOffset: () => extractPossibleWordsFromTextOffset,
  extractText: () => extractText,
  extractWordsFromCode: () => extractWordsFromCode,
  extractWordsFromCodeTextOffset: () => extractWordsFromCodeTextOffset,
  extractWordsFromText: () => extractWordsFromText,
  extractWordsFromTextOffset: () => extractWordsFromTextOffset,
  isFirstCharacterLower: () => isFirstCharacterLower,
  isFirstCharacterUpper: () => isFirstCharacterUpper,
  isLowerCase: () => isLowerCase,
  isUpperCase: () => isUpperCase2,
  lcFirst: () => lcFirst,
  match: () => match,
  matchCase: () => matchCase,
  matchStringToTextOffset: () => matchStringToTextOffset,
  matchToTextOffset: () => matchToTextOffset,
  removeAccents: () => removeAccents2,
  snakeToCamel: () => snakeToCamel,
  splitCamelCaseWord: () => splitCamelCaseWord,
  splitCamelCaseWordWithOffset: () => splitCamelCaseWordWithOffset,
  stringToRegExp: () => stringToRegExp,
  textOffset: () => textOffset,
  ucFirst: () => ucFirst2
});

// ../node_modules/.pnpm/cspell@9.1.5/node_modules/cspell/dist/esm/application-D-NwS6qb.js
var import_node_assert18 = __toESM(require("node:assert"), 1);
var import_node_util5 = require("node:util");

// ../node_modules/.pnpm/chalk-template@1.1.0/node_modules/chalk-template/index.js
var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.))|(?:{(~)?(#?[\w:]+(?:\([^)]*\))?(?:\.#?[\w:]+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(})|((?:.|[\r\n\f])+?)/gi;
var STYLE_REGEX = /(?:^|\.)(?:(?:(\w+)(?:\(([^)]*)\))?)|(?:#(?=[:a-fA-F\d]{2,})([a-fA-F\d]{6})?(?::([a-fA-F\d]{6}))?))/g;
var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
var ESCAPE_REGEX2 = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
var ESCAPES = /* @__PURE__ */ new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function unescape(c) {
  const u = c[0] === "u";
  const bracket = c[1] === "{";
  if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
    return String.fromCodePoint(Number.parseInt(c.slice(1), 16));
  }
  if (u && bracket) {
    return String.fromCodePoint(Number.parseInt(c.slice(2, -1), 16));
  }
  return ESCAPES.get(c) || c;
}
function parseArguments(name2, arguments_) {
  const results = [];
  const chunks = arguments_.trim().split(/\s*,\s*/g);
  let matches;
  for (const chunk of chunks) {
    const number = Number(chunk);
    if (!Number.isNaN(number)) {
      results.push(number);
    } else if (matches = chunk.match(STRING_REGEX)) {
      results.push(matches[2].replace(ESCAPE_REGEX2, (_, escape, character) => escape ? unescape(escape) : character));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
    }
  }
  return results;
}
function parseHex(hex) {
  const n = Number.parseInt(hex, 16);
  return [
    // eslint-disable-next-line no-bitwise
    n >> 16 & 255,
    // eslint-disable-next-line no-bitwise
    n >> 8 & 255,
    // eslint-disable-next-line no-bitwise
    n & 255
  ];
}
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;
  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name2 = matches[1];
    if (matches[2]) {
      results.push([name2, ...parseArguments(name2, matches[2])]);
    } else if (matches[3] || matches[4]) {
      if (matches[3]) {
        results.push(["rgb", ...parseHex(matches[3])]);
      }
      if (matches[4]) {
        results.push(["bgRgb", ...parseHex(matches[4])]);
      }
    } else {
      results.push([name2]);
    }
  }
  return results;
}
function makeTemplate(chalk2) {
  function buildStyle(styles3) {
    const enabled = {};
    for (const layer of styles3) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk2;
    for (const [styleName, styles4] of Object.entries(enabled)) {
      if (!Array.isArray(styles4)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles4.length > 0 ? current[styleName](...styles4) : current[styleName];
    }
    return current;
  }
  function template2(string) {
    const styles3 = [];
    const chunks = [];
    let chunk = [];
    string.replace(TEMPLATE_REGEX, (_, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape(escapeCharacter));
      } else if (style) {
        const string2 = chunk.join("");
        chunk = [];
        chunks.push(styles3.length === 0 ? string2 : buildStyle(styles3)(string2));
        styles3.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles3.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(styles3)(chunk.join("")));
        chunk = [];
        styles3.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles3.length > 0) {
      throw new Error(`Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? "" : "s"} (\`}\`)`);
    }
    return chunks.join("");
  }
  return template2;
}
function makeChalkTemplate(template2) {
  function chalkTemplate(firstString, ...arguments_) {
    if (!Array.isArray(firstString) || !Array.isArray(firstString.raw)) {
      throw new TypeError("A tagged template literal must be provided");
    }
    const parts = [firstString.raw[0]];
    for (let index = 1; index < firstString.raw.length; index++) {
      parts.push(
        String(arguments_[index - 1]).replace(/[{}\\]/g, "\\$&"),
        String(firstString.raw[index])
      );
    }
    return template2(parts.join(""));
  }
  return chalkTemplate;
}
var template = makeTemplate(source_default);
var chalk_template_default = makeChalkTemplate(template);
var templateStderr = makeTemplate(chalkStderr);
var chalkTemplateStderr = makeChalkTemplate(templateStderr);

// ../node_modules/.pnpm/cspell@9.1.5/node_modules/cspell/dist/esm/application-D-NwS6qb.js
var import_promises4 = __toESM(require("node:fs/promises"), 1);
var fs$1 = __toESM(require("node:fs"), 1);
var import_node_fs7 = require("node:fs");
var import_node_url13 = require("node:url");
var path$1 = __toESM(require("node:path"), 1);
var import_node_path10 = __toESM(require("node:path"), 1);

// ../node_modules/.pnpm/cspell-gitignore@9.1.5/node_modules/cspell-gitignore/dist/findRepoRoot.js
async function findRepoRoot(directory, vfs) {
  directory = toFileDirURL(directory);
  vfs = vfs || getDefaultVirtualFs().getFS(directory);
  const foundDir = await vfs.findUp(".git", directory, { type: "directory" });
  const foundFile = await vfs.findUp(".git", directory, { type: "file" });
  const found = foundDir || foundFile;
  if (!found)
    return void 0;
  return toFilePathOrHref(new URL(".", found));
}

// ../node_modules/.pnpm/cspell-gitignore@9.1.5/node_modules/cspell-gitignore/dist/utils.js
function isDefined5(v) {
  return v !== void 0 && v !== null;
}
function isParentOf(parent, child) {
  parent = toFileDirURL(parent);
  return child.pathname.startsWith(parent.pathname);
}
function makeRelativeTo(child, parent) {
  const c = toFileURL(child);
  const p = toFileDirURL(parent);
  const rel = urlRelative(p, c);
  if (rel.startsWith("../"))
    return void 0;
  return rel;
}

// ../node_modules/.pnpm/cspell-gitignore@9.1.5/node_modules/cspell-gitignore/dist/GitIgnoreFile.js
var GitIgnoreFile = class _GitIgnoreFile {
  matcher;
  gitignore;
  constructor(matcher, gitignore) {
    this.matcher = matcher;
    this.gitignore = gitignore;
  }
  get root() {
    return this.matcher.root;
  }
  isIgnored(file) {
    return this.matcher.match(file.toString());
  }
  isIgnoredEx(file) {
    const m = this.matcher.matchEx(file.toString());
    const { matched } = m;
    const partial = m;
    const pattern = partial.pattern;
    const glob2 = pattern?.rawGlob ?? partial.glob;
    const root = partial.root;
    const line = pattern?.line;
    return { glob: glob2, matched, gitIgnoreFile: toFilePathOrHref(this.gitignore), root, line };
  }
  getGlobPatters() {
    return this.matcher.patterns;
  }
  getGlobs(relativeToDir) {
    return this.getGlobPatters().map((pat) => globToString(pat, relativeToDir)).filter(isDefined5);
  }
  static parseGitignore(content, gitignoreFilename) {
    gitignoreFilename = toFileURL(gitignoreFilename);
    const root = urlDirname(gitignoreFilename).href;
    const options = { root };
    const globs = content.split(/\r?\n/g).map((glob2, index) => ({
      glob: glob2.replace(/^#.*/, ""),
      source: gitignoreFilename.toString(),
      line: index + 1
    })).filter((g) => !!g.glob);
    const globMatcher = new GlobMatcher(globs, options);
    return new _GitIgnoreFile(globMatcher, gitignoreFilename);
  }
  static async loadGitignore(gitignore, vfs) {
    gitignore = toFileURL(gitignore);
    const file = await vfs.readFile(gitignore, "utf8");
    return this.parseGitignore(file.getText(), gitignore);
  }
};
var GitIgnoreHierarchy = class {
  gitIgnoreChain;
  constructor(gitIgnoreChain) {
    this.gitIgnoreChain = gitIgnoreChain;
    mustBeHierarchical(gitIgnoreChain);
  }
  isIgnored(file) {
    for (const git of this.gitIgnoreChain) {
      if (git.isIgnored(file))
        return true;
    }
    return false;
  }
  /**
   * Check to see which `.gitignore` file ignored the given file.
   * @param file - fsPath to check.
   * @returns IsIgnoredExResult of the match or undefined if there was no match.
   */
  isIgnoredEx(file) {
    for (const git of this.gitIgnoreChain) {
      const r = git.isIgnoredEx(file);
      if (r.matched)
        return r;
    }
    return void 0;
  }
  getGlobPatters() {
    return this.gitIgnoreChain.flatMap((gf) => gf.getGlobPatters());
  }
  getGlobs(relativeTo) {
    return this.gitIgnoreChain.flatMap((gf) => gf.getGlobs(relativeTo));
  }
};
async function loadGitIgnore(dir, vfs) {
  dir = toFileDirURL(dir);
  if (!dir.pathname.startsWith("/"))
    return void 0;
  vfs ??= getDefaultVirtualFs().getFS(dir);
  const file = new URL(".gitignore", dir);
  try {
    return await GitIgnoreFile.loadGitignore(file, vfs);
  } catch {
    return void 0;
  }
}
function mustBeHierarchical(chain) {
  let root = "";
  for (const file of chain) {
    if (!file.root.startsWith(root)) {
      throw new Error("Hierarchy violation - files are not nested");
    }
    root = file.root;
  }
}
function globToString(glob2, relativeToDir) {
  if (glob2.isGlobalPattern)
    return glob2.glob;
  relativeToDir = toFileDirURL(relativeToDir);
  const root = toFileDirURL(glob2.root);
  if (isParentOf(root, relativeToDir) && glob2.glob.startsWith("**/"))
    return glob2.glob;
  const base = makeRelativeTo(root, relativeToDir);
  if (base === void 0)
    return void 0;
  return (base ? base + "/" : "") + glob2.glob;
}

// ../node_modules/.pnpm/cspell-gitignore@9.1.5/node_modules/cspell-gitignore/dist/GitIgnore.js
var GitIgnore = class {
  resolvedGitIgnoreHierarchies = /* @__PURE__ */ new Map();
  knownGitIgnoreHierarchies = /* @__PURE__ */ new Map();
  _roots;
  _sortedRoots;
  _vfs;
  /**
   * @param roots - (search roots) an optional array of root paths to prevent searching for `.gitignore` files above the root.
   *   If a file is under multiple roots, the closest root will apply. If a file is not under any root, then
   *   the search for `.gitignore` will go all the way to the system root of the file.
   */
  constructor(roots = [], vfs) {
    this._vfs = vfs;
    this._sortedRoots = resolveAndSortRoots(roots);
    this._roots = new Set(this._sortedRoots);
  }
  findResolvedGitIgnoreHierarchy(directory) {
    return this.resolvedGitIgnoreHierarchies.get(toFileDirURL(directory).href);
  }
  isIgnoredQuick(file) {
    const uFile = toFileURL(file);
    const gh = this.findResolvedGitIgnoreHierarchy(getDir(uFile));
    return gh?.isIgnored(uFile);
  }
  async isIgnored(file) {
    const uFile = toFileURL(file);
    const gh = await this.findGitIgnoreHierarchy(getDir(uFile));
    return gh.isIgnored(uFile);
  }
  async isIgnoredEx(file) {
    const uFile = toFileURL(file);
    const gh = await this.findGitIgnoreHierarchy(getDir(uFile));
    return gh.isIgnoredEx(uFile);
  }
  async findGitIgnoreHierarchy(directory) {
    directory = toFileDirURL(directory).href;
    const known = this.knownGitIgnoreHierarchies.get(directory);
    if (known) {
      return known;
    }
    const find = this._findGitIgnoreHierarchy(directory);
    this.knownGitIgnoreHierarchies.set(directory, find);
    const found = await find;
    this.resolvedGitIgnoreHierarchies.set(directory, found);
    return find;
  }
  filterOutIgnored(files) {
    const iter = this.filterOutIgnoredAsync(files);
    return isAsyncIterable2(files) ? iter : asyncIterableToArray(iter);
  }
  async *filterOutIgnoredAsync(files) {
    for await (const file of files) {
      const isIgnored = this.isIgnoredQuick(file) ?? await this.isIgnored(file);
      if (!isIgnored) {
        yield file;
      }
    }
  }
  get roots() {
    return this._sortedRoots;
  }
  addRoots(roots) {
    const rootsToAdd = roots.map((r) => toFileDirURL(r).href).filter((r) => !this._roots.has(r));
    if (!rootsToAdd.length)
      return;
    rootsToAdd.forEach((r) => this._roots.add(r));
    this._sortedRoots = resolveAndSortRoots([...this._roots]);
    this.cleanCachedEntries();
  }
  peekGitIgnoreHierarchy(directory) {
    directory = toFileDirURL(directory).href;
    return this.knownGitIgnoreHierarchies.get(directory);
  }
  async getGlobs(directory) {
    const hierarchy = await this.findGitIgnoreHierarchy(directory);
    return hierarchy.getGlobs(directory);
  }
  cleanCachedEntries() {
    this.knownGitIgnoreHierarchies.clear();
    this.resolvedGitIgnoreHierarchies.clear();
  }
  async _findGitIgnoreHierarchy(directory) {
    directory = toFileDirURL(directory);
    const root = this.determineRoot(directory);
    const parent = urlDirname(directory);
    const parentHierarchy = parent.href !== directory.href && isParentOf(root, parent) ? await this.findGitIgnoreHierarchy(parent) : void 0;
    const git = await loadGitIgnore(directory, this._vfs);
    if (!git) {
      return parentHierarchy || new GitIgnoreHierarchy([]);
    }
    const chain = parentHierarchy ? [...parentHierarchy.gitIgnoreChain, git] : [git];
    return new GitIgnoreHierarchy(chain);
  }
  determineRoot(directory) {
    const uDir = toFileDirURL(directory);
    const roots = this.roots;
    for (let i = roots.length - 1; i >= 0; --i) {
      const r = roots[i];
      if (uDir.href.startsWith(r))
        return r;
    }
    return uDir.pathname.startsWith("/") ? new URL("/", uDir).href : uDir.href;
  }
};
function resolveAndSortRoots(roots) {
  const sortedRoots = roots.map((a) => toFileDirURL(a).href);
  sortRoots(sortedRoots);
  Object.freeze(sortedRoots);
  return sortedRoots;
}
function getDir(file) {
  return urlDirname(toFileURL(file));
}
function sortRoots(roots) {
  roots.sort((a, b) => a.length - b.length || a.localeCompare(b));
  return roots;
}
function isAsyncIterable2(i) {
  const as = i;
  return typeof as[Symbol.asyncIterator] === "function";
}
async function asyncIterableToArray(iter) {
  const r = [];
  for await (const t of iter) {
    r.push(t);
  }
  return r;
}

// ../node_modules/.pnpm/cspell@9.1.5/node_modules/cspell/dist/esm/application-D-NwS6qb.js
var crypto = __toESM(require("node:crypto"), 1);
var import_consumers = __toESM(require("node:stream/consumers"), 1);

// ../node_modules/.pnpm/tinyglobby@0.2.14/node_modules/tinyglobby/dist/index.mjs
var import_path2 = __toESM(require("path"), 1);
var import_fdir = __toESM(require_dist2(), 1);
var import_picomatch2 = __toESM(require_picomatch2(), 1);
var ONLY_PARENT_DIRECTORIES = /^(\/?\.\.)+$/;
function getPartialMatcher(patterns, options) {
  const patternsCount = patterns.length;
  const patternsParts = Array(patternsCount);
  const regexes = Array(patternsCount);
  for (let i = 0; i < patternsCount; i++) {
    const parts = splitPattern(patterns[i]);
    patternsParts[i] = parts;
    const partsCount = parts.length;
    const partRegexes = Array(partsCount);
    for (let j = 0; j < partsCount; j++) partRegexes[j] = import_picomatch2.default.makeRe(parts[j], options);
    regexes[i] = partRegexes;
  }
  return (input) => {
    const inputParts = input.split("/");
    if (inputParts[0] === ".." && ONLY_PARENT_DIRECTORIES.test(input)) return true;
    for (let i = 0; i < patterns.length; i++) {
      const patternParts = patternsParts[i];
      const regex = regexes[i];
      const inputPatternCount = inputParts.length;
      const minParts = Math.min(inputPatternCount, patternParts.length);
      let j = 0;
      while (j < minParts) {
        const part = patternParts[j];
        if (part.includes("/")) return true;
        const match2 = regex[j].test(inputParts[j]);
        if (!match2) break;
        if (part === "**") return true;
        j++;
      }
      if (j === inputPatternCount) return true;
    }
    return false;
  };
}
var splitPatternOptions = { parts: true };
function splitPattern(path$12) {
  var _result$parts;
  const result = import_picomatch2.default.scan(path$12, splitPatternOptions);
  return ((_result$parts = result.parts) === null || _result$parts === void 0 ? void 0 : _result$parts.length) ? result.parts : [path$12];
}
var isWin = process.platform === "win32";
var POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}*?|]|^!|[!+@](?=\()|\\(?![()[\]{}!*+?@|]))/g;
var WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}]|^!|[!+@](?=\())/g;
var escapePosixPath = (path$12) => path$12.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, "\\$&");
var escapeWin32Path = (path$12) => path$12.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, "\\$&");
var escapePath = isWin ? escapeWin32Path : escapePosixPath;
function isDynamicPattern(pattern, options) {
  if ((options === null || options === void 0 ? void 0 : options.caseSensitiveMatch) === false) return true;
  const scan3 = import_picomatch2.default.scan(pattern);
  return scan3.isGlob || scan3.negated;
}
function log2(...tasks) {
  console.log(`[tinyglobby ${(/* @__PURE__ */ new Date()).toLocaleTimeString("es")}]`, ...tasks);
}
var PARENT_DIRECTORY = /^(\/?\.\.)+/;
var ESCAPING_BACKSLASHES = /\\(?=[()[\]{}!*+?@|])/g;
var BACKSLASHES = /\\/g;
function normalizePattern3(pattern, expandDirectories, cwd, props, isIgnore) {
  let result = pattern;
  if (pattern.endsWith("/")) result = pattern.slice(0, -1);
  if (!result.endsWith("*") && expandDirectories) result += "/**";
  const escapedCwd = escapePath(cwd);
  if (import_path2.default.isAbsolute(result.replace(ESCAPING_BACKSLASHES, ""))) result = import_path2.posix.relative(escapedCwd, result);
  else result = import_path2.posix.normalize(result);
  const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);
  const parts = splitPattern(result);
  if (parentDirectoryMatch === null || parentDirectoryMatch === void 0 ? void 0 : parentDirectoryMatch[0]) {
    const n = (parentDirectoryMatch[0].length + 1) / 3;
    let i = 0;
    const cwdParts = escapedCwd.split("/");
    while (i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]) {
      result = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || ".";
      i++;
    }
    const potentialRoot = import_path2.posix.join(cwd, parentDirectoryMatch[0].slice(i * 3));
    if (!potentialRoot.startsWith(".") && props.root.length > potentialRoot.length) {
      props.root = potentialRoot;
      props.depthOffset = -n + i;
    }
  }
  if (!isIgnore && props.depthOffset >= 0) {
    var _props$commonPath;
    (_props$commonPath = props.commonPath) !== null && _props$commonPath !== void 0 || (props.commonPath = parts);
    const newCommonPath = [];
    const length = Math.min(props.commonPath.length, parts.length);
    for (let i = 0; i < length; i++) {
      const part = parts[i];
      if (part === "**" && !parts[i + 1]) {
        newCommonPath.pop();
        break;
      }
      if (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) break;
      newCommonPath.push(part);
    }
    props.depthOffset = newCommonPath.length;
    props.commonPath = newCommonPath;
    props.root = newCommonPath.length > 0 ? import_path2.default.posix.join(cwd, ...newCommonPath) : cwd;
  }
  return result;
}
function processPatterns({ patterns, ignore = [], expandDirectories = true }, cwd, props) {
  if (typeof patterns === "string") patterns = [patterns];
  else if (!patterns) patterns = ["**/*"];
  if (typeof ignore === "string") ignore = [ignore];
  const matchPatterns = [];
  const ignorePatterns = [];
  for (const pattern of ignore) {
    if (!pattern) continue;
    if (pattern[0] !== "!" || pattern[1] === "(") ignorePatterns.push(normalizePattern3(pattern, expandDirectories, cwd, props, true));
  }
  for (const pattern of patterns) {
    if (!pattern) continue;
    if (pattern[0] !== "!" || pattern[1] === "(") matchPatterns.push(normalizePattern3(pattern, expandDirectories, cwd, props, false));
    else if (pattern[1] !== "!" || pattern[2] === "(") ignorePatterns.push(normalizePattern3(pattern.slice(1), expandDirectories, cwd, props, true));
  }
  return {
    match: matchPatterns,
    ignore: ignorePatterns
  };
}
function getRelativePath(path$12, cwd, root) {
  return import_path2.posix.relative(cwd, `${root}/${path$12}`) || ".";
}
function processPath(path$12, cwd, root, isDirectory2, absolute) {
  const relativePath = absolute ? path$12.slice(root === "/" ? 1 : root.length + 1) || "." : path$12;
  if (root === cwd) return isDirectory2 && relativePath !== "." ? relativePath.slice(0, -1) : relativePath;
  return getRelativePath(relativePath, cwd, root);
}
function formatPaths(paths, cwd, root) {
  for (let i = paths.length - 1; i >= 0; i--) {
    const path$12 = paths[i];
    paths[i] = getRelativePath(path$12, cwd, root) + (!path$12 || path$12.endsWith("/") ? "/" : "");
  }
  return paths;
}
function crawl(options, cwd, sync) {
  if (process.env.TINYGLOBBY_DEBUG) options.debug = true;
  if (options.debug) log2("globbing with options:", options, "cwd:", cwd);
  if (Array.isArray(options.patterns) && options.patterns.length === 0) return sync ? [] : Promise.resolve([]);
  const props = {
    root: cwd,
    commonPath: null,
    depthOffset: 0
  };
  const processed = processPatterns(options, cwd, props);
  const nocase = options.caseSensitiveMatch === false;
  if (options.debug) log2("internal processing patterns:", processed);
  const matcher = (0, import_picomatch2.default)(processed.match, {
    dot: options.dot,
    nocase,
    ignore: processed.ignore
  });
  const ignore = (0, import_picomatch2.default)(processed.ignore, {
    dot: options.dot,
    nocase
  });
  const partialMatcher = getPartialMatcher(processed.match, {
    dot: options.dot,
    nocase
  });
  const fdirOptions = {
    filters: [options.debug ? (p, isDirectory2) => {
      const path$12 = processPath(p, cwd, props.root, isDirectory2, options.absolute);
      const matches = matcher(path$12);
      if (matches) log2(`matched ${path$12}`);
      return matches;
    } : (p, isDirectory2) => matcher(processPath(p, cwd, props.root, isDirectory2, options.absolute))],
    exclude: options.debug ? (_, p) => {
      const relativePath = processPath(p, cwd, props.root, true, true);
      const skipped = relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
      if (skipped) log2(`skipped ${p}`);
      else log2(`crawling ${p}`);
      return skipped;
    } : (_, p) => {
      const relativePath = processPath(p, cwd, props.root, true, true);
      return relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
    },
    pathSeparator: "/",
    relativePaths: true,
    resolveSymlinks: true
  };
  if (options.deep !== void 0) fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);
  if (options.absolute) {
    fdirOptions.relativePaths = false;
    fdirOptions.resolvePaths = true;
    fdirOptions.includeBasePath = true;
  }
  if (options.followSymbolicLinks === false) {
    fdirOptions.resolveSymlinks = false;
    fdirOptions.excludeSymlinks = true;
  }
  if (options.onlyDirectories) {
    fdirOptions.excludeFiles = true;
    fdirOptions.includeDirs = true;
  } else if (options.onlyFiles === false) fdirOptions.includeDirs = true;
  props.root = props.root.replace(BACKSLASHES, "");
  const root = props.root;
  if (options.debug) log2("internal properties:", props);
  const api = new import_fdir.fdir(fdirOptions).crawl(root);
  if (cwd === root || options.absolute) return sync ? api.sync() : api.withPromise();
  return sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then((paths) => formatPaths(paths, cwd, root));
}
async function glob(patternsOrOptions, options) {
  if (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error("Cannot pass patterns as both an argument and an option");
  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === "string" ? {
    ...options,
    patterns: patternsOrOptions
  } : patternsOrOptions;
  const cwd = opts.cwd ? import_path2.default.resolve(opts.cwd).replace(BACKSLASHES, "/") : process.cwd().replace(BACKSLASHES, "/");
  return crawl(opts, cwd, false);
}

// ../node_modules/.pnpm/cspell@9.1.5/node_modules/cspell/dist/esm/application-D-NwS6qb.js
var readline = __toESM(require("node:readline"), 1);
var import_node_worker_threads = require("node:worker_threads");
var import_file_entry_cache = __toESM(require_cache3(), 1);
var import_meta2 = {};
var ImplChannel = class {
  constructor(stream) {
    this.stream = stream;
  }
  write = (msg) => this.stream.write(msg);
  writeLine = (msg) => this.write(msg + "\n");
  clearLine = (dir, callback) => this.stream.clearLine?.(dir, callback) ?? false;
  printLine = (...params) => this.writeLine(params.length && (0, import_node_util5.formatWithOptions)({ colors: this.stream.hasColors?.() }, ...params) || "");
  getColorLevel = () => getColorLevel(this.stream);
};
var Console = class {
  stderrChannel;
  stdoutChannel;
  constructor(stdout = process.stdout, stderr = process.stderr) {
    this.stdout = stdout;
    this.stderr = stderr;
    this.stderrChannel = new ImplChannel(this.stderr);
    this.stdoutChannel = new ImplChannel(this.stdout);
  }
  log = (...p) => this.stdoutChannel.printLine(...p);
  error = (...p) => this.stderrChannel.printLine(...p);
  info = this.log;
  warn = this.error;
};
var console2 = new Console();
function getColorLevel(stream) {
  const depth = stream.getColorDepth?.() || 0;
  switch (depth) {
    case 1:
      return 1;
    case 4:
      return 2;
    case 24:
      return 3;
    default:
      return 0;
  }
}
var CheckFailed = class extends Error {
  constructor(message, exitCode = 1) {
    super(message);
    this.exitCode = exitCode;
  }
};
var ApplicationError = class extends Error {
  constructor(message, exitCode = 1, cause) {
    super(message);
    this.exitCode = exitCode;
    this.cause = cause;
  }
};
var IOError = class extends ApplicationError {
  constructor(message, cause) {
    super(message, void 0, cause);
    this.cause = cause;
  }
  get code() {
    return this.cause.code;
  }
  isNotFound() {
    return this.cause.code === "ENOENT";
  }
};
function toError5(e) {
  if (isError5(e)) return e;
  if (isErrorLike(e)) {
    const ex = new Error(e.message, { cause: e });
    if (e.code !== void 0) ex.code = e.code;
    return ex;
  }
  const message = (0, import_node_util5.format)(e);
  return new Error(message);
}
function isError5(e) {
  return e instanceof Error;
}
function isErrorLike(e) {
  if (e instanceof Error) return true;
  if (!e || typeof e !== "object") return false;
  const ex = e;
  return typeof ex.message === "string";
}
function toApplicationError(e, message) {
  if (e instanceof ApplicationError && !message) return e;
  const err = toError5(e);
  return new ApplicationError(message ?? err.message, void 0, err);
}
var uniqueFn2 = uniqueFilterFnGenerator2;
function uniqueFilterFnGenerator2(extractFn) {
  const values = /* @__PURE__ */ new Set();
  const extractor = extractFn || ((a) => a);
  return (v) => {
    const vv = extractor(v);
    const ret = !values.has(vv);
    values.add(vv);
    return ret;
  };
}
function clean4(src) {
  const r = src;
  for (const key of Object.keys(r)) if (r[key] === void 0) delete r[key];
  return r;
}
var templateIssue = `{green $filename}:{yellow $row:$col} - $message ({red $text}) $quickFix`;
var templateIssueNoFix = `{green $filename}:{yellow $row:$col} - $message ({red $text})`;
var templateIssueWithSuggestions = `{green $filename}:{yellow $row:$col} - $message ({red $text}) Suggestions: {yellow [$suggestions]}`;
var templateIssueWithContext = `{green $filename}:{yellow $row:$col} $padRowCol- $message ({red $text})$padContext -- {gray $contextLeft}{red {underline $text}}{gray $contextRight}`;
var templateIssueWithContextWithSuggestions = `{green $filename}:{yellow $row:$col} $padRowCol- $message ({red $text})$padContext -- {gray $contextLeft}{red {underline $text}}{gray $contextRight}
	 Suggestions: {yellow [$suggestions]}`;
var templateIssueLegacy = `{green $filename}[$row, $col]: $message: {red $text}`;
var templateIssueWordsOnly = "$text";
(0, import_node_assert18.default)(true);
function genIssueEmitter(stdIO, errIO, template2, uniqueIssues, reportedIssuesCollection) {
  const uniqueFilter = uniqueIssues ? uniqueFilterFnGenerator2((issue) => issue.text) : () => true;
  const defaultWidth = 10;
  let maxWidth = defaultWidth;
  let uri;
  return function issueEmitter(issue) {
    if (!uniqueFilter(issue)) return;
    if (uri !== issue.uri) {
      maxWidth = defaultWidth;
      uri = issue.uri;
    }
    maxWidth = Math.max(maxWidth * 0.999, issue.text.length, 10);
    const issueText = formatIssue(stdIO, template2, issue, Math.ceil(maxWidth));
    reportedIssuesCollection?.push(formatIssue(errIO, template2, issue, Math.ceil(maxWidth)));
    stdIO.writeLine(issueText);
  };
}
function nullEmitter2() {
}
function relativeUriFilename(uri, rootURL) {
  const url2 = toFileURL(uri);
  const rel = urlRelative(rootURL, url2);
  if (rel.startsWith("..")) return toFilePathOrHref(url2);
  return rel;
}
function reportProgress(io, p, cwdURL2, options) {
  if (p.type === "ProgressFileComplete") return reportProgressFileComplete(io, p, cwdURL2, options);
  if (p.type === "ProgressFileBegin") return reportProgressFileBegin(io, p, cwdURL2);
}
function determineFilename(io, p, cwd) {
  const fc = "" + p.fileCount;
  const fn = (" ".repeat(fc.length) + p.fileNum).slice(-fc.length);
  const idx2 = fn + "/" + fc;
  const filename = io.chalk.gray(relativeUriFilename(p.filename, cwd));
  return {
    idx: idx2,
    filename
  };
}
function reportProgressFileBegin(io, p, cwdURL2) {
  const { idx: idx2, filename } = determineFilename(io, p, cwdURL2);
  if (io.getColorLevel() > 0) {
    io.clearLine?.(0);
    io.write(`${idx2} ${filename}\r`);
  }
}
function reportProgressFileComplete(io, p, cwd, options) {
  const { idx: idx2, filename } = determineFilename(io, p, cwd);
  const { verbose, debug: debug5 } = options;
  const time = reportTime(io, p.elapsedTimeMs, !!p.cached);
  const skipped = p.processed === false ? " skipped" : "";
  const hasErrors = p.numErrors ? io.chalk.red` X` : "";
  const newLine = skipped && (verbose || debug5) || hasErrors || isSlow(p.elapsedTimeMs) || io.getColorLevel() < 1 ? "\n" : "";
  const msg = `${idx2} ${filename} ${time}${skipped}${hasErrors}${newLine || "\r"}`;
  io.write(msg);
}
function reportTime(io, elapsedTimeMs, cached) {
  if (cached) return io.chalk.green("cached");
  if (elapsedTimeMs === void 0) return "-";
  const slow = isSlow(elapsedTimeMs);
  const color = !slow ? io.chalk.white : slow === 1 ? io.chalk.yellow : io.chalk.redBright;
  return color(elapsedTimeMs.toFixed(2) + "ms");
}
function isSlow(elapsedTmeMs) {
  if (!elapsedTmeMs || elapsedTmeMs < 1e3) return 0;
  if (elapsedTmeMs < 2e3) return 1;
  return 2;
}
function getReporter(options, config) {
  const perfStats = {
    filesProcessed: 0,
    filesSkipped: 0,
    filesCached: 0,
    elapsedTimeMs: 0,
    perf: /* @__PURE__ */ Object.create(null)
  };
  const noColor = options.color === false;
  const forceColor = options.color === true;
  const uniqueIssues = config?.unique || false;
  const defaultIssueTemplate = options.wordsOnly ? templateIssueWordsOnly : options.legacy ? templateIssueLegacy : options.showContext ? options.showSuggestions ? templateIssueWithContextWithSuggestions : templateIssueWithContext : options.showSuggestions ? templateIssueWithSuggestions : options.showSuggestions === false ? templateIssueNoFix : templateIssue;
  const { fileGlobs, silent, summary, issues, progress: showProgress, verbose, debug: debug5 } = options;
  const issueTemplate = config?.issueTemplate || defaultIssueTemplate;
  assertCheckTemplate(issueTemplate);
  const console$1 = config?.console || console2;
  const colorLevel = noColor ? 0 : forceColor ? 2 : console$1.stdoutChannel.getColorLevel();
  const stdio = {
    ...console$1.stdoutChannel,
    chalk: new Chalk({ level: colorLevel })
  };
  const stderr = {
    ...console$1.stderrChannel,
    chalk: new Chalk({ level: colorLevel })
  };
  const consoleError = (msg) => stderr.writeLine(msg);
  function createInfoLog(wrap) {
    return (msg) => console$1.info(wrap(msg));
  }
  const emitters = {
    Debug: !silent && debug5 ? createInfoLog(stdio.chalk.cyan) : nullEmitter2,
    Info: !silent && verbose ? createInfoLog(stdio.chalk.yellow) : nullEmitter2,
    Warning: createInfoLog(stdio.chalk.yellow)
  };
  function infoEmitter(message, msgType) {
    emitters[msgType]?.(message);
  }
  const rootURL = toFileDirURL(options.root || process.cwd());
  function relativeIssue(fn) {
    const fnFilename = options.relative ? (uri) => relativeUriFilename(uri, rootURL) : (uri) => toFilePathOrHref(toFileURL(uri, rootURL));
    return (i) => {
      const fullFilename = i.uri ? toFilePathOrHref(toFileURL(i.uri, rootURL)) : "";
      const filename = i.uri ? fnFilename(i.uri) : "";
      const r = {
        ...i,
        filename,
        fullFilename
      };
      fn(r);
    };
  }
  const repeatIssues = false;
  const issuesCollection = void 0;
  const errorCollection = [];
  function errorEmitter(message, error4) {
    if (isSpellingDictionaryLoadError(error4)) error4 = error4.cause;
    const errorText = (0, import_node_util5.formatWithOptions)({ colors: stderr.stream.hasColors?.() }, stderr.chalk.red(message), debug5 ? error4 : error4.toString());
    errorCollection?.push(errorText);
    consoleError(errorText);
  }
  const resultEmitter = (result) => {
    if (!fileGlobs.length && !result.files) return;
    const { files, issues: issues$1, cachedFiles, filesWithIssues, errors } = result;
    const numFilesWithIssues = filesWithIssues.size;
    if (stderr.getColorLevel() > 0) {
      stderr.write("\r");
      stderr.clearLine(0);
    }
    if (issuesCollection?.length || errorCollection?.length) consoleError("-------------------------------------------");
    if (issuesCollection?.length) {
      consoleError("Issues found:");
      issuesCollection.forEach((issue) => consoleError(issue));
    }
    const cachedFilesText = cachedFiles ? ` (${cachedFiles} from cache)` : "";
    const withErrorsText = errors ? ` with ${errors} error${errors === 1 ? "" : "s"}` : "";
    const numFilesWidthIssuesText = numFilesWithIssues === 1 ? "1 file" : `${numFilesWithIssues} files`;
    const summaryMessage = `CSpell: Files checked: ${files}${cachedFilesText}, Issues found: ${issues$1} in ${numFilesWidthIssuesText}${withErrorsText}.`;
    consoleError(summaryMessage);
    if (errorCollection?.length && issues$1 > 5) {
      consoleError("-------------------------------------------");
      consoleError("Errors:");
      errorCollection.forEach((error4) => consoleError(error4));
    }
    if (options.showPerfSummary) {
      consoleError("-------------------------------------------");
      consoleError("Performance Summary:");
      consoleError(`  Files Processed: ${perfStats.filesProcessed.toString().padStart(6)}`);
      consoleError(`  Files Skipped  : ${perfStats.filesSkipped.toString().padStart(6)}`);
      consoleError(`  Files Cached   : ${perfStats.filesCached.toString().padStart(6)}`);
      consoleError(`  Processing Time: ${perfStats.elapsedTimeMs.toFixed(2).padStart(9)}ms`);
      consoleError("Stats:");
      const stats2 = Object.entries(perfStats.perf).filter((p) => !!p[1]).map(([key, value]) => [key, value.toFixed(2)]);
      const padName = Math.max(...stats2.map((s) => s[0].length));
      const padValue = Math.max(...stats2.map((s) => s[1].length));
      stats2.sort((a, b) => a[0].localeCompare(b[0]));
      for (const [key, value] of stats2) value && consoleError(`  ${key.padEnd(padName)}: ${value.padStart(padValue)}ms`);
    }
  };
  function collectPerfStats(p) {
    if (p.cached) {
      perfStats.filesCached++;
      return;
    }
    perfStats.filesProcessed += p.processed ? 1 : 0;
    perfStats.filesSkipped += !p.processed ? 1 : 0;
    perfStats.elapsedTimeMs += p.elapsedTimeMs || 0;
    if (!p.perf) return;
    for (const [key, value] of Object.entries(p.perf)) if (typeof value === "number") perfStats.perf[key] = (perfStats.perf[key] || 0) + value;
  }
  function progress(p) {
    if (!silent && showProgress) reportProgress(stderr, p, rootURL, options);
    if (p.type === "ProgressFileComplete") collectPerfStats(p);
  }
  return {
    issue: relativeIssue(silent || !issues ? nullEmitter2 : genIssueEmitter(stdio, stderr, issueTemplate, uniqueIssues, issuesCollection)),
    error: silent ? nullEmitter2 : errorEmitter,
    info: infoEmitter,
    debug: emitters.Debug,
    progress,
    result: !silent && summary ? resultEmitter : nullEmitter2,
    features: void 0
  };
}
function formatIssue(io, templateStr, issue, maxIssueTextWidth) {
  function clean$12(t$1) {
    return t$1.replace(/\s+/, " ");
  }
  const { uri = "", filename, row, col, text, context = issue.line, offset } = issue;
  const contextLeft = clean$12(context.text.slice(0, offset - context.offset));
  const contextRight = clean$12(context.text.slice(offset + text.length - context.offset));
  const contextFull = clean$12(context.text);
  const padContext = " ".repeat(Math.max(maxIssueTextWidth - text.length, 0));
  const rowText = row.toString();
  const colText = col.toString();
  const padRowCol = " ".repeat(Math.max(1, 8 - (rowText.length + colText.length)));
  const suggestions$1 = formatSuggestions(io, issue);
  const msg = issue.message || (issue.isFlagged ? "Forbidden word" : "Unknown word");
  const messageColored = issue.isFlagged ? `{yellow ${msg}}` : msg;
  const substitutions = {
    $col: colText,
    $contextFull: contextFull,
    $contextLeft: contextLeft,
    $contextRight: contextRight,
    $filename: filename,
    $padContext: padContext,
    $padRowCol: padRowCol,
    $row: rowText,
    $suggestions: suggestions$1,
    $text: text,
    $uri: uri,
    $quickFix: formatQuickFix(io, issue),
    $message: msg,
    $messageColored: messageColored
  };
  const t = templateStr.replaceAll("$messageColored", messageColored);
  const chalkTemplate = makeTemplate(io.chalk);
  return substitute(chalkTemplate(t), substitutions).trimEnd();
}
function formatSuggestions(io, issue) {
  if (issue.suggestionsEx) return issue.suggestionsEx.map((sug) => sug.isPreferred ? io.chalk.italic(io.chalk.bold(sug.wordAdjustedToMatchCase || sug.word)) + "*" : sug.wordAdjustedToMatchCase || sug.word).join(", ");
  if (issue.suggestions) return issue.suggestions.join(", ");
  return "";
}
function formatQuickFix(io, issue) {
  if (!issue.suggestionsEx?.length) return "";
  const preferred = issue.suggestionsEx.filter((sug) => sug.isPreferred).map((sug) => sug.wordAdjustedToMatchCase || sug.word);
  if (!preferred.length) return "";
  const fixes = preferred.map((w) => io.chalk.italic(io.chalk.yellow(w)));
  return `fix: (${fixes.join(", ")})`;
}
function substitute(text, substitutions) {
  const subs = [];
  for (const [match2, replaceWith] of Object.entries(substitutions)) {
    const len = match2.length;
    for (let i$1 = text.indexOf(match2); i$1 >= 0; i$1 = text.indexOf(match2, i$1)) {
      const end = i$1 + len;
      const reg = /\b/y;
      reg.lastIndex = end;
      if (reg.test(text)) subs.push([
        i$1,
        end,
        replaceWith
      ]);
      i$1 = end;
    }
  }
  subs.sort((a, b) => a[0] - b[0]);
  let i = 0;
  function sub(r) {
    const [a, b, t] = r;
    const prefix = text.slice(i, a);
    i = b;
    return prefix + t;
  }
  const parts = subs.map(sub);
  return parts.join("") + text.slice(i);
}
function assertCheckTemplate(template2) {
  const r = checkTemplate(template2);
  if (r instanceof Error) throw r;
}
function checkTemplate(template2) {
  const chalk$1 = new Chalk();
  const chalkTemplate = makeTemplate(chalk$1);
  const substitutions = {
    $col: "<col>",
    $contextFull: "<contextFull>",
    $contextLeft: "<contextLeft>",
    $contextRight: "<contextRight>",
    $filename: "<filename>",
    $padContext: "<padContext>",
    $padRowCol: "<padRowCol>",
    $row: "<row>",
    $suggestions: "<suggestions>",
    $text: "<text>",
    $uri: "<uri>",
    $quickFix: "<quickFix>",
    $message: "<message>",
    $messageColored: "<messageColored>"
  };
  try {
    const t = chalkTemplate(template2);
    const result = substitute(t, substitutions);
    const problems = [...result.matchAll(/\$[a-z]+/gi)].map((m) => m[0]);
    if (problems.length) throw new Error(`Unresolved template variable${problems.length > 1 ? "s" : ""}: ${problems.map((v) => `'${v}'`).join(", ")}`);
    return true;
  } catch (e) {
    const msg = e instanceof Error ? e.message : `${e}`;
    return new ApplicationError(msg);
  }
}
function getFeatureFlags() {
  return getSystemFeatureFlags();
}
var environmentKeys = {
  CSPELL_ENABLE_DICTIONARY_LOGGING: "CSPELL_ENABLE_DICTIONARY_LOGGING",
  CSPELL_ENABLE_DICTIONARY_LOG_FILE: "CSPELL_ENABLE_DICTIONARY_LOG_FILE",
  CSPELL_ENABLE_DICTIONARY_LOG_FIELDS: "CSPELL_ENABLE_DICTIONARY_LOG_FIELDS",
  CSPELL_GLOB_ROOT: "CSPELL_GLOB_ROOT",
  CSPELL_CONFIG_PATH: "CSPELL_CONFIG_PATH",
  CSPELL_DEFAULT_CONFIG_PATH: "CSPELL_DEFAULT_CONFIG_PATH"
};
function setEnvironmentVariable(key, value) {
  process.env[key] = value;
}
function getEnvironmentVariable(key) {
  return process.env[key];
}
function truthy(value) {
  switch (value?.toLowerCase().trim()) {
    case "t":
    case "true":
    case "on":
    case "yes":
    case "1":
      return true;
  }
  return false;
}
var _dirname;
try {
  if (typeof import_meta2.url !== "string") throw new Error("assert");
  _dirname = (0, import_node_url13.fileURLToPath)(new URL(".", import_meta2.url));
} catch {
  _dirname = __dirname;
}
var pkgDir = _dirname;
var name = "cspell";
var version$1 = "9.1.5";
var engines = { node: ">=20" };
var npmPackage = {
  name,
  version: version$1,
  engines
};
var asyncMap = operators.opMapAsync;
var asyncFilter = operators.opFilterAsync;
var asyncAwait = operators.opAwaitAsync;
var asyncFlatten = operators.opFlattenAsync;
var UTF8 = "utf8";
var STDIN = "stdin";
var STDINProtocol = "stdin:";
var STDINUrlPrefix = "stdin://";
var FileUrlPrefix = "file://";
var defaultExcludeGlobs = ["node_modules/**"];
async function globP(pattern, options) {
  const cwd = options?.root || options?.cwd || process.cwd();
  const ignoreRaw = typeof options?.ignore === "string" ? [options.ignore] : options?.ignore;
  const ignore = ignoreRaw?.filter((g) => !g.startsWith("../"));
  const onlyFiles = options?.nodir;
  const dot = options?.dot;
  const patterns = typeof pattern === "string" ? [pattern] : pattern;
  const useOptions = clean4({
    cwd,
    onlyFiles,
    dot,
    ignore,
    absolute: true,
    followSymbolicLinks: false,
    expandDirectories: false
  });
  const compare$12 = new Intl.Collator("en").compare;
  const absolutePaths = (await glob$1(patterns, useOptions)).sort(compare$12);
  const relativePaths = absolutePaths.map((absFilename) => path$1.relative(cwd, absFilename));
  return relativePaths;
}
function calcGlobs(commandLineExclude) {
  const globs = new Set((commandLineExclude || []).flatMap((glob$2) => glob$2.split(/(?<!\\)\s+/g)).map((g) => g.replaceAll("\\ ", " ")));
  const commandLineExcludes = {
    globs: [...globs],
    source: "arguments"
  };
  const defaultExcludes = {
    globs: defaultExcludeGlobs,
    source: "default"
  };
  return commandLineExcludes.globs.length ? commandLineExcludes : defaultExcludes;
}
function extractPatterns(globs) {
  const r = globs.reduce((info5, g) => {
    const source = g.source;
    const patterns = g.matcher.patternsNormalizedToRoot;
    return [...info5, ...patterns.map((glob$2) => ({
      glob: glob$2,
      source
    }))];
  }, []);
  return r;
}
function calcExcludeGlobInfo(root, commandLineExclude) {
  commandLineExclude = typeof commandLineExclude === "string" ? [commandLineExclude] : commandLineExclude;
  const choice = calcGlobs(commandLineExclude);
  const matcher = new GlobMatcher(choice.globs, {
    root,
    dot: true
  });
  return [{
    matcher,
    source: choice.source
  }];
}
function buildGlobMatcher(globs, root, isExclude) {
  const withRoots = globs.map((g) => {
    const source = typeof g === "string" ? "command line" : void 0;
    return {
      source,
      ...fileOrGlobToGlob(g, root)
    };
  });
  return new GlobMatcher(withRoots, {
    root,
    mode: isExclude ? "exclude" : "include"
  });
}
function extractGlobsFromMatcher(globMatcher) {
  return globMatcher.patternsNormalizedToRoot.map((g) => g.glob);
}
function normalizeGlobsToRoot(globs, root, isExclude) {
  const urls = globs.filter((g) => typeof g === "string" && isPossibleUrlRegExp.test(g));
  const onlyGlobs = globs.filter((g) => typeof g !== "string" || !isPossibleUrlRegExp.test(g));
  return [urls, extractGlobsFromMatcher(buildGlobMatcher(onlyGlobs, root, isExclude))].flat();
}
var isPossibleGlobRegExp = /[()*?[{}]/;
var isPossibleUrlRegExp = /^[\d_a-z-]{3,}:\/\//;
async function adjustPossibleDirectory(glob$2, root) {
  const g = typeof glob$2 === "string" ? {
    glob: glob$2,
    root
  } : {
    glob: glob$2.glob,
    root: glob$2.root ?? root
  };
  if (isPossibleGlobRegExp.test(g.glob)) return glob$2;
  if (isPossibleUrlRegExp.test(g.glob)) return glob$2;
  const dirPath = path$1.resolve(g.root, g.glob);
  try {
    const stat$1 = await import_node_fs7.promises.stat(dirPath);
    if (stat$1.isDirectory()) {
      const useGlob = import_node_path10.posix.join(posixPath(g.glob), "**");
      return typeof glob$2 === "string" ? useGlob : {
        ...glob$2,
        glob: useGlob
      };
    }
  } catch {
    return glob$2;
  }
  return glob$2;
}
function posixPath(p) {
  return path$1.sep === "\\" ? p.replaceAll("\\", "/") : p;
}
async function normalizeFileOrGlobsToRoot(globs, root) {
  const adjustedGlobs = await Promise.all(globs.map((g) => adjustPossibleDirectory(g, root)));
  return normalizeGlobsToRoot(adjustedGlobs, root, false);
}
function glob$1(patterns, options) {
  patterns = typeof patterns === "string" ? workaroundPicomatchBug(patterns) : patterns.map((g) => workaroundPicomatchBug(g));
  return glob(patterns, options);
}
function readStdin() {
  return readline.createInterface(process.stdin);
}
function isStdinUrl(url2) {
  if (url2 instanceof URL) return url2.protocol === STDINProtocol;
  return url2.startsWith(STDINProtocol);
}
function resolveStdinUrl(url2, cwd) {
  (0, import_node_assert18.default)(url2.startsWith(STDINProtocol), `Expected url to start with ${STDINProtocol}`);
  const path$2 = decodeURIComponent(url2).slice(STDINProtocol.length).replace(/^\/\//, "").replace(/^\/([a-z]:)/i, "$1");
  const fileUrl = toFileURL(path$2, cwd);
  return fileUrl.toString().replace(/^file:/, STDINProtocol) + (path$2 ? "" : "/");
}
function fileInfoToDocument(fileInfo, languageId, locale) {
  const { filename, text } = fileInfo;
  languageId = languageId || void 0;
  locale = locale || void 0;
  const uri = filenameToUrl(filename);
  if (uri.href.startsWith(STDINProtocol)) return clean4({
    uri: uri.href,
    text,
    languageId,
    locale
  });
  return fileToDocument(uri.href, text, languageId, locale);
}
function filenameToUrl(filename, cwd = ".") {
  if (filename instanceof URL) return filename;
  const cwdURL2 = toFileDirURL(cwd);
  if (filename === STDIN) return new URL("stdin:///");
  if (isStdinUrl(filename)) return new URL(resolveStdinUrl(filename, cwd));
  return toFileURL(filename, cwdURL2);
}
function filenameToUri(filename, cwd) {
  return toURL(filenameToUrl(filename, cwd));
}
function isBinaryFile$1(filename, cwd) {
  const uri = filenameToUri(filename, cwd);
  if (uri.protocol.startsWith("stdin")) return false;
  return isBinaryFile2(uri);
}
function resolveFilename(filename, cwd) {
  cwd = cwd || process.cwd();
  if (filename === STDIN) return STDINUrlPrefix;
  if (filename.startsWith(FileUrlPrefix)) {
    const url2 = new URL(filename.slice(FileUrlPrefix.length), toFileDirURL(cwd));
    return (0, import_node_url13.fileURLToPath)(url2);
  }
  if (isStdinUrl(filename)) return resolveStdinUrl(filename, cwd);
  return path$1.resolve(cwd, filename);
}
function readFileInfo(filename, encoding = UTF8, handleNotFound = false) {
  filename = resolveFilename(filename);
  const pText = filename.startsWith(STDINProtocol) ? import_consumers.default.text(process.stdin) : readFileText(filename, encoding);
  return pText.then((text) => ({
    text,
    filename
  }), (e) => {
    const error4 = toError5(e);
    return handleNotFound && error4.code === "EISDIR" ? Promise.resolve({
      text: "",
      filename,
      errorCode: error4.code
    }) : handleNotFound && error4.code === "ENOENT" ? Promise.resolve({
      text: "",
      filename,
      errorCode: error4.code
    }) : Promise.reject(new IOError(`Error reading file: "${filename}"`, error4));
  });
}
function readFile3(filename, encoding = UTF8) {
  return readFileInfo(filename, encoding).then((info5) => info5.text);
}
async function findFiles(globPatterns, options) {
  const stdin = [];
  const globPats = globPatterns.filter((filename) => !isStdin(filename) && !filename.startsWith(FileUrlPrefix) ? true : (stdin.push(filename), false));
  const globResults = globPats.length ? await globP(globPats, options) : [];
  const cwd = options.cwd || process.cwd();
  return [...stdin, ...globResults].map((filename) => resolveFilename(filename, cwd));
}
var resolveFilenames = asyncMap(resolveFilename);
function readFileListFiles(listFiles) {
  let useStdin = false;
  const files = listFiles.filter((file) => {
    const isStdin$1 = file === "stdin";
    useStdin = useStdin || isStdin$1;
    return !isStdin$1;
  });
  const found = pipeAsync(files, asyncMap((file) => readFileListFile(file)), asyncAwait(), asyncFlatten());
  const stdin = useStdin ? readStdin() : [];
  return pipeAsync(toAsyncIterable(found, stdin), resolveFilenames);
}
async function readFileListFile(listFile) {
  try {
    const relTo = path$1.resolve(path$1.dirname(listFile));
    const content = await readFile3(listFile);
    const lines = content.split("\n").map((a) => a.trim()).filter((a) => !!a).map((file) => path$1.resolve(relTo, file));
    return lines;
  } catch (err) {
    throw toApplicationError(err, `Error reading file list from: "${listFile}"`);
  }
}
function isStdin(filename) {
  return filename === STDIN || isStdinUrl(filename);
}
async function isFile(filename) {
  if (isStdin(filename)) return true;
  try {
    const stat$1 = await import_node_fs7.promises.stat(filename);
    return stat$1.isFile();
  } catch {
    return false;
  }
}
async function isDir(filename) {
  try {
    const stat$1 = await import_node_fs7.promises.stat(filename);
    return stat$1.isDirectory();
  } catch {
    return false;
  }
}
function isNotDir(filename) {
  return isDir(filename).then((a) => !a);
}
function relativeToCwd2(filename, cwd = process.cwd()) {
  const urlCwd = toFileDirURL(cwd);
  const url2 = toFileURL(filename, urlCwd);
  const rel = urlRelative(urlCwd, url2);
  if (rel.startsWith("..")) return toFilePathOrHref(url2);
  return rel;
}
function createFromFile$1(pathToCache, useChecksum) {
  return import_file_entry_cache.default.createFromFile(pathToCache, useChecksum);
}
function createFromFile(pathToCache, useCheckSum, useRelative) {
  const absPathToCache = path$1.resolve(pathToCache);
  const relDir = path$1.dirname(absPathToCache);
  (0, import_node_fs7.mkdirSync)(relDir, { recursive: true });
  const create = wrap(() => createFromFile$1(absPathToCache, useCheckSum));
  const feCache = create();
  const cacheWrapper = {
    get cache() {
      return feCache.cache;
    },
    getHash(buffer) {
      return feCache.getHash(buffer);
    },
    hasFileChanged: wrap((cwd, file) => {
      return feCache.hasFileChanged(resolveFile2(cwd, file));
    }),
    analyzeFiles: wrap((cwd, files) => {
      return feCache.analyzeFiles(resolveFiles(cwd, files));
    }),
    getFileDescriptor: wrap((cwd, file) => {
      return feCache.getFileDescriptor(resolveFile2(cwd, file));
    }),
    getUpdatedFiles: wrap((cwd, files) => {
      return feCache.getUpdatedFiles(resolveFiles(cwd, files));
    }),
    normalizeEntries: wrap((cwd, files) => {
      return feCache.normalizeEntries(resolveFiles(cwd, files));
    }),
    removeEntry: wrap((cwd, file) => {
      return feCache.removeEntry(resolveFile2(cwd, file));
    }),
    deleteCacheFile() {
      feCache.deleteCacheFile();
    },
    destroy() {
      feCache.destroy();
    },
    reconcile: wrap((_cwd, noPrune) => {
      feCache.reconcile(noPrune);
    })
  };
  return cacheWrapper;
  function resolveFile2(cwd, file) {
    if (!useRelative) return normalizePath(file);
    const r = path$1.relative(relDir, path$1.resolve(cwd, file));
    return normalizePath(r);
  }
  function resolveFiles(cwd, files) {
    return files?.map((file) => resolveFile2(cwd, file));
  }
  function wrap(fn) {
    return (...params) => {
      const cwd = process.cwd();
      try {
        import_node_worker_threads.isMainThread && process.chdir(relDir);
        return fn(cwd, ...params);
      } finally {
        import_node_worker_threads.isMainThread && process.chdir(cwd);
      }
    };
  }
}
function normalizePath(filePath) {
  if (path$1.sep === "/") return filePath;
  return filePath.split(path$1.sep).join("/");
}
var compare2 = Intl.Collator().compare;
var ShallowObjectCollection = class {
  tree = {};
  get(v) {
    if (typeof v !== "object" || v === null) return v;
    const keys3 = Object.entries(v).filter((entry) => entry[1] !== void 0).sort((a, b) => compare2(a[0], b[0]));
    let t = this.tree;
    for (const [key, obj] of keys3) {
      if (!t.c) t.c = /* @__PURE__ */ new Map();
      const c0 = t.c.get(key);
      const cc = c0 || /* @__PURE__ */ new Map();
      if (!c0) t.c.set(key, cc);
      const c1 = cc.get(obj);
      const ccc = c1 || {};
      if (!c1) cc.set(obj, ccc);
      t = ccc;
    }
    if (t.v) return t.v;
    t.v = v;
    return v;
  }
};
var cacheDataKeys = {
  v: "v",
  r: "r",
  d: "d"
};
var META_DATA_BASE_VERSION = "1";
var META_DATA_VERSION_SUFFIX = "-" + META_DATA_BASE_VERSION + "-" + Object.keys(cacheDataKeys).join("|");
var DiskCache = class {
  cacheFileLocation;
  cacheDir;
  fileEntryCache;
  dependencyCache = /* @__PURE__ */ new Map();
  dependencyCacheTree = {};
  objectCollection = new ShallowObjectCollection();
  ocCacheFileResult = new ShallowObjectCollection();
  version;
  constructor(cacheFileLocation, useCheckSum, cspellVersion, useUniversalCache) {
    this.useCheckSum = useCheckSum;
    this.cspellVersion = cspellVersion;
    this.useUniversalCache = useUniversalCache;
    this.cacheFileLocation = (0, import_node_path10.resolve)(cacheFileLocation);
    this.cacheDir = (0, import_node_path10.dirname)(this.cacheFileLocation);
    this.fileEntryCache = createFromFile(this.cacheFileLocation, useCheckSum, useUniversalCache);
    this.version = calcVersion(cspellVersion);
  }
  async getCachedLintResults(filename) {
    filename = normalizePath(filename);
    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filename);
    const meta = fileDescriptor.meta;
    const data = meta?.data;
    const result = data?.r;
    const versionMatches = this.version === data?.v;
    if (fileDescriptor.notFound || fileDescriptor.changed || !meta || !result || !versionMatches || !this.checkDependencies(data.d)) return void 0;
    const dd = { ...data };
    if (dd.d) dd.d = setTreeEntry(this.dependencyCacheTree, dd.d);
    dd.r = dd.r && this.normalizeResult(dd.r);
    meta.data = this.objectCollection.get(dd);
    const hasErrors = !!result && (result.errors > 0 || result.configErrors > 0 || result.issues.length > 0);
    const cached = true;
    const shouldReadFile = hasErrors;
    return {
      ...result,
      elapsedTimeMs: void 0,
      fileInfo: shouldReadFile ? await readFileInfo(filename) : { filename },
      cached
    };
  }
  setCachedLintResults({ fileInfo, elapsedTimeMs: _, cached: __, ...result }, dependsUponFiles) {
    const fileDescriptor = this.fileEntryCache.getFileDescriptor(fileInfo.filename);
    const meta = fileDescriptor.meta;
    if (fileDescriptor.notFound || !meta) return;
    const data = this.objectCollection.get({
      v: this.version,
      r: this.normalizeResult(result),
      d: this.calcDependencyHashes(dependsUponFiles)
    });
    meta.data = data;
  }
  reconcile() {
    this.fileEntryCache.reconcile();
  }
  reset() {
    this.fileEntryCache.destroy();
    this.dependencyCache.clear();
    this.dependencyCacheTree = {};
    this.objectCollection = new ShallowObjectCollection();
    this.ocCacheFileResult = new ShallowObjectCollection();
  }
  normalizeResult(result) {
    const { issues, processed, errors, configErrors, reportIssueOptions, ...rest } = result;
    if (!Object.keys(rest).length) return this.ocCacheFileResult.get(result);
    return this.ocCacheFileResult.get({
      issues,
      processed,
      errors,
      configErrors,
      reportIssueOptions
    });
  }
  calcDependencyHashes(dependsUponFiles) {
    dependsUponFiles.sort();
    const c = getTreeEntry(this.dependencyCacheTree, dependsUponFiles);
    if (c?.d) return c.d;
    const dependencies = dependsUponFiles.map((f) => this.getDependency(f));
    return setTreeEntry(this.dependencyCacheTree, dependencies);
  }
  checkDependency(dep) {
    const depFile = this.resolveFile(dep.f);
    const cDep = this.dependencyCache.get(depFile);
    if (cDep && compDep(dep, cDep)) return true;
    if (cDep) return false;
    const d = this.getFileDep(depFile);
    if (compDep(dep, d)) {
      this.dependencyCache.set(depFile, dep);
      return true;
    }
    this.dependencyCache.set(depFile, d);
    return false;
  }
  getDependency(file) {
    const dep = this.dependencyCache.get(file);
    if (dep) return dep;
    const d = this.getFileDep(file);
    this.dependencyCache.set(file, d);
    return d;
  }
  getFileDep(file) {
    (0, import_node_assert18.default)((0, import_node_path10.isAbsolute)(file), `Dependency must be absolute "${file}"`);
    const f = this.toRelFile(file);
    let h;
    try {
      const buffer = fs$1.readFileSync(file);
      h = this.getHash(buffer);
    } catch {
      return { f };
    }
    return {
      f,
      h
    };
  }
  checkDependencies(dependencies) {
    if (!dependencies) return false;
    for (const dep of dependencies) if (!this.checkDependency(dep)) return false;
    return true;
  }
  getHash(buffer) {
    return crypto.createHash("md5").update(buffer).digest("hex");
  }
  resolveFile(file) {
    return normalizePath((0, import_node_path10.resolve)(this.cacheDir, file));
  }
  toRelFile(file) {
    return normalizePath(this.useUniversalCache ? (0, import_node_path10.relative)(this.cacheDir, file) : file);
  }
};
function getTreeEntry(tree, keys3) {
  let r = tree;
  for (const k of keys3) {
    r = r.c?.get(k);
    if (!r) return r;
  }
  return r;
}
function setTreeEntry(tree, deps, update = false) {
  let r = tree;
  for (const d$1 of deps) {
    const k = d$1.f;
    if (!r.c) r.c = /* @__PURE__ */ new Map();
    const cn = r.c.get(k);
    const n = cn ?? {};
    if (!cn) r.c.set(k, n);
    r = n;
  }
  let d = r.d;
  if (!d || r.d && update) {
    r.d = deps;
    d = deps;
  }
  return d;
}
function compDep(a, b) {
  return a.f === b.f && a.h === b.h;
}
function calcVersion(version$2) {
  return version$2 + META_DATA_VERSION_SUFFIX;
}
var DummyCache = class {
  getCachedLintResults() {
    return Promise.resolve(void 0);
  }
  setCachedLintResults() {
    return;
  }
  reconcile() {
    return;
  }
  reset() {
    return;
  }
};
var DEFAULT_CACHE_LOCATION = ".cspellcache";
var versionSuffix = "";
function createCache5(options) {
  const { useCache, cacheLocation, cacheStrategy, reset } = options;
  const location = import_node_path10.default.resolve(cacheLocation);
  const useChecksum = cacheStrategy === "content";
  const version$2 = normalizeVersion(options.version);
  const useUniversal = options.cacheFormat === "universal";
  const cache5 = useCache ? new DiskCache(location, useChecksum, version$2, useUniversal) : new DummyCache();
  reset && cache5.reset();
  return cache5;
}
async function calcCacheSettings(config, cacheOptions, root) {
  const cs = config.cache ?? {};
  const useCache = cacheOptions.cache ?? cs.useCache ?? false;
  const cacheLocation = await resolveCacheLocation(import_node_path10.default.resolve(root, cacheOptions.cacheLocation ?? cs.cacheLocation ?? DEFAULT_CACHE_LOCATION));
  const cacheStrategy = cacheOptions.cacheStrategy ?? cs.cacheStrategy ?? "content";
  const cacheFormat = cacheOptions.cacheFormat ?? cs.cacheFormat ?? "universal";
  const optionals = {};
  if (cacheOptions.cacheReset) optionals.reset = true;
  return {
    ...optionals,
    useCache,
    cacheLocation,
    cacheStrategy,
    version: cacheOptions.version,
    cacheFormat
  };
}
async function resolveCacheLocation(cacheLocation) {
  try {
    const s = await (0, import_promises4.stat)(cacheLocation);
    if (s.isFile()) return cacheLocation;
    return import_node_path10.default.join(cacheLocation, DEFAULT_CACHE_LOCATION);
  } catch (err) {
    if (isErrorLike(err) && err.code === "ENOENT") return cacheLocation;
    throw err;
  }
}
function normalizeVersion(version$2) {
  const parts = version$2.split(".").slice(0, 2);
  (0, import_node_assert18.default)(parts.length === 2);
  return parts.join(".") + versionSuffix;
}
async function readConfig(configFile, root, stopConfigSearchAt) {
  configFile ??= getEnvironmentVariable(environmentKeys.CSPELL_CONFIG_PATH);
  if (configFile) {
    const cfgFile = typeof configFile === "string" ? await readConfigHandleError(configFile) : configFile;
    return configFileToConfigInfo(cfgFile);
  }
  const config = await searchForConfig(root, { stopSearchAt: stopConfigSearchAt });
  const defaultConfigFile2 = getEnvironmentVariable(environmentKeys.CSPELL_DEFAULT_CONFIG_PATH);
  if (!config && defaultConfigFile2) {
    const cfgFile = await readConfigFile2(defaultConfigFile2).catch(() => void 0);
    if (cfgFile) return configFileToConfigInfo(cfgFile);
  }
  return {
    source: config?.__importRef?.filename || "None found",
    config: config || {}
  };
}
async function configFileToConfigInfo(cfgFile) {
  const config = await resolveConfigFileImports(cfgFile);
  const source = toFilePathOrHref(cfgFile.url);
  return {
    source,
    config
  };
}
function readConfigFile2(filename) {
  return readConfigFile(filename);
}
async function readConfigHandleError(filename) {
  try {
    return await readConfigFile2(filename);
  } catch (e) {
    const settings = { __importRef: {
      filename: filename.toString(),
      error: e
    } };
    return {
      url: filenameToUrl(filename),
      settings
    };
  }
}
function prefCharIndex(text, offset, count3 = 1) {
  if (offset - count3 < 0) return 0;
  for (; count3 > 0 && offset > 0; count3--) {
    let code = text.charCodeAt(--offset) || 0;
    if (code === 65039) code = text.charCodeAt(--offset) || 0;
    offset -= (code & 64512) === 56320 ? 1 : 0;
  }
  return offset < 0 ? 0 : offset;
}
function nextCharIndex(text, offset, count3 = 1) {
  if (offset + count3 >= text.length) return text.length;
  for (; count3 > 0 && offset < text.length; count3--) {
    const code = text.charCodeAt(offset++) || 0;
    offset += (code & 64512) === 55296 ? 1 : 0;
    if (text.charCodeAt(offset) === 65039) offset++;
  }
  return offset > text.length ? text.length : offset;
}
function lineContext(lineText, start, end, contextRange) {
  let left = prefCharIndex(lineText, start, contextRange);
  let right = nextCharIndex(lineText, end, contextRange);
  const isLetter2 = /^\p{L}$/u;
  const isMark = /^\p{M}$/u;
  for (let n = contextRange / 2; n > 0 && left > 0; n--, left--) {
    const c = lineText[left - 1];
    if (isMark.test(c)) {
      if (!isLetter2.test(lineText[left - 2])) break;
      left--;
      continue;
    }
    if (!isLetter2.test(lineText[left - 1])) break;
  }
  for (let n = contextRange / 2; n > 0 && right < lineText.length; n--, right++) {
    if (!isLetter2.test(lineText[right])) break;
    if (isMark.test(lineText[right + 1])) right++;
  }
  left = left < 0 ? 0 : left;
  const t0 = lineText.slice(left, right);
  const tLeft = t0.trimStart();
  left = Math.min(left + t0.length - tLeft.length, start);
  const text = tLeft.trimEnd();
  const context = {
    text,
    offset: left
  };
  return context;
}
function extractContext(tdo, contextRange) {
  const { line, offset, text } = tdo;
  const start = offset - line.offset;
  const context = lineContext(line.text, start, start + text.length, contextRange);
  context.offset += line.offset;
  return context;
}
function* prefetchIterable(iterable, size) {
  (0, import_node_assert18.default)(size >= 0);
  const buffer = [];
  for (const value of iterable) {
    buffer.push(value);
    if (buffer.length >= size - 1) {
      const value$1 = buffer[0];
      buffer.shift();
      yield value$1;
    }
  }
  yield* buffer;
}
function filterFeatureIssues(features, issue, reportOptions) {
  if (issue.issueType === IssueType.directive) return features?.issueType && reportOptions?.validateDirectives || false;
  if (features?.unknownWords) return true;
  if (!reportOptions) return true;
  if (issue.isFlagged || !reportOptions.unknownWords || reportOptions.unknownWords === unknownWordsChoices.ReportAll) return true;
  if (issue.hasPreferredSuggestions && reportOptions.unknownWords !== unknownWordsChoices.ReportFlagged) return true;
  if (issue.hasSimpleSuggestions && reportOptions.unknownWords === unknownWordsChoices.ReportSimple) return true;
  return false;
}
function handleIssue(reporter, issue, reportOptions) {
  if (!reporter.issue) return;
  if (!filterFeatureIssues(reporter.features, issue, reportOptions)) return;
  if (!reporter.features?.contextGeneration && !issue.context) {
    issue = { ...issue };
    issue.context = issue.line;
  }
  return reporter.issue(issue, reportOptions);
}
async function loadReporters(reporters, defaultReporter, config) {
  async function loadReporter(reporterSettings) {
    if (reporterSettings === "default") return defaultReporter;
    if (!Array.isArray(reporterSettings)) reporterSettings = [reporterSettings];
    const [moduleName, settings] = reporterSettings;
    try {
      const { getReporter: getReporter$1 } = await dynamicImportFrom(moduleName, [process.cwd(), pkgDir]);
      return getReporter$1(settings, config);
    } catch (e) {
      throw new ApplicationError(`Failed to load reporter ${moduleName}: ${toError5(e).message}`);
    }
  }
  reporters = !reporters || !reporters.length ? ["default"] : [...reporters];
  const loadedReporters = await Promise.all(reporters.map(loadReporter));
  return loadedReporters.filter((v) => v !== void 0);
}
function finalizeReporter(reporter) {
  if (!reporter) return void 0;
  if (reporterIsFinalized(reporter)) return reporter;
  const final = {
    issue: (...params) => reporter.issue?.(...params),
    info: (...params) => reporter.info?.(...params),
    debug: (...params) => reporter.debug?.(...params),
    progress: (...params) => reporter.progress?.(...params),
    error: (...params) => reporter.error?.(...params),
    result: (...params) => reporter.result?.(...params),
    features: reporter.features
  };
  return final;
}
function reporterIsFinalized(reporter) {
  return !!reporter && reporter.features && typeof reporter.issue === "function" && typeof reporter.info === "function" && typeof reporter.debug === "function" && typeof reporter.error === "function" && typeof reporter.progress === "function" && typeof reporter.result === "function" || false;
}
var reportIssueOptionsKeyMap = {
  unknownWords: "unknownWords",
  validateDirectives: "validateDirectives",
  showContext: "showContext"
};
function setValue(options, key, value) {
  if (value !== void 0) options[key] = value;
}
function extractReporterIssueOptions(settings) {
  const src = settings;
  const options = {};
  for (const key in reportIssueOptionsKeyMap) {
    const k = key;
    setValue(options, k, src[k]);
  }
  return options;
}
function mergeReportIssueOptions(a, b) {
  const options = extractReporterIssueOptions(a);
  if (!b) return options;
  for (const key in reportIssueOptionsKeyMap) {
    const k = key;
    setValue(options, k, b[k]);
  }
  return options;
}
var LintReporter = class {
  #reporters = [];
  #config;
  #finalized = false;
  constructor(defaultReporter, config) {
    this.defaultReporter = defaultReporter;
    this.#config = config;
    if (defaultReporter) this.#reporters.push(finalizeReporter(defaultReporter));
  }
  get config() {
    return this.#config;
  }
  set config(config) {
    (0, import_node_assert18.default)(!this.#finalized, "Cannot change the configuration of a finalized reporter");
    this.#config = config;
  }
  issue(issue, reportOptions) {
    for (const reporter of this.#reporters) handleIssue(reporter, issue, reportOptions);
  }
  info(...params) {
    for (const reporter of this.#reporters) reporter.info(...params);
  }
  debug(...params) {
    for (const reporter of this.#reporters) reporter.debug(...params);
  }
  error(...params) {
    for (const reporter of this.#reporters) reporter.error(...params);
  }
  progress(...params) {
    for (const reporter of this.#reporters) reporter.progress(...params);
  }
  async result(result) {
    await Promise.all(this.#reporters.map((reporter) => reporter.result?.(result)));
  }
  get features() {
    return {
      unknownWords: true,
      issueType: true
    };
  }
  async loadReportersAndFinalize(reporters) {
    (0, import_node_assert18.default)(!this.#finalized, "Cannot change the configuration of a finalized reporter");
    const loaded = await loadReporters(reporters, this.defaultReporter, this.config);
    this.#reporters = [...new Set(loaded)].map((reporter) => finalizeReporter(reporter));
  }
  emitProgressBegin(filename, fileNum, fileCount) {
    this.progress({
      type: "ProgressFileBegin",
      fileNum,
      fileCount,
      filename
    });
  }
  emitProgressComplete(filename, fileNum, fileCount, result) {
    const filteredIssues = result.issues.filter((issue) => filterFeatureIssues({}, issue, result.reportIssueOptions));
    const numIssues = filteredIssues.length;
    for (const reporter of this.#reporters) {
      const progress = clean4({
        type: "ProgressFileComplete",
        fileNum,
        fileCount,
        filename,
        elapsedTimeMs: result.elapsedTimeMs,
        processed: result.processed,
        numErrors: numIssues || result.errors,
        cached: result.cached,
        perf: result.perf,
        issues: reporter.features && result.issues,
        reportIssueOptions: reporter.features && result.reportIssueOptions
      });
      reporter.progress(progress);
    }
    result.issues.forEach((issue) => this.issue(issue, result.reportIssueOptions));
    return numIssues;
  }
};
function getTimeMeasurer() {
  const timer = createPerfTimer2("timer");
  return () => timer.elapsed;
}
async function writeFileOrStream(filename, data) {
  switch (filename) {
    case "stdout": {
      await writeStream(process.stdout, data);
      return;
    }
    case "stderr": {
      await writeStream(process.stderr, data);
      return;
    }
    case "null":
      return;
  }
  return import_promises4.default.writeFile(filename, data);
}
function writeStream(stream, data) {
  return new Promise((resolve$1, reject) => {
    stream.write(data, (err) => {
      if (err) reject(err);
      else resolve$1();
    });
  });
}
var version2 = npmPackage.version;
var BATCH_SIZE = 8;
var { opFilterAsync: opFilterAsync2 } = operators;
async function runLint(cfg) {
  const reporter = new LintReporter(cfg.reporter, cfg.options);
  const configErrors = /* @__PURE__ */ new Set();
  const timer = getTimeMeasurer();
  const logDictRequests = truthy(getEnvironmentVariable("CSPELL_ENABLE_DICTIONARY_LOGGING"));
  if (logDictRequests) _debug.cacheDictionaryEnableLogging(true);
  const lintResult = await run2();
  if (logDictRequests) await writeDictionaryLog();
  await reporter.result(lintResult);
  const elapsed = timer();
  if (getFeatureFlags().getFlag("timer")) console2.log(`Elapsed Time: ${elapsed.toFixed(2)}ms`);
  return lintResult;
  function prefetch(filename, configInfo, cache5) {
    if (isBinaryFile$1(filename, cfg.root)) return {
      filename,
      result: Promise.resolve({ skip: true })
    };
    const reportIssueOptions = extractReporterIssueOptions(configInfo.config);
    async function fetch() {
      const getElapsedTimeMs = getTimeMeasurer();
      const cachedResult = await cache5.getCachedLintResults(filename);
      if (cachedResult) {
        reporter.debug(`Filename: ${filename}, using cache`);
        const fileResult = {
          ...cachedResult,
          elapsedTimeMs: getElapsedTimeMs()
        };
        return { fileResult };
      }
      const uri = filenameToUri(filename, cfg.root).href;
      const checkResult = await shouldCheckDocument({ uri }, {}, configInfo.config);
      if (!checkResult.shouldCheck) return { skip: true };
      const fileInfo = await readFileInfo(filename, void 0, true);
      return {
        fileInfo,
        reportIssueOptions
      };
    }
    const result = fetch();
    return {
      filename,
      result
    };
  }
  async function processFile(filename, configInfo, cache5, prefetch$1) {
    if (prefetch$1?.fileResult) return prefetch$1.fileResult;
    const getElapsedTimeMs = getTimeMeasurer();
    const reportIssueOptions = prefetch$1?.reportIssueOptions;
    const cachedResult = await cache5.getCachedLintResults(filename);
    if (cachedResult) {
      reporter.debug(`Filename: ${filename}, using cache`);
      return {
        ...cachedResult,
        elapsedTimeMs: getElapsedTimeMs(),
        reportIssueOptions: {
          ...cachedResult.reportIssueOptions,
          ...reportIssueOptions
        }
      };
    }
    const result = {
      fileInfo: { filename },
      issues: [],
      processed: false,
      errors: 0,
      configErrors: 0,
      elapsedTimeMs: 0,
      reportIssueOptions
    };
    const fileInfo = prefetch$1?.fileInfo || await readFileInfo(filename, void 0, true);
    if (fileInfo.errorCode) {
      if (fileInfo.errorCode !== "EISDIR" && cfg.options.mustFindFiles) {
        const err = new LinterError(`File not found: "${filename}"`);
        reporter.error("Linter:", err);
        result.errors += 1;
      }
      return result;
    }
    const doc = fileInfoToDocument(fileInfo, cfg.options.languageId, cfg.locale);
    const { text } = fileInfo;
    result.fileInfo = fileInfo;
    let spellResult = {};
    reporter.info(`Checking: ${filename}, File type: ${doc.languageId ?? "auto"}, Language: ${doc.locale ?? "default"}`, MessageTypes.Info);
    try {
      const { showSuggestions: generateSuggestions, validateDirectives, skipValidation } = cfg.options;
      const numSuggestions = configInfo.config.numSuggestions ?? 5;
      const validateOptions2 = clean4({
        generateSuggestions,
        numSuggestions,
        validateDirectives,
        skipValidation
      });
      const r = await spellCheckDocument(doc, validateOptions2, configInfo.config);
      spellResult = r;
      result.processed = r.checked;
      result.perf = r.perf ? { ...r.perf } : void 0;
      result.issues = textApi_exports.calculateTextDocumentOffsets(doc.uri, text, r.issues).map(mapIssue);
    } catch (e) {
      reporter.error(`Failed to process "${filename}"`, toError5(e));
      result.errors += 1;
    }
    result.elapsedTimeMs = getElapsedTimeMs();
    const config = spellResult.settingsUsed ?? {};
    result.reportIssueOptions = mergeReportIssueOptions(spellResult.settingsUsed || configInfo.config, reportIssueOptions);
    result.configErrors += await reportConfigurationErrors(config);
    const elapsed$1 = result.elapsedTimeMs;
    const dictionaries = config.dictionaries || [];
    reporter.info(`Checked: ${filename}, File type: ${config.languageId}, Language: ${config.language} ... Issues: ${result.issues.length} ${elapsed$1.toFixed(2)}ms`, MessageTypes.Info);
    reporter.info(`Config file Used: ${spellResult.localConfigFilepath || configInfo.source}`, MessageTypes.Info);
    reporter.info(`Dictionaries Used: ${dictionaries.join(", ")}`, MessageTypes.Info);
    if (cfg.options.debug) {
      const { id: _id, name: _name, __imports, __importRef, ...cfg$1 } = config;
      const debugCfg = {
        filename,
        languageId: doc.languageId ?? cfg$1.languageId ?? "default",
        config: {
          ...cfg$1,
          source: null
        },
        source: spellResult.localConfigFilepath
      };
      reporter.debug(JSON.stringify(debugCfg, void 0, 2));
    }
    const dep = calcDependencies(config);
    cache5.setCachedLintResults(result, dep.files);
    return result;
  }
  function mapIssue({ doc: _, ...tdo }) {
    const context = cfg.showContext ? extractContext(tdo, cfg.showContext) : void 0;
    return clean4({
      ...tdo,
      context
    });
  }
  async function processFiles(files, configInfo, cacheSettings) {
    const fileCount = Array.isArray(files) ? files.length : void 0;
    const status = runResult();
    const cache5 = createCache5(cacheSettings);
    const failFast = cfg.options.failFast ?? configInfo.config.failFast ?? false;
    function* prefetchFiles(files$1) {
      const iter = prefetchIterable(pipeSync(files$1, opMapSync((filename) => prefetch(filename, configInfo, cache5))), BATCH_SIZE);
      for (const v of iter) yield v;
    }
    async function* prefetchFilesAsync(files$1) {
      for await (const filename of files$1) yield prefetch(filename, configInfo, cache5);
    }
    const emptyResult = {
      fileInfo: { filename: "" },
      issues: [],
      processed: false,
      errors: 0,
      configErrors: 0,
      elapsedTimeMs: 1,
      reportIssueOptions: void 0
    };
    async function processPrefetchFileResult(pf, index) {
      const { filename, result: pFetchResult } = pf;
      const getElapsedTimeMs = getTimeMeasurer();
      const fetchResult = await pFetchResult;
      reporter.emitProgressBegin(filename, index, fileCount ?? index);
      if (fetchResult?.skip) return {
        filename,
        fileNum: index,
        result: {
          ...emptyResult,
          fileInfo: { filename },
          elapsedTimeMs: getElapsedTimeMs()
        }
      };
      const result = await processFile(filename, configInfo, cache5, fetchResult);
      return {
        filename,
        fileNum: index,
        result
      };
    }
    async function* loadAndProcessFiles() {
      let i = 0;
      if (isAsyncIterable(files)) for await (const pf of prefetchFilesAsync(files)) yield processPrefetchFileResult(pf, ++i);
      else for (const pf of prefetchFiles(files)) {
        await pf.result;
        yield processPrefetchFileResult(pf, ++i);
      }
    }
    for await (const fileP of loadAndProcessFiles()) {
      const { filename, fileNum, result } = fileP;
      status.files += 1;
      status.cachedFiles = (status.cachedFiles || 0) + (result.cached ? 1 : 0);
      const numIssues = reporter.emitProgressComplete(filename, fileNum, fileCount ?? fileNum, result);
      if (numIssues || result.errors) {
        status.filesWithIssues.add(relativeToCwd2(filename, cfg.root));
        status.issues += numIssues;
        status.errors += result.errors;
        if (failFast) return status;
      }
      status.errors += result.configErrors;
    }
    cache5.reconcile();
    return status;
  }
  function calcDependencies(config) {
    const { configFiles, dictionaryFiles } = extractDependencies(config);
    return { files: [...configFiles, ...dictionaryFiles] };
  }
  async function reportConfigurationErrors(config) {
    const errors = extractImportErrors(config);
    let count3 = 0;
    errors.forEach((ref) => {
      const key = ref.error.toString();
      if (configErrors.has(key)) return;
      configErrors.add(key);
      count3 += 1;
      reporter.error("Configuration", ref.error);
    });
    const dictCollection = await getDictionary(config);
    dictCollection.dictionaries.forEach((dict) => {
      const dictErrors = dict.getErrors?.() || [];
      const msg = `Dictionary Error with (${dict.name})`;
      dictErrors.forEach((error4) => {
        const key = msg + error4.toString();
        if (configErrors.has(key)) return;
        configErrors.add(key);
        count3 += 1;
        reporter.error(msg, error4);
      });
    });
    return count3;
  }
  function countConfigErrors(configInfo) {
    return reportConfigurationErrors(configInfo.config);
  }
  async function run2() {
    if (cfg.options.root) setEnvironmentVariable(ENV_CSPELL_GLOB_ROOT, cfg.root);
    const configInfo = await readConfig(cfg.configFile, cfg.root, cfg.options.stopConfigSearchAt);
    if (cfg.options.defaultConfiguration !== void 0) configInfo.config.loadDefaultConfiguration = cfg.options.defaultConfiguration;
    configInfo.config = mergeSettings(configInfo.config, cfg.cspellSettingsFromCliOptions);
    const reporterConfig = clean4({
      maxNumberOfProblems: configInfo.config.maxNumberOfProblems,
      maxDuplicateProblems: configInfo.config.maxDuplicateProblems,
      minWordLength: configInfo.config.minWordLength,
      ...cfg.options,
      console: console2
    });
    const reporters = cfg.options.reporter ?? configInfo.config.reporters;
    reporter.config = reporterConfig;
    await reporter.loadReportersAndFinalize(reporters);
    setLogger(getLoggerFromReporter(reporter));
    const globInfo = await determineGlobs(configInfo, cfg);
    const { fileGlobs, excludeGlobs } = globInfo;
    const hasFileLists = !!cfg.fileLists.length;
    if (!fileGlobs.length && !hasFileLists && !cfg.files?.length) return runResult();
    header(fileGlobs, excludeGlobs);
    checkGlobs(fileGlobs, reporter);
    reporter.info(`Config Files Found:
    ${configInfo.source}
`, MessageTypes.Info);
    const configErrors$1 = await countConfigErrors(configInfo);
    if (configErrors$1 && cfg.options.exitCode !== false && !cfg.options.continueOnError) return runResult({ errors: configErrors$1 });
    const { root } = cfg;
    try {
      const cacheSettings = await calcCacheSettings(configInfo.config, {
        ...cfg.options,
        version: version2
      }, root);
      const files = await determineFilesToCheck(configInfo, cfg, reporter, globInfo);
      const result = await processFiles(files, configInfo, cacheSettings);
      if (configErrors$1 && cfg.options.exitCode !== false) result.errors ||= configErrors$1;
      return result;
    } catch (e) {
      const err = toApplicationError(e);
      reporter.error("Linter", err);
      return runResult({ errors: 1 });
    }
  }
  function header(files, cliExcludes) {
    const formattedFiles = files.length > 100 ? [...files.slice(0, 100), "..."] : files;
    reporter.info(`
cspell;
Date: ${(/* @__PURE__ */ new Date()).toUTCString()}
Options:
    verbose:   ${yesNo(!!cfg.options.verbose)}
    config:    ${cfg.configFile || "default"}
    exclude:   ${cliExcludes.join("\n               ")}
    files:     ${formattedFiles}
    wordsOnly: ${yesNo(!!cfg.options.wordsOnly)}
    unique:    ${yesNo(!!cfg.options.unique)}
`, MessageTypes.Info);
  }
}
function checkGlobs(globs, reporter) {
  globs.filter((g) => g.startsWith("'") || g.endsWith("'")).map((glob$2) => source_default.yellow(glob$2)).forEach((glob$2) => reporter.error("Linter", new CheckFailed(`Glob starting or ending with ' (single quote) is not likely to match any files: ${glob$2}.`)));
}
async function determineGlobs(configInfo, cfg) {
  const useGitignore = cfg.options.gitignore ?? configInfo.config.useGitignore ?? false;
  const gitignoreRoots = cfg.options.gitignoreRoot ?? configInfo.config.gitignoreRoot;
  const gitIgnore = useGitignore ? await generateGitIgnore(gitignoreRoots) : void 0;
  const cliGlobs = cfg.fileGlobs;
  const allGlobs = cliGlobs.length && cliGlobs || cfg.options.filterFiles !== false && configInfo.config.files || [];
  const combinedGlobs = await normalizeFileOrGlobsToRoot(allGlobs, cfg.root);
  const cliExcludeGlobs = extractPatterns(cfg.excludes).map((p) => p.glob);
  const normalizedExcludes = normalizeGlobsToRoot(cliExcludeGlobs, cfg.root, true);
  const includeGlobs = combinedGlobs.filter((g) => !g.startsWith("!"));
  const excludeGlobs = [...combinedGlobs.filter((g) => g.startsWith("!")).map((g) => g.slice(1)), ...normalizedExcludes];
  const fileGlobs = includeGlobs;
  const appGlobs = {
    allGlobs,
    gitIgnore,
    fileGlobs,
    excludeGlobs,
    normalizedExcludes
  };
  return appGlobs;
}
async function determineFilesToCheck(configInfo, cfg, reporter, globInfo) {
  async function _determineFilesToCheck() {
    const { fileLists } = cfg;
    const hasFileLists = !!fileLists.length;
    const { allGlobs, gitIgnore, fileGlobs, excludeGlobs, normalizedExcludes } = globInfo;
    const { root } = cfg;
    const globsToExcludeRaw = [...configInfo.config.ignorePaths || [], ...excludeGlobs];
    const globsToExclude = globsToExcludeRaw.filter((g) => !globPattern(g).startsWith("!"));
    if (globsToExclude.length !== globsToExcludeRaw.length) {
      const globs = globsToExcludeRaw.map((g) => globPattern(g)).filter((g) => g.startsWith("!"));
      const msg = `Negative glob exclusions are not supported: ${globs.join(", ")}`;
      reporter.info(msg, MessageTypes.Warning);
    }
    const globMatcher = buildGlobMatcher(globsToExclude, root, true);
    const ignoreGlobs = extractGlobsFromMatcher(globMatcher);
    const globOptions = {
      root,
      cwd: root,
      ignore: [...ignoreGlobs, ...normalizedExcludes],
      nodir: true
    };
    const enableGlobDot = cfg.enableGlobDot ?? configInfo.config.enableGlobDot;
    if (enableGlobDot !== void 0) globOptions.dot = enableGlobDot;
    const opFilterExcludedFiles = opFilter(filterOutExcludedFilesFn(globMatcher));
    const includeFilter = createIncludeFileFilterFn(allGlobs, root, enableGlobDot);
    const rawCliFiles = cfg.files?.map((file) => resolveFilename(file, root)).filter(includeFilter);
    const cliFiles = cfg.options.mustFindFiles ? rawCliFiles : rawCliFiles && pipeAsync(rawCliFiles, opFilterAsync2(isFile));
    const foundFiles = hasFileLists ? concatAsyncIterables(cliFiles, await useFileLists(fileLists, includeFilter)) : cliFiles || await findFiles(fileGlobs, globOptions);
    const filtered = gitIgnore ? await gitIgnore.filterOutIgnored(foundFiles) : foundFiles;
    const files = isAsyncIterable(filtered) ? pipeAsync(filtered, opFilterExcludedFiles) : [...pipeSync(filtered, opFilterExcludedFiles)];
    return files;
  }
  function isExcluded(filename, globMatcherExclude) {
    if (isBinaryFile2(toFileURL(filename))) return true;
    const { root } = cfg;
    const absFilename = path$1.resolve(root, filename);
    const r = globMatcherExclude.matchEx(absFilename);
    if (r.matched) {
      const { glob: glob$2, source } = extractGlobSource(r.pattern);
      reporter.info(`Excluded File: ${path$1.relative(root, absFilename)}; Excluded by ${glob$2} from ${source}`, MessageTypes.Info);
    }
    return r.matched;
  }
  function filterOutExcludedFilesFn(globMatcherExclude) {
    const patterns = globMatcherExclude.patterns;
    const excludeInfo = patterns.map(extractGlobSource).map(({ glob: glob$2, source }) => `Glob: ${glob$2} from ${source}`).filter(uniqueFn2());
    reporter.info(`Exclusion Globs: 
    ${excludeInfo.join("\n    ")}
`, MessageTypes.Info);
    return (filename) => !isExcluded(filename, globMatcherExclude);
  }
  return _determineFilesToCheck();
}
function extractGlobSource(g) {
  const { glob: glob$2, rawGlob, source } = g;
  return {
    glob: rawGlob || glob$2,
    source
  };
}
function runResult(init = {}) {
  const { files = 0, filesWithIssues = /* @__PURE__ */ new Set(), issues = 0, errors = 0, cachedFiles = 0 } = init;
  return {
    files,
    filesWithIssues,
    issues,
    errors,
    cachedFiles
  };
}
function yesNo(value) {
  return value ? "Yes" : "No";
}
function getLoggerFromReporter(reporter) {
  const log3 = (...params) => {
    const msg = (0, import_node_util5.format)(...params);
    reporter.info(msg, "Info");
  };
  const error4 = (...params) => {
    const msg = (0, import_node_util5.format)(...params);
    const err = {
      message: "",
      name: "error",
      toString: () => ""
    };
    reporter.error(msg, err);
  };
  const warn = (...params) => {
    const msg = (0, import_node_util5.format)(...params);
    reporter.info(msg, "Warning");
  };
  return {
    log: log3,
    warn,
    error: error4
  };
}
async function generateGitIgnore(roots) {
  const root = (typeof roots === "string" ? [roots].filter((r) => !!r) : roots) || [];
  if (!root?.length) {
    const cwd = process.cwd();
    const repo = await findRepoRoot(cwd) || cwd;
    root.push(repo);
  }
  return new GitIgnore(root?.map((p) => path$1.resolve(p)));
}
async function useFileLists(fileListFiles, filterFiles) {
  const files = readFileListFiles(fileListFiles);
  return pipeAsync(files, opFilter(filterFiles), opFilterAsync2(isNotDir));
}
function createIncludeFileFilterFn(includeGlobPatterns, root, dot) {
  if (!includeGlobPatterns?.length) return () => true;
  const patterns = includeGlobPatterns.map((g) => g === "." ? "/**" : g);
  const options = {
    root,
    mode: "include"
  };
  if (dot !== void 0) options.dot = dot;
  const globMatcher = new GlobMatcher(patterns, options);
  return (file) => globMatcher.match(file);
}
async function* concatAsyncIterables(...iterables) {
  for (const iter of iterables) {
    if (!iter) continue;
    yield* iter;
  }
}
async function writeDictionaryLog() {
  const fieldsCsv = getEnvironmentVariable("CSPELL_ENABLE_DICTIONARY_LOG_FIELDS") || "time, word, value";
  const fields = fieldsCsv.split(",").map((f) => f.trim());
  const header = fields.join(", ") + "\n";
  const lines = _debug.cacheDictionaryGetLog().filter((d) => d.method === "has").map((d) => fields.map((f) => f in d ? `${d[f]}` : "").join(", "));
  const data = header + lines.join("\n") + "\n";
  const filename = getEnvironmentVariable("CSPELL_ENABLE_DICTIONARY_LOG_FILE") || "cspell-dictionary-log.csv";
  await writeFileOrStream(filename, data);
}
function globPattern(g) {
  return typeof g === "string" ? g : g.glob;
}
var LinterError = class extends Error {
  constructor(message) {
    super(message);
  }
  toString() {
    return this.message;
  }
};
var defaultContextRange = 20;
var LintRequest = class {
  locale;
  configFile;
  excludes;
  root;
  showContext;
  enableGlobDot;
  fileLists;
  files;
  cspellSettingsFromCliOptions;
  constructor(fileGlobs, options, reporter) {
    this.fileGlobs = fileGlobs;
    this.options = options;
    this.reporter = reporter;
    this.root = path$1.resolve(options.root || process.cwd());
    this.configFile = options.config;
    this.excludes = calcExcludeGlobInfo(this.root, options.exclude);
    this.locale = options.locale ?? options.local ?? "";
    this.enableGlobDot = options.dot;
    this.showContext = Math.max(options.showContext === true ? defaultContextRange : options.showContext ? options.showContext : 0, 0);
    this.fileLists = (options.fileList ?? options.fileLists) || [];
    this.files = mergeFiles(options.file, options.files);
    const noConfigSearch = options.configSearch === false ? true : options.configSearch === true ? false : void 0;
    const dictionaries = [...(options.disableDictionary ?? []).map((d) => `!${d}`), ...(options.dictionary ?? []).map((d) => `!!${d}`)];
    const languageSettings = [{
      languageId: "*",
      locale: "*",
      dictionaries
    }];
    this.cspellSettingsFromCliOptions = {
      ...noConfigSearch !== void 0 ? { noConfigSearch } : {},
      ...extractUnknownWordsConfig(options),
      languageSettings
    };
  }
};
function mergeFiles(a, b) {
  const files = merge4(a, b);
  if (!files) return void 0;
  return [...new Set(files.flatMap((a$1) => a$1.split("\n").map((a$2) => a$2.trim())).filter((a$1) => !!a$1))];
}
function merge4(a, b) {
  if (!a) return b;
  if (!b) return a;
  return [...a, ...b];
}
function extractUnknownWordsConfig(options) {
  const config = {};
  if (!options.report) return config;
  switch (options.report) {
    case "all": {
      config.unknownWords = unknownWordsChoices.ReportAll;
      break;
    }
    case "simple": {
      config.unknownWords = unknownWordsChoices.ReportSimple;
      break;
    }
    case "typos": {
      config.unknownWords = unknownWordsChoices.ReportCommonTypos;
      break;
    }
    case "flagged": {
      config.unknownWords = unknownWordsChoices.ReportFlagged;
      break;
    }
  }
  return config;
}
function fixLegacy(opts) {
  const { local, ...rest } = opts;
  if (local && !rest.locale) rest.locale = local;
  return rest;
}
function lint(fileGlobs, options, reporter) {
  options = fixLegacy(options);
  const unknownWordsConfig = extractUnknownWordsConfig(options);
  const useOptions = {
    ...options,
    ...unknownWordsConfig
  };
  const reporterOptions = {
    ...useOptions,
    console: console2
  };
  const cfg = new LintRequest(fileGlobs, useOptions, finalizeReporter(reporter) ?? getReporter({
    ...useOptions,
    fileGlobs
  }, reporterOptions));
  return runLint(cfg);
}

// src/spell.ts
async function lint2(globs, lintOptions, reporter) {
  const { root, config, checkDotFiles, files, showSuggestions, report } = lintOptions;
  const mustFindFiles = !files;
  const options = {
    root,
    config,
    files,
    // filterFiles: files ? false : undefined,
    mustFindFiles,
    showSuggestions,
    report
  };
  if (checkDotFiles) {
    options.dot = true;
  } else if (checkDotFiles === false) {
    options.dot = false;
  }
  await lint(globs, options, reporter);
}

// src/checkSpelling.ts
var core2 = { debug: import_core2.debug, error: import_core2.error, info: import_core2.info, warning: import_core2.warning };
async function checkSpellingForContext(params, context) {
  const files = await gatherGitCommitFilesFromContext(context);
  const globs = await gatherFileGlobsFromContext(context);
  const result = await checkSpelling(params, globs, files);
  return result;
}
async function gatherGitCommitFilesFromContext(context) {
  if (context.useEventFiles) {
    const eventFiles = await gatherFiles(context);
    if (!eventFiles) return void 0;
    const root = await gitRoot();
    return [...eventFiles].map((f) => import_node_path11.default.resolve(root, f));
  }
}
async function gatherFileGlobsFromContext(context) {
  if (context.useCSpellFiles) {
    return void 0;
  }
  const files = new Set(
    context.globs.split("\n").map((a) => a.trim()).filter((a) => !!a)
  );
  return [...files];
}
async function gatherFiles(context) {
  const eventName = context.githubContext.eventName;
  try {
    switch (eventName) {
      case "push":
        return new Set(await gitListFilesForPush(context.githubContext.payload));
      case "pull_request":
        return new Set(await gitListFilesForPullRequest(context.githubContext.payload));
      default:
        core2.warning(`Unsupported event: ${eventName}. Using files from latest commit.`);
        return new Set(await gitListFiles("HEAD"));
    }
  } catch (e) {
    core2.error(toError(e));
  }
  return void 0;
}
async function checkSpelling(params, globs, files) {
  const options = {
    root: params.root || process.cwd(),
    config: params.config || void 0,
    checkDotFiles: checkDotMap[params.check_dot_files],
    files,
    showSuggestions: params.suggestions === "true",
    report: params.report
  };
  const reporterOptions = {
    verbose: params.verbose === "true",
    treatFlaggedWordsAsErrors: params.treat_flagged_words_as_errors === "true"
  };
  const collector = new CSpellReporterForGithubAction(params.inline, reporterOptions, core2);
  await lint2(globs || [], options, collector.reporter);
  return collector.result;
}

// src/getActionParams.ts
var import_core3 = __toESM(require_core(), 1);
function getActionParams() {
  const params = {
    // github_token: getInput('github_token', { required: true }),
    files: (0, import_core3.getInput)("files"),
    incremental_files_only: tf((0, import_core3.getInput)("incremental_files_only")),
    config: (0, import_core3.getInput)("config"),
    root: (0, import_core3.getInput)("root"),
    inline: (0, import_core3.getInput)("inline").toLowerCase(),
    treat_flagged_words_as_errors: tf((0, import_core3.getInput)("treat_flagged_words_as_errors")),
    strict: tf((0, import_core3.getInput)("strict")),
    verbose: tf((0, import_core3.getInput)("verbose")),
    check_dot_files: tf((0, import_core3.getInput)("check_dot_files")),
    use_cspell_files: tf((0, import_core3.getInput)("use_cspell_files")),
    suggestions: tf((0, import_core3.getInput)("suggestions")),
    report: (0, import_core3.getInput)("report").toLowerCase()
  };
  return applyDefaults(params);
}
function tf(v) {
  const mapValues = {
    true: "true",
    t: "true",
    false: "false",
    f: "false",
    "0": "false",
    "1": "true"
  };
  v = typeof v === "boolean" || typeof v === "number" ? v ? "true" : "false" : v;
  v = v.toString();
  v = v.toLowerCase();
  v = mapValues[v] || v;
  return v;
}

// src/action.ts
var core3 = { debug: import_core4.debug, error: import_core4.error, info: import_core4.info, warning: import_core4.warning };
var defaultGlob = "**";
var supportedIncrementalEvents = /* @__PURE__ */ new Set(["push", "pull_request"]);
function friendlyEventName(eventName) {
  switch (eventName) {
    case "push":
      return "Push";
    case "pull_request":
      return "Pull Request";
    default:
      return `'${eventName}'`;
  }
}
function isSupportedEvent(eventName) {
  return supportedIncrementalEvents.has(eventName);
}
async function action(githubContext) {
  const params = getActionParams();
  validateActionParams(params, core3.error);
  const eventName = githubContext.eventName;
  if (params.incremental_files_only === "true" && !isSupportedEvent(eventName)) {
    params.files = params.files || defaultGlob;
    core3.warning("Unable to determine which files have changed, checking files: " + params.files);
    params.incremental_files_only = "false";
  }
  params.files = params.files || (params.incremental_files_only !== "true" ? defaultGlob : "");
  const dot = !!checkDotMap[params.check_dot_files];
  const context = {
    githubContext,
    globs: params.files,
    useEventFiles: params.incremental_files_only === "true",
    useCSpellFiles: params.use_cspell_files === "true",
    dot
  };
  core3.info(friendlyEventName(eventName));
  const result = await checkSpellingForContext(params, context);
  if (!result.files && !context.useEventFiles) {
    core3.error("No files found to check.");
  }
  const message = `Files checked: ${result.files}, Issues found: ${result.issues} in ${result.filesWithIssues.size} files.`;
  core3.info(message);
  outputResult(result);
  const fnS = (n) => n === 1 ? "" : "s";
  if (params.strict === "true" && result.issues) {
    const filesWithIssues = result.filesWithIssues.size;
    const err = `${result.issues} spelling issue${fnS(result.issues)} found in ${filesWithIssues} of the ${result.files} file${fnS(result.files)} checked.`;
    (0, import_core4.setFailed)(err);
  }
  if (result.errors) {
    (0, import_core4.setFailed)("Errors encountered.");
  }
  return !(result.issues + result.errors);
}
function outputResult(runResult2) {
  const result = normalizeResult(runResult2);
  (0, import_core4.setOutput)("success", result.success);
  (0, import_core4.setOutput)("errors", result.errors);
  (0, import_core4.setOutput)("number_of_files_checked", result.number_of_files_checked);
  (0, import_core4.setOutput)("number_of_issues", result.number_of_issues);
  (0, import_core4.setOutput)("number_of_files_with_issues", result.files_with_issues.length);
  (0, import_core4.setOutput)("files_with_issues", normalizeFiles(result.files_with_issues));
  (0, import_core4.setOutput)("result", result);
}
function normalizeResult(result) {
  const { issues: number_of_issues, files: number_of_files_checked, filesWithIssues } = result;
  return {
    success: !number_of_issues && !result.errors,
    errors: result.errors,
    number_of_issues,
    number_of_files_checked,
    files_with_issues: normalizeFiles(filesWithIssues).slice(0, 1e3)
  };
}
function normalizeFiles(files) {
  const cwd = process.cwd();
  return [...files].map((file) => import_node_path12.default.relative(cwd, file));
}

// src/main.ts
async function run() {
  try {
    (0, import_core5.info)("cspell-action");
    const githubContext = new import_context.Context();
    await action(githubContext);
    (0, import_core5.info)("Done.");
    return void 0;
  } catch (error4) {
    console.error(error4);
    const err = toError(error4);
    (0, import_core5.setFailed)(err.message);
    return err;
  }
}

// src/main_root.ts
run();
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

smol-toml/dist/error.js:
smol-toml/dist/util.js:
smol-toml/dist/date.js:
smol-toml/dist/primitive.js:
smol-toml/dist/extract.js:
smol-toml/dist/struct.js:
smol-toml/dist/parse.js:
smol-toml/dist/stringify.js:
smol-toml/dist/index.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)
*/
